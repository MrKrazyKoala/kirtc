( () => {
    var e, t, n, i, a, r = {
        60544: (e, t, n) => {
            "use strict";
            n.r(t),
            n.d(t, {
                formats: () => c,
                messages: () => o()
            });
            var i = n(53533)
              , a = n(61888)
              , r = n(38087)
              , s = n(91450)
              , o = n.n(s);
            const c = {
                eventChart: {
                    date: "%m/%d",
                    time: "%H:%M"
                },
                systemStatus: {
                    date: "yyyy-MM-dd HH:mm:ss"
                },
                ipcDatePicker: {
                    seconds: "MMM d, y - HH:mm:ss",
                    noSeconds: "MMM d, y - HH:mm"
                },
                library: {
                    createdOn: "yyyy-MM-dd",
                    startTime: "yyyy-MM-dd HH:mm:ss",
                    fileName: "yyyy-MM-dd_'at'_HH.mm.ss_UTC"
                },
                licensing: {
                    fileName: "yyyy-MM-dd_hh.mm.ss_UTC",
                    lastUpdated: "yyyy-MM-dd HH:mm:ss",
                    supportExpiration: "yyyy-MM-dd"
                },
                auditLogs: {
                    short: "MMM d, y",
                    medium: "MMM d, y, HH:mm:ss",
                    long: "MMMM d, y, HH:mm:ss"
                },
                weekDayOrder: [7, 1, 2, 3, 4, 5, 6]
            };
            (0,
            i.qS)(a.Z, "en", r.Z)
        }
        ,
        44582: (e, t, n) => {
            var i = {
                "./de/de.module": [67464, 736, 464],
                "./de/export.module": [30920, 920],
                "./en/en.module": [60544],
                "./en/export.module": [59058, 58],
                "./es/es.module": [17463, 736, 463],
                "./es/export.module": [22909, 879],
                "./fr/export.module": [57169, 169],
                "./fr/fr.module": [47926, 736, 926],
                "./it/export.module": [24909, 909],
                "./it/it.module": [71968, 736, 968],
                "./nl/export.module": [69536, 536],
                "./nl/nl.module": [86646, 736, 646],
                "./pt/export.module": [52235, 235],
                "./pt/pt.module": [66977, 736, 977]
            };
            function a(e) {
                if (!n.o(i, e))
                    return Promise.resolve().then(( () => {
                        var t = new Error("Cannot find module '" + e + "'");
                        throw t.code = "MODULE_NOT_FOUND",
                        t
                    }
                    ));
                var t = i[e]
                  , a = t[0];
                return Promise.all(t.slice(1).map(n.e)).then(( () => n(a)))
            }
            a.keys = () => Object.keys(i),
            a.id = 44582,
            e.exports = a
        }
        ,
        45002: (e, t, n) => {
            !function() {
                "use strict";
                angular.module("ipconfigure.orchid.singularity").directive("baguette", (function() {
                    return {
                        restrict: "E",
                        template: n(80167)
                    }
                }
                ))
            }()
        }
        ,
        59822: (e, t, n) => {
            angular.module("ipconfigure.orchid.singularity").directive("newCameraGroup", (function() {
                return {
                    restrict: "E",
                    template: n(15869)
                }
            }
            ))
        }
        ,
        65934: () => {
            function e(e) {
                this.context = e
            }
            angular.module("ipconfigure.orchid.singularity").factory("canvasCursorFactory", (function() {
                var t = {
                    createCanvasCursor: function(t) {
                        return new e(t)
                    }
                };
                return t
            }
            )),
            e.prototype.onStart = function(e) {}
            ,
            e.prototype.onDraw = function(e) {}
            ,
            e.prototype.onStop = function(e) {}
            ,
            e.prototype.clear = function() {
                this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height)
            }
            ,
            e.prototype.draw = function(e, t, n, i) {
                this.clear(),
                this.context.fillStyle = n,
                this.context.lineWidth = i,
                this.context.beginPath(),
                this.context.arc(e, t, i / 2, 0, 2 * Math.PI, !1),
                this.context.fill(),
                this.context.lineWidth = 1,
                this.context.closePath(),
                this.context.stroke()
            }
            ,
            e.prototype.resize = function(e) {
                this.context.canvas.width = e.width,
                this.context.canvas.height = e.height
            }
            ,
            e.prototype.listen = function() {
                var e = this;
                this.context.canvas.addEventListener("mousedown", (function(t) {
                    e.onStart(t),
                    t.preventDefault()
                }
                )),
                this.context.canvas.addEventListener("touchstart", (function(t) {
                    e.onStart(t),
                    t.preventDefault()
                }
                )),
                this.context.canvas.addEventListener("mousemove", (function(t) {
                    e.onDraw(t),
                    t.preventDefault()
                }
                )),
                this.context.canvas.addEventListener("touchmove", (function(t) {
                    var n = t.target.getBoundingClientRect();
                    t.offsetX = t.touches[0].pageX - n.left,
                    t.offsetY = t.touches[0].pageY - n.top,
                    e.onDraw(t),
                    t.preventDefault()
                }
                )),
                this.context.canvas.addEventListener("mouseup", (function(t) {
                    e.onStop(t)
                }
                )),
                this.context.canvas.addEventListener("mouseleave", (function(t) {
                    e.onStop(t),
                    e.clear()
                }
                )),
                this.context.canvas.addEventListener("touchend", (function(t) {
                    e.onStop(t),
                    e.clear()
                }
                )),
                this.context.canvas.addEventListener("mouseenter", (function(t) {
                    t.buttons > 0 && (e.onStart(t),
                    t.preventDefault())
                }
                ))
            }
        }
        ,
        88774: (e, t, n) => {
            angular.module("ipconfigure.orchid.singularity").component("motionDetectionMask", {
                controller: ["$scope", "$element", "canvasMaskFactory", "canvasCursorFactory", function(e, t, n, i) {
                    var a, r, s, o, c, l = "#F5798C", d = "draw", u = this, m = !1;
                    function h() {
                        a.onStart = function(e) {
                            !function(e) {
                                if (void 0 === u.brushSize)
                                    return;
                                if (!0 === u.disabled)
                                    return;
                                if (!0 === u.processing)
                                    return;
                                r.setMode(u.drawingMode),
                                r.setBrushColor(u.brushColor),
                                r.setBrushSize(u.brushSize),
                                r.start(e.offsetX, e.offsetY)
                            }(e)
                        }
                        ,
                        a.onDraw = function(e) {
                            !function(e) {
                                if (void 0 === u.brushSize)
                                    return;
                                if (!0 === u.disabled)
                                    return;
                                if (!0 === u.processing)
                                    return;
                                r.draw(e.offsetX, e.offsetY, !0),
                                a.draw(e.offsetX, e.offsetY, u.drawingMode === d ? u.brushColor : l, u.brushSize)
                            }(e)
                        }
                        ,
                        a.onStop = function(e) {
                            !function(e) {
                                if (void 0 === u.brushSize)
                                    return;
                                r.stop(e.offsetX, e.offsetY),
                                p()
                            }(e)
                        }
                        ,
                        a.listen()
                    }
                    function p() {
                        u.maskPromise = r.getMask()
                    }
                    u.$onInit = function() {
                        s = t[0].querySelector("#motion-mask-cursor-canvas"),
                        o = t[0].querySelector("#motion-mask-canvas"),
                        c = t[0].querySelector("#full-scale-mirror"),
                        a = i.createCanvasCursor(s.getContext("2d")),
                        (r = n.createMask(o.getContext("2d"), c.getContext("2d"))).setMode(u.drawingMode),
                        r.setBrushColor(u.brushColor),
                        r.setBrushSize(u.brushSize),
                        h(),
                        e.$on("clearmask", (function() {
                            r.clear(),
                            p()
                        }
                        ))
                    }
                    ,
                    u.$onChanges = function(e) {
                        if (e.containerSize && !e.containerSize.isFirstChange()) {
                            if (!m && (m = !0,
                            c.width = e.containerSize.currentValue.naturalWidth,
                            c.height = e.containerSize.currentValue.naturalHeight,
                            angular.isDefined(u.maskHref))) {
                                u.processing = !0;
                                var t = function() {
                                    return u.processing = !1
                                };
                                r.setMask(u.maskHref).then(p).then(t, t)
                            }
                            r.resize(e.containerSize.currentValue),
                            a.resize(e.containerSize.currentValue)
                        }
                    }
                }
                ],
                controllerAs: "mask",
                bindings: {
                    containerSize: "<",
                    maskHref: "<",
                    maskPromise: "=",
                    brushSize: "<",
                    brushColor: "<",
                    drawingMode: "<",
                    disabled: "="
                },
                template: n(69115)
            })
        }
        ,
        14435: (e, t, n) => {
            function i(e, t) {
                this.color = e,
                this.context = t
            }
            angular.module("ipconfigure.orchid.singularity").component("motionDetectionObjectSize", {
                controller: ["$scope", "$element", function(e, t) {
                    var n, a, r, s = this;
                    function o(e, t) {
                        if (e < 0 || e > 100)
                            throw Error("objectSize should be percentage with a range of [0, 100]");
                        if (0 !== t.width && 0 !== t.height) {
                            var n = e / 100
                              , i = t.width * n
                              , a = t.height * n;
                            r.draw(t.width / 2 - i / 2, t.height / 2 - a / 2, t.width * n, t.height * n)
                        }
                    }
                    s.$onInit = function() {
                        n = t[0].querySelector("#motion-mask-object-size-canvas"),
                        a = n.getContext("2d"),
                        r = new i(s.fillColor,a),
                        e.$watch((function() {
                            return s.objectSize
                        }
                        ), (function() {
                            void 0 !== s.containerSize && o(s.objectSize, s.containerSize)
                        }
                        ))
                    }
                    ,
                    s.$onChanges = function(e) {
                        e.containerSize && !e.containerSize.isFirstChange() && (!function(e) {
                            if (void 0 === e || !e.hasOwnProperty("width") || !e.hasOwnProperty("height"))
                                throw Error("dimensions should have width and height properties");
                            n.width = e.width,
                            n.height = e.height
                        }(e.containerSize.currentValue),
                        o(s.objectSize, e.containerSize.currentValue))
                    }
                }
                ],
                controllerAs: "mask",
                bindings: {
                    objectSize: "=",
                    containerSize: "<",
                    fillColor: "<"
                },
                template: n(63815)
            }),
            i.prototype.draw = function(e, t, n, i) {
                this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height),
                this.context.beginPath(),
                this.context.fillStyle = this.color,
                this.context.rect(e, t, n, i),
                this.context.fill(),
                this.context.stroke()
            }
        }
        ,
        69473: (e, t, n) => {
            !function() {
                "use strict";
                angular.module("ipconfigure.orchid.singularity").directive("dialogErrors", [function() {
                    return {
                        restrict: "E",
                        template: n(75027),
                        scope: {
                            targetObject: "="
                        },
                        link: function(e, t) {
                            e.$watch((function() {
                                return angular.isDefined(e.targetObject.error) && e.targetObject.error.length > 0
                            }
                            ), (function(e, n) {
                                e ? (t[0].style.display = "block",
                                t[0].style.minHeight = "100px") : (t[0].style.display = "none",
                                t[0].style.minHeight = "0px")
                            }
                            ))
                        }
                    }
                }
                ])
            }()
        }
        ,
        12207: (e, t, n) => {
            !function() {
                function e(e) {
                    const t = "eye"
                      , n = "eye-slash"
                      , i = "password"
                      , a = "text";
                    var r = this;
                    r.icon = t,
                    r.type = i,
                    r.hidden = !0,
                    r.required = !!angular.isDefined(e.required) && e.required,
                    r.disabled = !!angular.isDefined(e.disabled) && e.disabled,
                    r.minlength = angular.isDefined(e.minlength) ? e.minlength : 0,
                    r.matchPassword = !!angular.isDefined(e.matchPassword) && e.matchPassword,
                    r.onIconClick = function(e) {
                        r.hidden = !r.hidden,
                        r.icon = r.hidden ? t : n,
                        r.type = r.hidden ? i : a,
                        e.stopPropagation()
                    }
                }
                e.$inject = ["$scope"],
                angular.module("ipconfigure.orchid.singularity").controller("PasswordFormFieldLiteController", e).directive("passwordFormFieldLite", (function() {
                    return {
                        restrict: "E",
                        require: "ngModel",
                        controller: "PasswordFormFieldLiteController",
                        controllerAs: "passwordFormFieldLite",
                        bindToController: !0,
                        template: n(97133),
                        scope: {
                            fieldName: "@",
                            required: "@?",
                            disabled: "@?",
                            minlength: "@?",
                            value: "=modelName",
                            matchPassword: "@?equal"
                        }
                    }
                }
                ))
            }()
        }
        ,
        46450: () => {
            !function() {
                "use strict";
                angular.module("ipconfigure.orchid.singularity").filter("filterByManaged", (function() {
                    return function(e, t) {
                        return e ? e.filter((function(e) {
                            return !!t[e.id] && !0 === t[e.id].managed
                        }
                        )) : e
                    }
                }
                ))
            }()
        }
        ,
        82025: () => {
            !function() {
                "use strict";
                angular.module("ipconfigure.orchid.singularity").filter("filterByNameSearch", (function() {
                    return function(e, t) {
                        var n = e;
                        return t.length && (n = e.filter((function(e) {
                            for (var n, i, a = 0 === t.length, r = 0; r < t.length; ++r) {
                                n = !0,
                                i = t[r].toLowerCase().split(" ");
                                for (var s = 0; s < i.length; ++s)
                                    if (e.name.toLowerCase().indexOf(i[s]) < 0 && e.uri.toLowerCase().indexOf(i[s]) < 0) {
                                        n = !1;
                                        break
                                    }
                                if (n) {
                                    a = !0;
                                    break
                                }
                            }
                            return a
                        }
                        ))),
                        n
                    }
                }
                ))
            }()
        }
        ,
        93609: () => {
            !function() {
                "use strict";
                angular.module("ipconfigure.orchid.singularity").directive("progressbarThreshold", ["$timeout", function(e) {
                    return {
                        restrict: "A",
                        link: function(t, n, i) {
                            var a = n[0]
                              , r = document.createElement("div");
                            e((function() {
                                a.style.position = "relative",
                                r.classList.add("progressbar-threshold"),
                                a.appendChild(r, a.firstElementChild)
                            }
                            )),
                            t.$watch(i.progressbarThreshold, (function(e) {
                                r.style.left = e + "%",
                                r.style.opacity = 0 === e ? "0" : "1"
                            }
                            ))
                        }
                    }
                }
                ])
            }()
        }
        ,
        53659: () => {
            function e(e) {
                return {
                    scope: !1,
                    restrict: "A",
                    link(e, t) {
                        const n = function(e) {
                            e.stopPropagation()
                        }
                          , i = "touchstart touchend touchmove";
                        t.on(i, n),
                        t.on("$destroy", (function() {
                            t.off(i, n)
                        }
                        ))
                    }
                }
            }
            e.$inject = ["Platform"],
            angular.module("ipconfigure.orchid.singularity").directive("preventDrag", e)
        }
        ,
        39734: () => {
            !function() {
                "use strict";
                angular.module("ipconfigure.orchid.singularity").filter("orderMapByOrchidName", ["RenewableService", function(e) {
                    return function(t) {
                        return t ? Object.keys(t).sort((function(t, n) {
                            const i = e.findOrchid(t)
                              , a = e.findOrchid(n);
                            return i && a ? i.name.toLowerCase().localeCompare(a.name.toLowerCase()) : 0
                        }
                        )) : t
                    }
                }
                ])
            }()
        }
        ,
        96895: () => {
            !function() {
                "use strict";
                angular.module("ipconfigure.orchid.singularity").factory("AutocompleteRepairService", ["$rootScope", "$timeout", "BrowserInfoService", function(e, t, n) {
                    var i = -1;
                    function a(e, t) {
                        e.getBoundingClientRect().width > 0 && (Math.round(e.scrollTop) !== i && (i = Math.round(e.scrollTop),
                        t()),
                        setTimeout((function() {
                            a(e, t)
                        }
                        ), 10))
                    }
                    function r(e, t) {
                        for (; (e = e.parentNode) && e.tagName.toLowerCase() !== t.toLowerCase(); )
                            ;
                        return e
                    }
                    function s(e) {
                        return e.offsetWidth > 0
                    }
                    function o(e, n) {
                        t((function() {
                            var t = n.getBoundingClientRect()
                              , i = document.body.getBoundingClientRect().height - (t.top + t.height)
                              , a = e.getElementsByTagName("li")
                              , r = 48 * (a.length > 5 ? 5 : a.length)
                              , s = i > r ? r : i;
                            e.style.maxHeight = s + "px",
                            e.style.height = i + "px",
                            e.style.opacity = 1
                        }
                        ))
                    }
                    function c(e, n) {
                        if (!document.getElementById(n + "-closer")) {
                            var i = document.createElement("div")
                              , a = document.createElement("i");
                            a.classList = "fa fa-times closer-icon",
                            i.appendChild(a),
                            i.classList = "autocomplete-closer",
                            i.id = n + "-closer",
                            i.addEventListener("click", (function(e) {
                                document.activeElement.blur(),
                                t((function() {
                                    !function(e) {
                                        for (var t, n, i = document.getElementsByTagName("md-autocomplete"), a = 0; a < i.length; ++a)
                                            (t = angular.element(i[a].firstElementChild)).blur(),
                                            (n = t.scope()).$apply((function() {
                                                n.$$childHead.$mdAutocompleteCtrl.hidden = !0
                                            }
                                            ))
                                    }()
                                }
                                ))
                            }
                            )),
                            e.appendChild(i)
                        }
                    }
                    function l(e) {
                        t((function() {
                            !0 === s(e) && angular.element(e).controller("mdVirtualRepeatContainer").$scope.$broadcast("$md-resize")
                        }
                        ), 100)
                    }
                    function d(e) {
                        var i = document.getElementsByClassName("md-autocomplete-suggestions-container");
                        !0 !== e && function(e) {
                            for (var t = 0; t < e.length; ++t)
                                if (!0 === s(e[t])) {
                                    e[t].style.opacity = 0;
                                    break
                                }
                        }(i),
                        t((function() {
                            !function(e) {
                                document.getElementsByTagName("md-autocomplete");
                                for (var t, i, a, d, u, m, h, p, g, f, v, y, b = 0; b < e.length; ++b)
                                    if (angular.element(e[b]).controller("mdVirtualRepeatContainer").repeater.isFirstRender && l(e[b]),
                                    !0 === s(e[b])) {
                                        t = e[b].getElementsByTagName("ul")[0].classList;
                                        for (var S = 0; S < t.length; ++S)
                                            if (t[S].indexOf("autocomplete---") > -1) {
                                                i = document.getElementById(t[S]),
                                                !0 === n.isMobile && c(e[b], t[S]);
                                                break
                                            }
                                        a = r(i, "md-autocomplete"),
                                        r(i, "md-chips-wrap").getElementsByTagName("md-chip"),
                                        d = e[b],
                                        u = void 0,
                                        m = void 0,
                                        h = void 0,
                                        p = void 0,
                                        g = void 0,
                                        f = void 0,
                                        v = void 0,
                                        y = void 0,
                                        u = a.getBoundingClientRect(),
                                        m = document.body.getBoundingClientRect(),
                                        p = ((h = document.getElementsByTagName("md-toolbar")) ? h[0] : void 0).getBoundingClientRect(),
                                        f = ((g = document.getElementsByTagName("md-dialog-actions")) ? g[0] : void 0).getBoundingClientRect(),
                                        v = u.top + u.height - m.top,
                                        y = d.getBoundingClientRect(),
                                        v > p.bottom - m.top && v < f.top - m.top ? (d.style.transition = "top 0.01s",
                                        d.style.top = v + "px") : (d.style.transition = "top 0s",
                                        d.style.top = "9999999999999999999px"),
                                        y.left < u.left && (d.style.left = u.left + "px"),
                                        o(e[b], a);
                                        break
                                    }
                            }(i)
                        }
                        ))
                    }
                    return e.$on("resize", (function() {
                        d(!1)
                    }
                    )),
                    {
                        handleDialog: function(e, t, n) {
                            a(document.getElementById("dialog-scroll-region"), (function() {
                                d(!0)
                            }
                            ))
                        },
                        notify: function() {
                            d()
                        }
                    }
                }
                ])
            }()
        }
        ,
        15784: () => {
            !function() {
                "use strict";
                angular.module("ipconfigure.orchid.singularity").factory("EasingService", ["$window", "$document", "BrowserInfoService", function(e, t, n) {
                    return {
                        scrollTo: function(i, a, r) {
                            var s = n.getBrowserInfo();
                            if (!1 === (n.isMobile && "Safari" === s.name)) {
                                var o, c = t[0].documentElement.scrollTop || t[0].body.parentNode.scrollTop || t[0].body.scrollTop, l = i - c, d = 0;
                                r = void 0 === r ? 500 : r,
                                o = function() {
                                    var n, i, s = e.requestAnimationFrame || e.webkitRequestAnimationFrame || e.mozRequestAnimationFrame || function(t) {
                                        e.setTimeout(t, 1e3 / 60)
                                    }
                                    ;
                                    n = function(e, t, n, i) {
                                        var a = (e /= i) * e
                                          , r = a * e;
                                        return t + n * (-1.25 * r * a + -2 * a * a + 7 * r + -4 * a + 1.25 * e)
                                    }(d += 20, c, l, r),
                                    i = n,
                                    t[0].documentElement.scrollTop = i,
                                    t[0].body.parentNode.scrollTop = i,
                                    t[0].body.scrollTop = i,
                                    d < r ? s(o) : a && "function" == typeof a && a()
                                }
                                ,
                                o()
                            } else
                                a()
                        }
                    }
                }
                ])
            }()
        }
        ,
        40632: () => {}
        ,
        16150: () => {}
        ,
        1843: () => {}
        ,
        23882: e => {
            e.exports = '<section layout="row" class="admin-section account-settings" flex>\n    \x3c!-- Navigation Bar --\x3e\n    <navigation display="left"></navigation>\n\n    <div class="generic-admin-container-area">\n        <div class="generic-admin-content">\n            <div [ngSwitch]="pageStatus">\n                <ng-container *ngSwitchCase="\'loaded\'">\n                    \x3c!-- General Settings --\x3e\n                    <section class="information-section">\n                        <mat-card-title>{{ msgs.accountInformation() }}</mat-card-title>\n                        <mat-card class="card-content">\n                            <general-settings class="general-settings" [userData]="userData" (onUserDataUpdate)="setUserData($event)"></general-settings>\n                        </mat-card>\n                    </section>\n\n                    \x3c!-- Password Changing --\x3e\n                    <section class="information-section security">\n                        <mat-card-title>{{ msgs.security() }}</mat-card-title>\n                        <mat-card class="card-content">\n                            <alert-banner *ngIf="!canUserChangePassword()">\n                                {{ msgs.youCantChangePasswordHere() }}\n                            </alert-banner>\n                            <button [disabled]="!canUserChangePassword()" (click)="openPasswordDialog()" mat-raised-button color="primary" class="edit-password-button">\n                                {{ msgs.changePassword() }}\n                            </button>\n                        </mat-card>\n                    </section>\n\n                    \x3c!-- Preferences Settings --\x3e\n                    <section class="information-section preferences" *ngIf="showPreferences">\n                        <mat-card-title>{{ msgs.preferences.preferences() }}</mat-card-title>\n                        <mat-card class="card-content">\n                            <mat-list>\n                                \x3c!-- New preference options get added here --\x3e\n                            </mat-list>\n                        </mat-card>\n                    </section>\n                </ng-container>\n                <ng-container *ngSwitchDefault>\n                    \x3c!-- Page Loading / Error Message --\x3e\n                    <page-loading [progress]="msgs.loadingAccountInformation()" [error]="errorMessage"> </page-loading>\n                </ng-container>\n            </div>\n        </div>\n    </div>\n</section>\n'
        }
        ,
        43814: e => {
            e.exports = '\x3c!-- Dialog Header --\x3e\n<mat-toolbar color="primary" class="edit-password-dialog-toolbar">\n    \x3c!-- Title --\x3e\n    <span mat-dialog-title class="dialog-title">{{ msgs.changePassword() }}</span>\n\n    \x3c!-- Close Button --\x3e\n    <button mat-icon-button mat-dialog-close disableRipple="true" tabindex="-1">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<form [formGroup]="newPasswordForm">\n    \x3c!-- Dialog Content --\x3e\n    <mat-dialog-content class="edit-password-dialog-content">\n        <div class="password-form">\n            \x3c!-- New Password Input --\x3e\n            <password-form-field formControlName="newPassword" label="{{ formMsgs.labels.newPassword() }}" errorMessage="{{ getNewPasswordErrorMessage() }}" [required]="true">\n            </password-form-field>\n\n            \x3c!-- Confirm New Password Input --\x3e\n            <password-form-field formControlName="confirmPassword" label="{{ formMsgs.labels.confirmPassword() }}" errorMessage="{{ getConfirmPasswordErrorMessage() }}" [required]="true">\n            </password-form-field>\n\n            \x3c!-- Error Dialog  --\x3e\n            <sing-dialog-errors *ngIf="errorMessage.length > 0" (onClose)="dismissErrorMessage()" [errmsg]="errorMessage" class="error-banner">\n            </sing-dialog-errors>\n        </div>\n    </mat-dialog-content>\n\n    \x3c!-- Dialog Buttons --\x3e\n    <mat-dialog-actions align="end">\n        \x3c!-- Cancel --\x3e\n        <button mat-button mat-dialog-close class="cancel-button" color="primary" [disabled]="processing">\n            {{ msgs.cancel() }}\n        </button>\n\n        \x3c!-- Save/Spinner Button --\x3e\n        <button class="update-button" mat-raised-button color="primary" (click)="saveButtonHandler()" [disabled]="newPasswordForm.invalid || processing">\n            <div [ngStyle]="{\'visibility\': processing ? \'hidden\' : \'visible\'}">\n                <span>{{ msgs.save() }}</span>\n            </div>\n            <mat-spinner class="processing-spinner" *ngIf="processing" mode="indeterminate" diameter="16">\n            </mat-spinner>\n        </button>\n    </mat-dialog-actions>\n</form>\n'
        }
        ,
        86867: e => {
            e.exports = '<div *ngIf="editMode; else readOnlyMode">\n    <form class="general-form" [formGroup]="generalForm">\n        \x3c!-- Username --\x3e\n        <mat-form-field floatLabel="always">\n            <mat-label>{{ formMsgs.labels.username() }}</mat-label>\n            <input matInput formControlName="username">\n            <mat-error>{{ getUsernameErrorMessage() }}</mat-error>\n        </mat-form-field>\n\n        \x3c!-- Email --\x3e\n        <mat-form-field floatLabel="always">\n            <mat-label>{{ formMsgs.labels.emailAddress() }}</mat-label>\n            <input matInput formControlName="email" type="email">\n            <mat-error>{{ getEmailErrorMessage() }}</mat-error>\n        </mat-form-field>\n\n        <sing-dialog-errors *ngIf="showErrorMessage()" (onClose)="dismissErrorMessage()" [errmsg]="errorMessage" class="error-banner">\n        </sing-dialog-errors>\n\n        \x3c!-- Dialog Buttons --\x3e\n        <mat-dialog-actions>\n            \x3c!-- Cancel --\x3e\n            <button mat-button type="button" color="primary" (click)="toggleEditMode(false)" [disabled]="processing">\n                {{ msgs.cancel() }}\n            </button>\n\n            \x3c!-- Save/Spinner Buttton --\x3e\n            <button class="update-button" mat-raised-button color="primary" (click)="saveButtonHandler()" [disabled]="!canSave()">\n                <div [ngStyle]="{ visibility: processing ? \'hidden\' : \'visible\' }">\n                    <span>{{ msgs.save() }}</span>\n                </div>\n                <mat-spinner class="processing-spinner" *ngIf="processing" mode="indeterminate" diameter="16">\n                </mat-spinner>\n            </button>\n        </mat-dialog-actions>\n    </form>\n</div>\n\n<ng-template #readOnlyMode>\n    <mat-list class="field-list">\n        <mat-list-item class="field-list-item" id="account-info-username">\n            <span matLine class="hint-text">{{ formMsgs.labels.username() }}</span>\n            <span matLine class="information">\n                {{ userData.username }}\n                <i *ngIf="canEditInformation" class="fa fa-pencil field-edit-button" (click)="toggleEditMode(true)"></i>\n            </span>\n        </mat-list-item>\n\n        <mat-list-item class="field-list-item" id="account-info-email">\n            <span matLine class="hint-text">{{ formMsgs.labels.emailAddress() }}</span>\n            <span matLine class="information">\n                {{ getUserEmail() }}\n                <i *ngIf="canEditInformation" class="fa fa-pencil field-edit-button" (click)="toggleEditMode(true)"></i>\n            </span>\n        </mat-list-item>\n    </mat-list>\n</ng-template>\n'
        }
        ,
        49802: e => {
            e.exports = '<section class="activation-page dashboard-section">\n    <navigation *ngIf="isOrchid" class="dashboard-navigation" display="left"></navigation>\n\n    <div class="page-content">\n        \x3c!-- Loading Message --\x3e\n\n        <page-loading class="loading-activation-cards" *ngIf="loading; else loadedContent" [progress]="msgs.loadingLicenseInfo()"></page-loading>\n\n        <ng-template #loadedContent>\n            <mat-card class="activation-info-card" [class.mb-30]="isOrchid">\n                <h2 class="activation-header">\n                    {{ msgs.headerActivation() }}\n                </h2>\n\n                \x3c!-- Degraded State Notice --\x3e\n                <div *ngIf="licenseSession.state.status === LicenseStateStatus.DEGRADED">\n                    <p>\n                        {{ msgs.systemDegradedState() }}\n                        <strong><em>{{ licenseSession.state.description }}</em></strong>\n                    </p>\n\n                    <div [ngSwitch]="licenseSession.state.reason">\n                        <p *ngSwitchCase="\'storage\'">{{ msgs.storageDeviceChanged() }}</p>\n                        <p *ngSwitchCase="\'storage_path\'">{{ msgs.storagePathInvalid() }}</p>\n                        <p [innerHtml]="errorHelpHTML"></p>\n                        <p *ngSwitchDefault>{{ msgs.invalidServerLicense() }}</p>\n                    </div>\n                </div>\n\n                \x3c!-- Pending Change notice --\x3e\n                <div *ngIf="licenseSession.state.status === LicenseStateStatus.PENDING_CHANGE">\n                    <p>{{ msgs.restartToUseNewLicense() }}</p>\n                </div>\n\n                <div class="no-matches-error-message" *ngIf="refreshOrchidFailed; else orchidLicenseData">\n                    {{ msgs.failedToFetchCHILDNAMELicenseInfo() }}\n                </div>\n\n                <ng-template #orchidLicenseData>\n                    <div>\n                        \x3c!-- \'Orchid Core VMS has been activated\' message --\x3e\n                        <div class="activation-status-container" [ngSwitch]="licenseSession.license.edition">\n                            <p *ngSwitchCase="\'trial\'" [innerHtml]="msgs.childNotActivated()"></p>\n\n                            <p *ngSwitchDefault [innerHtml]="msgs.childActivated()"></p>\n                        </div>\n\n                        <div *ngIf="licenseIsTimed">\n                            <p>\n                                {{ msgs.licenseWillExpireIn({ VALUE: licenseSession.license.brandedEdition }) }}\n                                <span class="bold">{{ formattedLicenseTimeRemaining }}</span>.\n                            </p>\n                        </div>\n\n                        <div class="mat-elevation-z1">\n                            <mat-table [dataSource]="dataSource" class="license-table" multiTemplateDataRows>\n                                \x3c!-- License Edition --\x3e\n                                <ng-container [matColumnDef]="TableColumns.EDITION">\n                                    <mat-header-cell *matHeaderCellDef>\n                                        {{ msgs.edition() }}\n                                    </mat-header-cell>\n                                    <mat-cell *matCellDef="let session">\n                                        {{ session.edition }}\n                                    </mat-cell>\n                                </ng-container>\n\n                                \x3c!-- Number of Cameras Licensed --\x3e\n                                <ng-container [matColumnDef]="TableColumns.CAMERAS">\n                                    <mat-header-cell *matHeaderCellDef>\n                                        {{ msgs.camerasLicensed() }}\n                                    </mat-header-cell>\n                                    <mat-cell *matCellDef="let session">\n                                        {{ licensedCameraCount }}/{{ session.cameras }}\n                                    </mat-cell>\n                                </ng-container>\n\n                                \x3c!-- Archive Retention --\x3e\n                                <ng-container [matColumnDef]="TableColumns.RETENTION">\n                                    <mat-header-cell *matHeaderCellDef>\n                                        {{ msgs.archiveRetention() }}\n                                    </mat-header-cell>\n                                    <mat-cell *matCellDef="let session">\n                                        {{ session.retention }}\n                                    </mat-cell>\n                                </ng-container>\n\n                                \x3c!-- Support Expiration --\x3e\n                                <ng-container [matColumnDef]="TableColumns.SUPPORT">\n                                    <mat-header-cell *matHeaderCellDef>\n                                        {{ msgs.supportExpiration() }}\n                                    </mat-header-cell>\n                                    <mat-cell *matCellDef="let session">\n                                        {{ session.support }}\n                                    </mat-cell>\n                                </ng-container>\n\n                                \x3c!-- Activation Code --\x3e\n                                <ng-container [matColumnDef]="TableColumns.ACTIVATION">\n                                    <mat-header-cell *matHeaderCellDef>\n                                        {{ msgs.activationCode() }}\n                                    </mat-header-cell>\n                                    <mat-cell *matCellDef="let session">\n                                        {{ session.activation }}\n                                    </mat-cell>\n                                </ng-container>\n\n                                <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>\n                                <mat-row *matRowDef="let row; columns: displayedColumns"></mat-row>\n                            </mat-table>\n                        </div>\n                    </div>\n                </ng-template>\n\n                <div class="license-controls">\n                    <button mat-raised-button *ngIf="licenseSession.license.edition !== \'trial\'" class="remove-button" [disabled]="refreshOrchidFailed" color="warn" (click)="removeLicense()">\n                        <span class="hide-lt-476px">{{ msgs.removeLicense() }}</span>\n                        <span class="hide-gt-475px">{{ msgs.remove() }}</span>\n                    </button>\n\n                    <button mat-raised-button color="primary" [disabled]="refreshOrchidFailed" [ngClass]="hasLicense ? \'modify-button\' : \'add-button\'" (click)="addLicense()">\n                        <span class="hide-lt-476px">{{ licenseButtonText }}</span>\n                        <span class="hide-gt-475px">{{ licenseButtonTextShort }}</span>\n                    </button>\n                </div>\n            </mat-card>\n\n            <mat-card class="parent-detach-card" *ngIf="isOrchid && trustedIssuer">\n                <div>\n                    <h2 class="activation-header">{{ msgs.parentStatus() }}</h2>\n                    <div>\n                        <p>\n                            {{ msgs.childCurrentlyManagedBy() }}\n                        </p>\n                        <p class="no-margin-bottom">\n                            {{ msgs.removeChildFromParent() }}\n                        </p>\n                        <span class="text-danger detach-failure-message-container">\n                            {{ failureDetach }}\n                        </span>\n                        <div class="detach-button-container">\n                            <spinner-button [color]="\'warn\'" [text]="msgs.detachFromParent()" [disabled]="processingDetach" [showSpinner]="processingDetach" (click)="detach()"></spinner-button>\n                        </div>\n                    </div>\n                </div>\n            </mat-card>\n        </ng-template>\n    </div>\n</section>\n'
        }
        ,
        35962: e => {
            e.exports = '<mat-toolbar color="primary">\n    <h2>\n        {{ silentActivation ? msgs.activation() : msgs.activationInstructions() }}\n    </h2>\n\n    <button mat-icon-button [disabled]="processing" (click)="cancel()">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content>\n    <div *ngIf="checkingForConnectivity; else connected" class="connecting">\n        <span>{{ msgs.connectingToActivationService() }}</span>\n\n        <mat-progress-spinner diameter="25" color="primary" mode="indeterminate"></mat-progress-spinner>\n    </div>\n    <ng-template #connected>\n        <mat-tab-group dynamicHeight [selectedIndex]="orchidSecurityUnreachable ? 1 : 0" (selectedTabChange)="onTabChange($event)" (animationDone)="onAnimationDone()">\n            \x3c!-- Online Activation Tab --\x3e\n            <mat-tab label="{{ msgs.onlineCAPS() }}" [disabled]="orchidSecurityUnreachable">\n                <p>\n                    {{ isActivated ? msgs.pleaseProvideActivationIsActive() : msgs.pleaseProvideActivation() }}\n                </p>\n\n                <form class="activation-form" [formGroup]="activationForm">\n                    \x3c!-- Activation/Upgrade Code Field --\x3e\n                    <mat-form-field floatLabel="always">\n                        <mat-label>\n                            {{ isActivated ? msgs.activationOrUpgradeCode() : msgs.activationCode() }}\n                        </mat-label>\n                        <input matInput *ngIf="!isActivated; else activatedInput" placeholder="XXXXX-XXXXX-XXXXX-XXXXX" formControlName="activationCode" required cdkFocusInitial id="formFocus1">\n                        <ng-template #activatedInput>\n                            <input matInput placeholder="XXXXX-XXXXX-XXXXX-XXXXX {{ msgs.or() }} XXXX-XXXX-XXXX-XXXX" formControlName="activationCode" required cdkFocusInitial id="formFocus1">\n                        </ng-template>\n                    </mat-form-field>\n\n                    \x3c!-- Location Field --\x3e\n                    <mat-form-field floatLabel="always">\n                        <mat-label>\n                            {{ msgs.location() }}\n                        </mat-label>\n                        <input matInput placeholder="{{msgs.locationInputPlaceHolder()}}" formControlName="location">\n                    </mat-form-field>\n                </form>\n\n            </mat-tab>\n\n            \x3c!-- Offline Activation Tab --\x3e\n            <mat-tab label="{{ msgs.offlineCAPS() }}">\n                <div [innerHtml]="msgs.toActivateAppNameAccessTheLicensingPortal({ID: orchid.discoverableOrchid.mid})">\n                </div>\n\n                <div class="machine-id-container">\n                    <h4 class="mid-header">\n                        {{ msgs.machineId() }}\n                    </h4>\n                    <code class="mid-display">\n                        {{ orchid.discoverableOrchid.mid }}\n                    </code>\n                </div>\n\n                <div class="license-key-container">\n                    <h4 class="license-key-header">\n                        {{ msgs.licenseKey() }}\n                    </h4>\n                    <textarea #licenseKey cdkFocusInitial class="license-key-textarea" [(ngModel)]="activationKey"></textarea>\n                </div>\n            </mat-tab>\n        </mat-tab-group>\n    </ng-template>\n</mat-dialog-content>\n\n<sing-dialog-errors *ngIf="error !== undefined" [errmsg]="error" [canClose]="true" (onClose)="error = undefined"></sing-dialog-errors>\n\n<mat-dialog-actions>\n    <button mat-button (click)="cancel()" [disabled]="processing">\n        {{ dialogMsgs.cancel() }}\n    </button>\n\n    <spinner-button (click)="activate()" [text]="msgs.activate()" [disabled]="(!silentActivation && !activationKey) || processing || formIsInvalid" [showSpinner]="processing"></spinner-button>\n\n</mat-dialog-actions>\n'
        }
        ,
        74220: e => {
            e.exports = '<section>\n    <mat-card class="centered">\n        <mat-card-title>Advanced Settings</mat-card-title>\n        <mat-card-content>\n            <div class="flex-col">\n                <mat-form-field>\n                    <mat-label>Default Player Mode</mat-label>\n                    <mat-select [(value)]="defaultPlayerMode" autofocus>\n                        <mat-option *ngFor="let mode of playerModes" [value]="mode.toLowerCase()">\n                            {{mode}}\n                        </mat-option>\n                    </mat-select>\n                </mat-form-field>\n\n                <mat-form-field>\n                    <mat-label>WebRTC Support Override</mat-label>\n                    <mat-select [(value)]="webRTCSupportOverride">\n                        <mat-option *ngFor="let val of enabledDisabledValues" [value]="val">\n                            {{val}}\n                        </mat-option>\n                    </mat-select>\n                </mat-form-field>\n\n                <mat-form-field>\n                    <mat-label>Log Level</mat-label>\n                    <mat-select [(value)]="logLevel">\n                        <mat-option *ngFor="let val of logLevels" [value]="val">\n                            {{val.toLowerCase()}}\n                        </mat-option>\n                    </mat-select>\n                </mat-form-field>\n\n                <mat-form-field *ngIf="isFusion()">\n                    <mat-label>Force Orchid Proxy</mat-label>\n                    <mat-select [(value)]="forceOrchidProxy">\n                        <mat-option *ngFor="let val of enabledDisabledValues" [value]="val">\n                            {{val}}\n                        </mat-option>\n                    </mat-select>\n                </mat-form-field>\n\n                <mat-form-field *ngIf="isFusion() && !isCustomLicense">\n                    <mat-label>App Theme</mat-label>\n                    <mat-select [(value)]="selectedAppTheme">\n                        <mat-option *ngFor="let val of appThemeOptions" [value]="val">\n                            {{val}}\n                        </mat-option>\n                    </mat-select>\n                </mat-form-field>\n            </div>\n        </mat-card-content>\n        <mat-card-actions class="flex-row-right">\n            <button mat-button (click)="cancel()">\n                Cancel\n            </button>\n            <button mat-raised-button color="primary" (click)="save()">\n                Save\n            </button>\n        </mat-card-actions>\n    </mat-card>\n</section>\n'
        }
        ,
        89795: e => {
            e.exports = '<div class="ambulance-section ambulance-padding">\n    <mat-card>\n        <p>{{ msgs.weAreHavingTroubleReaching({ VALUE: orchid.name }) }}</p>\n        <p *ngIf="orchid.failureReason">{{ msgs.troubleReason({ VALUE: orchid.failureReason }) }}</p>\n        <p [innerHTML]="errorHelp"></p>\n        <div class="ambulance-icon">\n            <div class="ambulance-wrapper">\n                <i class="fa fa-ambulance fa-flip-horizontal fa-5x"></i>\n            </div>\n        </div>\n    </mat-card>\n</div>\n'
        }
        ,
        69828: e => {
            e.exports = "<router-outlet></router-outlet>\n"
        }
        ,
        70253: e => {
            e.exports = '<div class="app-death-container">\n    <mat-card>\n        <h1>{{ msgs.appUnresponsive() }}</h1>\n        <p class="error-reason">{{ getReason() }}</p>\n        <p class="error-help" [innerHTML]="errorHelp"></p>\n        <div class="reload-app-container" *ngIf="!showAmbulance">\n            <button mat-button (click)="reload()">{{ msgs.reload() }}</button>\n        </div>\n        <div class="ambulance-container" *ngIf="showAmbulance">\n            <div class="ambulance-wrapper">\n                <i class="fa fa-ambulance fa-flip-horizontal fa-5x"></i>\n            </div>\n        </div>\n    </mat-card>\n</div>\n'
        }
        ,
        36768: e => {
            e.exports = '<section layout="row" class="admin-section audit-logs-page">\n    <navigation class="navigation-padding" display="left" *ngIf="isOrchid"></navigation>\n\n    <div class="admin-content centered audit-logs-page-content">\n        <mat-card class="system-reports-container admin-card">\n            <mat-card-content class="audit-logs-admin-content">\n                <div class="title-bar" *ngIf="isOrchid">\n                    \x3c!-- Page Title --\x3e\n                    <h1>{{ msgs.auditLogs() }}</h1>\n                </div>\n\n                \x3c!-- Audit Filters Component --\x3e\n                <audit-logs-filters *ngIf="showFilters" [@fadeIn] #auditFilters [trustedIssuerName]="trustedIssuerName" [cameras]="cameras" [users]="users" (search)="handleFiltersSearch()"></audit-logs-filters>\n\n                \x3c!-- Empty results message --\x3e\n                <p class="empty-data-text" *ngIf="showNoResults && !showError">{{ msgs.noResults() }}</p>\n\n                \x3c!-- Error message --\x3e\n                <p class="empty-data-text error-message" *ngIf="showError">{{ error.reason ?? msgs.error() }}</p>\n\n                \x3c!-- Indefinite Spinner --\x3e\n                <div class="spinner-container" *ngIf="showSpinner" [@fadeOut]>\n                    <mat-spinner mode="indeterminate" diameter="24"></mat-spinner>\n                </div>\n\n                <div class="audit-logs-buttons-and-table" *ngIf="showTable" [@fadeIn]>\n                    \x3c!-- Audit Logs Buttons --\x3e\n                    <div class="audit-logs-button-bar">\n                        \x3c!-- Refresh Button --\x3e\n                        <button mat-mini-fab class="refresh-button action-button" color="primary" (click)="refresh()" [matTooltip]="refreshTooltip" matTooltipPosition="above">\n                            <i class="fa-solid fa-arrows-rotate"></i>\n                        </button>\n\n                        \x3c!-- Export Logs Button --\x3e\n                        <button mat-mini-fab class="mat-primary action-button download-button" (click)="handleExportButtonClick()" [matTooltip]="msgs.exportLogs()" matTooltipPosition="above"></button>\n                    </div>\n\n                    \x3c!-- Audit Logs Table --\x3e\n                    <audit-logs-table #logsTable [trustedIssuerName]="trustedIssuerName" [servicesActionsMap]="servicesActionsMap" [servicesDescriptionsMap]="servicesDescriptionsMap" [servicesResourcesMap]="servicesResourcesMap" [logs]="auditLogs" [state]="state" [pageSize]="pageSize" (moreClick)="handleMoreClick($event)" (onSort)="handleSort($event)"></audit-logs-table>\n                </div>\n\n                \x3c!-- Back to Top button --\x3e\n                <div class="bottom-anchor" *ngIf="showTopButton" [@fadeInOut]>\n                    <div class="navigation-spacer"></div>\n                    <div class="top-container">\n                        <button mat-mini-fab color="primary" *ngIf="auditLogs.length >= 0" (click)="top()" [matTooltip]="backToTopTooltip">\n                            <i class="fa-solid fa-arrow-up-to-line"></i>\n                        </button>\n                    </div>\n                </div>\n            </mat-card-content>\n        </mat-card>\n    </div>\n</section>\n'
        }
        ,
        76984: e => {
            e.exports = '<div class="audit-logs-expanded-detail">\n    <div class="log-detail__bg">\n        <div class="log-detail__contents">\n            <div class="log-quick-summary">\n                <audit-logs-resource-chip [resourceData]="{ type: resourceType, name: resourceName }" [actionType]="logType"></audit-logs-resource-chip>\n                <chip-list [hidePagination]="true" [listType]="\'chip\'" [data]="convertToChipData()"></chip-list>\n            </div>\n\n            <div class="log-detail__details">\n                <div class="log-detail__cols">\n                    \x3c!-- log.client column --\x3e\n                    <div class="log-detail__col">\n                        <span class="log-detail__col-header">{{ msgs.client.header() }}</span>\n                        <ul>\n                            <li><strong>{{ msgs.client.user() }}: </strong>{{ log.client.username }}</li>\n                            <li>\n                                <strong>{{ msgs.client.authType() }}: </strong><span class="monospace">{{ log.client.authType }}</span>\n                            </li>\n                            <li *ngIf="log.client.remoteAuthProvider">\n                                <strong>{{ msgs.client.remoteAuthProvider() }}: </strong><span class="monospace">{{ log.client.remoteAuthProvider }}</span>\n                            </li>\n                            <li><strong>{{ msgs.client.address() }}: </strong><span class="monospace">{{ log.client.address }}</span>\n                            </li>\n                            <li *ngIf="log.client.forwarding">\n                                <strong>{{ msgs.client.forwardingAddresses() }}: </strong><span class="monospace">{{ log.client.forwarding.addresses }}</span>\n                            </li>\n                            <li *ngIf="log.client.forwarding">\n                                <strong>{{ msgs.client.originatingAddress() }}: </strong><span class="monospace">{{ log.client.forwarding.originatingAddress }}</span>\n                            </li>\n                            <li>\n                                <strong>{{ msgs.client.userAgent() }}: </strong><span class="monospace">{{ log.client.userAgent }}</span>\n                            </li>\n                        </ul>\n                    </div>\n                    \x3c!-- log.request column --\x3e\n                    <div class="log-detail__col">\n                        <span class="log-detail__col-header">{{ msgs.request.header() }}</span>\n                        <ul>\n                            <li *ngIf="log.request.resource">\n                                <strong>{{ msgs.request.resourceName() }}: </strong>\n                                {{ log.request.resource.name }}\n                            </li>\n                            <li *ngIf="log.request.parentResource">\n                                <strong>{{ msgs.request.parentResourceName() }}: </strong>\n                                {{ log.request.parentResource.name }}\n                            </li>\n                            <li>\n                                <strong>{{ msgs.request.requestUri() }}: </strong><span class="monospace">{{ log.request.uri }}</span>\n                            </li>\n                            <li>\n                                <strong>{{ msgs.request.requestTime() }}: </strong>\n                                {{ log.request.time | date: dateFormat.long }}\n                            </li>\n                            <li *ngIf="log.request.responseStatus">\n                                <strong>{{ msgs.request.responseStatus() }}: </strong>\n                                <span class="monospace">\n                                    {{ log.request.responseStatus }}\n                                    \x3c!-- info icon for 100 level status --\x3e\n                                    <mat-icon [color]="\'warn\'" class="fa-solid fa-circle-info" *ngIf="log.request.responseStatus <= 199"></mat-icon>\n                                    \x3c!-- success icon for 200 level status --\x3e\n                                    <mat-icon [color]="\'success\'" class="fa-solid fa-circle-check" *ngIf="log.request.responseStatus >= 200 && log.request.responseStatus <= 299"></mat-icon>\n                                    \x3c!-- fail icon for 300+ level status --\x3e\n                                    <mat-icon [color]="\'fail\'" class="fa-solid fa-circle-xmark" *ngIf="log.request.responseStatus >= 300"></mat-icon>\n                                </span>\n                            </li>\n                        </ul>\n                    </div>\n                    \x3c!-- log.metrics column --\x3e\n                    <div class="log-detail__col">\n                        <span class="log-detail__col-header">{{ msgs.metrics.header() }}</span>\n                        <ul>\n                            <li *ngIf="log.metrics.earliestPlaybackTime">\n                                <strong>{{ msgs.metrics.earliestPlaybackTime() }}: </strong>\n                                {{ log.metrics.earliestPlaybackTime | date: dateFormat.long }}\n                            </li>\n                            <li *ngIf="log.metrics.latestPlaybackTime">\n                                <strong>{{ msgs.metrics.latestPlaybackTime() }}: </strong>\n                                \x3c!-- If video is still currently being viewed --\x3e\n                                <span *ngIf="log.metrics.streamSessionDuration === 0">{{ msgs.currentlyViewing() }}</span>\n                                \x3c!-- else show end time --\x3e\n                                <span *ngIf="log.metrics.streamSessionDuration !== 0">\n                                    {{ log.metrics.latestPlaybackTime | date: dateFormat.long }}\n                                </span>\n                            </li>\n                            <li *ngIf="log.metrics.rateLimitGroupDuration">\n                                <strong>{{ msgs.metrics.rateLimitGroupDuration() }}: </strong>\n                                {{ formatDuration(log.metrics.rateLimitGroupDuration) }}\n                            </li>\n                            <li *ngIf="log.metrics.requestCount">\n                                <strong>{{ msgs.metrics.requestCount() }}: </strong>\n                                {{ log.metrics.requestCount }}\n                            </li>\n                            <li *ngIf="log.metrics.streamSessionDuration">\n                                <strong>{{ msgs.metrics.streamSessionDuration() }}: </strong>\n                                {{ formatDuration(log.metrics.streamSessionDuration) }}\n                            </li>\n                        </ul>\n                    </div>\n                </div>\n\n                \x3c!-- Change Diff --\x3e\n                <div *ngIf="log.request.changeDiff && log.request.changeDiff.original && log.request.changeDiff.updated" class="log-detail__change-diff-summary">\n                    <span class="log-detail__col-header">{{ msgs.request.changeDiff() }}: </span>\n                    <div class="log-detail__change-diff-columns">\n                        <div class="log-detail__change-diff-col log-detail__change-diff-col--original">\n                            <strong>{{ msgs.request.original() }}: </strong>\n                            <pre class="monospace">{{ getChangeDiff(log.request.changeDiff.original) }}</pre>\n                        </div>\n                        <div class="log-detail__change-diff-col log-detail__change-diff-col--updated">\n                            <strong>{{ msgs.request.updated() }}: </strong>\n                            <pre class="monospace">{{ getChangeDiff(log.request.changeDiff.updated) }}</pre>\n                        </div>\n                    </div>\n                </div>\n\n            </div>\n        </div>\n    </div>\n    \x3c!-- Spacer with height value to replace margin-bottom to avoid animation flicker --\x3e\n    <div class="log-detail__spacer"></div>\n</div>\n'
        }
        ,
        10719: e => {
            e.exports = '<section class="audit-logs-filters">\n    <mat-expansion-panel #auditLogsFiltersMainPanel hideToggle>\n        \x3c!-- Main Panel Header and Custom Arrow Toggle --\x3e\n        <mat-expansion-panel-header class="main-header">\n            <div class="main-header-contents">\n                <div class="main-header-contents-top">\n                    <mat-panel-title>\n                        <h2>{{ msgs.filters.headline() }}</h2>\n                    </mat-panel-title>\n\n                    <mat-panel-description>\n                        <i class="fa-solid fa-chevron-right" [class.fa-rotate-90]="auditLogsFiltersMainPanel.expanded"></i>\n                    </mat-panel-description>\n                </div>\n\n                <div class="main-header-contents-bottom">\n                    \x3c!-- Date Button --\x3e\n                    <button mat-raised-button class="mat-accent date-range-button" (click)="handleDateRangeClick($event)">\n                        <mat-icon class="fa-regular fa-calendar"></mat-icon>\n                        {{ dateButtonLabel }}\n                        <mat-icon (click)="handleDateRangeReset($event)" class="fa-solid fa-circle-xmark date-range-reset-button" *ngIf="isDateRangeDirty"></mat-icon>\n                    </button>\n\n                    \x3c!-- Active Chips --\x3e\n                    <div class="active-chips">\n                        \x3c!-- User Chips --\x3e\n                        <mat-chip *ngFor="let user of activeUsers" (click)="removeUser(user)">\n                            <div class="active-chip-copy">\n                                <span class="hint">{{ user.title }}</span>\n                                <span>{{ user.name }}</span>\n                            </div>\n                            <i class="fa-solid fa-circle-xmark"></i>\n                        </mat-chip>\n\n                        \x3c!-- Camera Chips --\x3e\n                        <mat-chip *ngFor="let camera of activeCameras" (click)="removeCamera(camera)">\n                            <div class="active-chip-copy">\n                                <span class="hint">{{ msgs.resources.camera() }}</span>\n                                <span>{{ camera.name }}</span>\n                            </div>\n                            <i class="fa-solid fa-circle-xmark"></i>\n                        </mat-chip>\n                    </div>\n                </div>\n            </div>\n        </mat-expansion-panel-header>\n\n        <ng-template matExpansionPanelContent>\n            <form [formGroup]="selectedFilters">\n                <mat-accordion multi hideToggle>\n                    \x3c!-- User filter panel --\x3e\n                    <mat-expansion-panel #auditLogsUserFilterPanel class="filter-panel filter-panel--users">\n                        \x3c!-- Header and Custom Arrow Toggle --\x3e\n                        <mat-expansion-panel-header>\n                            <mat-panel-title>\n                                <h2>\n                                    <i class="fa-solid fa-circle-user"></i>\n                                    {{ msgs.filters.selectUser() }}\n                                </h2>\n                            </mat-panel-title>\n                            <mat-panel-description>\n                                <i class="fa-solid fa-chevron-right" [class.fa-rotate-90]="auditLogsUserFilterPanel.expanded"></i>\n                            </mat-panel-description>\n                        </mat-expansion-panel-header>\n                        \x3c!-- User Selection --\x3e\n                        <ng-template matExpansionPanelContent>\n                            <selectable-chip-list [listType]="\'checkbox\'" [data]="chipUsersData" [checkboxForm]="selectedFilters.controls[\'users\']"></selectable-chip-list>\n                        </ng-template>\n                    </mat-expansion-panel>\n\n                    \x3c!-- Camera filter panel --\x3e\n                    <mat-expansion-panel #auditLogsCameraFilterPanel class="filter-panel filter-panel--cameras">\n                        \x3c!-- Header and Custom Arrow Toggle --\x3e\n                        <mat-expansion-panel-header>\n                            <mat-panel-title>\n                                <h2>\n                                    <i class="fa-solid fa-video-camera"></i>\n                                    {{ msgs.filters.selectCamera() }}\n                                </h2>\n                            </mat-panel-title>\n                            <mat-panel-description>\n                                <i class="fa-solid fa-chevron-right" [class.fa-rotate-90]="auditLogsCameraFilterPanel.expanded"></i>\n                            </mat-panel-description>\n                        </mat-expansion-panel-header>\n                        \x3c!-- Camera Selection --\x3e\n                        <ng-template matExpansionPanelContent>\n                            <selectable-chip-list [listType]="\'checkbox\'" [data]="chipCamerasData" [checkboxForm]="selectedFilters.controls[\'cameras\']"></selectable-chip-list>\n                        </ng-template>\n                    </mat-expansion-panel>\n\n                    \x3c!-- Advanced filters panel --\x3e\n                    <mat-expansion-panel #auditLogsAdvancedFiltersPanel class="filter-panel filter-panel--advanced">\n                        \x3c!-- Header and Custom Arrow Toggle --\x3e\n                        <mat-expansion-panel-header>\n                            <mat-panel-title>\n                                <h2>\n                                    <i class="fa-solid fa-cogs"></i>\n                                    {{ msgs.filters.advancedFilters() }}\n                                </h2>\n                            </mat-panel-title>\n                            <mat-panel-description>\n                                <i class="fa-solid fa-chevron-right" [class.fa-rotate-90]="auditLogsAdvancedFiltersPanel.expanded"></i>\n                            </mat-panel-description>\n                        </mat-expansion-panel-header>\n\n                        \x3c!-- AuthType Selection --\x3e\n                        <ng-template matExpansionPanelContent>\n                            <h3>{{ msgs.filters.selectAuthType() }}</h3>\n                            <selectable-chip-list #authTypeChips [selectAll]="true" [listType]="\'checkbox\'" [data]="chipAuthTypesData" [checkboxForm]="selectedFilters.controls[\'authTypes\']"></selectable-chip-list>\n                        </ng-template>\n                    </mat-expansion-panel>\n                </mat-accordion>\n            </form>\n            \x3c!-- Filters Footer --\x3e\n            <div class="audit-logs-filters__footer">\n                \x3c!-- Reset Button --\x3e\n                <button mat-flat-button (click)="handleResetClick()">{{ msgs.filters.reset() }}</button>\n\n                \x3c!-- Search Button --\x3e\n                <button mat-flat-button color="primary" (click)="auditLogsFiltersMainPanel.expanded = false; handleSearchClick()">\n                    {{ msgs.filters.search() }}\n                </button>\n            </div>\n        </ng-template>\n    </mat-expansion-panel>\n\n    \x3c!-- Resources Selector --\x3e\n</section>\n'
        }
        ,
        72703: e => {
            e.exports = '<div class="mat-chip action-type-{{ actionType }}">\n    <div class="chip-title-container">\n        <span class="action-type-label">{{ actionType }}</span>\n        <i class="resource-icon {{ getIcon() }}"></i>\n    </div>\n    <span class="chip-label">\n        <span class="resource-type">{{ resourceTypeLabel }}</span>\n        <span class="resource-name" *ngIf="resourceData.name">: {{ resourceData.name }}</span>\n    </span>\n</div>\n'
        }
        ,
        64161: e => {
            e.exports = '<mat-table #logsTable matSort (matSortChange)="handleSort($event)" [matSortActive]="sort.active" [matSortDirection]="sort.direction" matSortDisableClear class="audit-logs-table expandable-striped-table" [dataSource]="dataSource" multiTemplateDataRows>\n    \x3c!-- Description column --\x3e\n    <ng-container [matColumnDef]="COLUMNS.DESCRIPTION">\n        <mat-header-cell *matHeaderCellDef>{{ msgs.description() }}</mat-header-cell>\n        <mat-cell *matCellDef="let log">\n            <div>\n                {{ getDescription(log) }}\n            </div>\n        </mat-cell>\n    </ng-container>\n\n    \x3c!-- Resource column --\x3e\n    <ng-container [matColumnDef]="COLUMNS.RESOURCE">\n        <mat-header-cell *matHeaderCellDef>{{ msgs.resource() }}</mat-header-cell>\n        <mat-cell *matCellDef="let log">\n            <audit-logs-resource-chip class="resource-chip" matTooltip="{{ getParentName(log) }}" [resourceData]="{ type: getParentResource(log), name: getParentName(log) }" [actionType]="getAction(log)"></audit-logs-resource-chip>\n        </mat-cell>\n    </ng-container>\n\n    \x3c!-- User column --\x3e\n    <ng-container [matColumnDef]="COLUMNS.USER">\n        <mat-header-cell *matHeaderCellDef>{{ msgs.user() }}</mat-header-cell>\n        <mat-cell *matCellDef="let log">\n            <div class="username-container">\n                <span class="hint-text">{{ getAuthType(log.client.authType, log.client.remoteAuthProvider) }}</span>\n                <span class="username-label">{{ log.client.username }}</span>\n            </div>\n        </mat-cell>\n    </ng-container>\n    >\n\n    \x3c!-- Date/Time column --\x3e\n    <ng-container [matColumnDef]="COLUMNS.DATE">\n        <mat-header-cell *matHeaderCellDef mat-sort-header> {{ msgs.date() }}</mat-header-cell>\n        <mat-cell *matCellDef="let log">{{ log.request.time | date: dateFormat.long }} </mat-cell>\n    </ng-container>\n\n    \x3c!-- Expanded Content Column - The detail row is made up of this one column that spans across all columns --\x3e\n    <ng-container matColumnDef="expandedDetail">\n        <mat-cell *matCellDef="let log" [attr.colspan]="columnsToDisplay.length">\n            <div class="detail-contents">\n                \x3c!-- <div [@fadeInOut]="expandedLogs[log.id] === true ? \'fade-in\' : \'fade-out\'"> --\x3e\n                <div [@detailExpand] *ngIf="expandedLogs[log.id] === true">\n                    <audit-logs-expanded-detail [log]="log" [logType]="getAction(log)" [resourceType]="getResource(log)" [userType]="getAuthType(log.client.authType, log.client.remoteAuthProvider)" [class]="\'log-action-type-\' + getAction(log)" [description]="getDescription(log)"></audit-logs-expanded-detail>\n                </div>\n            </div>\n        </mat-cell>\n    </ng-container>\n\n    \x3c!-- Footer row - more "pagination" button --\x3e\n    <ng-container matColumnDef="footer">\n        <td mat-footer-cell *matFooterCellDef>\n            <table-indeterminate-footer *ngIf="dataSource.data.length" [pageSize]="pageSize" [dataSource]="dataSource.data" [showSpinner]="state === ComponentState.Loading" (moreClick)="moreClick.emit($event)"></table-indeterminate-footer>\n        </td>\n    </ng-container>\n\n    <mat-header-row *matHeaderRowDef="columnsToDisplay"></mat-header-row>\n\n    <mat-row *matRowDef="let log; columns: columnsToDisplay" matRipple class="log-summary-row" [@rowReveal] [class.expanded-row]="expandedLogs[log.id]" (click)="handleSummaryClick(log.id)"></mat-row>\n    <mat-row *matRowDef="let log; columns: [\'expandedDetail\']" class="log-detail-row" [class.expanded-row]="expandedLogs[log.id]"></mat-row>\n    <mat-footer-row *matFooterRowDef="[\'footer\']"></mat-footer-row>\n</mat-table>\n'
        }
        ,
        70595: e => {
            e.exports = '<div class="camera-group-settings-dialog">\n    <mat-toolbar color="primary">\n        <span class="toolbar-title">{{ msgs.cameraGroupSettings() }}</span>\n        <button mat-icon-button (click)="cancel()" [disabled]="processing">\n            <i class="fa fa-times fa-2x"></i>\n        </button>\n    </mat-toolbar>\n\n    <mat-dialog-content>\n        <div>\n            <mat-checkbox class="show-servers-checkbox" [checked]="showOrchids === \'true\'" (change)="showOrchids = $event.checked ? \'true\' : \'false\'">{{ msgs.showServersInBag() }}</mat-checkbox>\n        </div>\n    </mat-dialog-content>\n\n    <sing-dialog-errors *ngIf="error !== undefined" [errmsg]="error" [canClose]="true" (onClose)="error = undefined"></sing-dialog-errors>\n\n    <mat-dialog-actions>\n        <button mat-button mat-dialog-close color="primary" (click)="cancel()" [disabled]="processing">{{ msgs.cancel() }}</button>\n\n        <button class="update-button" mat-raised-button color="primary" (click)="updateCameraGroupSettings()" [disabled]="processing">\n            <div [ngStyle]="{\'visibility\': processing ? \'hidden\' : \'visible\'}">\n                <span class="hide-at-500px-or-less">{{ msgs.updateSettings() }}</span>\n                <span class="hide-at-gt-500px">{{ msgs.update() }}</span>\n            </div>\n            <mat-spinner class="processing-spinner" *ngIf="processing" mode="indeterminate" diameter="25"></mat-spinner>\n        </button>\n    </mat-dialog-actions>\n</div>\n'
        }
        ,
        96062: e => {
            e.exports = '<mat-toolbar class="dialog-toolbar" color="primary">\n    <span class="dialog-title">{{ msgs.movedNamedGroup({VALUE: dialogData.group.name }) }}</span>\n    <button mat-icon-button disableRipple="true" [disabled]="processing" (click)="close()">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content>\n    <mat-form-field appearance="fill" class="parent-group-selection">\n        <mat-label>{{ msgs.parentGroup() }}</mat-label>\n        <mat-select [(value)]="selectedItem">\n            <mat-option *ngFor="let flatGroup of flatGroups" [value]="flatGroup">\n                {{ flatGroup.groupPath }}\n            </mat-option>\n        </mat-select>\n    </mat-form-field>\n</mat-dialog-content>\n\n<sing-dialog-errors *ngIf="error !== undefined" [errmsg]="error" [canClose]="true" (onClose)="error = undefined"></sing-dialog-errors>\n\n<mat-dialog-actions>\n    <button mat-button mat-dialog-close (click)="close()">{{ msgs.cancel() }}</button>\n\n    <button mat-button mat-raised-button color="primary" [disabled]="processing" (click)="moveGroup()">\n        <span [class.invisible]="processing">{{ msgs.moveGroup() }}</span>\n\n        <mat-progress-spinner class="centered-spinner" *ngIf="processing" diameter="25" color="primary" mode="indeterminate"></mat-progress-spinner>\n    </button>\n</mat-dialog-actions>\n'
        }
        ,
        81723: e => {
            e.exports = '<mat-toolbar color="primary">\n    <span mat-dialog-title class="toolbar-title">{{ msgs.addCamerasToGroup() }}</span>\n    <button class="add-lib-x-button" mat-icon-button disableRipple="true" (click)="cancel()" [disabled]="processing">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n<mat-dialog-content>\n    <form [formGroup]="formGroup">\n        \x3c!-- Select a group to assign cameras to --\x3e\n        <mat-form-field class="select-group">\n            <mat-label>{{ msgs.selectAGroup() }}</mat-label>\n            <mat-select class="selectClass" formControlName="groupId" required cdkFocusInitial panelClass="group-name-select" #groupNameSelect (openedChange)="scrollToNode($event)" disableOptionCentering>\n                <mat-tree [dataSource]="dataSource" [treeControl]="treeControl">\n                    \x3c!-- This is the tree node template for leaf nodes --\x3e\n                    <mat-tree-node *matTreeNodeDef="let node" matTreeNodePadding id="{{node.id}}">\n                        \x3c!-- use a disabled button to provide padding for tree leaf --\x3e\n                        <mat-option class="option-container" [value]="node.id">\n                            <button mat-icon-button disabled="disabled"></button>\n                            {{node.name}}\n                        </mat-option>\n                    </mat-tree-node>\n                    \x3c!-- This is the tree node template for expandable nodes --\x3e\n                    <mat-tree-node *matTreeNodeDef="let node; when: hasChild" matTreeNodePadding id="{{node.id}}">\n                        <mat-option class="option-container" [value]="node.id">\n                            <button mat-icon-button matTreeNodeToggle [attr.aria-label]="\'Toggle \' + node.name">\n                                <mat-icon class="mat-icon-rtl-mirror">\n                                    <i class="fa fa-chevron-right expanded-icon" [ngClass]="{\'down\': treeControl.isExpanded(node)}"></i>\n                                </mat-icon>\n                            </button>\n                            {{node.name}}\n                        </mat-option>\n                    </mat-tree-node>\n                </mat-tree>\n            </mat-select>\n            <mat-error *ngIf="formGroup.controls[\'groupId\'].hasError(\'required\')">\n                {{ msgs.groupNameIsRequired()}}\n            </mat-error>\n        </mat-form-field>\n\n        <camera-picker *ngIf="!loading" [data]="ungroupedOrchids" [loaded]="!loading" (onTotalDataListChange)="updateCamerasAndServers($event)"></camera-picker>\n    </form>\n</mat-dialog-content>\n\x3c!-- Dialog Error --\x3e\n<sing-dialog-errors class="error-banner" *ngIf="showError" (onClose)="dismissMe()" [errmsg]="error">\n</sing-dialog-errors>\n<mat-dialog-actions>\n    <div class="running-total">\n        <button mat-stroked-button color="primary" [disabled]="totalCameras === 0 && totalServers === 0">\n            <span class="total-text">\n                {{ msgs.totalServers({SERVERS: totalServers }) }} &nbsp; {{ msgs.totalCameras({CAMERAS: totalCameras })\n                }}\n            </span>\n            <span class="total-icons">\n                <i class="fa fa-server fa-regular"></i>: {{ totalServers }} &nbsp; <i class="fa fa-video-camera"></i>:\n                {{ totalCameras }}\n            </span>\n        </button>\n    </div>\n    <div class="main-buttons">\n        <button mat-button class="cancel-button" [disabled]="processing" (click)="processing ? none : cancel()">\n            {{msgs.cancel()}}\n        </button>\n        <spinner-button class="save-button" [disabled]="formGroup.value.groupId === null || (totalCameras === 0 && totalServers === 0)" [text]="msgs.addToGroup()" [color]="\'primary\'" (click)="addToGroup()" [showSpinner]="processing"></spinner-button>\n    </div>\n</mat-dialog-actions>\n'
        }
        ,
        54312: e => {
            e.exports = '<div class="search-and-toggle">\n    \x3c!-- Search bar --\x3e\n    <div class="search-filter">\n        <search-bar class="search-bar" #searchChipInput [data]="allDataNames" (filteredData)="updateFilteredData($event)"></search-bar>\n\n        \x3c!-- Selected only filter --\x3e\n        <div class="filter-menu">\n            <div class="filter-button">\n\n                <button mat-icon-button [matMenuTriggerFor]="menu">\n                    <i class="fa fa-filter fa-lg"></i>\n                    <i class="fa fa-caret-down"></i>\n                </button>\n            </div>\n            <mat-menu #menu="matMenu" xPosition="before">\n                <button mat-menu-item (click)="getSelectedData()">\n                    <i class="fa-regular fa-check-square fa-lg"></i>&nbsp;\n                    <span>{{ messages.cameraPicker.selectedOnly() }}</span>\n                </button>\n            </mat-menu>\n        </div>\n    </div>\n\n    <div class="dropdown-toggle">\n\n        \x3c!-- Drop down filter search --\x3e\n        <mat-form-field appearance="fill" class="drop-down">\n            <mat-label>{{ messages.cameraPicker.searchOptions() }}</mat-label>\n            <mat-select disableOptionCentering (selectionChange)="getAdvancedSearchOption($event)" [(ngModel)]="advancedSearch" [disabled]="camerasOnly">\n                <mat-option *ngFor="let option of searchingOptions" [value]="option.value">\n                    {{option.name}}\n                </mat-option>\n            </mat-select>\n        </mat-form-field>\n\n        \x3c!-- Toggle between views --\x3e\n        <div class="toggle-buttons" *ngIf="!camerasOnly">\n            <mat-button-toggle-group [(ngModel)]="viewType">\n                <mat-button-toggle value="cards" (click)="tabsChangeView.selectedIndex = 0" matTooltip="{{ messages.cameraPicker.cardView() }}" [matTooltipShowDelay]="800">\n                    <i class="fa fa-bars fa-lg"></i>\n                </mat-button-toggle>\n                <mat-button-toggle value="table" (click)="tabsChangeView.selectedIndex = 1" matTooltip="{{ messages.cameraPicker.tableView() }}" [matTooltipShowDelay]="800">\n                    <i class="fa fa-table fa-lg"></i>\n                </mat-button-toggle>\n            </mat-button-toggle-group>\n        </div>\n    </div>\n\n</div>\n\n\n\x3c!-- Mat-tab allows for toggling view animation --\x3e\n\n<mat-tab-group dynamicHeight class="invisible-tabs" #tabsChangeView>\n    <mat-tab label="cards">\n        \x3c!-- If data is loading --\x3e\n        <page-loading *ngIf="!loaded && building">\n        </page-loading>\n\n        \x3c!-- Camera Picker Card View --\x3e\n        <picker-cards *ngIf="loaded" [style.visibility]="viewType === ViewTypes.CARDS && loaded ? \'visible\' : \'hidden\'" [servers]="serverData" [totalDataList]="totalDataList" [noData]="noData" [filtering]="filtering" [advancedSearch]="advancedSearch" [selectedData]="selectedData" [viewType]="viewType" [hideSelectAllCameras]="hideSelectAllCameras" [hideSelectAllServers]="hideSelectAllServers" [camerasOnly]="camerasOnly" [pageSizeOptions]="pageSizeOptions" [pageSizeCameras]="pageSizeCameras" (updated)="sendSelectedToParent(totalDataList)"></picker-cards>\n    </mat-tab>\n\n    <mat-tab label="table">\n        \x3c!-- If data is loading --\x3e\n        <page-loading *ngIf="!loaded && building">\n        </page-loading>\n\n        \x3c!-- Camera Picker Table View --\x3e\n        \x3c!-- In an effort to get the 24.12.0 release out, we are just hiding table view when in cameras only mode. --\x3e\n        <picker-table *ngIf="loaded && !camerasOnly" [style.visibility]="viewType === ViewTypes.TABLE && loaded ? \'visible\' : \'hidden\'" [servers]="serverData" [data]="serverDataTable" [totalDataList]="totalDataList" [noData]="noData" [filtering]="filtering" [selectedData]="selectedData" [viewType]="viewType" [advancedSearch]="advancedSearch" [hideSelectAllCameras]="hideSelectAllCameras" [hideSelectAllServers]="hideSelectAllServers" (updated)="sendSelectedToParent(totalDataList)"></picker-table>\n    </mat-tab>\n</mat-tab-group>\n'
        }
        ,
        22718: e => {
            e.exports = '<div>\n    <mat-chip-list class="list-item">\n        <div class="server-item" *ngIf="isServer">\n            <mat-chip class="server" [disabled]="!dataItem.supported" (click)="onClickServer(dataItem)">\n                <mat-checkbox (click)="$event.stopPropagation()" (change)="$event ? onClickServer(dataItem) : null" [checked]="dataItem.selected" [disabled]="!dataItem.supported">\n                    <p matTooltip="{{ dataItem.serverName }}" [matTooltipShowDelay]="800">\n                        {{ messages.motionStyles.server() }}\n                    </p>\n                </mat-checkbox>\n            </mat-chip>\n        </div>\n        <div class="camera-tile" *ngIf="!isServer">\n            <mat-chip [disabled]="dataItem.serverSelected || !dataItem.supported" (click)="dataItem.serverSelected ? null : onClickCamera(dataItem)">\n                <mat-checkbox (click)="$event.stopPropagation()" (change)="$event ? onClickCamera(dataItem) : null" [checked]="dataItem.serverSelected ? dataItem.serverSelected : dataItem.selected" [disabled]="dataItem.serverSelected || !dataItem.supported">\n                    <p [class.disabled-camera-text]="!isCameraEnabled(dataItem)" matTooltip="{{ dataItem.cameraName }}" [matTooltipShowDelay]="800">\n                        <i *ngIf="!isCameraEnabled(dataItem)" class="{{ playerIcons.camera_disabled }}"></i>\n                        {{ dataItem.cameraName }}\n                    </p>\n                </mat-checkbox>\n            </mat-chip>\n        </div>\n    </mat-chip-list>\n</div>\n'
        }
        ,
        66475: e => {
            e.exports = '<search-bar class="search-bar" [data]="cameraNames" (filteredData)="updateFilteredData($event)"></search-bar>\n\n<div *ngIf="filteredCameras.length > 0; else noCameraDiscoveredCard" (window:resize)="onResize($event)">\n    \x3c!-- Preview Tiles --\x3e\n    <div class="preview-tiles" *ngIf="showThumbnails">\n        <div *ngFor="let camera of pagedCamerasArray">\n            <preview-tile [dataItem]="camera" (onServerSelected)="onClickServer($event)" (onCameraSelected)="onClickCamera($event)"></preview-tile>\n        </div>\n    </div>\n    \x3c!-- List items (chips) --\x3e\n    <div class="list-items" *ngIf="!showThumbnails">\n        <div *ngFor="let camera of pagedCamerasArray">\n            <list-item [dataItem]="camera" (onServerSelected)="onClickServer($event)" (onCameraSelected)="onClickCamera($event)"></list-item>\n        </div>\n    </div>\n\n    \x3c!-- Pagination of cameras --\x3e\n    <pagination class="pagination-cameras" (page)="handlePageEventCameras($event)" [dataSource]="filteredCameras" (pagedData)="updatePagedCameras($event)" [pageSize]="pageSizeCameras" [pageSizeOptions]="pageSizeOptionsCameras">\n    </pagination>\n</div>\n\n<ng-template #noCameraDiscoveredCard>\n    \x3c!-- No cameras match the search message --\x3e\n    <div class="no-matches-error-message no-data">\n        {{ messages.noCamerasMatchSearch() }}\n    </div>\n</ng-template>\n'
        }
        ,
        69215: e => {
            e.exports = '<div class="picker-cards" *ngIf="!noData; else noServerDiscoveredCard">\n    \x3c!-- Select all and change view --\x3e\n    <div class="select-and-thumbnails">\n        <div class="select-all" *ngIf="!(hideSelectAllCameras && hideSelectAllServers)">\n            <mat-checkbox *ngIf="!hideSelectAllServers" name="servers" class="bulkServerSelector" (click)="$event.stopPropagation()" (change)="onClickBulkSelect($event)" [(ngModel)]="allServers">{{ messages.cameraPicker.selectAllServers() }}</mat-checkbox>\n            <mat-checkbox *ngIf="!hideSelectAllCameras" name="cameras" class="bulkCameraSelector" (click)="$event.stopPropagation()" (change)="onClickBulkSelect($event)" [(ngModel)]="allCameras" [disabled]="noCameras">{{ messages.cameraPicker.selectAllCameras() }}</mat-checkbox>\n        </div>\n        <div class="slide-toggles">\n            <mat-slide-toggle class="slide-toggle" [checked]="showThumbnails" (change)="$event ? changeView() : null" labelPosition="before">\n                <span class="toggle-text">\n                    {{ messages.cameraPicker.showThumbnails() }}\n                </span>\n                <i class="fa-regular fa-image mobile-icons fa-lg" aria-hidden="true"></i>\n            </mat-slide-toggle>\n        </div>\n    </div>\n\n    \x3c!-- Server cards --\x3e\n    <mat-accordion multi *ngIf="pagedServers.length !== 0; else noServerDiscoveredCard">\n        <mat-expansion-panel *ngFor="let server of pagedServers; let i = index" hideToggle #panel>\n            \x3c!-- Card header --\x3e\n            <mat-expansion-panel-header [class.is-disabled]="!server.supported">\n                <mat-panel-title class="checkbox-header" *ngIf="!panel.expanded">\n                    <mat-checkbox [checked]="camerasOnly ? allCamerasAreSelected(server) : server.selected" [indeterminate]="camerasOnly ? someCamerasAreSelected(server) : getTotalCamerasSelected(server) !== 0" (click)="$event.stopPropagation()" (change)="onClickServer(server)" [disabled]="!server.supported">\n                    </mat-checkbox>\n                    <div class="server-details">\n                        <span class="server-name" matTooltip="{{ server.serverName }}" [matTooltipShowDelay]="800">\n                            {{ server.serverName }}\n                        </span>\n                        <span *ngIf="!server.supported" class="hint-text">\n                            {{ messages.notAvailable({VALUE: server.version}) }}\n                        </span>\n                    </div>\n                </mat-panel-title>\n                <div class="server-details" *ngIf="panel.expanded">\n                    <div class="checkbox-header">\n                        {{ server.serverName }}\n                    </div>\n                    <span *ngIf="!server.supported" class="hint-text">\n                        {{ messages.notAvailable({VALUE: server.version}) }}\n                    </span>\n                </div>\n\n                <tag class="camera-count" [label]="server.cameras.length" [icon]="InformationIcons.camera"></tag>\n\n            </mat-expansion-panel-header>\n\n            \x3c!-- Picker card contents --\x3e\n            <ng-template matExpansionPanelContent>\n                <picker-card-contents [showThumbnails]="showThumbnails" [advancedSearch]="advancedSearch" (serverClicked)="onClickServer($event)" (cameraClicked)="onClickCamera(server, $event)" [server]="server" [pageSizeCameras]="pageSizeCameras" [pageSizeOptions]="pageSizeOptions"></picker-card-contents>\n            </ng-template>\n        </mat-expansion-panel>\n    </mat-accordion>\n\n    \x3c!-- Pagination of servers --\x3e\n    <pagination class="pagination-total" (page)="handlePageEventServers($event)" [dataSource]="servers" (pagedData)="updatePagedServers($event)" [pageSize]="pageSizeServers" [pageSizeOptions]="pageSizeOptionsServers">\n    </pagination>\n</div>\n\n\x3c!-- No discoverable cameras message --\x3e\n<ng-template #noServerDiscoveredCard>\n    <div class="no-matches-error-message no-data">\n        <span *ngIf="!selectedData">\n            <span *ngIf="advancedSearch === SearchOptions.ALL && !filtering">\n                {{ messages.cameraPicker.noServersCamerasDiscovered() }}\n            </span>\n            <span *ngIf="advancedSearch === SearchOptions.SERVERS && !filtering">\n                {{ messages.cameraPicker.noServersDiscovered() }}\n            </span>\n            <span *ngIf="advancedSearch === SearchOptions.CAMERAS && !filtering">\n                {{ messages.noCamerasDiscovered() }}\n            </span>\n            <span *ngIf="advancedSearch === SearchOptions.ALL && filtering">\n                {{ messages.cameraPicker.noServersCamerasMatchSearch() }}\n            </span>\n            <span *ngIf="advancedSearch === SearchOptions.SERVERS && filtering">\n                {{ messages.cameraPicker.noServersMatchSearch() }}\n            </span>\n            <span *ngIf="advancedSearch === SearchOptions.CAMERAS && filtering">\n                {{ messages.noCamerasMatchSearch() }}\n            </span>\n        </span>\n        <span *ngIf="selectedData && !filtering">\n            {{ messages.cameraPicker.noSelectedData() }}\n        </span>\n        <span *ngIf="selectedData && filtering">\n            {{ messages.cameraPicker.noSelectedDataSearch() }}\n        </span>\n    </div>\n</ng-template>\n'
        }
        ,
        6558: e => {
            e.exports = '<div class="preview-tile" [class.is-disabled]="!dataItem.supported">\n    <div class="server-tile" *ngIf="isServer" (click)="dataItem.supported ? onClickServer(dataItem) : null" matRipple>\n        <div class="orchid-logo-container">\n            <img class="preview-image orchid-logo" src="images/logo_small_white.png">\n        </div>\n        <div class="preview-text">\n            <p matTooltip="{{ dataItem.serverName }}" [matTooltipShowDelay]="800">\n                {{ messages.motionStyles.server() }}\n            </p>\n            <mat-checkbox (click)="$event.stopPropagation()" (change)="$event ? onClickServer(dataItem) : null" [checked]="dataItem.selected" [disabled]="!dataItem.supported">\n            </mat-checkbox>\n        </div>\n    </div>\n    <div class="camera-tile" *ngIf="!isServer" (click)="(dataItem.serverSelected || !dataItem.supported) ? null : onClickCamera(dataItem)" matRipple [matRippleDisabled]="dataItem.serverSelected" [ngClass]="{ disabled: dataItem.serverSelected }">\n        <div class="stream-preview">\n            <sing-image-loader [src]="previewUrl" [disabled]="!itemIsEnabled(dataItem) || !dataItem.supported"></sing-image-loader>\n        </div>\n        <div class="preview-text">\n            <p matTooltip="{{ dataItem.cameraName }}" [matTooltipShowDelay]="800">\n                {{ dataItem.cameraName }}\n            </p>\n            <mat-checkbox (click)="$event.stopPropagation()" (change)="$event ? onClickCamera(dataItem) : null" [checked]="dataItem.serverSelected ? dataItem.serverSelected : dataItem.selected" [disabled]="dataItem.serverSelected || !dataItem.supported">\n            </mat-checkbox>\n        </div>\n    </div>\n</div>\n'
        }
        ,
        82816: e => {
            e.exports = '<div class="picker-table" *ngIf="!loading">\n    <mat-card>\n        <table class="interactive" mat-table multiTemplateDataRows matSort [dataSource]="advancedSearch === SearchOptions.ALL ? pagedData : dataSource" (matSortChange)="sortData($event)" matSortDirection="asc" matSortActive="DisplayColumns.SERVERS" [ngClass]="{ camerasOnlyTable: advancedSearch === SearchOptions.CAMERAS }">\n            \x3c!-- Server checkbox column --\x3e\n            <ng-container [matColumnDef]="DisplayColumns.SERVERSCHECKBOX">\n                \x3c!-- Select all header for servers --\x3e\n                <th mat-header-cell *matHeaderCellDef>\n                    <mat-checkbox *ngIf="!hideSelectAllServers" name="servers" [checked]="allServers" (click)="$event.stopPropagation()" (change)="onClickBulkSelect($event)" [indeterminate]="someServers"></mat-checkbox>\n                </th>\n                <ng-container *matCellDef="let data">\n                    <td mat-cell *ngIf="data.serverName" [attr.rowspan]="advancedSearch === SearchOptions.ALL ? data.rowSpan : 1" class="servers interactive-cell" [ngClass]="{ whiteBackground: data.index % 2, greyBackground: data.index! % 2 }" (click)="onClickServer(data)">\n                        <div class="server-cell" [style.display]="data.serverName ? \'\' : \'none\'">\n                            <div class="server-checkbox">\n                                <mat-checkbox (click)="$event.stopPropagation()" (change)="$event ? onClickServer(data) : null" [checked]="data.selected"></mat-checkbox>\n                            </div>\n                        </div>\n                    </td>\n                </ng-container>\n            </ng-container>\n\n            \x3c!-- Server Column --\x3e\n            <ng-container [matColumnDef]="DisplayColumns.SERVERS">\n                <th mat-header-cell *matHeaderCellDef mat-sort-header (click)="onChangePage(pageEvent)" disableClear>\n                    {{ messages.cameraPicker.servers() }}\n                </th>\n                <ng-container *matCellDef="let data">\n                    \x3c!-- When not in cameras only mode / server cell--\x3e\n                    <td mat-cell *ngIf="data.serverName && advancedSearch !== SearchOptions.CAMERAS" class="servers" [attr.rowspan]="advancedSearch === SearchOptions.ALL ? data.rowSpan : 1" [ngClass]="{ whiteBackground: data.index % 2, greyBackground: data.index! % 2 }" (click)="onClickServer(data)">\n                        <div class="server-cell interactive-cell" [style.display]="data.serverName ? \'\' : \'none\'">\n                            <div class="server-info" [ngClass]="advancedSearch === SearchOptions.ALL ? \'all-data\' : \'servers-or-cameras\'">\n                                <span class="server-name" matTooltip="{{ data.serverName }}" [matTooltipShowDelay]="800">\n                                    {{ data.serverName }}\n                                </span>\n\n                                <div class="camera-totals">\n                                    <icon-total [primaryColor]="true" [icon]="\'fa-check\'" [number]="getTotalCamerasSelected(data)" [hidden]="getTotalCamerasSelected(data) === 0 || filtering"></icon-total>\n                                    <icon-total [icon]="\'fa-video-camera\'" [number]="data.serverName ? data.cameras.length : \'\'" [primaryColor]="data.selected" [hidden]="filtering"></icon-total>\n                                </div>\n                            </div>\n                            \x3c!-- Shows how many cameras of the same server are on the next page --\x3e\n                            <span class="extra-cameras" *ngIf="\n                                    data.nextPageTotal > 0 &&\n                                    advancedSearch === SearchOptions.ALL &&\n                                    !isPaginationVisible\n                                ">\n                                <p>\n                                    {{ messages.cameraPicker.nextPageTotal({ VALUE: data.nextPageTotal }) }}\n                                    <i class="fa fa-long-arrow-right"></i>\n                                </p>\n                            </span>\n                        </div>\n                    </td>\n                    \x3c!-- When in cameras only mode --\x3e\n                    <td mat-cell *ngIf="advancedSearch === SearchOptions.CAMERAS" class="servers" (click)="onClickCamera(data.serverId, data.cameraId)">\n                        <div class="server-cell">\n                            <div class="server-checkbox server-name">\n                                <span matTooltip="{{ data.orchidName }}" [matTooltipShowDelay]="800">\n                                    {{ data.orchidName }}\n                                </span>\n                            </div>\n                        </div>\n                    </td>\n                </ng-container>\n            </ng-container>\n\n            \x3c!-- Camera checkbox column --\x3e\n            <ng-container [matColumnDef]="DisplayColumns.CAMERASCHECKBOX">\n                <th mat-header-cell *matHeaderCellDef matTooltip="{{ messages.cameraPicker.allServersAreSelected() }}" [matTooltipDisabled]="\n                        !(allCamsDisabled && advancedSearch === SearchOptions.CAMERAS) || hideSelectAllCameras\n                    ">\n                    <mat-checkbox *ngIf="!hideSelectAllCameras" #bulkCameraCheckbox name="cameras" (click)="$event.stopPropagation()" (change)="onClickBulkSelect($event)" [(ngModel)]="allCameras" [indeterminate]="someCameras" [disabled]="allCamsDisabled && advancedSearch === SearchOptions.CAMERAS"></mat-checkbox>\n                </th>\n                <ng-container *matCellDef="let data">\n                    \x3c!-- Server cell--\x3e\n                    <td mat-cell *ngIf="advancedSearch !== SearchOptions.CAMERAS && data.serverName" [ngClass]="{ whiteBackground: data.index % 2, greyBackground: data.index! % 2 }" (click)="onClickServer(data)">\n                        <mat-checkbox (click)="$event.stopPropagation()" (change)="$event ? onClickServer(data) : null" [checked]="data.selected"></mat-checkbox>\n                    </td>\n\n                    \x3c!-- Camera cell --\x3e\n                    <td mat-cell *ngIf="advancedSearch !== SearchOptions.CAMERAS && !data.serverName" [ngClass]="{ whiteBackground: data.index % 2, greyBackground: data.index! % 2 }" (click)="onClickCamera(data.serverId, data.cameraId)">\n                        <mat-checkbox (click)="$event.stopPropagation()" (change)="$event ? onClickCamera(data.serverId, data.cameraId) : null" [checked]="data.serverSelected ? data.serverSelected : data.selected" [disabled]="data.serverSelected"></mat-checkbox>\n                    </td>\n                    \x3c!-- Cameras only cell --\x3e\n\n                    <td mat-cell *ngIf="advancedSearch === SearchOptions.CAMERAS" (click)="onClickCamera(data.serverId, data.cameraId)" matTooltip="{{ messages.cameraPicker.serverIsSelected() }}" [matTooltipDisabled]="!(data.serverSelected && advancedSearch === SearchOptions.CAMERAS)">\n                        <mat-checkbox (click)="$event.stopPropagation()" (change)="$event ? onClickCamera(data.serverId, data.cameraId) : null" [checked]="data.serverSelected ? data.serverSelected : data.selected" [disabled]="data.serverSelected"></mat-checkbox>\n                    </td>\n                </ng-container>\n            </ng-container>\n\n            \x3c!-- Camera Column --\x3e\n            <ng-container [matColumnDef]="DisplayColumns.CAMERAS">\n                <th mat-header-cell *matHeaderCellDef mat-sort-header disableClear (click)="onChangePage(pageEvent)">\n                    <span class="cameras-heading">\n                        {{ messages.cameraPicker.cameras() }}\n                    </span>\n                </th>\n                <ng-container *matCellDef="let data">\n                    \x3c!-- server cell --\x3e\n                    <td mat-cell *ngIf="advancedSearch !== SearchOptions.CAMERAS && data.serverName" [ngClass]="{ whiteBackground: data.index % 2, greyBackground: data.index! % 2 }" (click)="onClickServer(data)">\n                        <span matTooltip="{{ messages.server() }}" [matTooltipShowDelay]="800">\n                            {{ messages.server() }}\n                        </span>\n                    </td>\n                    \x3c!-- Camera cell--\x3e\n                    <td mat-cell *ngIf="advancedSearch !== SearchOptions.CAMERAS && !data.serverName" [ngClass]="{ whiteBackground: data.index % 2, greyBackground: data.index! % 2 }" (click)="onClickCamera(data.serverId, data.cameraId)">\n                        <span [class.disabled-camera-text]="!isCameraEnabled(data)" matTooltip="{{ data.cameraName }}" [matTooltipShowDelay]="800">\n                            <i *ngIf="!isCameraEnabled(data)" class="{{ playerIcons.camera_disabled }}"></i>\n                            {{ data.cameraName }}\n                        </span>\n                    </td>\n\n                    \x3c!-- Cameras only cell --\x3e\n                    <td mat-cell *ngIf="advancedSearch === SearchOptions.CAMERAS && !data.serverName" (click)="onClickCamera(data.serverId, data.cameraId)">\n                        <span [class.disabled-camera-text]="!isCameraEnabled(data)" matTooltip="{{ data.cameraName }}" [matTooltipShowDelay]="800">\n                            <i *ngIf="!isCameraEnabled(data)" class="{{ playerIcons.camera_disabled }}"></i>\n                            {{ data.cameraName }}\n                        </span>\n                    </td>\n                </ng-container>\n            </ng-container>\n\n            \x3c!-- Layout of table --\x3e\n            <tr mat-header-row *matHeaderRowDef="displayedColumns" [ngClass]="{\n                    serversOnly: advancedSearch === SearchOptions.SERVERS,\n                    camerasOnly: advancedSearch === SearchOptions.CAMERAS\n                }"></tr>\n            <tr mat-row class="mat-row" *matRowDef="let data; columns: displayedColumns" [ngClass]="{\n                    serversOnly: advancedSearch === SearchOptions.SERVERS,\n                    camerasOnly: advancedSearch === SearchOptions.CAMERAS\n                }"></tr>\n\n            \x3c!-- Row options for when there is no data --\x3e\n            <tr class="mat-row row-no-cameras" *matNoDataRow>\n                <td class="mat-cell" [attr.colspan]="displayedColumns.length">\n                    <div class="cell-no-cameras no-matches-error-message">\n                        <span *ngIf="!selectedData">\n                            <span *ngIf="advancedSearch === SearchOptions.ALL && !filtering">\n                                {{ messages.cameraPicker.noServersCamerasDiscovered() }}\n                            </span>\n                            <span *ngIf="advancedSearch === SearchOptions.SERVERS && !filtering">\n                                {{ messages.cameraPicker.noServersDiscovered() }}\n                            </span>\n                            <span *ngIf="advancedSearch === SearchOptions.CAMERAS && !filtering">\n                                {{ messages.noCamerasDiscovered() }}\n                            </span>\n                            <span *ngIf="advancedSearch === SearchOptions.ALL && filtering">\n                                {{ messages.cameraPicker.noServersCamerasMatchSearch() }}\n                            </span>\n                            <span *ngIf="advancedSearch === SearchOptions.SERVERS && filtering">\n                                {{ messages.cameraPicker.noServersMatchSearch() }}\n                            </span>\n                            <span *ngIf="advancedSearch === SearchOptions.CAMERAS && filtering">\n                                {{ messages.noCamerasMatchSearch() }}\n                            </span>\n                        </span>\n                        <span *ngIf="selectedData && !filtering">\n                            {{ messages.cameraPicker.noSelectedData() }}\n                        </span>\n                        <span *ngIf="selectedData && filtering">\n                            {{ messages.cameraPicker.noSelectedDataSearch() }}\n                        </span>\n                    </div>\n                </td>\n            </tr>\n        </table>\n\n        \x3c!-- Pagination --\x3e\n        <mat-paginator *ngIf="dataSource.data.length !== 0" class="pagination-table" showFirstLastButtons [pageSize]="pageEvent.pageSize" [pageSizeOptions]="pageSizeOptions" [hidden]="!isPaginationVisible" (page)="clickPaginator($event)">\n        </mat-paginator>\n    </mat-card>\n</div>\n\n\x3c!-- If data is loading --\x3e\n<div class="loading" *ngIf="loading">\n    <mat-spinner mode="indeterminate" diameter="100"></mat-spinner>\n</div>\n'
        }
        ,
        47666: e => {
            e.exports = '<ng-container *ngIf="hasCameras; else noServerCameras">\n    <div class="camera-previews">\n        <stream-preview-checkbox *ngFor="let camera of cameras" [hideStreamSelect]="hideStreamSelect" [enableMotionWarning]="enableMotionWarning" [preSelected]="initiallySelectedCameraIds.has(camera.id)" [camera]="camera" [label]="checkboxText" [fallbackCameraName]="msgs.unknown()" (stateChanges)="onStateChange($event)"></stream-preview-checkbox>\n    </div>\n</ng-container>\n<ng-template #noServerCameras>\n    <div class="no-cameras-error-info">\n        {{ msgs.noCamerasAvailable() }}\n    </div>\n</ng-template>\n'
        }
        ,
        70160: e => {
            e.exports = '<div class="camera-manual-add-container">\n    <form class="manual-add-camera-form" [formGroup]="addCameraForm" (keydown.enter)="!formHasErrors() ? registerCameraManually() : null">\n        <div class="register-information-container">\n            <h3>{{ msgs.registerCamera() }}</h3>\n            <div class="camera-url-info-container">\n                <mat-form-field class="manual-add-camera-form-field driver-select">\n                    <mat-label>{{ msgs.driver() }}</mat-label>\n                    <mat-select formControlName="driver" class="manual-add-camera-select" (selectionChange)="handleDriverSelectChange($event)">\n                        <mat-option [value]="CameraDriverType.ONVIF">{{ CameraDriverType.ONVIF }}</mat-option>\n                        <mat-option [value]="CameraDriverType.RTSP">{{ CameraDriverType.RTSP }}</mat-option>\n                    </mat-select>\n                    <mat-error *ngIf="addCameraForm.controls[\'driver\'].hasError(\'required\')">\n                        {{ msgs.driverRequired() }}\n                    </mat-error>\n                </mat-form-field>\n                <mat-form-field class="manual-add-camera-form-field discovery-url">\n                    <mat-label>{{\n                        currentDriver === CameraDriverType.ONVIF ? msgs.onvifDiscoveryURL() : msgs.rtspStreamUri()\n                    }}</mat-label>\n                    <input matInput formControlName="discoveryUrl" class="manual-add-camera-input">\n                    <mat-error *ngIf="addCameraForm.controls[\'discoveryUrl\'].hasError(\'required\')">\n                        {{\n                            currentDriver === CameraDriverType.ONVIF\n                                ? msgs.onvifDiscoveryUrlRequired()\n                                : msgs.rtspStreamUriRequired()\n                        }}\n                    </mat-error>\n                </mat-form-field>\n            </div>\n            <mat-checkbox class="tls-ignore-checkbox" *ngIf="showTlsIgnoreCheckbox" formControlName="ignoreTlsCerts">{{\n                msgs.ignoreTlsCertificateValidation()\n            }}</mat-checkbox>\n            <mat-form-field class="manual-add-camera-form-field camera-name">\n                <mat-label>{{ msgs.cameraName() }}</mat-label>\n                <input matInput formControlName="name" class="manual-add-camera-input">\n                <mat-error *ngIf="addCameraForm.controls[\'name\'].hasError(\'required\')">\n                    {{ msgs.cameraNameRequired() }}\n                </mat-error>\n            </mat-form-field>\n        </div>\n        <div class="credentials-container">\n            <h3>{{ msgs.credentials() }}</h3>\n            <div class="credential-fields-container">\n                <mat-form-field class="manual-add-camera-form-field username">\n                    <mat-label>{{ formMsgs.labels.username() }}</mat-label>\n                    <input matInput formControlName="username" class="manual-add-camera-input">\n                    <mat-error *ngIf="addCameraForm.controls[\'username\'].hasError(\'required\')">\n                        {{ msgs.credentialErrors.username.usernameRequired() }}\n                    </mat-error>\n                </mat-form-field>\n                <password-form-field class="manual-add-camera-form-field password" formControlName="password" required="true" errorMessage="{{ msgs.credentialErrors.password.passwordRequired() }}" [label]="formMsgs.labels.password()"></password-form-field>\n            </div>\n        </div>\n    </form>\n</div>\n<sing-dialog-errors *ngIf="errorMessage.length > 0" [errmsg]="errorMessage" canClose="true" (onClose)="handleClosingErrorMessage()"></sing-dialog-errors>\n\n<div class="actions-bar-container">\n    <button (click)="cancelManualRegistration()" class="cancel-button" mat-button>{{ msgs.cancel() }}</button>\n    <spinner-button [disabled]="formHasErrors() || processing" (click)="registerCameraManually()" class="register-camera-button" [text]="msgs.registerCamera()" [showSpinner]="processing"></spinner-button>\n</div>\n'
        }
        ,
        89201: e => {
            e.exports = '<h2 mat-dialog-title class="add-camera-dialog-header">\n    <span class="dialog-title">{{ msgs.registerCameras() }}</span><button class="close-button" matRipple (click)="close()">\n        <i class="{{ ActionsIcons.close }} close-icon"></i>\n    </button>\n</h2>\n<mat-dialog-content class="add-camera-dialog-content">\n    <mat-tab-group dynamicHeight>\n        <mat-tab [disabled]="componentState === ComponentState.LOADING" class="auto-tab" [label]="msgs.auto()">\n            <onvif-bulk-registration (onRegistrationStart)="handleRegistrationStart()" (onRegistrationEnd)="handleRegistrationEnd()" [orchid]="orchid" (onClose)="close()"></onvif-bulk-registration>\n        </mat-tab>\n        <mat-tab [disabled]="componentState === ComponentState.LOADING" class="manual-tab" [label]="msgs.manual()">\n            <camera-manual-add (onRegistrationStart)="handleRegistrationStart()" (onRegistrationEnd)="handleRegistrationEnd()" [orchid]="orchid" (onClose)="close()"></camera-manual-add>\n        </mat-tab>\n    </mat-tab-group>\n</mat-dialog-content>\n'
        }
        ,
        80781: e => {
            e.exports = '<h2 mat-dialog-title class="camera-configuration-protocol-dialog-header">\n    <span class="dialog-title">{{ msgs.editCameraConfigurationProtocol() }}</span><button [disabled]="processing" class="close-button" matRipple (click)="close()">\n        <i class="{{ ActionsIcons.close }} close-icon"></i>\n    </button>\n</h2>\n<mat-dialog-content class="camera-configuration-protocol-dialog-content">\n    <mat-form-field class="camera-configuration-protocol-field config-protocol-select">\n        <mat-label>{{ msgs.configuration() }}</mat-label>\n        <mat-select class="config-protocol-select" (selectionChange)="handleConfigProtocolChange($event)" [disabled]="processing" [(value)]="selectedProtocol">\n            <mat-option [value]="ConnectionProtocol.HTTP">HTTP</mat-option>\n            <mat-option [value]="ConnectionProtocol.HTTPS">HTTPS</mat-option>\n        </mat-select>\n    </mat-form-field>\n\n    <mat-checkbox class="tls-ignore-checkbox" *ngIf="selectedProtocol === ConnectionProtocol.HTTPS" [disabled]="processing" [(ngModel)]="ignoreTlsCerts">{{ msgs.ignoreTlsCertificateValidation() }}</mat-checkbox>\n</mat-dialog-content>\n\n<sing-dialog-errors *ngIf="errorMessage.length > 0" (onClose)="handleErrorMessageClose()" [errmsg]="errorMessage"></sing-dialog-errors>\n\n<mat-dialog-actions class="camera-configuration-protocol-dialog-actions">\n    <button mat-flat-button [disabled]="processing" (click)="close()" class="config-protocol-cancel-button">\n        <span class="config-protocol-cancel-button-text">{{ msgs.cancel() }}</span>\n    </button>\n    <spinner-button (click)="saveConfigurationProtocol()" [text]="msgs.save()" [showSpinner]="processing" [disabled]="processing">\n    </spinner-button>\n</mat-dialog-actions>\n'
        }
        ,
        94930: e => {
            e.exports = '<h2 mat-dialog-title class="recover-camera-dialog-title">\n    <span class="dialog-title">{{ msgs.connectionSettings() }}</span><button class="close-button" matRipple (click)="close()">\n        <i class="{{ ActionsIcons.close }} close-icon"></i>\n    </button>\n</h2>\n<mat-dialog-content class="recover-camera-dialog-content">\n    <div class="use-case-text-container">\n        <p class="use-case-title">{{ msgs.useThisToRecoverAndSynchronize() }}</p>\n        <ul class="use-case-list">\n            <li class="use-case-item">{{ msgs.theCamerasIPHasChanged() }}</li>\n            <li class="use-case-item">{{ msgs.theCamerasSettingsChangedOutsideOf() }}</li>\n        </ul>\n    </div>\n\n    <form class="recover-camera-form" [formGroup]="recoverCameraForm" (keydown.enter)="recoverCameraForm.valid ? recoverCamera() : null">\n        <mat-form-field class="recover-camera-field discovery-url-field">\n            <mat-label>{{ msgs.onvifDiscoveryURL() }}</mat-label>\n            <input matInput formControlName="discoveryUrl" class="recover-camera-input">\n            <mat-error *ngIf="recoverCameraForm.controls[\'discoveryUrl\'].hasError(\'required\')">{{\n                msgs.onvifDiscoveryUrlRequired()\n            }}</mat-error>\n        </mat-form-field>\n\n        <mat-checkbox class="tls-ignore-checkbox" *ngIf="showTlsIgnoreCheckbox" formControlName="ignoreTlsCerts">{{\n            msgs.ignoreTlsCertificateValidation()\n        }}</mat-checkbox>\n\n        <div class="credentials-container">\n            <mat-form-field class="recover-camera-field username-field">\n                <mat-label>{{ msgs.username() }}</mat-label>\n                <input matInput formControlName="username" class="recover-camera-input">\n                <mat-error *ngIf="recoverCameraForm.controls[\'username\'].hasError(\'required\')">{{\n                    msgs.errors.username.usernameRequired()\n                }}</mat-error>\n            </mat-form-field>\n            <password-form-field class="recover-camera-field password-field" formControlName="password" [label]="msgs.password()" [errorMessage]="msgs.errors.password.passwordRequired()"></password-form-field>\n        </div>\n    </form>\n</mat-dialog-content>\n<sing-dialog-errors *ngIf="errorMessage.length > 0" (onClose)="handleClosingError()" [errmsg]="errorMessage"></sing-dialog-errors>\n<mat-dialog-actions class="recover-camera-dialog-actions">\n    <button mat-flat-button class="cancel-button" (click)="close()">{{ msgs.cancel() }}</button>\n    <spinner-button (click)="recoverCamera()" [disabled]="!recoverCameraForm.valid || processing" [showSpinner]="processing" class="submit-button" [text]="msgs.recoverCamera()">\n    </spinner-button>\n</mat-dialog-actions>\n'
        }
        ,
        285: e => {
            e.exports = '\x3c!-- Bulk camera register --\x3e\n<div class="bulk-register">\n    \x3c!-- Credentials form section - left side --\x3e\n    <div class="credentials-form flexible-child">\n        \x3c!-- Credentials heading --\x3e\n        <div class="row credentials">\n            <h3 class="credentials-text">\n                {{ msgs.credentials() }}\n            </h3>\n        </div>\n        <form [formGroup]="credentialsForm">\n            \x3c!-- Credentials inputs --\x3e\n            <div class="single-column-form credentials">\n                <div class="credentials-section">\n                    \x3c!-- Username --\x3e\n                    <div class="credentials-field username-wrapper">\n                        <mat-form-field>\n                            <mat-label>{{ formMsgs.labels.username() }}</mat-label>\n                            <input formControlName="username" matInput autocapitalize="off" autocorrect="off">\n                            <mat-error>{{ getUsernameErrorMessage() }}</mat-error>\n                        </mat-form-field>\n                    </div>\n\n                    \x3c!-- Password --\x3e\n                    <password-form-field class="credentials-field" formControlName="password" label="{{ formMsgs.labels.password() }}" [errorMessage]="getPasswordErrorMessage()" (keydown.enter)="!isRegisterButtonDisabled ? handleRegisterButtonClick($event) : null"></password-form-field>\n                </div>\n            </div>\n\n            <div class="connection-configuration-section" *ngIf="cameraConnectionPreferenceIsSupported">\n                <mat-form-field class="protocol-select-field">\n                    <mat-label>{{ msgs.connectionPreference() }}</mat-label>\n                    <mat-select [(value)]="connectionPreference" (selectionChange)="handleConnectionPreferenceChange()" [disabled]="processing">\n                        <mat-option [value]="ConnectionProtocol.HTTP">HTTP</mat-option>\n                        <mat-option [value]="ConnectionProtocol.HTTPS">HTTPS</mat-option>\n                    </mat-select>\n                </mat-form-field>\n\n                <div class="advanced-connection-settings" *ngIf="connectionPreference === ConnectionProtocol.HTTPS">\n                    <div class="connection-setting">\n                        <mat-checkbox #alternateProtocolCheckbox [disabled]="processing" (change)="handleAlternateProtocolCheckboxChange($event)" class="alternate-protocol-option">{{ msgs.useHttpIfHttpsIsUnavailable() }}</mat-checkbox>\n                    </div>\n                    <div class="connection-setting">\n                        <mat-checkbox [disabled]="processing" (change)="handleIgnoreTlsCertCheckboxChange($event)" class="ignore-tls-option">{{ msgs.ignoreTlsCertificateValidation() }}</mat-checkbox>\n                    </div>\n                </div>\n            </div>\n            \x3c!-- Action buttons and Error Info --\x3e\n            <div class="credentials">\n                \x3c!-- Error with credentials --\x3e\n                <div class="text-danger" [hidden]="!failure">\n                    <label>\n                        {{ msgs.registrationError() }}\n                    </label>\n                </div>\n\n                \x3c!-- Submit credentials button --\x3e\n                <div class="submit-buttons">\n                    <button mat-raised-button color="primary" type="submit" class="action-button register-btn" (click)="handleRegisterButtonClick($event)" [disabled]="isRegisterButtonDisabled" [matBadge]="totalCamerasSelected" [matBadgeHidden]="isRegisterButtonDisabled" matBadgeColor="primary" matBadgeSize="medium">\n                        <span [hidden]="processing">\n                            {{\n                                registrationStatus.complete ? msgs.retryFailedCameras() : msgs.registerSelectedCameras()\n                            }}\n                        </span>\n                        <mat-spinner mode="indeterminate" diameter="25" *ngIf="processing"> </mat-spinner>\n                    </button>\n                </div>\n\n                \x3c!-- Registration status of cameras as they are processed --\x3e\n                <div class="registration-status" [hidden]="!registrationStatus.show">\n                    <p>\n                        <b>{{ msgs.registrationStatus() }}</b>\n                        {{ registrationStatus.progress }}/{{ registrationStatus.total }} <br><br>\n                        <mat-progress-bar mode="determinate" [value]="registrationStatus.progressPercentage"></mat-progress-bar>\n                    </p>\n                    <p>\n                        <b>{{ msgs.errors() }}</b>\n                        {{ registrationStatus.errors.length }}\n                    </p>\n                </div>\n            </div>\n        </form>\n    </div>\n\n    \x3c!-- Camera choice table --\x3e\n    <div class="camera-table-whole flexible-child">\n        <div class="filtering">\n            <div class="search-bar">\n                <div class="search-icon-container">\n                    <i class="search-icon {{ InformationIcons.search }}"></i>\n                </div>\n                \x3c!-- Filtering form --\x3e\n                <input class="search-bar-input" matInput [(ngModel)]="filter" (keyup)="applyFilter($event)" placeholder="{{ msgs.search() }}" #input>\n            </div>\n\n            <button class="refresh-button" (click)="refresh()" [disabled]="processingRefresh || componentState === ComponentState.LOADING" matRipple>\n                <i class="refresh-icon {{ ActionsIcons.refresh }}"></i>\n            </button>\n        </div>\n\n        \x3c!-- Camera registration table --\x3e\n        <mat-card class="camera-table" *ngIf="componentState === ComponentState.LOADED">\n            \x3c!-- Table of cameras --\x3e\n            <table *ngIf="dataSource.filteredData.length > 0" mat-table multiTemplateDataRows matSort [dataSource]="dataSource" class="orchid-table striped-table registration-table interactive" style="width: 100%" [ngClass]="{ interactive: !processing && !registrationStatus.complete }">\n                \x3c!-- Checkbox column --\x3e\n                <ng-container matColumnDef="camera-status">\n                    <th mat-header-cell *matHeaderCellDef style="width: 32px">\n                        <mat-checkbox [hidden]="registrationStatus.show" [(ngModel)]="allFilteredCamsChecked" (change)="onBulkCheckboxChange($event)" [indeterminate]="someFilteredCamsChecked" [disabled]="bulkCheckboxIsDisabled()"></mat-checkbox>\n                        <mat-progress-spinner mode="indeterminate" diameter="15" class="header-spinner" *ngIf="processing" style="float: left"></mat-progress-spinner>\n                        <i class="fa fa-check text-success" [hidden]="!registrationStatus.complete"></i>\n                    </th>\n                    \x3c!-- Camera processing symbols --\x3e\n                    <td mat-cell *matCellDef="let camera" class="responsive-side" style="width: 32px">\n                        <mat-checkbox [disabled]="connectionPreferenceIsNotSupported(camera)" class="bulk-option" [(ngModel)]="camera.selected" (ngModelChange)="updateNumCamsSelected()" [hidden]="camera.status !== \'checkbox\'" (click)="$event.stopPropagation()"></mat-checkbox>\n                        <mat-progress-spinner mode="indeterminate" diameter="15" class="body-spinner" *ngIf="camera.status == \'processing\'" style="float: left"></mat-progress-spinner>\n                        <i class="fa fa-check success-text" [hidden]="camera.status !== \'success\'"></i>\n                        <i class="fa fa-times text-danger" [hidden]="camera.status !== \'failure\'"></i>\n                    </td>\n                    <ng-container> </ng-container>\n                </ng-container>\n\n                \x3c!-- Registered cameras column --\x3e\n                <ng-container matColumnDef="registered">\n                    <th mat-header-cell *matHeaderCellDef mat-sort-header class="bulk-registration-control" style="width: 32px" [hidden]="registrationStatus.show" (click)="firstPage()">\n                        <i class="fa fa-video-camera"></i>\n                    </th>\n                    <td mat-cell *matCellDef="let camera" style="width: 32px" [hidden]="registrationStatus.show">\n                        <i class="fa fa-video-camera camera-registered" [hidden]="!camera.registered"></i>\n                    </td>\n                </ng-container>\n\n                \x3c!-- Camera Model Name--\x3e\n                <ng-container matColumnDef="name">\n                    <th mat-header-cell mat-sort-header *matHeaderCellDef class="camera-name" (click)="firstPage()">\n                        {{ msgs.model() }}\n                    </th>\n                    <td mat-cell *matCellDef="let camera; let i = index" class="camera-name">\n                        <div class="unsupported-protocol-message-container" *ngIf="connectionPreferenceIsNotSupported(camera)">\n                            <i class="unsupported-protocol-icon {{ InformationIcons.error }}"></i>\n                            <span class="unsupported-protocol-message">{{\n                                msgs.VALUEUnsupported({ VALUE: connectionPreference.toUpperCase() })\n                            }}</span>\n                        </div>\n                        <span [class.unsupported]="connectionPreferenceIsNotSupported(camera)">{{ camera.name }}</span>\n                    </td>\n                </ng-container>\n\n                \x3c!-- IP Address --\x3e\n                <ng-container matColumnDef="ip-address">\n                    <th mat-header-cell mat-sort-header *matHeaderCellDef class="camera-ip" (click)="firstPage()">\n                        IP\n                    </th>\n                    <td mat-cell *matCellDef="let camera" class="camera-ip">\n                        <div class="protocol-tags-container">\n                            <tag *ngFor="let protocol of getSupportedProtocols(camera)" class="protocol-tag" [label]="protocol" [class.https-protocol-tag]="protocol === ConnectionProtocol.HTTPS" [class.http-protocol-tag]="protocol === ConnectionProtocol.HTTP" [class.unsupported]="connectionPreferenceIsNotSupported(camera)"></tag>\n                        </div>\n                        <p [class.unsupported]="connectionPreferenceIsNotSupported(camera)">{{ camera.ip }}</p>\n                    </td>\n                </ng-container>\n\n                \x3c!-- Error column - appears after each camera if error on registration --\x3e\n                <ng-container matColumnDef="registrationError">\n                    <th mat-header-cell mat-sort-header *matHeaderCellDef [ngClass]="registrationStatus.show ? \'registrationError-show\' : \'registrationError-hide\'" (click)="firstPage()">\n                        {{ msgs.status() }}\n                    </th>\n                    <td mat-cell *matCellDef="let camera" [ngClass]="registrationStatus.show ? \'registrationError-show\' : \'registrationError-hide\'">\n                        <p [class.fail-text]="camera.status == \'failure\'" [class.success-text]="camera.status == \'success\'" [class.registration-pending]="camera.status == \'pending\'">\n                            {{ camera.registrationMessage }}\n                        </p>\n                    </td>\n                </ng-container>\n\n                \x3c!-- Error row - small screens --\x3e\n                <ng-container matColumnDef="registrationError-small">\n                    <td mat-cell [attr.colspan]="displayedColumns.length" *matCellDef="let camera" [ngClass]="camera.registrationMessage === \'\' ? \'no-error\' : \'show-error\'">\n                        <p [class.registration-error]="camera.status == \'failure\'" [class.fail-text]="camera.status == \'failure\'" [class.registration-success]="camera.status == \'success\'" [class.registration-pending]="camera.status == \'pending\'">\n                            {{ camera.registrationMessage }}\n                        </p>\n                    </td>\n                </ng-container>\n\n                \x3c!-- Layout of table --\x3e\n                <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>\n                <mat-row class="camera-info-row" *matRowDef="let camera; columns: displayedColumns" [class.unsupported]="connectionPreferenceIsNotSupported(camera)" (click)="onRowClick(camera)" [ngClass]="camera.registrationMessage === \'\' ? \'no-error\' : \'show-error\'"></mat-row>\n                <mat-row *matRowDef="let camera; columns: [\'registrationError-small\']" [ngClass]="camera.registrationMessage === \'\' ? \'no-error\' : \'show-error\'"></mat-row>\n            </table>\n\n            <mat-paginator #paginator *ngIf="dataSource.filteredData.length > 0" class="camera-pagination" showFirstLastButtons [pageSizeOptions]="pageSizeOptions" [pageSize]="pageSize" aria-label="msgs.ariaLabels.selectCameraPage()" [ngClass]="{ hidden: !isPaginationVisible() }">\n            </mat-paginator>\n        </mat-card>\n        <div class="empty-search-container" *ngIf="componentState === ComponentState.LOADED">\n            <error-banner *ngIf="dataSource.filteredData.length === 0" [type]="ERROR_TYPE.EMPTY_SEARCH"></error-banner>\n        </div>\n\n        <div class="loading-spinner-container" *ngIf="processRefresh || componentState === ComponentState.LOADING">\n            <mat-spinner class="loading-spinner"></mat-spinner>\n        </div>\n\n        <div class="api-error-container" *ngIf="componentState === ComponentState.ERROR">\n            <error-banner class="api-error"></error-banner>\n        </div>\n    </div>\n</div>\n'
        }
        ,
        67597: e => {
            e.exports = '<div [ngClass]="[\'alert-banner\', type]">\n    <mat-icon *ngIf="showIcon" class="alert-banner-icon">\n        <i [ngClass]="[\'fa\', \'fa-\' + bannerIcon]"></i>\n    </mat-icon>\n    <div class="alert-banner-text-container">\n        <h5 *ngIf="showTitle()" class="alert-banner-title">{{ title }}</h5>\n        <span class="alert-banner-message">\n            <ng-content></ng-content>\n        </span>\n    </div>\n    <mat-icon class="alert-banner-dismiss-button" *ngIf="dismissable" (click)="dismiss()">\n        <i class="fa fa-times"></i>\n    </mat-icon>\n</div>\n'
        }
        ,
        72422: e => {
            e.exports = '<form *ngIf="formGroup" [formGroup]="formGroup">\n    <mat-form-field>\n        <mat-label [ngClass]="{ \'warn-text\': valid === false }">\n            {{ dataName }}\n            <circle-hint *ngIf="tooltip" class="circle-hint" [tooltip]="tooltip"></circle-hint>\n        </mat-label>\n        <mat-chip-list #dataChipList [formControl]="matListCtrl">\n            \x3c!-- Placeholder chip with message --\x3e\n            <mat-chip *ngIf="placeholderChip && formGroup.value.length === 0" (click)="dataTrigger.openPanel()" selectable="false" [removable]="false">\n                <i class="fa-solid fa-plus mat-chip-add-icon"></i>\n                {{ placeholderChip}}\n            </mat-chip>\n\n            <mat-chip *ngFor="let item of formGroup.value" (removed)="removeItem(item)" selectable="false" [removable]="!item.readonly" [disabled]="item.readonly">\n                {{ item.name || item.username}}\n                <i class="fa-solid fa-circle-xmark library-search-remove-icon" matChipRemove *ngIf="!item.readonly"></i>\n            </mat-chip>\n\n            \x3c!-- Plus Icon chip appears if at least one chip is selected but less than the total --\x3e\n            <mat-chip *ngIf="placeholderChip && formGroup.value.length > 0 && formGroup.value.length < data.length" (click)="dataTrigger.openPanel()" selectable="false" removable="false" class="mat-chip-add">\n                <i class="fa-solid fa-plus mat-chip-add-icon mat-chip-add-icon--no-margin"></i>\n            </mat-chip>\n            <input closeOnScroll matInput placeholder="{{ placeholderChip ? \'\' : msgs.searchForType({TYPE: dataType}) }}" #dataInput #dataTrigger="matAutocompleteTrigger" [formControl]="dataInputCtrl" required [matAutocomplete]="dataAuto" [matChipInputAddOnBlur]="true" [matChipInputFor]="dataChipList" [matChipInputSeparatorKeyCodes]="separatorKeysCodes">\n            <mat-autocomplete #dataAuto="matAutocomplete" (optionSelected)="addItem($event)" panelWidth="auto" autoActiveFirstOption>\n                <mat-option disabled="disabled" *ngIf="(filteredSortedSelectableData$ | async)?.length === 0 && formGroup.value.length !== data.length">\n                    {{ msgs.yourSearchDidNotMatchAnyResults()}}\n                </mat-option>\n                <mat-option disabled="disabled" *ngIf="(filteredSortedSelectableData$ | async)?.length === 0 && formGroup.value.length === data.length">\n                    {{ msgs.noOptionsToSelect()}}\n                </mat-option>\n                <mat-option *ngFor="let filteredItem of filteredSortedSelectableData$ | async" [value]="filteredItem" (click)="$event.stopPropagation(); dataTrigger.openPanel()">\n                    {{filteredItem.name || filteredItem.username}}\n                </mat-option>\n            </mat-autocomplete>\n        </mat-chip-list>\n        <mat-hint class="warn-text" *ngIf="valid === false">{{ invalidPrompt }}</mat-hint>\n    </mat-form-field>\n</form>\n'
        }
        ,
        67021: e => {
            e.exports = '<div *ngIf="!allItems" class="chip-list-total" (window:resize)="onResize($event)">\n    \x3c!-- Regular list --\x3e\n    <div *ngIf="listType === LIST_TYPE.text" class="text-list">\n        <div *ngFor="let item of pagedData" class="text-items">\n            <div class="text-box">\n                <i matChipAvatar class="fa fa-{{ icon }} mat-chip-avatar" *ngIf="icon"></i>\n                <i matChipAvatar class="{{ item.icon }} mat-chip-avatar" *ngIf="item.icon"></i>\n                <div class="chip-label-container">\n                    <span class="chip-title hint-text" *ngIf="item.title">{{ item.title }}</span>\n                    <span>\n                        <strong *ngIf="item.bold">{{ item.bold }}: </strong>{{ item.name }}\n                    </span>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    \x3c!-- Chip List --\x3e\n    <div class="list" *ngIf="listType === LIST_TYPE.chip">\n        <mat-chip-list *ngFor="let item of pagedData">\n            <div class="tooltipDiv" matTooltip="{{ getTooltip(item.name, item.bold) }}" [matTooltipShowDelay]="800" [matTooltipPosition]="\'below\'">\n                <mat-chip selectable="false" disableRipple="true" class="show" [ngClass]="{\n                        auto: chipWidth === CHIP_WIDTH.AUTO,\n                        \'fixed-small\': chipWidth === CHIP_WIDTH.FIXED_SMALL,\n                        \'fixed-medium\': chipWidth === CHIP_WIDTH.FIXED_MEDIUM,\n                        \'fixed-large\': chipWidth === CHIP_WIDTH.FIXED_LARGE,\n                        \'green-chip\': style === CHIP_STYLE_TYPE.GREEN,\n                        \'blue-chip\': style === CHIP_STYLE_TYPE.BLUE\n                    }">\n                    <i matChipAvatar class="fa fa-{{ icon }} mat-chip-avatar" *ngIf="icon"></i>\n                    <i matChipAvatar class="{{ item.icon }} mat-chip-avatar" *ngIf="item.icon"></i>\n                    <div class="chip-label-container">\n                        <span class="chip-title hint-text" *ngIf="item.title">{{ item.title }}</span>\n                        <span class="chip-label">\n                            <strong *ngIf="item.bold">{{ item.bold }}: </strong>{{ item.name }}\n                        </span>\n                    </div>\n                </mat-chip>\n            </div>\n        </mat-chip-list>\n    </div>\n    <mat-chip-list>\n        <mat-chip class="auto show" [ngClass]="emptyMessageRed ? \'warn-chip\' : \'none-chip\'" selectable="false" disableRipple="true" *ngIf="data.length === 0 && emptyMessage">\n            <i matChipAvatar class="fa fa-times" *ngIf="emptyMessageCross"></i>\n            <span style="font-style: italic">{{ emptyMessage }}</span>\n        </mat-chip>\n    </mat-chip-list>\n</div>\n<div class="list" *ngIf="allItems">\n    <mat-chip-list>\n        <mat-chip selectable="false" disableRipple="true" class="auto show">\n            <i matChipAvatar class="fa fa-check"></i>\n            <span>{{ allItemsMessage }}</span>\n        </mat-chip>\n    </mat-chip-list>\n</div>\n<pagination *ngIf="!allItems" (page)="handlePageEvent($event)" [dataSource]="data" (pagedData)="updatePagedData($event)" [pageSize]="pageSize" [pageSizeOptions]="pageSizeOptions" [hidePageSize]="hidePageSize"></pagination>\n'
        }
        ,
        11930: e => {
            e.exports = '<div class="chip-list-total" (window:resize)="onResize($event)">\n    \x3c!-- Checkbox Chip List--\x3e\n    <div class="list checkbox-list" *ngIf="listType === TYPE.checkbox">\n        <mat-chip-list [selectable]="true" #chipList multiple="multiple" [formControl]="checkboxForm">\n            <mat-chip #allChip="matChip" *ngIf="selectAll" class="checkbox-chip-item" color="none" (click)="handleAllChipSelect(allChip)">\n                <mat-checkbox (click)="$event.stopPropagation()" [checked]="allSelected">\n                    <div class="chip-label-container">\n                        <span class="chip-label">{{ msgs.all() }}</span>\n                    </div>\n                </mat-checkbox>\n            </mat-chip>\n\n            <div *ngFor="let item of pagedData" class="tooltipDiv" matTooltip="{{ getTooltip(item.name, item.bold) }}" [matTooltipShowDelay]="800" [matTooltipPosition]="\'below\'">\n                <mat-chip class="checkbox-chip-item" [class.has-title]="item.title" color="none" #chip="matChip" [value]="item" (click)="handleChipSelect(chip)">\n                    <mat-checkbox (click)="$event.stopPropagation()" [checked]="chip.selected">\n                        <div class="chip-label-container">\n                            <span class="chip-title" *ngIf="item.title">{{ item.title }}</span>\n                            <span class="chip-label">{{ item.name }}</span>\n                        </div>\n                    </mat-checkbox>\n                </mat-chip>\n            </div>\n        </mat-chip-list>\n    </div>\n\n    <mat-chip-list>\n        <mat-chip class="auto show" [ngClass]="emptyMessageRed ? \'warn-chip\' : \'none-chip\'" selectable="false" disableRipple="true" *ngIf="data.length === 0 && emptyMessage">\n            <i matChipAvatar class="fa fa-times" *ngIf="emptyMessageCross"></i>\n            <span style="font-style: italic">{{ emptyMessage }}</span>\n        </mat-chip>\n    </mat-chip-list>\n</div>\n\n<pagination *ngIf="!allItems || hidePagination" (page)="handlePageEvent($event)" [dataSource]="data" (pagedData)="updatePagedData($event)" [pageSize]="pageSize" [pageSizeOptions]="pageSizeOptions" [hidePageSize]="hidePageSize">\n</pagination>\n'
        }
        ,
        55760: e => {
            e.exports = '<mat-icon class="fa fa-question-circle hint" matTooltip="{{tooltip}}" matTooltipPosition="right">\n</mat-icon>\n'
        }
        ,
        40957: e => {
            e.exports = '<div class="error-box" *ngIf="displayError()">\n    <div *ngIf="canClose" class="clear-errors" (click)="clearError()">\n        <i class="fa fa-times"></i>\n    </div>\n    <div class="triangle-container">\n        <i class="fa fa-triangle-exclamation"></i>\n    </div>\n    <div class="error-display">{{ errmsg }}</div>\n</div>\n'
        }
        ,
        8070: e => {
            e.exports = '<div class="info-container">\n    <i class="{{ bannerIcon }}"></i>\n    <div class="message-container">\n        <span class="label-medium">{{ bannerTitle }}</span>\n        <span class="body-small">{{ bannerDescription }}</span>\n    </div>\n</div>\n<ng-content></ng-content>\n'
        }
        ,
        91677: e => {
            e.exports = '<div class="error-container">\n    <h3 class="error-title" *ngIf="title.length > 0">{{title}}</h3>\n    <span class="error-message hint-text">{{ message }}</span>\n    <button class="error-refresh-button" mat-stroked-button color="primary" *ngIf="canRefresh()" (click)="refreshHandler()">\n        <span class="button-text"><i class="fa fa-undo"></i>{{ msgs.tryAgain() }}</span>\n    </button>\n</div>\n'
        }
        ,
        76087: e => {
            e.exports = '<div class="expand-button {{color}} {{direction}}">\n    <i class="fa fa-{{icon}}"></i>\n</div>\n'
        }
        ,
        60113: e => {
            e.exports = '<ng-container *ngIf="!isTagWithValue; else tagWithValueChip">\n    <div class="label-container">\n        <i *ngIf="icon.length > 0" class="filter-icon {{ icon }}"></i>\n        <span *ngIf="icon.length === 0" class="filter-type-copy label-small">{{ filter.typeLabel }}: </span>\n        <span class="body-small filter-label-copy">{{\n            filter.type === \'search\' ? \'"\' + filter.data.label + \'"\' : filter.data.label\n        }}</span>\n    </div>\n    <button (click)="handleRemove()" matRipple class="close-button"><i class="{{ icons.close }}"></i></button>\n</ng-container>\n\n\x3c!-- Filter with an extra value to render --\x3e\n<ng-template #tagWithValueChip>\n    <div class="tag-value-label-container">\n        <i class="filter-icon {{ icon }}"></i>\n        <span class="body-small filter-label-copy">{{ filter.data.label }}</span>\n    </div>\n    <div class="tag-value-container">\n        <span class="body-small filter-label-copy">{{ filter.data.value }}</span>\n    </div>\n    <button (click)="handleRemove()" matRipple class="close-button close-button--value"><i class="{{ icons.close }}"></i></button>\n</ng-template>\n'
        }
        ,
        33057: e => {
            e.exports = '<div class="icon-total">\n    <i [ngClass]="{\'primaryColor\': primaryColor}" class="fa" [class]="icon"></i>\n    <span>{{ number }}</span>\n</div>\n'
        }
        ,
        36966: e => {
            e.exports = '<div *ngIf="!failed" class="image-preview-container" [ngClass]="{\n        disabled: disabled\n    }">\n    <img *ngIf="!failed" [src]="src" (error)="onError()">\n    <div class="disable-camera-status-container">\n        <tag type="disabled-camera"></tag>\n    </div>\n</div>\n<div *ngIf="failed" class="image-error-container">\n    <div *ngIf="!disabled" class="unavailable">\n        <i class="fa-regular fa-frown"></i>\n    </div>\n    <div *ngIf="disabled" class="disabled-camera-no-preview-icon">\n        <i class="fa-solid fa-video-slash"></i>\n    </div>\n</div>\n'
        }
        ,
        53182: e => {
            e.exports = '<mat-drawer-container hasBackdrop="false">\n    <mat-drawer mode="over" [opened]="showDrawer" position="end">\n        <div class="drawer-content">\n            <div class="drawer-title-container">\n                <h3 class="drawer-title">{{ drawerTitle }}</h3>\n                <button class="close-button-container" mat-icon-button (click)="handleCloseButtonClick()">\n                    <i class="{{ ActionsIcons.close }} fa-lg"></i>\n                </button>\n            </div>\n            <p class="drawer-body-text" [innerHtml]="drawerInfoText"></p>\n        </div>\n    </mat-drawer>\n    <mat-drawer-content>\n        <ng-content></ng-content>\n    </mat-drawer-content>\n</mat-drawer-container>\n'
        }
        ,
        26858: e => {
            e.exports = '<div class="calendar-header-container">\n\n    <div class="month-name-container">\n        <span class="month-name">\n            {{periodLabel}}\n        </span>\n    </div>\n\n    <button mat-icon-button class="nav-left-button" (click)="previousClicked()">\n        <i class="fa-solid fa-chevron-left"></i>\n    </button>\n\n    <button mat-icon-button class="nav-right-button" (click)="nextClicked()">\n        <i class="fa-solid fa-chevron-right"></i>\n    </button>\n\n</div>\n'
        }
        ,
        81687: e => {
            e.exports = '<div class="orchid-camera-picker-container" *ngIf="hasCameras; else noCameras">\n    <div class="camera-previews" *ngIf="!loading; else loadingSpinner">\n        <div *ngFor="let camera of paginatedCameras" class="preview-tile mat-elevation-z4" [class.cursor-pointer]="!viewOnly" (click)="onCameraSelected(camera)">\n            <div class="camera-tile" [class.selected-border]="!viewOnly && cameraIsSelected(camera) === true" matRipple [matRippleDisabled]="viewOnly">\n                <div class="preview-text">\n                    <p matTooltip="{{ camera.cameraName }}" [matTooltipShowDelay]="800">\n                        {{ camera.cameraName }}\n                    </p>\n                </div>\n                <div class="stream-preview">\n                    <sing-image-loader [src]="camera.previewUrl" [disabled]="!cameraIsEnabled(camera)"></sing-image-loader>\n                </div>\n            </div>\n        </div>\n    </div>\n    <mat-paginator *ngIf="cameras.length > pageSizeOptions[0]" class="paginator" showFirstLastButtons [pageSizeOptions]="pageSizeOptions" [pageSize]="pageSize" [length]="cameras.length" (page)="onPaginatorChange($event)"></mat-paginator>\n\n    <ng-template #loadingSpinner>\n        <mat-spinner class="loading-cameras-spinner" mode="indeterminate" diameter="20"></mat-spinner>\n    </ng-template>\n</div>\n\n<ng-template #noCameras>\n    <div class="no-cameras-error-info">\n        {{ msgs.noCamerasAvailable() }}\n    </div>\n</ng-template>\n'
        }
        ,
        81175: e => {
            e.exports = '    \x3c!-- Pagination of servers --\x3e\n    <mat-paginator class="pagination" showFirstLastButtons [length]="length" [pageSize]="pageSize" [pageSizeOptions]="pageSizeOptions" (page)="onChangePage($event)" [hidden]="!isPaginationVisible" [hidePageSize]="hidePageSize">\n    </mat-paginator>\n'
        }
        ,
        12930: e => {
            e.exports = '<mat-form-field class="password-form-field" appearance="standard">\n    <mat-label>{{ label }}</mat-label>\n\n    <input matInput [disabled]="disabled" (focusout)="onFocusOut()" (input)="onInput($event)" [type]="type" [value]="value" [required]="required" [placeholder]="placeholder" [errorStateMatcher]="matcher" autocorrect="off" autocomplete="off">\n\n    <mat-error *ngIf="isErrorState()">{{ errorMessage }}</mat-error>\n\n    \x3c!-- Visibility Toggle Button --\x3e\n    <button mat-icon-button matSuffix (click)="onIconClick($event)" [attr.aria-label]="\'Hide password\'" [disabled]="disabled" tabindex="-1" type="button">\n        <mat-icon>\n            <i class="fa-regular fa-{{ icon }}"></i>\n        </mat-icon>\n    </button>\n</mat-form-field>\n'
        }
        ,
        43149: e => {
            e.exports = '<ng-container *ngIf="loaded; else loaderContainer">\n    \x3c!-- Search Bar --\x3e\n    <search-bar class="search-bar" #searchChipInput [data]="searchableList" [disabled]="disabled" (filteredData)="updateFilteredData($event)" [searchPlaceholder]="messages.enterRecordersNameorIP()"></search-bar>\n\n    \x3c!-- List of Checkbox Selection Recorders--\x3e\n    <div [class.disabled]="disabled || disableAll" class="recorders-container" *ngIf="filteredServers.length > 0; else emptyCopyContainer">\n        <div class="options-header-container">\n            <mat-checkbox *ngIf="numSupportedOrchids > 1" [checked]="selectAll" [disabled]="disabled || disableAll" (change)="onSelectAllClick($event)"><span class="body-medium">{{ messages.selectAll({ NUMBER: numSupportedOrchids }) }}</span></mat-checkbox>\n        </div>\n        <div class="recorder-options-container">\n            <mat-checkbox class="recorder-option" *ngFor="let server of pagedServers" [checked]="isOrchidSelected(server)" [disabled]="disabled || !orchidIsSupported(server) || disableAll" (change)="onOrchidSelected(server)">\n                <div class="recorder-info">\n                    <span class="label-medium">{{ server.name }}</span>\n                    <a class="body-tiny text-link" href="{{ server.uri }}" target="_blank">{{ server.uri }}</a>\n                    <span *ngIf="!orchidIsSupported(server) && !disabled" class="unsupported-orchid-text hint-text">\n                        {{ msgs.notAvailable({ VALUE: server.version.version }) }}\n                    </span>\n                </div>\n                <tag [label]="server.cameras.length || 0" [icon]="icons.camera"></tag>\n            </mat-checkbox>\n        </div>\n\n        \x3c!-- Pagination --\x3e\n        <pagination class="recorders-pagination" (page)="handlePage($event)" [dataSource]="filteredServers" (pagedData)="updatePagedData($event)" [pageSize]="pageSize" [pageSizeOptions]="pageSizeOptions"></pagination>\n    </div>\n</ng-container>\n\n\x3c!-- Empty search result message --\x3e\n<ng-template #emptyCopyContainer>\n    <error-banner type="empty-search" [icon]="icons.servers.search"></error-banner>\n</ng-template>\n\n\x3c!-- Loader --\x3e\n<ng-template #loaderContainer>\n    <mat-spinner mode="indeterminate" diameter="20"></mat-spinner>\n</ng-template>\n'
        }
        ,
        93842: e => {
            e.exports = '<mat-form-field appearance="standard" class="search-bar" floatLabel="always" [ngClass]="{ disabled: disabled }">\n    <mat-label>\n        {{ searchLabel }}\n    </mat-label>\n    <mat-chip-list #searchChipList class="mat-chip-list-search">\n        <span *ngIf="searchMode === SearchModes.CHIPS">\n            <mat-chip class="chipSearch" *ngFor="let term of searchTerms" selectable="false" removable="true" (removed)="onSearchTermRemoved(term)">\n                {{ term }}\n                <i class="fa-solid fa-circle-xmark library-search-remove-icon" matChipRemove></i>\n            </mat-chip>\n        </span>\n        <input matInput placeholder="{{ searchPlaceholder }}" [matChipInputFor]="searchChipList" [matChipInputSeparatorKeyCodes]="separatorKeysCodes" [matChipInputAddOnBlur]="true" (matChipInputTokenEnd)="onSearchTermAdded($event)" [formControl]="searchInput" (input)="updateSearch($event.target.value)">\n    </mat-chip-list>\n</mat-form-field>\n'
        }
        ,
        69858: e => {
            e.exports = '<button mat-raised-button [color]="color" [disabled]="disabled || showSpinner">\n    <i *ngIf="icon !== \'\'" class="fa {{ icon }} fa-lg" [style.color]="textColor" [ngStyle]="{ visibility: showSpinner ? \'hidden\' : \'visible\' }"></i>\n    <span class="buttonText" [style.color]="textColor" [ngStyle]="{ visibility: showSpinner ? \'hidden\' : \'visible\' }">{{\n        text\n    }}</span>\n\n    <mat-progress-spinner class="processing-spinner" *ngIf="showSpinner" diameter="25" color="primary" mode="indeterminate"></mat-progress-spinner>\n</button>\n'
        }
        ,
        54424: e => {
            e.exports = '<span class="table-indeterminate-footer">\n    <button mat-mini-fab color="primary" *ngIf="dataSource.length >= pageSize" [disabled]="dataSource.length >= pageSize && dataSource.length % pageSize !== 0" (click)="moreClick.emit($event)">\n        <i *ngIf="showSpinner" class="fa-solid fa-circle-notch fa-spin"></i>\n        <i *ngIf="!showSpinner" class="fa-solid fa-angles-down"></i>\n    </button>\n\n    <span *ngIf="dataSource.length % pageSize !== 0" class="count">{{ msgs.COUNTevents({ START: 1, COUNT: dataSource.length }) }}</span>\n\n    <span *ngIf="dataSource.length % pageSize === 0" class="count">{{ msgs.STARTdashCOUNTofmany({ START: 1, COUNT: dataSource.length }) }}</span>\n</span>\n'
        }
        ,
        9910: e => {
            e.exports = '<div class="tag {{ type }}">\n    <span class="tag-icon-container" *ngIf="this.icon.length > 0"><i class="tag-icon {{icon}}"></i></span>\n    <span class="tag-label">{{ label }}</span>\n</div>\n'
        }
        ,
        41402: e => {
            e.exports = '<mat-dialog-content class="mini-dialog">\n    <ng-container *ngIf="options.content; else messageTemplate">\n        <ng-container *ngComponentOutlet="options.content; injector: contentInputInjector"></ng-container>\n    </ng-container>\n    <ng-template #messageTemplate>\n        <p class="dialog-message">{{ options.message }}</p>\n    </ng-template>\n</mat-dialog-content>\n\n\x3c!-- Error notification --\x3e\n<sing-dialog-errors class="file-prompt-errors" *ngIf="error !== undefined" [errmsg]="error" [canClose]="true" (onClose)="error = undefined"></sing-dialog-errors>\n\n<mat-dialog-actions>\n    <button *ngIf="!options.hideCancelButton" mat-button mat-dialog-close class="btn btn-cancel" (click)="cancel()" [disabled]="isProcessing">\n        {{ options.cancelText }}\n    </button>\n    <button mat-button class="btn btn-confirm" color="primary" cdkFocusInitial (click)="confirm()" [disabled]="isProcessing">\n        <span *ngIf="!isProcessing">{{ options.confirmText }}</span>\n\n        <mat-spinner mode="indeterminate" diameter="25" *ngIf="isProcessing"></mat-spinner>\n    </button>\n</mat-dialog-actions>\n'
        }
        ,
        37406: e => {
            e.exports = '<div>\n    <mat-toolbar color="primary" *ngIf="showDialogTitle">\n        <h2>{{ options.title }}</h2>\n        <span></span>\n        <button mat-icon-button (click)="close()">\n            <i class="fa fa-times fa-2x"></i>\n        </button>\n    </mat-toolbar>\n\n    <mat-dialog-content>\n        <div [innerHTML]="options.message">\n        </div>\n    </mat-dialog-content>\n\n    <mat-dialog-actions>\n        <button mat-raised-button color="primary" (click)="close()">\n            {{ options.okText }}\n        </button>\n    </mat-dialog-actions>\n</div>\n'
        }
        ,
        14211: e => {
            e.exports = '<mat-toolbar color="primary">\n    <span>{{ options.title }}</span>\n    <button mat-icon-button disableRipple="true" (click)="cancel()">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content>\n    <mat-form-field>\n        <mat-label>{{ options.message }}</mat-label>\n        <input cdkFocusInitial matInput [(ngModel)]="options.value">\n    </mat-form-field>\n</mat-dialog-content>\n\n<sing-dialog-errors *ngIf="error !== undefined" [errmsg]="error" [canClose]="true" (onClose)="error = undefined"></sing-dialog-errors>\n\n<mat-dialog-actions>\n    <button mat-button mat-dialog-close color="primary" class="btn btn-cancel" (click)="cancel()" [disabled]="isProcessing">{{ options.cancelText }}</button>\n    <button mat-button color="primary" mat-raised-button (click)="confirm()" [disabled]="!options.value">{{ options.confirmText }}</button>\n</mat-dialog-actions>\n'
        }
        ,
        10748: e => {
            e.exports = '<section class="file-prompt" [ngClass]="styleClasses">\n    \x3c!-- Top-right close button (x) --\x3e\n    <mat-toolbar class="file-prompt-header">\n        <span>{{options.title}}</span>\n        <button mat-icon-button (click)="close()">\n            <i class="fa fa-times fa-2x"></i>\n        </button>\n    </mat-toolbar>\n\n    \x3c!-- File input section --\x3e\n    <mat-dialog-content class="file-prompt-body">\n        <div class="file-prompt-message">\n            <span *ngFor="let line of lines">{{ line }}</span>\n        </div>\n        <input class="remove-focus-outline" #FileInput type="file" cdkFocusInitial (change)="onChange($event)" [attr.accept]="accept" [attr.multiple]="options.allowMultipleFiles ? \'\' : null">\n    </mat-dialog-content>\n\n    \x3c!-- Error notification --\x3e\n    <sing-dialog-errors class="file-prompt-errors" *ngIf="error !== undefined" [errmsg]="error" [canClose]="true" (onClose)="clearErrors()"></sing-dialog-errors>\n\n    \x3c!-- OK / Cancel buttons --\x3e\n    <mat-dialog-actions class="file-prompt-footer">\n        <button mat-button [disabled]="isProcessing" (click)="close()">\n            {{ options.cancelText }}\n        </button>\n        <button class="file-prompt-ok" mat-raised-button (click)="ok()" [disabled]="disableOk" color="primary">\n            <span [class.file-prompt-ok-spinner]="isProcessing">\n                {{ options.okText }}\n            </span>\n            <mat-spinner [class.file-prompt-ok-spinner]="isProcessing" *ngIf="isProcessing" diameter="25"></mat-spinner>\n        </button>\n    </mat-dialog-actions>\n</section>\n'
        }
        ,
        28815: e => {
            e.exports = '<mat-calendar class="calendar" [startAt]="date.value" [selected]="date.value" [maxDate]="maxDate" [minDate]="minDate" [dateClass]="dateClass" (selectedChange)="onDateSelected($event)">\n</mat-calendar>\n'
        }
        ,
        61473: e => {
            e.exports = '<div class="pickers-container">\n    <calendar-input [date]="datetimeFG.controls.date" [archivesPerDay]="archivesPerDay"></calendar-input>\n    <time-inputs *ngIf="!hideTime" [group]="datetimeFG" [hideSeconds]="hideSeconds"></time-inputs>\n</div>\n'
        }
        ,
        99955: e => {
            e.exports = '<mat-toolbar mat-dialog-title color="primary" class="datetime-picker-dialog-header">\n    <h2 class="datetime-picker-dialog-title">{{titleText}}</h2>\n    <span class="datetime-picker-dialog-title-spacer"></span>\n    <button class="datetime-picker-dialog-close" mat-icon-button disableRipple="true" (click)="cancel()">\n        <mat-icon class="fa fa-times fa-2x"></mat-icon>\n    </button>\n</mat-toolbar>\n<mat-dialog-content>\n    <date-time-picker *ngIf="!loading" [date]="data.date" [hideTime]="data.hideTime" [hideSeconds]="data.hideSeconds" [archivesPerDay]="archivesPerDay"></date-time-picker>\n    <mat-spinner *ngIf="loading" diameter="50" color="primary" mode="indeterminate"></mat-spinner>\n</mat-dialog-content>\n<mat-dialog-actions align="end">\n    <button class="datetime-picker-dialog-cancel" mat-button (click)="cancel()">{{cancelText}}</button>\n    <button class="datetime-picker-dialog-ok" mat-raised-button [disabled]="!valid || loading" (click)="close(false)" color="primary">{{okText}}</button>\n</mat-dialog-actions>\n'
        }
        ,
        46947: e => {
            e.exports = '<div class="time-input-container">\n    <button tabindex="-1" class="time-input-button" mat-icon-button disableRipple="true" [id]="incrementButtonId" (click)="incrementTime()">\n        <mat-icon class="fa fa-2x fa-angle-up"></mat-icon>\n    </button>\n    <mat-form-field class="time-input-form-field" appearance="outline">\n        <input cdkFocusInitial (blur)="displayZeroPaddedNumber()" class="time-input" type="text" matInput required minlength="1" maxlength="2" pattern="^[0-9]{1,2}$" [min]="min" [max]="max" [placeholder]="placeHolder" [formControl]="fakeNumberInputControl" [id]="inputId">\n    </mat-form-field>\n    <button tabindex="-1" class="time-input-button" mat-icon-button disableRipple="true" [id]="decrementButtonId" (click)="decrementTime()">\n        <mat-icon class="fa fa-2x fa-angle-down"></mat-icon>\n    </button>\n</div>\n'
        }
        ,
        34744: e => {
            e.exports = '<div class="time-picker-container">\n    <time-input id="hours-time-input" #hoursTimeInput [group]="group" [max]="hoursMax" [min]="hoursMin" [rollover$]="rollover$" fieldName="hours" placeHolder="HH" (isInputValid)="isHoursInputValid($event)"></time-input>\n    <div class="time-spacer-container">\n        <span class="time-spacer">:</span>\n    </div>\n    <time-input id="minutes-time-input" #minutesTimeInput [group]="group" [max]="minutesMax" [min]="minutesMin" [rollover$]="rollover$" fieldName="minutes" placeHolder="MM" (isInputValid)="isMinutesInputValid($event)"></time-input>\n    <div class="time-spacer-container" *ngIf="!hideSeconds && group.controls.seconds">\n        <span class="time-spacer">:</span>\n    </div>\n    <time-input *ngIf="!hideSeconds && group.controls.seconds" id="seconds-time-input" #secondsInput [group]="group" [max]="secondsMax" [min]="secondsMin" [rollover$]="rollover$" fieldName="seconds" placeHolder="SS" (isInputValid)="isSecondsInputValid($event)"></time-input>\n</div>\n'
        }
        ,
        14789: e => {
            e.exports = '<error icon="fa-solid fa-triangle-exclamation" title="{{ msgs.accessDenied() }}" message="{{ msgs.youAreNotAuthorizedToAccessTheRequestedResource() }}"></error>;\n'
        }
        ,
        39864: e => {
            e.exports = '<error icon="fa-regular fa-thumbs-down" title="{{ msgs.browserCheck() }}" [showProceedToStage]="false">\n    <p *ngIf="showWSMsg">{{ msgs.thisBrowserDoesNotSupportWebSockets() }}</p>\n\n    <p>{{ msgs.forTheBestStreamingExperiencePleaseDownload() }}</p>\n\n    <div class="browser-icons">\n        <a class="text-link" href="https://www.google.com/chrome/" target="_blank">\n            <i class="fa fa-chrome"></i>\n            <span>Google Chrome ({{ msgs.latest() }})</span>\n        </a>\n    </div>\n    <div *ngIf="!showWSMsg">\n        <a class="text-link" href="javascript:void(0)" (click)="forceCompatibility()">{{msgs.alternativelyYouCanContinueInCompatibilityMode()}}</a>\n    </div>\n</error>\n'
        }
        ,
        8633: e => {
            e.exports = '<mat-toolbar color="primary">\n    <logo></logo>\n</mat-toolbar>\n\n<div class="error-container">\n    <mat-card>\n        <mat-card-header>\n            <mat-card-title>\n                <h1><i class="fa {{icon}}" *ngIf="icon"></i>{{ title }}</h1>\n            </mat-card-title>\n        </mat-card-header>\n        <mat-card-content>\n            <p *ngIf="message">{{ message }}\n            </p>\n            <ng-content *ngIf="message === undefined"></ng-content>\n        </mat-card-content>\n        <mat-card-actions align="end">\n            <button color="primary" mat-raised-button *ngIf="showProceedToStage" [routerLink]="[\'/stage\']">{{ msgs.proceedToTheStage() }}</button>\n        </mat-card-actions>\n    </mat-card>\n</div>\n'
        }
        ,
        72389: e => {
            e.exports = '<error icon="fa-regular fa-calendar-times" title="{{ msgs.expired() }}" message="{{ msgs.theRequestedResourceHasExpired() }}"></error>;\n'
        }
        ,
        60656: e => {
            e.exports = '<error icon="fa-solid fa-user-secret" title="{{ msgs.incognito() }}" [showProceedToStage]="false" message="{{ msgs.youAreEitherUsingAnAncientBrowserPrivateBrowsingOrIncognitoModePleaseSwitchToNormalBrowsingToUseSERVER({ SERVER: this.appName }) }}">\n</error>\n'
        }
        ,
        90206: e => {
            e.exports = '<error icon="fa-solid fa-binoculars" title="{{ msgs.notFound() }}" message="{{ msgs.theRequestedResourceCouldNotBeFound() }}"></error>;\n'
        }
        ,
        69528: e => {
            e.exports = '<error icon="fa-regular fa-thumbs-down" title="{{ msgs.browserCheck() }}" [showProceedToStage]="false">\n    <div class="warning-text">{{ msgs.browserNotSupported() }}</div>\n    <div style="padding-top: 10px">{{ msgs.toCorrectThis() }}</div>\n\n    <div class="browser-icons">\n        <a class="text-link" href="https://www.google.com/chrome/" target="_blank">\n            <i class="fa fa-chrome"></i>\n            <span>Google Chrome ({{ msgs.latest() }})</span>\n        </a>\n    </div>\n    <div>\n        {{ msgs.stuffMaybeBroken() }} <a class="text-link" href="javascript:void(0)" (click)="allowUnsupportedBrowser()">{{ msgs.continueAnyway() }}</a>\n    </div>\n</error>\n'
        }
        ,
        89966: e => {
            e.exports = '\x3c!-- Filter Button --\x3e\n<button mat-button [matMenuTriggerFor]="filtersPanel" class="filter-button" *ngIf="filters.length > 0" (menuOpened)="clearSearchInput()">\n    <span class="label-small">{{ filterLabel }}</span>\n    <i class="fa-solid fa-caret-down"></i>\n</button>\n\n\x3c!-- Filters Panel --\x3e\n<mat-menu #filtersPanel="matMenu" class="filter-menu-panel">\n    \x3c!-- Searchbar --\x3e\n    <div class="searchbar-container panel-searchbar" (click)="$event.stopPropagation()" *ngIf="filters.length > MAX_ITEMS">\n        <i class="fa-regular fa-magnifying-glass search-icon"></i>\n        <input #searchInput [formControl]="filterSearchForm" class="searchbar-input" type="text" matInput placeholder="{{ msgs.search() }}" (blur)="searchInput.focus()" (click)="$event.stopPropagation()">\n    </div>\n\n    \x3c!-- Filter Options --\x3e\n    <div class="filter-options-container">\n        <ng-container *ngIf="activeFilters.length > 0; else emptySearch">\n            <button *ngFor="let filter of activeFilters; trackBy: id" mat-menu-item role="menuitemcheckbox" (click)="toggleFilter($event, filter)">\n                <mat-checkbox class="filter-checkbox" [checked]="filter.value">\n                    \x3c!-- Plain string filter label --\x3e\n                    <span *ngIf="isGenericLabel(filter)">{{ filter.data.label }}</span>\n\n                    \x3c!-- Resource Tag filter --\x3e\n                    <resource-tag *ngIf="filter.type === \'resource_tag\'" [tag]="{ key: filter.data.label, value: filter.data.value }"></resource-tag>\n\n                    \x3c!-- Event Subscription Type filter --\x3e\n                    <tag *ngIf="filter.type === \'event_subscription_type\'" [type]="filter.id"></tag>\n                </mat-checkbox>\n            </button>\n            <button *ngIf="hiddenFilterCount > 0" mat-menu-item disabled="disabled">\n                {{ msgs.plusVALUEMore({VALUE: hiddenFilterCount}) }}\n            </button>\n        </ng-container>\n        <ng-template #emptySearch>\n            <error-banner [type]="ERROR_TYPE.EMPTY_SEARCH"> </error-banner>\n        </ng-template>\n    </div>\n</mat-menu>\n'
        }
        ,
        89547: e => {
            e.exports = '<button mat-button *ngIf="isFramerateCritical" (click)="showNotification()" tooltip="matTooltip" matTooltip="{{ msgs.title() }}" [matTooltipHideDelay]="0" [matTooltipShowDelay]="300">\n    <i class="fa fa-thumbs-down"></i>\n</button>\n'
        }
        ,
        69603: e => {
            e.exports = '<iframe id="player" class="player api-player" #player [src]="source" frameBorder="0" [style.visibility]="iFrameIsReady ? \'visible\': \'hidden\'"></iframe>\n<div class="loading" *ngIf="iFrameIsReady !== true">\n    <mat-spinner class="processing-spinner" mode="indeterminate" diameter="50"></mat-spinner>\n</div>\n'
        }
        ,
        65247: e => {
            e.exports = '<mat-toolbar color="primary">\n    <span mat-dialog-title class="toolbar-title">{{ msgs.addLibraryItems() }}</span>\n    <button class="add-lib-x-button" mat-icon-button disableRipple="true" (click)="cancel()">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n<mat-dialog-content [formGroup]="libraryItemGroup" triggerCloseOnScroll>\n    <ng-container *ngIf="hasOrchids; else noOrchidsMessage">\n        \x3c!-- Name input field --\x3e\n        <mat-form-field class="full-width-item">\n            <mat-label>{{ msgs.libraryItemName() }}</mat-label>\n            <input matInput type="text" required formControlName="name" cdkFocusInitial placeholder="{{ msgs.egParkingLotIncident() }}">\n        </mat-form-field>\n\n        \x3c!-- Date input field --\x3e\n        <div class="full-width-date">\n            <div class="from-btn">\n                <p class="date-label">\n                    {{ msgs.from() }}<span class="from-nbsp">&nbsp;</span>\n                </p>\n                <button class="calendar-btn" mat-raised-button (click)="showDatetimePicker(false)" color="primary">\n                    <i class="calendar-icon fa-regular fa-calendar-days"></i>{{ fromDate.getTime() | date: dateTimeFormat }}\n                </button>\n            </div>\n            <div class="to-btn">\n                <p class="date-label">\n                    {{ msgs.to() }}<span class="from-nbsp">&nbsp;</span>\n                </p>\n                <button class="calendar-btn" mat-raised-button (click)="showDatetimePicker(true)" color="primary">\n                    <i class="calendar-icon fa-regular fa-calendar-days"></i>{{ toDate.getTime() | date: dateTimeFormat }}\n                </button>\n            </div>\n            <p *ngIf="toDate.getTime() > fromDate.getTime()" class="time-span-display">\n                ({{ toDate.getTime() - fromDate.getTime() | timeDuration: true }})\n            </p>\n        </div>\n        <div class="warn" *ngIf="haveDisplayableErrors">\n            <span>{{ errorMessage }}</span>\n        </div>\n\n        \x3c!-- Server search field --\x3e\n        <mat-form-field class="full-width-server">\n            <mat-label>{{ msgs.server() }}</mat-label>\n            <input closeOnScroll type="text" placeholder="{{ msgs.server() }}" [attr.aria-label]="msgs.server()" matInput formControlName="server" [matAutocomplete]="auto" required>\n            <mat-autocomplete autoActiveFirstOption [displayWith]="displayServerName" #auto="matAutocomplete">\n                <mat-option class="add-library-item-server-option" *ngFor="let orchid of filteredOrchids$ | async" [value]="orchid">\n                    {{ orchid.name }}\n                </mat-option>\n            </mat-autocomplete>\n        </mat-form-field>\n\n        \x3c!-- Server cameras list / or error message --\x3e\n        <ng-container *ngIf="serverFieldValid">\n            <ng-container *ngIf="hasServerCameras; else noServerCameras">\n                <div class="previews">\n                    <stream-preview-checkbox *ngFor="let camera of serverCameras" [camera]="camera" [fallbackCameraName]="msgs.unknown()" [label]="msgs.addToLibrary()" (stateChanges)="onSelectionStateChange($event)"></stream-preview-checkbox>\n                </div>\n                <div class="tooltip-container">\n                    <i class="fa fa-circle-question tooltip-icon"></i>\n                    {{ msgs.theCameraStreamWithTheHighestResolutionAvailableIsPreSelected() }}\n                </div>\n            </ng-container>\n            <ng-template #noServerCameras>\n                <div class="info no-matches-error-message">\n                    {{ isAdmin ? msgs.thereAreNoCamerasAssociatedWithThisServer() : msgs.noCamerasWithExport() }}\n                </div>\n            </ng-template>\n        </ng-container>\n    </ng-container>\n    <ng-template #noOrchidsMessage>\n        <p class="no-matches-error-message">{{ msgs.noServersWithCamerasToExport() }}</p>\n    </ng-template>\n</mat-dialog-content>\n\n\x3c!-- Dialog Error --\x3e\n<sing-dialog-errors class="error-banner" *ngIf="addLibItemsFailed" (onClose)="dismissMe()" [errmsg]="msgs.oneOrMoreOfTheLibraryItemsFailedToBeCreated()">\n</sing-dialog-errors>\n\n<mat-dialog-actions>\n    <ng-container *ngIf="hasOrchids; else noOrchidsButton">\n        <button mat-button class="cancel-button" (click)="cancel()">\n            <span>{{ msgs.cancel() }}</span>\n        </button>\n        <button class="ok-button" mat-raised-button color="primary" [disabled]="addLibItemButtonDisabled" (click)="confirm()">\n            <span *ngIf="showAddLibItemButton; else fetchingSpinner">{{ msgs.addToLibrary() }}</span>\n            <ng-template #fetchingSpinner>\n                <mat-progress-spinner diameter="25" color="primary" mode="indeterminate"></mat-progress-spinner>\n            </ng-template>\n        </button>\n    </ng-container>\n    <ng-template #noOrchidsButton>\n        <button class="ok-button" mat-button color="primary" (click)="cancel()">{{ msgs.ok() }}</button>\n    </ng-template>\n</mat-dialog-actions>\n'
        }
        ,
        58738: e => {
            e.exports = '<section layout="row" class="admin-section">\n    <navigation display="left"></navigation>\n\n    <div class="library-content">\n        <div class="library-actions" *ngIf="componentState === ComponentState.Loaded">\n            <button mat-raised-button color="primary" type="button" class="add-button" (click)="addLibraryItem()">\n                <span>{{ msgs.addLibraryItems() }}</span>\n            </button>\n        </div>\n\n        <page-loading *ngIf="componentState === ComponentState.Loading" [progress]="msgs.loadingLibraryItems()">\n        </page-loading>\n\n        <div class="error" *ngIf="componentState === ComponentState.Failed">\n            {{ msgs.failedToLoadLibraryItems() }}\n        </div>\n\n        <div *ngIf="componentState === ComponentState.Loaded">\n            <mat-card class="filter">\n                <mat-form-field class="search" floatLabel="always">\n                    <mat-label>{{ msgs.search() }}</mat-label>\n                    <mat-chip-list #chipList>\n                        <mat-chip *ngFor="let term of searchTerms" selectable="false" removable="true" (removed)="onSearchTermRemoved(term)">\n                            {{ term }}\n                            <i class="fa-solid fa-circle-xmark library-search-remove-icon" matChipRemove></i>\n                        </mat-chip>\n                        <input placeholder="{{ msgs.nameServerOrCamera() }}" [matChipInputFor]="chipList" [matChipInputSeparatorKeyCodes]="separatorKeysCodes" [matChipInputAddOnBlur]="true" (matChipInputTokenEnd)="onSearchTermAdded($event)">\n                    </mat-chip-list>\n                </mat-form-field>\n                <mat-form-field class="sort" hideRequiredMarker>\n                    <mat-label>{{ msgs.sort() }}</mat-label>\n\n                    <mat-select [(ngModel)]="sortOnProperty" (selectionChange)="onSortSelectionChanged($event)" matNativeControl required>\n                        <mat-option value="request.source.cameraName">{{ msgs.camera() }}</mat-option>\n                        <mat-option value="createdBy">{{ msgs.createdBy() }}</mat-option>\n                        <mat-option value="createdOnMs">{{ msgs.createdOn() }}</mat-option>\n                        <mat-option value="name">{{ msgs.name() }}</mat-option>\n                        <mat-option value="request.source.orchidName">{{ msgs.server() }}</mat-option>\n                        <mat-option value="files.0.contentLength">{{ msgs.size() }}</mat-option>\n                        <mat-option value="request.startTimeMs">{{ msgs.startTime() }}</mat-option>\n                        <mat-option value="status.state">{{ msgs.status() }}</mat-option>\n                    </mat-select>\n                    <button mat-icon-button matSuffix (click)="onSortDescendChanged($event)">\n                        <i class="descending-icon fa fa-lg fa-sort-amount-asc" [ngClass]="{ \'fa-flip-vertical\': sortDescending, \'no-flip\': !sortDescending }"></i>\n                    </button>\n                </mat-form-field>\n            </mat-card>\n\n            <div *ngIf="filteredLibraryItems.length === 0 && searchTerms.length === 0" class="no-matches-error-message">\n                {{ msgs.noItemsHaveBeenAddedToTheLibrary() }}\n            </div>\n            <div *ngIf="filteredLibraryItems.length === 0 && searchTerms.length > 0" class="empty no-matches-error-message">\n                {{ msgs.noLibraryItemsWereFoundThatMatchTheSearchCriteria() }}\n            </div>\n\n            <mat-accordion *ngIf="libraryItems.length > 0">\n                <mat-expansion-panel hideToggle (opened)="onLibraryItemPanelExpanded(libraryItem)" (closed)="onLibraryItemPanelCollapsed(libraryItem)" *ngFor="\n                        let libraryItem of filteredLibraryItems\n                            | slice: pageIndex * pageSize:pageIndex * pageSize + pageSize\n                    ">\n                    <mat-expansion-panel-header [collapsedHeight]="\'92px\'" [expandedHeight]="\'92px\'">\n                        <div class="header-left">\n                            <mat-checkbox *ngIf="libraryItem.processing === undefined || libraryItem.processing === false" [(ngModel)]="libraryItem.selectedForDelete" (click)="$event.stopPropagation()"></mat-checkbox>\n                            <mat-spinner *ngIf="libraryItem.processing" diameter="20"></mat-spinner>\n                            <div class="header-detail-container">\n                                <div class="name">\n                                    <h4>{{ libraryItem.name }}</h4>\n                                    <i class="fa fa-pencil ng-scope" *ngIf="libraryItem.expanded" (click)="rename(libraryItem); $event.stopPropagation()"></i>\n                                </div>\n                                <div class="source">\n                                    <div>{{ libraryItem.request.source.orchidName }}</div>\n                                    <div>{{ libraryItem.request.source.cameraName }}</div>\n                                </div>\n                            </div>\n                        </div>\n                        <div class="fixed-header-right">\n                            <sing-image-loader *ngIf="libraryItem.status.state === LibraryItemState.Completed" [src]="libraryItem.previewUrl"></sing-image-loader>\n                            <span *ngIf="libraryItem.status.state === LibraryItemState.Failed" class="unavailable">\n                                <i class="fa fa-triangle-exclamation md-subhead error-small"></i>\n                            </span>\n                            <div *ngIf="libraryItem.status.state === LibraryItemState.Started" class="library-download-progress" style="display: flex; flex-direction: column">\n                                <span>\n                                    {{ libraryItem.transferStatus }}\n                                </span>\n                                <mat-progress-bar *ngIf="libraryItem.status.progress" [mode]="\n                                        libraryItem.status.progress.transfer.sizeBytes === 0\n                                            ? \'indeterminate\'\n                                            : \'determinate\'\n                                    " [value]="libraryItem.calculatedProgress"></mat-progress-bar>\n                                <span *ngIf="\n                                        libraryItem.status.progress &&\n                                        libraryItem.status.progress.transfer.sizeBytes > 0\n                                    ">\n                                    {{\n                                        msgs.COMPLETEDofTOTAL({\n                                            COMPLETED: libraryItem.status.progress.transfer.sentBytes | bytes,\n                                            TOTAL: libraryItem.status.progress.transfer.sizeBytes | bytes\n                                        })\n                                    }}\n                                </span>\n                            </div>\n                            <span *ngIf="libraryItem.status.state === LibraryItemState.Pending">\n                                <i class="fa-regular fa-hourglass"></i>\n                            </span>\n                            <span *ngIf="libraryItem.status.state === LibraryItemState.Canceled">\n                                <i class="fa fa-ban"></i>\n                            </span>\n                        </div>\n                    </mat-expansion-panel-header>\n\n                    <div class="library-item-content">\n                        <div class="content-container">\n                            <div class="content-row">\n                                <div class="flex-full-width">\n                                    <div>\n                                        <label>{{ msgs.startTime() }}</label>\n                                        {{ libraryItem.request.startTimeMs | date: formats.startTime }}\n                                    </div>\n\n                                    <div class="whitespace-normal">\n                                        <label>{{ msgs.duration() }}</label>\n                                        {{ calcDuration(libraryItem) }}\n                                    </div>\n                                    <div>\n                                        <label>{{ msgs.size() }}</label>\n                                        <span *ngIf="libraryItem.status.state === LibraryItemState.Completed">\n                                            {{ libraryItem.files[0].contentLength | bytes }}\n                                        </span>\n                                    </div>\n                                    <div>\n                                        <label>{{ msgs.format() }}</label>\n                                        <span *ngIf="libraryItem.status.state === LibraryItemState.Completed">\n                                            {{\n                                                libraryItem.files[0].contentType | humanizeMimeType: msgs.unknown()\n                                            }}</span>\n                                    </div>\n                                </div>\n                                <div class="flex-full-width">\n                                    <div>\n                                        <label>{{ msgs.createdOn() }}</label>\n                                        {{ libraryItem.createdOnMs | date: formats.createdOn }}\n                                    </div>\n                                    <div>\n                                        <label>{{ msgs.createdBy() }}</label>\n                                        {{ libraryItem.createdBy }}\n                                    </div>\n                                </div>\n                                <div class="flex-full-width library-item-status">\n                                    <div>\n                                        <label>{{ msgs.status() }}</label>\n                                        <span>{{\n                                            libraryItem.status.state.toLowerCase() | localizeMessage: msgs\n                                        }}</span>\n                                        <div *ngIf="libraryItem.status.error" class="error-small">\n                                            {{ libraryItem.status.error }}\n                                        </div>\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                        <div class="error" *ngIf="libraryItem.error">\n                            {{ msgs.libraryError() }} {{ libraryItem.error }}\n                        </div>\n                    </div>\n                    <mat-action-row>\n                        \x3c!-- Delete button --\x3e\n                        <button mat-raised-button class="action-button remove-button delete-button-text" color="warn" [disabled]="libraryItem.processing" (click)="delete(libraryItem)">\n                            {{ msgs.delete() }}\n                        </button>\n\n                        \x3c!-- Cancel button --\x3e\n                        <button *ngIf="\n                                libraryItem.status.state === LibraryItemState.Pending ||\n                                libraryItem.status.state === LibraryItemState.Started\n                            " mat-raised-button color="primary" [disabled]="libraryItem.processing" (click)="cancel(libraryItem)">\n                            {{ msgs.cancel() }}\n                        </button>\n\n                        \x3c!-- Retry button --\x3e\n                        <button *ngIf="\n                                libraryItem.status.state === LibraryItemState.Failed ||\n                                libraryItem.status.state === LibraryItemState.Canceled\n                            " mat-raised-button color="primary" [disabled]="libraryItem.processing" (click)="retry(libraryItem)">\n                            {{ msgs.retry() }}\n                        </button>\n\n                        \x3c!-- Download Button --\x3e\n                        <button mat-raised-button color="primary" [disabled]="libraryItem.processing" (click)="download(libraryItem)" *ngIf="\n                                libraryItem.status.state === LibraryItemState.Completed &&\n                                libraryItem.files[0].downloadUrl\n                            ">\n                            {{ msgs.download() }}\n                        </button>\n\n                        \x3c!-- Open external button for everything except non-PWA Safari --\x3e\n                        <button class="opener" mat-raised-button color="primary" [disabled]="libraryItem.opening" (click)="open(libraryItem)" *ngIf="\n                                useAnchorTagToOpen === false &&\n                                libraryItem.status.state === LibraryItemState.Completed &&\n                                libraryItem.files[0].isExternal\n                            ">\n                            <span *ngIf="!libraryItem.opening; else spinner"> {{ msgs.open() }}</span>\n                            <ng-template #spinner>\n                                <mat-progress-spinner diameter="25" color="primary" mode="indeterminate"></mat-progress-spinner>\n                            </ng-template>\n                        </button>\n\n                        \x3c!-- external asset Anchor tag used for iOS Safari and not PWA --\x3e\n                        <a class="opener" mat-raised-button color="primary" [disabled]="libraryItem.opening || !libraryItem.externalUrl" [href]="libraryItem.externalUrl" target="_blank" *ngIf="\n                                useAnchorTagToOpen === true &&\n                                libraryItem.status.state === LibraryItemState.Completed &&\n                                libraryItem.files[0].isExternal\n                            ">\n                            <span *ngIf="!libraryItem.opening && libraryItem.externalUrl; else spinner">\n                                {{ msgs.open() }}</span>\n                            <ng-template #spinner>\n                                <mat-progress-spinner diameter="25" color="primary" mode="indeterminate"></mat-progress-spinner>\n                            </ng-template>\n                        </a>\n                    </mat-action-row>\n                </mat-expansion-panel>\n            </mat-accordion>\n            <div class="library-footer">\n                <div class="delete-actions" *ngIf="filteredLibraryItems.length > 0">\n                    <mat-checkbox class="delete-all" [checked]="areAllSelectedForDelete()" (change)="toggleSelectAll($event.checked)"></mat-checkbox>\n                    <button mat-raised-button class="action-button remove-button delete-button-text" color="warn" (click)="delete()" [disabled]="areAnySelectedForDelete() === false">\n                        {{ msgs.delete() }}\n                    </button>\n                </div>\n\n                <pagination class="pagination-total" (page)="handlePage($event)" [dataSource]="filteredLibraryItems" [pageSize]="pageSize" [pageSizeOptions]="[10, 20, 30, 40]">\n                </pagination>\n            </div>\n        </div>\n    </div>\n</section>\n'
        }
        ,
        55999: e => {
            e.exports = '<section class="licensing-section activation-report-section">\n    <page-loading *ngIf="componentState === ComponentState.LOADING" [progress]="msgs.loadingActivationReport()"></page-loading>\n\n    <section [class.hidden-licensing-section]="componentState !== ComponentState.LOADED">\n        <section class="licensing-card-header">\n            \x3c!-- Card title --\x3e\n            <mat-card-title class="licensing-card-title">\n                {{ msgs.exportActivationReport() }}\n            </mat-card-title>\n\n            \x3c!-- Buttons --\x3e\n            <span class="button-group page-buttons">\n                \x3c!-- Upload Button --\x3e\n                <button mat-raised-button [disabled]="!canExport" (click)="export()" color="primary">\n                    {{ msgs.buttons.downloadReport() }}\n                </button>\n            </span>\n        </section>\n\n        <mat-card class="licensing-card" [class.hidden-licensing-card]="licenses.length === 0">\n            <div *ngIf="error" class="licensing-error-text licensing-card-error">\n                {{ error }}\n            </div>\n\n            <mat-card-content>\n                \x3c!-- Table for import status --\x3e\n                <table mat-table [dataSource]="dataSource" [trackBy]="getRowId" matSort [matSortActive]="defaultSort.id" [matSortDirection]="defaultSort.start" [matSortDisableClear]="defaultSort.disableClear" class="licensing-table">\n                    <ng-container *ngFor="let col of columns" [matColumnDef]="col.columnDef">\n                        <th mat-header-cell mat-sort-header *matHeaderCellDef>\n                            {{ col.header }}\n                        </th>\n                        <td mat-cell *matCellDef="let item" [attr.data-title]="col.header">\n                            {{ col.formatter(item) }}\n                        </td>\n                    </ng-container>\n\n                    <tr mat-header-row *matHeaderRowDef="displayCols"></tr>\n                    <tr mat-row *matRowDef="let row; columns: displayCols"></tr>\n                </table>\n\n                <mat-paginator showFirstLastButtons *ngIf="!hidePaginator" [pageSizeOptions]="pageSizeOptions" [attr.aria-label]="msgs.ariaLabels.selectPageOfActivationReport()">\n                </mat-paginator>\n            </mat-card-content>\n        </mat-card>\n\n        \x3c!-- Show warning if no data to display --\x3e\n        <div class="licensing-placeholder" *ngIf="licenses.length === 0">\n            <ng-template *ngIf="error; then hasError; else noLicenses"></ng-template>\n\n            <ng-template #hasError>\n                <div class="licensing-error-text fail-text">\n                    {{ error }}\n                </div>\n            </ng-template>\n\n            <ng-template #noLicenses>\n                <div class="no-matches-error-message">\n                    {{ msgs.noChildNameServersHaveBeenRegistered() }}\n                </div>\n            </ng-template>\n        </div>\n    </section>\n</section>\n'
        }
        ,
        62095: e => {
            e.exports = '<section class="licensing-section import-section">\n    <page-loading *ngIf="componentState === ComponentState.LOADING" [progress]="msgs.loadingActivationBundleStatus()"></page-loading>\n\n    <section [class.hidden-licensing-section]="componentState !== ComponentState.LOADED">\n        <section class="licensing-card-header">\n            \x3c!-- Card title (left) --\x3e\n            <mat-card-title class="licensing-card-title">\n                {{ msgs.importActivationBundle() }}\n            </mat-card-title>\n\n            \x3c!-- Buttons (right) --\x3e\n            <span class="licensing-button-group">\n                \x3c!-- Upload Button --\x3e\n                <button mat-raised-button (click)="upload()" color="primary">\n                    {{ msgs.buttons.uploadBundle() }}\n                </button>\n            </span>\n        </section>\n\n        <div *ngIf="licenseImports.length > 0; else importsError">\n            \x3c!-- Card for bulk imports --\x3e\n            <section class="licensing-card-subheader">\n                \x3c!-- Process state and progress indicators --\x3e\n                <div class="import-status">\n                    <div class="import-status-block">\n                        <div>\n                            <span class="import-status-title">{{ msgs.status() }}: </span>\n                            <span>{{ processStateString }}</span>\n                        </div>\n\n                        <mat-progress-bar *ngIf="isProcessing; else feedbackBar" class="import-progress-bar" mode="determinate" [value]="progress"></mat-progress-bar>\n\n                        <ng-template #feedbackBar>\n                            <mat-progress-bar *ngIf="isShowingFeedback" class="import-progress-bar" mode="indeterminate" [value]="progress"></mat-progress-bar>\n                        </ng-template>\n                    </div>\n\n                    <div *ngIf="isProcessing" class="import-progress-text">\n                        {{ msgs.countOfTotalComplete({ COUNT: numProcessed, TOTAL: licenseImports.length }) }}\n                    </div>\n                </div>\n\n                \x3c!-- Cancel / Retry buttons --\x3e\n                <section class="licensing-button-group">\n                    <button mat-raised-button (click)="cancel()" [disabled]="!canCancel" color="primary">\n                        {{ msgs.buttons.cancel() }}\n                    </button>\n\n                    <button mat-raised-button (click)="retry()" [disabled]="!canRetry" color="primary">\n                        {{ msgs.buttons.retry() }}\n                    </button>\n\n                    <button mat-raised-button (click)="clear()" [disabled]="!canClear" color="primary">\n                        {{ msgs.buttons.clear() }}\n                    </button>\n                </section>\n            </section>\n            <mat-card class="licensing-card">\n                <mat-card-content class="centered">\n                    \x3c!-- Table for import status --\x3e\n                    <table mat-table [dataSource]="dataSource" [trackBy]="getRowId" matSort [matSortActive]="defaultSort.id" [matSortDirection]="defaultSort.start" [matSortDisableClear]="defaultSort.disableClear" class="licensing-table responsive-table-800 striped-table">\n                        <ng-container *ngFor="let col of columns" [matColumnDef]="col.columnDef">\n                            \x3c!-- Column header --\x3e\n                            <th mat-header-cell mat-sort-header *matHeaderCellDef [class.responsive-hide]="col.hideable === true">\n                                {{ col.header }}\n                            </th>\n\n                            \x3c!-- Row cells for this column --\x3e\n                            <td mat-cell *matCellDef="let item" [attr.data-title]="col.header" [class.responsive-hide]="col.hideable === true" [class.fail-text]="isFail(item.itemStatus)">\n                                {{ col.formatter(item) }}\n                            </td>\n                        </ng-container>\n\n                        \x3c!-- Status Column --\x3e\n                        <ng-container [matColumnDef]="specialColumns.status.columnDef">\n                            <th mat-header-cell mat-sort-header *matHeaderCellDef>\n                                {{ specialColumns.status.header }}\n                            </th>\n                            <td mat-cell *matCellDef="let item" [attr.data-title]="specialColumns.status.header" [class.fail-text]="isFail(item.itemStatus)" [class.responsive-hide]="specialColumns.status.hideable === true">\n                                <span matTooltipClass="import-error-tooltip" matTooltipPosition="above" matTooltip="{{ getStatusDetailString(item) }}">\n                                    {{ specialColumns.status.formatter(item) }}\n                                    <i *ngIf="isFail(item.itemStatus)" class="fa fa-triangle-exclamation"> </i>\n                                </span>\n                            </td>\n                        </ng-container>\n\n                        <tr mat-header-row *matHeaderRowDef="displayCols"></tr>\n                        <tr mat-row *matRowDef="let row; columns: displayCols"></tr>\n                    </table>\n\n                    <mat-paginator showFirstLastButtons [class.hidden]="hidePaginator" [pageSizeOptions]="pageSizeOptions" [attr.aria-label]="msgs.ariaLabels.selectPageOfLicenseImports()">\n                    </mat-paginator>\n                </mat-card-content>\n            </mat-card>\n\n            \x3c!-- Show warning if no data to display --\x3e\n            <ng-template #importsError>\n                <div class="licensing-placeholder">\n                    <div *ngIf="errors.length > 0; then hasError; else noImports"></div>\n\n                    <ng-template #hasError>\n                        <div class="licensing-error-text fail-text" *ngFor="let err of errors">\n                            {{ err }}\n                        </div>\n                    </ng-template>\n\n                    <ng-template #noImports>\n                        <div class="no-matches-error-message">\n                            {{ msgs.noActivationDataToDisplay() }}\n                        </div>\n                    </ng-template>\n                </div>\n            </ng-template>\n        </div>\n    </section>\n</section>\n'
        }
        ,
        60244: e => {
            e.exports = '<navigation display="left"></navigation>\n\n<section class="licensing-page admin-section" layout="row" flex>\n    <section class="licensing-group">\n        <activation-report class="licensing-child-container">\n        </activation-report>\n\n        <bulk-license-import class="licensing-child-container">\n        </bulk-license-import>\n    </section>\n</section>\n'
        }
        ,
        25379: e => {
            e.exports = '<a class="nav-bar-logo" [routerLink]="[\'/stage\']">\n    <img class="nav-bar-logo-image" [src]="logoUrl" data-brand-logo="">\n    <div class="hide-xs nav-bar-logo-text">\n        <span class="brand">{{ appName }}</span>\n        <span class="license">{{ appLicense }}</span>\n    </div>\n</a>\n'
        }
        ,
        25415: e => {
            e.exports = '<mat-card class="camera-link-overlay-card" [class.disabled]="disabled">\n    <div class="preview wide" *ngIf="!previewFail; else previewError">\n        <mat-spinner *ngIf="loading"></mat-spinner>\n        <img [class.hidden]="loading" [class.shown]="!loading" [class.disabled]="disabled" (load)="imageLoaded()" (error)="imageLoadFailed()" [src]="previewSrcURL">\n        <div *ngIf="disabled" class="disable-camera-status-container">\n            <tag type="disabled-camera"></tag>\n        </div>\n    </div>\n    <ng-template #previewError>\n        <div class="previewFailure">\n            <mat-icon fontIcon="fa-regular fa-frown"></mat-icon>\n        </div>\n    </ng-template>\n    <mat-card-header>\n        <mat-card-title>{{ camera.name }}</mat-card-title>\n        <mat-card-subtitle class="camera-details">\n            <span class="camera-detail">{{ orchid.name }}</span>\n        </mat-card-subtitle>\n        <button mat-icon-button color="primary" class="add-to-stage" (click)="addToStage()">\n            <i class="fa fa-plus"></i>\n        </button>\n    </mat-card-header>\n</mat-card>\n'
        }
        ,
        42831: e => {
            e.exports = '<div #mapcontent class="map-content undraggable">\n    <mat-spinner *ngIf="loading" diameter="90"></mat-spinner>\n\n    <div #maptarget class="map-target">\n        <div class="map-controls hidden-control">\n            <button mat-raised-button color="primary" class="map-zoom-in" (click)="zoomIn()">\n                <i class="fa-regular fa-lg fa-search-plus"></i>\n            </button>\n            <button mat-raised-button color="primary" class="map-zoom-out" (click)="zoomOut()">\n                <i class="fa-regular fa-lg fa-search-minus"></i>\n            </button>\n        </div>\n    </div>\n</div>\n\n<div style="display: none">\n    <div #cameraMapOverlay>\n        <ng-template [cdkPortalOutlet]="mapCameraOverlayPortal"></ng-template>\n    </div>\n</div>\n'
        }
        ,
        36481: e => {
            e.exports = '<mat-toolbar color="primary">\n    <span>{{ msgs.editVALUEmap({ VALUE: shadowCameraGroup.name }) }}</span>\n    <button class="add-lib-x-button" mat-icon-button disableRipple="true" (click)="cancel()">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n<mat-dialog-content class="map-dialog-content">\n    <div class="drawer-container">\n        <div class="bag-drawer" [@transitionDrawer]="drawerOpened" cdkDropList #unmappedContainer="cdkDropList" [cdkDropListConnectedTo]="[mappedContainer]" cdkDropListSortingDisabled="true">\n            <expand-button class="drawer-toggle" [expanded]="drawerOpened" (click)="drawerOpened = !drawerOpened" color="white" type="triangle" direction="right"></expand-button>\n            <div *ngIf="unmappedBagItems.length === 0" class="bag bag-empty">\n                {{ msgs.thereAreNoMoreCamerasAvailableToBeAddedToTheMap() }}\n            </div>\n\n            <div *ngIf="unmappedBagItems.length > 0" class="bag">\n                <div *ngFor="let item of unmappedBagItems" class="item">\n                    \x3c!--\n                     In order to scroll through the bag on mobile, we need to add a dragStartDelay so that a user\n                     isn\'t mistakenly dragging a camera when they meant to scroll over them. However we don\'t want\n                     this delay to hinder the user experience on desktop. So the delay is dynamically set based on a\n                     given mouse/touch event\n                     --\x3e\n                    <div *ngIf="item.type === BagItemType.CAMERA" class="container camera" cdkDrag [cdkDragData]="item" [cdkDragDisabled]="\n                            item.type === BagItemType.SERVER || shadowCameraGroup.mapConfiguration === null\n                        " [cdkDragStartDelay]="dragStartDelay" (mousedown)="dragStartDelay = 0" (touchstart)="dragStartDelay = 60" (doubleClick)="addCameraToMap(item)">\n                        <div *cdkDragPlaceholder></div>\n                        <div class="drag-preview" *cdkDragPreview>\n                            \x3c!-- If camera is neither dewarp enabled or ptz, load regular camera icon  --\x3e\n                            <i *ngIf="!item.cameraType.isDewarp && !item.cameraType.isPTZ" class="fa-kit fa-video-camera"></i>\n                            \x3c!-- Icon will be dewarp if dewarp is enable - regardless of if it is ptz or not. --\x3e\n                            <i *ngIf="item.cameraType.isDewarp" class="fa-kit fa-dewarp"></i>\n                            \x3c!-- If icon is not dewarp, but can tilt, zoom, or pan, then load ptz icon --\x3e\n                            <i *ngIf="!item.cameraType.isDewarp && item.cameraType.isPTZ" class="fa-kit fa-ptz"></i>\n                        </div>\n                        <stream-preview *ngIf="item.type === BagItemType.CAMERA" [title]="item.name" [orchidId]="item.orchidId" [cameraId]="item.cameraId" [isCameraActive]="item.active" [attr.data-orchid-id]="item.orchidId" [attr.data-camera-id]="item.cameraId" class="stream-preview">\n                        </stream-preview>\n\n                        <label>{{ item.name }}</label>\n                        <span>{{ item.description }}</span>\n                    </div>\n                    <div *ngIf="item.type === BagItemType.SERVER" class="server">\n                        <div class="orchid-name sub-title ng-binding ng-scope" ng-if="!shadowCameraGroupCameras.collapse" [title]="item.name">\n                            <i ng-if="!shadowCameraGroupCameras.selectable" class="fa-regular fa-server ng-scope"></i>\n                            {{ item.name }}\n                        </div>\n                        <div class="cameras-container ng-scope">\n                            <div class="list-camera" tabindex="0" aria-hidden="false">\n                                <div class="orchid-logo-container">\n                                    <img class="preview-image orchid-logo" src="images/logo_small_white.png">\n                                </div>\n                            </div>\n                        </div>\n                        <span class="fail-text">{{ msgs.serversCanNotBeAddedToAMap() }}</span>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <div class="drawer-content">\n            <sing-dialog-errors *ngIf="errors" [errmsg]="errors" (onClose)="errors = null"></sing-dialog-errors>\n\n            <div [hidden]="shadowCameraGroup.mapConfiguration === null" class="drop-zone" style="width: 100%; height: 100%" cdkDropList #mappedContainer="cdkDropList">\n                <div class="map-buttons" *ngIf="shadowCameraGroup.mapConfiguration">\n                    <button class="remove-button" mat-raised-button color="primary" (click)="promptToDeleteMap()" [disabled]="processing">\n                        <span class="hide-xs">{{ msgs.deleteMap() }}</span>\n                        <span class="hide-gt-xs">{{ msgs.delete() }}</span>\n                    </button>\n\n                    <button class="upload-button" mat-raised-button color="primary" (click)="promptForMapFile()" [disabled]="processing">\n                        <span class="hide-xs">{{ msgs.uploadMap() }}</span>\n                        <span class="hide-gt-xs">{{ msgs.upload() }}</span>\n                    </button>\n                </div>\n                <map #mapComponent *ngIf="shadowCameraGroup.mapConfiguration && !errors" [editMode]="true" [mapConfiguration]="shadowCameraGroup.mapConfiguration" [cameras]="mappedCameras$" (selectFeature)="displayCameraDetails($event)" (onError)="setError($event)"></map>\n            </div>\n\n            <div *ngIf="!shadowCameraGroup.mapConfiguration" class="no-map-configured">\n                <button mat-raised-button color="primary" (click)="promptForMapFile()" [disabled]="processing">\n                    {{ msgs.uploadMap() }}\n                </button>\n            </div>\n\n            \x3c!-- Collapse/Expand Camera Card --\x3e\n            <div class="selected-camera-card" [@transitionCameraCard]="cameraHandleState">\n                \x3c!-- Don\'t show camera header or preview until camera is fetched and selected --\x3e\n                <ng-container *ngIf="selectedCameraItem">\n                    <div class="selected-camera-header" (click)="changeCameraHandleState()" title="{{ selectedCameraItem.orchidName }}: {{ selectedCameraItem.cameraName }}">\n                        <span class="camera-name">\n                            {{ selectedCameraItem.orchidName }}: {{ selectedCameraItem.cameraName }}\n                        </span>\n                        <i (click)="promptToRemoveCamera($event)" class="fa-regular fa-trash-can fa-2x remove-camera-icon"></i>\n                        \x3c!-- Chevron down when fully expanded, Chevron up in all other situations --\x3e\n                        <i class="chevron-icon fa" [ngClass]="{\n                                \'fa-chevron-down\': cameraHandleState === CameraHandleState.FULLYEXPANDED,\n                                \'fa-chevron-up\':\n                                    cameraHandleState === CameraHandleState.PARTIALLYEXPANDED ||\n                                    cameraHandleState === CameraHandleState.HIDDEN\n                            }"></i>\n                    </div>\n                    \x3c!-- Outer stream preview <div> helps set aspect ratio 16x9 --\x3e\n                    <div class="selected-camera-preview">\n                        <stream-preview [title]="selectedCameraItem.cameraName" [orchidId]="selectedCameraItem.orchidId" [cameraId]="selectedCameraItem.cameraId" [isCameraActive]="selectedCameraItem.active" [previewImagePixelWidth]="previewImagePixelWidth" class="stream-preview">\n                        </stream-preview>\n                    </div>\n                </ng-container>\n            </div>\n        </div>\n    </div>\n</mat-dialog-content>\n\n<mat-dialog-actions>\n    <div class="actions-left">\n        <mat-checkbox [(ngModel)]="!shadowCameraGroup.hideCamerasInBag" [checked]="!shadowCameraGroup.hideCamerasInBag" (change)="toggleShowCamerasInBag($event)" [disabled]="!shadowCameraGroup.mapConfiguration">\n            {{ msgs.showCamerasInBag() }}\n        </mat-checkbox>\n\n        <mat-icon class="label-hint map-tip tooltip-icon" fontSet="fa" fontIcon="fa-circle-question" #tooltip="matTooltip" (click)="tooltip.toggle()" matTooltip="{{ msgs.whenCheckedCamerasInThisGroupWillBeDisplayedInTheBagOnTheStage() }}" matTooltipPosition="right"></mat-icon>\n    </div>\n    <div class="actions-right">\n        <button id="cancel" mat-button color="primary" class="btn btn-cancel" (click)="cancel()" [disabled]="processing">\n            {{ msgs.cancel() }}\n        </button>\n        <button id="confirm" mat-raised-button color="primary" [disabled]="processing" (click)="confirm()">\n            <span *ngIf="!processing">{{ msgs.saveMap() }}</span>\n\n            <mat-spinner mode="indeterminate" diameter="25" *ngIf="processing"></mat-spinner>\n        </button>\n    </div>\n</mat-dialog-actions>\n'
        }
        ,
        77919: e => {
            e.exports = '<mat-toolbar color="primary">\n    <span mat-dialog-title class="dialog-header-title">{{ dialogTitle }}</span>\n    <button class="" mat-icon-button disableRipple="true" (click)="cancel()" cdkFocusInitial>\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content [formGroup]="motionAlertForm" triggerCloseOnScroll>\n    \x3c!-- Camera Selection --\x3e\n    <div class="selected-cameras-header">\n        <p class="dialog-headers">{{msgs.cameraSelection()}}</p>\n        <p class="selected-cameras">\n            {{msgs.SELECTEDslashTOTALselected({SELECTED: currentSelectedCameras.length, TOTAL: orchid.cameras.length})}}\n        </p>\n    </div>\n    <mat-hint *ngIf="cameraSelectionError" class="dialog-warning camera-error">\n        {{msgs.mustSelectAtLeastOneCamera()}}\n    </mat-hint>\n    <camera-selection [hideStreamSelect]="true" [enableMotionWarning]="true" [selectedCameras]="currentSelectedCameras" [cameras]="orchid.cameras" [checkboxText]="msgs.addToNotification()" (onCameraOrStreamSelect)="cameraSelectionForm.updateValueAndValidity()">\n    </camera-selection>\n    \x3c!-- Schedule Dropdown --\x3e\n    <p class="dialog-headers schedule-header">\n        {{msgs.scheduleSelection()}}\n        <mat-icon class="schedule-tooltip tooltip-icon" fontSet="fa" fontIcon="fa-circle-question" matTooltip="{{msgs.tzWarning()}}" matTooltipPosition="after">\n        </mat-icon>\n    </p>\n    <div class="schedule-container">\n        <mat-form-field class="summary-field" appearance="standard">\n            <mat-label>{{msgs.schedule()}}</mat-label>\n            <mat-select #select formControlName="schedule" panelClass="schedule-select-override">\n                \x3c!-- Trigger used to properly format schedule name without showing summary component --\x3e\n                <mat-select-trigger>\n                    {{ select.value?.name }}\n                </mat-select-trigger>\n                <mat-option class="none-option-override" [value]="null">\n                    {{msgs.none()}}\n                </mat-option>\n                <mat-option *ngFor="let schedule of allSchedules" [value]="schedule" class="option-override">\n                    <span class="schedule-name">{{ schedule.name }}</span>\n                    <schedule-summary class="summary-comp" [slots]="schedule.timeSlots"></schedule-summary>\n                </mat-option>\n            </mat-select>\n        </mat-form-field>\n        <mat-error *ngIf="scheduleSelectionError" class="schedule-warning dialog-warning">\n            {{msgs.noEmailsWillBeSentForThisSchedule()}}\n        </mat-error>\n    </div>\n    \x3c!-- Recipients Form --\x3e\n    <p class="dialog-headers no-margin-bottom">{{msgs.emailConfiguration()}}</p>\n    <recipients [allUsers]="allUsers" [allGroups]="allGroups" [allSmtpServers]="allSmtpServers" [recipientsForm]="recipientsForm">\n    </recipients>\n    \x3c!-- Alert Configuration --\x3e\n    <p class="dialog-headers alert-config-header">{{msgs.alertConfiguration()}}</p>\n    <div formGroupName="advancedSettings" class="advanced-settings-container">\n        <div class="alert-config-row">\n            <span>{{msgs.advancedMessage.aMotionAlertWillBeSent()}}</span>\n            <mat-form-field class="advanced-settings-form-field" appearance="standard">\n                <input matInput formControlName="minEventDurationSec" type="number" min="1">\n            </mat-form-field>\n            {{msgs.timeUnitsPlural.second({ VALUE: advancedSettingForm.value.minEventDurationSec })}}\n        </div>\n\n        <div class="alert-config-row">\n            <span>{{msgs.advancedMessage.timeToWait()}}</span>\n            <mat-form-field class="advanced-settings-form-field" appearance="standard">\n                <input matInput formControlName="throttlePerCameraSec" type="number" min="1">\n            </mat-form-field>\n            {{msgs.timeUnitsPlural.second({ VALUE: advancedSettingForm.value.throttlePerCameraSec })}}\n        </div>\n\n        <div class="alert-config-row">\n            <span>{{msgs.advancedMessage.maxExportClipDuration()}}</span>\n            <mat-form-field class="advanced-settings-form-field" appearance="standard">\n                <input matInput formControlName="maxExportDurationSec" type="number" min="1" [max]="maxExportDurationLimit">\n            </mat-form-field>\n            {{ msgs.timeUnitsPlural.second({ VALUE: advancedSettingForm.value.maxExportDurationSec }) }}\n        </div>\n    </div>\n    <div class="advanced-error-msg">\n        <mat-hint class="advanced-settings-warning dialog-warning" *ngIf="advancedSettingsNegativeNumError || alertConfigDecimalsError">\n            {{msgs.timeMustBeAPositiveWholeNumber()}}\n        </mat-hint>\n        <mat-hint class="advanced-settings-warning dialog-warning" *ngIf="advancedSettingForm.controls.maxExportDurationSec.hasError(MotionAlertDialogErrors.MaxValueExceeded)">\n            {{msgs.maxExportDurationLimitExceeded()}}\n        </mat-hint>\n    </div>\n</mat-dialog-content>\n\n\x3c!-- Error notification --\x3e\n<sing-dialog-errors class="file-prompt-errors" *ngIf="error !== undefined" [errmsg]="error" [canClose]="true" (onClose)="error = undefined"></sing-dialog-errors>\n\n<mat-dialog-actions>\n    <mat-checkbox class="enable-notification-checkbox" [(ngModel)]="isNotificationEnabled">{{ msgs.enabled() }}</mat-checkbox>\n\n    <span>\n        <button mat-button mat-dialog-close class="btn btn-cancel" (click)="cancel()">{{msgs.cancel()}}</button>\n\n        <button class="save-button" mat-raised-button color="primary" [disabled]="motionAlertForm.invalid || !showSaveDialogButton" (click)="confirm()">\n            <span *ngIf="showSaveDialogButton else loading">{{msgs.saveMotionAlert()}}</span>\n            <ng-template #loading>\n                <mat-progress-spinner diameter="25" color="primary" mode="indeterminate"></mat-progress-spinner>\n            </ng-template>\n        </button>\n    </span>\n</mat-dialog-actions>\n'
        }
        ,
        12344: e => {
            e.exports = '<section layout="row" class="admin-section motion-alerts-page-content-area" flex>\n    <navigation display="left"></navigation>\n\n    <div class="generic-admin-container-area">\n        \x3c!-- Loading spinner --\x3e\n        <div class="generic-admin-content centered pt-20" *ngIf="loading">\n            <page-loading [progress]="msgs.loadingMotionAlerts()"></page-loading>\n        </div>\n\n        \x3c!-- Error loading message --\x3e\n        <div *ngIf="errorLoadingData" class="failed-to-load-message hint-text">\n            {{ msgs.failedToLoadMotionAlerts() }}\n        </div>\n\n        \x3c!-- Loaded content --\x3e\n        <div *ngIf="!loading && !errorLoadingData">\n            <div class="generic-admin-content centered">\n                <div class="generic-admin-header mt-20">\n                    <mat-card class="w-full">\n                        <mat-tab-group mat-align-tabs="start">\n                            <mat-tab label="{{ msgs.motionAlertsCOUNT({ COUNT: motionAlertNotifications.length }) }}">\n                                <div class="motion-alerts-tab">\n                                    <span class="self-center m-auto">\n                                        <motion-alerts-list></motion-alerts-list>\n                                    </span>\n                                </div>\n                            </mat-tab>\n                            <mat-tab label="{{ msgs.schedulesCOUNT({ COUNT: schedules.length }) }}">\n                                <div class="schedules-tab">\n                                    <schedule-list></schedule-list>\n                                </div>\n                            </mat-tab>\n                        </mat-tab-group>\n                    </mat-card>\n                </div>\n            </div>\n        </div>\n    </div>\n</section>\n'
        }
        ,
        62426: e => {
            e.exports = '<div *ngIf="loading">\n    <page-loading [progress]="msgs.loadingMotionAlerts()"></page-loading>\n</div>\n\n<div *ngIf="!loading && errorLoadingData" class="failed-to-load-message hint-text">\n    {{ msgs.failedToLoadMotionAlerts() }}\n</div>\n\n<div class="pt-25 alert-list-container" *ngIf="!loading && !errorLoadingData">\n    \x3c!-- Search Bar --\x3e\n    <div *ngIf="orchids.length > 0">\n        <mat-form-field class="orchid-alert-search" floatLabel="always" appearance="outline">\n            <mat-label>{{ msgs.search() }}</mat-label>\n            <mat-chip-list #chipList>\n                <mat-chip *ngFor="let term of searchTerms" selectable="false" removable="true" (removed)="onSearchTermRemoved(term)">\n                    {{ term }}\n                    <i class="fa-solid fa-circle-xmark" matChipRemove></i>\n                </mat-chip>\n                <input placeholder="Orchid Recorder" [matChipInputFor]="chipList" [matChipInputSeparatorKeyCodes]="separatorKeysCodes" [matChipInputAddOnBlur]="true" (matChipInputTokenEnd)="onSearchTermAdded($event)">\n            </mat-chip-list>\n        </mat-form-field>\n        <mat-form-field class="orchid-status-filter" appearance="outline" floatLabel="always">\n            <mat-label>{{ msgs.status() }}</mat-label>\n            <mat-select class="sort-select-choices" [(ngModel)]="sortOnProperty" (selectionChange)="onServerStatusFilterChange($event)" matNativeControl required>\n                <mat-option value="orchid.name">{{ msgs.name() }}</mat-option>\n                <mat-option value="notification.name">{{ msgs.configured() }}</mat-option>\n                <mat-option value="notification.isEnabled">{{ msgs.enabled() }}</mat-option>\n            </mat-select>\n            <button mat-icon-button matSuffix (click)="onSortDescendChange($event)">\n                <i class="descending-icon fa fa-lg fa-sort-amount-asc" [ngClass]="{\n                        \'fa-flip-vertical\':\n                            (sortDescending && sortOnProperty !== \'notification.isEnabled\') ||\n                            (!sortDescending && sortOnProperty === \'notification.isEnabled\'),\n                        \'no-flip\':\n                            (!sortDescending && sortOnProperty !== \'notification.isEnabled\') ||\n                            (sortDescending && sortOnProperty === \'notification.isEnabled\')\n                    }"></i>\n            </button>\n        </mat-form-field>\n    </div>\n    <div *ngIf="orchids.length > 0" class="configured-server-count">\n        {{\n            msgs.CONFIGUREDslashTOTALconfigured({ CONFIGURED: motionAlertNotifications.length, TOTAL: orchids.length })\n        }}\n    </div>\n\n    <div *ngIf="orchids.length === 0" class="no-linked-orchids">{{ msgs.noChildNameServersHaveBeenRegistered() }}</div>\n\n    <div *ngIf="filteredOrchidNotifPairs.length === 0 && orchids.length > 0" class="no-orchids-found">\n        <div class="no-matches-error-message">{{ msgs.searchReturnedNoChildNameServers() }}</div>\n    </div>\n\n    <div class="orchids-table striped-table">\n        <div *ngFor="\n                let orchidNotifPair of filteredOrchidNotifPairs\n                    | slice: pageIndex * pageSize:pageIndex * pageSize + pageSize;\n                let i = index;\n                trackBy: trackOrchidNotifPair\n            " class="orchids-table-rows">\n            <div class="name-column">\n                <i class="fa-regular fa-server server-icon"></i>\n                <div class="orchid-name">{{ orchidNotifPair.orchid.name }}</div>\n            </div>\n\n            <div class="notification-column">\n                <div class="num-cams-in-notification" *ngIf="orchidNotifPair.notification !== null">\n                    {{ msgs.COUNTcamerasAdded({ COUNT: orchidNotifPair.notification.conditions[0].cameraIds.length }) }}\n                </div>\n            </div>\n\n            <div class="actions-column">\n                <button class="add-notification-button" *ngIf="orchidNotifPair.notification === null" mat-button color="primary" (click)="addEditNotification(orchidNotifPair)">\n                    {{ msgs.addNotification() }}\n                </button>\n\n                <div class="actions-column-icons" *ngIf="orchidNotifPair.notification !== null">\n                    <i class="fa-regular fa-clock preview-schedule-on-hover pl-7 pr-7" [ngClass]="{ \'disabled-color\': orchidNotifPair.notification.conditions[0].scheduleId === null }" (mouseover)="setCurrentSchedulePreview(orchidNotifPair)" (mouseout)="currentSchedulePreview = undefined" (touchstart)="setCurrentSchedulePreview(orchidNotifPair)" matTooltip="{{ msgs.noScheduleIsConfiguredForThisNotification() }}" [matTooltipDisabled]="orchidNotifPair.notification.conditions[0].scheduleId !== null" [matTooltipPosition]="\'above\'">\n                        <schedule-summary class="schedule-preview" *ngIf="\n                                currentSchedulePreview !== undefined &&\n                                orchidNotifPair.notification.conditions[0].scheduleId ===\n                                    currentSchedulePreview.notification.conditions[0].scheduleId &&\n                                currentSchedulePreview.notification.id === orchidNotifPair.notification.id\n                            " [slots]="findScheduleFromNotification(orchidNotifPair.notification).timeSlots"></schedule-summary>\n                    </i>\n\n                    <i class="fa fa-pencil pl-7 pr-7" (click)="addEditNotification(orchidNotifPair)"></i>\n\n                    <i class="fa-regular fa-trash-can pl-7 pr-7" (click)="deleteNotification(orchidNotifPair)"></i>\n\n                    <i *ngIf="orchidNotifPair.notification.isEnabled && orchidNotifPair.error === \'\'" class="fa fa-envelope pr-12 pl-12" matTooltip="{{ msgs.notificationIsConfiguredCorrectlyNotificationsWillBeSent() }}" #matTooltip="matTooltip" (click)="matTooltip.toggle()"></i>\n\n                    <span class="fa-stack pl-8" *ngIf="orchidNotifPair.notification.isEnabled && orchidNotifPair.error !== \'\'" matTooltip="{{ orchidNotifPair.error }}" #matTooltip="matTooltip" (click)="matTooltip.toggle()">\n                        <i class="fa fa-envelope fa-stack-1x"></i>\n                        <i class="fa fa-ban fa-stack-2x red"></i>\n                    </span>\n\n                    <i *ngIf="!orchidNotifPair.notification.isEnabled" class="fa fa-envelope disabled-envelope pr-12 pl-12" matTooltip="{{ msgs.notificationIsDisabledNoNotificationsWillBeSent() }}" #matTooltip="matTooltip" (click)="matTooltip.toggle()"></i>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <mat-paginator *ngIf="filteredOrchidNotifPairs.length > pageSize" [length]="filteredOrchidNotifPairs.length" [pageSize]="pageSize" [pageSizeOptions]="[10, 20, 50]" (page)="onPaginatorChange($event)" attr.aria-label="{{ msgs.selectPage() }}" showFirstLastButtons></mat-paginator>\n</div>\n'
        }
        ,
        63003: e => {
            e.exports = '<form [formGroup]="recipientsForm">\n    \x3c!-- Users Input --\x3e\n    <mat-form-field class="users-form-field" appearance="standard">\n        <mat-label>{{ msgs.users() }}</mat-label>\n        <mat-chip-list formControlName="users" #usersChipList [attr.aria-label]="msgs.recipients.userSelection()">\n            <mat-chip *ngFor="let user of selectedFormUsers" (removed)="onUserRemoved(user)" selectable="false" removable="true">\n                {{user.username}}\n                <mat-icon matChipRemove class="recipients-chip-mat-icon" fontSet="fa" fontIcon="fa-circle-xmark">\n                </mat-icon>\n            </mat-chip>\n            <input closeOnScroll matInput placeholder="{{ msgs.notifications.searchForAUser() }}" #usersInput #userTrigger="matAutocompleteTrigger" [formControl]="usersInputCtrl" [matAutocomplete]="usersAuto" [matChipInputAddOnBlur]="true" [matChipInputFor]="usersChipList" [matChipInputSeparatorKeyCodes]="separatorKeysCodes">\n            <mat-autocomplete #usersAuto="matAutocomplete" (optionSelected)="onUserSelected($event)" panelWidth="auto" autoActiveFirstOption>\n                <mat-option disabled="disabled" *ngIf="(filteredSortedSelectableUsers$ | async)?.length === 0">\n                    {{ msgs.recipients.noUsersMatchSearch() }}\n                </mat-option>\n                \x3c!-- Need to stop propagation and reopen the panel on click since Angular Material 12 does not support this behavior --\x3e\n                <mat-option *ngFor="let filteredUser of filteredSortedSelectableUsers$ | async" (click)="$event.stopPropagation(); userTrigger.openPanel()" [value]="filteredUser">\n                    {{filteredUser.username}}\n                </mat-option>\n            </mat-autocomplete>\n        </mat-chip-list>\n        <mat-hint *ngIf="usersWithoutEmails.length > 0" class="recipients-warning">\n            {{ msgs.notifications.usersWithoutEmailAddresses() }} {{ usersWithoutEmailsStr }}\n        </mat-hint>\n    </mat-form-field>\n\n    \x3c!-- Groups Input --\x3e\n    <mat-form-field class="groups-form-field" appearance="standard">\n        <mat-label>\n            {{ msgs.notifications.permissionGroups() }}\n            <mat-icon class="groups-tooltip tooltip-icon" fontSet="fa" fontIcon="fa-circle-question" matTooltip="{{ msgs.notifications.emailsWillBeSentToAllUsersInSpecifiedPermissionGroups() }}" matTooltipPosition="after">\n            </mat-icon>\n        </mat-label>\n        <mat-chip-list formControlName="groups" #groupsChipList [attr.aria-label]="msgs.recipients.groupSelection()">\n            <mat-chip *ngFor="let group of selectedFormGroups" selectable="false" removable="true" (removed)="onGroupRemoved(group)">\n                {{group.name}}\n                <mat-icon matChipRemove class="recipients-chip-mat-icon" fontSet="fa" fontIcon="fa-circle-xmark">\n                </mat-icon>\n            </mat-chip>\n            <input closeOnScroll matInput placeholder="{{ msgs.notifications.searchForAGroup() }}" #groupsInput #groupTrigger="matAutocompleteTrigger" [formControl]="groupsInputCtrl" [matAutocomplete]="groupsAuto" [matChipInputAddOnBlur]="true" [matChipInputFor]="groupsChipList" [matChipInputSeparatorKeyCodes]="separatorKeysCodes">\n            <mat-autocomplete #groupsAuto="matAutocomplete" (optionSelected)="onGroupSelected($event)" panelWidth="auto" autoActiveFirstOption>\n                <mat-option disabled="disabled" *ngIf="(filteredSortedSelectableGroups$ | async)?.length === 0;">\n                    {{ msgs.recipients.noGroupsMatchSearch() }}\n                </mat-option>\n                \x3c!-- Need to stop propagation and reopen the panel on click since Angular Material 12 does not support this behavior --\x3e\n                <mat-option *ngFor="let filteredGroup of filteredSortedSelectableGroups$ | async" (click)="$event.stopPropagation(); groupTrigger.openPanel()" [value]="filteredGroup">\n                    {{filteredGroup.name}}\n                </mat-option>\n            </mat-autocomplete>\n        </mat-chip-list>\n        <mat-hint *ngIf="groupsWithoutEmailsList.length > 0" class="recipients-warning">\n            {{ msgs.notifications.groupsWithoutEmailAddresses() }} {{ groupsWithoutEmailsStr }}\n        </mat-hint>\n    </mat-form-field>\n\n    \x3c!-- Emails Input --\x3e\n    <mat-form-field class="emails-chip-list" appearance="standard">\n        <mat-label>{{ msgs.notifications.emails() }}</mat-label>\n        <mat-chip-list formControlName="emailAddresses" #emailsChipList [attr.aria-label]="msgs.recipients.emailSelection()">\n            <mat-chip *ngFor="let email of selectedFormEmails" selectable="false" removable="true" (removed)="onEmailRemoved(email)">\n                {{email}}\n                <mat-icon matChipRemove class="recipients-chip-mat-icon" fontSet="fa" fontIcon="fa-circle-xmark">\n                </mat-icon>\n            </mat-chip>\n            <input matInput type="email" placeholder="{{ msgs.notifications.typeAnEmail() }}" [formControl]="emailsInputCtrl" [matChipInputAddOnBlur]="true" [matChipInputFor]="emailsChipList" [matChipInputSeparatorKeyCodes]="separatorKeysCodes" (matChipInputTokenEnd)="onEmailSelected($event)">\n        </mat-chip-list>\n    </mat-form-field>\n\n    <div class="smtp-server-row">\n        \x3c!-- SMTP Server Input --\x3e\n        <mat-form-field class="smtp-server-form-field" appearance="standard">\n            <mat-label>{{ msgs.notifications.smtpServer() }}</mat-label>\n            <mat-select formControlName="smtpServer">\n                <mat-option class="none-option-override" [value]="null">\n                    {{msgs.notifications.none()}}\n                </mat-option>\n                <mat-option *ngFor="let smtpServer of allSmtpServers" [value]="smtpServer">\n                    {{smtpServer.name}}\n                </mat-option>\n            </mat-select>\n            <mat-hint *ngIf="smtpServerSelectionError" class="recipients-warning">\n                {{ msgs.notifications.noEmailsWillBeSentForThisActionUnlessAnSmtpServerIsSpecified() }}\n            </mat-hint>\n        </mat-form-field>\n        \x3c!-- SMTP From-Address Input --\x3e\n        <mat-form-field class="smtp-address-form-field" appearance="standard">\n            <mat-label>{{ msgs.notifications.smtpFromAddress() }} *</mat-label>\n            <input matInput formControlName="smtpFromAddress">\n            <mat-error>{{ msgs.notifications.aValidEmailAddressIsRequired() }}</mat-error>\n        </mat-form-field>\n    </div>\n</form>\n'
        }
        ,
        80722: e => {
            e.exports = '<div class="container">\n    \x3c!-- Dialog header --\x3e\n    <mat-toolbar color="primary">\n        <div class="md-toolbar-tools">\n            \x3c!-- Title --\x3e\n            <span>{{ title }}</span>\n\n            \x3c!-- X button --\x3e\n            <button mat-icon-button disableRipple="true" (click)="cancel()" [disabled]="isProcessing">\n                <i class="fa fa-times fa-2x"></i>\n            </button>\n        </div>\n    </mat-toolbar>\n\n    \x3c!-- Dialog body --\x3e\n    <mat-dialog-content triggerCloseOnScroll>\n        <form #scheduleForm="ngForm">\n            <mat-form-field class="schedule-name">\n                \x3c!-- Schedule name input --\x3e\n                <mat-label>{{ msgs.name() }}</mat-label>\n                <input cdkFocusInitial matInput required [(ngModel)]="data.name" (keydown.enter)="$event.target.blur()" name="name">\n            </mat-form-field>\n\n            \x3c!-- Schedule preview --\x3e\n            <schedule-summary class="summary" [slots]="allSlots"></schedule-summary>\n\n            \x3c!-- Row for each day-of-the-week --\x3e\n            <div class="weekdays">\n                <ng-container *ngFor="let day of data.days; index as idxDay">\n                    <ng-container *ngFor="let template of [rowDivider, rowName, rowTimeInputs]" [ngTemplateOutlet]="template" [ngTemplateOutletContext]="{day: day, idxDay: idxDay}"></ng-container>\n                </ng-container>\n\n                \x3c!-- Row divider --\x3e\n                <ng-template #rowDivider let-day="day" let-idxDay="idxDay" class="divider">\n                    <div class="divider" *ngIf="idxDay !== 0"></div>\n                </ng-template>\n\n                \x3c!-- Day name --\x3e\n                <ng-template #rowName let-day="day" let-idxDay="idxDay">\n                    <div class="day-name">\n                        {{ day.name }}\n                    </div>\n\n                    \x3c!-- Add button that\'s only visible on mobile --\x3e\n                    <div [class.invisible]="day.slots.length > 0" [class.empty-day]="day.slots.length === 0" class="only-mobile add-slot-button-container">\n                        <button type="button" mat-icon-button class="add-slot-button" (click)="day.addSlot()">\n                            <i class="fa fa-plus"></i>\n                        </button>\n                    </div>\n                </ng-template>\n\n                \x3c!-- Inputs for start / stop inputs --\x3e\n                <ng-template #rowTimeInputs let-day="day" let-idxDay="idxDay">\n                    <div [class.empty-day]="day.slots.length === 0" class="time-container">\n                        \x3c!-- If this day doesn\'t have any slots, populate with an invisible placeholder, so the layout doesnt jump around when adding one --\x3e\n                        <ng-container *ngFor="let slot of getSlotsWithDefault(day); index as idxSlot; trackBy: trackSlotBy">\n                            <div ngModelGroup="{{ \'day\' + idxDay + \'slot\' + idxSlot }}" class="start-stop">\n                                \x3c!-- Start time --\x3e\n                                <mat-form-field>\n                                    <mat-label>{{ msgs.start() }}</mat-label>\n\n                                    <input closeOnScroll #startInput #autoStartTrigger="matAutocompleteTrigger" [ngModel]="slot.start" matInput type="text" name="start-{{idxDay}}-{{idxSlot}}" (focusout)="onTimeInputFocusOut($event.target.value, slot, \'start\', startInput, stopInput)" (keydown.enter)="onTimeInputKeydownEnter(slot, startInput, autoStartTrigger, \'start\')" [matAutocomplete]="autoStart">\n                                    <mat-autocomplete #autoStart="matAutocomplete" (optionSelected)="slot.setTime($event.option.value, \'start\'); startInput.blur()" [displayWith]="Interval.minutesToTwentyFour">\n                                        <mat-option *ngFor="let option of (0 | timeHint:slot.stop)" [value]="option">\n                                            {{ Interval.minutesToTwentyFour(option) }}\n                                        </mat-option>\n                                    </mat-autocomplete>\n                                </mat-form-field>\n\n                                <span class="dash">  </span>\n\n                                \x3c!-- Stop time --\x3e\n                                <mat-form-field>\n                                    <mat-label>{{ msgs.stop() }}</mat-label>\n\n                                    <input closeOnScroll #stopInput #autoStopTrigger="matAutocompleteTrigger" [ngModel]="slot.stop" matInput type="text" name="stop-{{idxDay}}-{{idxSlot}}" (focusout)="onTimeInputFocusOut($event.target.value, slot, \'stop\', startInput, stopInput)" (keydown.enter)="onTimeInputKeydownEnter(slot, stopInput, autoStopTrigger, \'stop\')" [matAutocomplete]="autoStop">\n                                    <mat-autocomplete #autoStop="matAutocomplete" (optionSelected)="slot.setTime($event.option.value, \'stop\'); stopInput.blur()" [displayWith]="Interval.minutesToTwentyFour">\n                                        <mat-option *ngFor="let option of (slot.start+1 | timeHint:1441)" [value]="option">\n                                            {{ Interval.minutesToTwentyFour(option) }}\n                                        </mat-option>\n                                    </mat-autocomplete>\n                                </mat-form-field>\n\n                                \x3c!-- Delete button --\x3e\n                                <button type="button" mat-icon-button (click)="day.removeSlot(idxSlot)" class="delete-slot-button">\n                                    <i class="fa fa-times"></i>\n                                </button>\n\n                                \x3c!-- Add button --\x3e\n                                \x3c!-- This should only be visible for the last slot --\x3e\n                                <button type="button" mat-icon-button (click)="day.addSlot()" [class.invisible]="idxSlot !== day.slots.length-1 && day.slots.length > 0" class="add-slot-button">\n                                    <i class="fa fa-plus"></i>\n                                </button>\n                            </div>\n                        </ng-container>\n                    </div>\n                </ng-template>\n            </div>\n        </form>\n    </mat-dialog-content>\n\n    \x3c!-- Errors --\x3e\n    <sing-dialog-errors *ngIf="error !== undefined" [errmsg]="error" [canClose]="true" (onClose)="clearErrors()"></sing-dialog-errors>\n\n    \x3c!-- Dialog footer buttons --\x3e\n    <mat-dialog-actions>\n        <button mat-button type="button" class="cancel-button" (click)="cancel()" [disabled]="isProcessing">\n            <span>{{ msgs.cancel() }}</span>\n        </button>\n        <button class="ok-button" mat-raised-button type="button" color="primary" [disabled]="!scheduleForm.valid || isProcessing" (click)="save()">\n            <span [class.invisible]="isProcessing">{{ msgs.save() }}</span>\n\n            <mat-progress-spinner diameter="25" color="primary" mode="indeterminate" [hidden]="!isProcessing"></mat-progress-spinner>\n        </button>\n    </mat-dialog-actions>\n</div>\n'
        }
        ,
        2660: e => {
            e.exports = '<section *ngIf="isLoading" class="loading">\n    <mat-progress-spinner diameter="50" color="primary" mode="indeterminate"></mat-progress-spinner>\n</section>\n\n\x3c!-- Header --\x3e\n<section *ngIf="!isLoading" [class.empty-body]="schedules.length === 0" class="container">\n    \x3c!-- Buttons --\x3e\n    <div class="header">\n        <span>\n            <button mat-raised-button class="add-button" color="primary" (click)="addSchedule()">\n                {{ msgs.addSchedule() }}\n            </button>\n        </span>\n    </div>\n\n    <ng-container *ngIf="schedules.length === 0; then bodyEmpty; else bodyNormal"></ng-container>\n\n    \x3c!-- Body when 0 schedules --\x3e\n    <ng-template #bodyEmpty>\n        <div class="plane-container">\n            <div class="plane">\n                <i class="fa-regular fa-paper-plane"></i>\n                <div>{{ msgs.noSchedulesCreatedYet() }}</div>\n                <a class="text-link" href="javascript:void(0)" (click)="addSchedule()">\n                    {{ msgs.addSchedule() }}\n                </a>\n            </div>\n        </div>\n    </ng-template>\n\n    \x3c!-- Body when 1+ schedules --\x3e\n    <ng-template #bodyNormal>\n        \x3c!-- Rows of schedules --\x3e\n        <table mat-table [trackBy]="getRowId" [dataSource]="dataSource" matSort [matSortActive]="defaultSort.id" [matSortDirection]="defaultSort.start" [matSortDisableClear]="defaultSort.disableClear" class="schedule-table interactive striped-table">\n            <tr mat-row *matRowDef="let schd; columns: [\'name\', \'summary\', \'edit\', \'delete\']" (click)="updateSchedule(schd)"></tr>\n\n            \x3c!-- Schedule name --\x3e\n            <ng-container matColumnDef="name">\n                <td mat-cell *matCellDef="let schd" class="name-cell">\n                    {{ schd.name }}\n                </td>\n            </ng-container>\n\n            \x3c!-- Schedule preview --\x3e\n            <ng-container matColumnDef="summary">\n                <td mat-cell *matCellDef="let schd" class="summary-cell">\n                    <div class="summary-container">\n                        <schedule-summary [slots]="schd.timeSlots"></schedule-summary>\n                    </div>\n                </td>\n            </ng-container>\n\n            \x3c!-- Edit button --\x3e\n            <ng-container matColumnDef="edit">\n                <td mat-cell *matCellDef class="edit-cell">\n                    <button mat-icon-button>\n                        <i class="fa fa-pencil fa-lg"></i>\n                    </button>\n                </td>\n            </ng-container>\n\n            \x3c!-- Delete button --\x3e\n            <ng-container matColumnDef="delete">\n                <td mat-cell *matCellDef="let schd" class="delete-cell">\n                    <button mat-icon-button (click)="$event.stopPropagation(); deleteSchedule(schd)">\n                        <i class="fa-regular fa-trash-can fa-lg"></i>\n                    </button>\n                </td>\n            </ng-container>\n        </table>\n    </ng-template>\n\n    <mat-paginator showFirstLastButtons [pageSizeOptions]="pageSizeOptions" [hidden]="hidePaginator"></mat-paginator>\n</section>\n'
        }
        ,
        9376: e => {
            e.exports = '<div class="schedule">\n    <hr>\n    <div class="weekday" *ngFor="let weekDay of Weekdays">\n        <span>{{ weekDay.initial }}</span>\n        <div *ngFor="let slot of weekDay.slots" class="slot" [ngStyle]="{\'left.px\': slot.left, \'width.px\': slot.width }">\n        </div>\n    </div>\n</div>\n'
        }
        ,
        8205: e => {
            e.exports = '<navigation display="left"></navigation>\n<section class="smtp-servers-page">\n    <section class="smtp-group">\n        \x3c!-- Loading SMTP Servers --\x3e\n        <div *ngIf="loading" class="loading-smtp">\n            <page-loading [progress]="msgs.loadingSmtpServers()"></page-loading>\n        </div>\n        \x3c!-- Use hidden instead of ngIfElse so the table is properly selected for sorting on AfterViewInit --\x3e\n        <div [hidden]="loading">\n            \x3c!-- Error Loading SMTP Servers --\x3e\n            <div *ngIf="error; else success" class="warn-text">{{ error }}</div>\n            \x3c!-- SMTP Servers Loaded --\x3e\n            <ng-template #success>\n                <div class="smtp-header-container">\n                    <div class="section-header mat-card-title">{{ msgs.smtpServers() }}</div>\n                    <button class="add-button" mat-raised-button color="primary" (click)="addSmtpServer($event)">\n                        <span class="full-text">{{ msgs.addSmtpServer() }}</span>\n                        <span class="mobile-text">{{ msgs.smtpServer() }}</span>\n                    </button>\n                </div>\n                \x3c!-- No SMTP Servers Configured --\x3e\n                <div class="no-matches-error-message" *ngIf="dataSource.data.length === 0">\n                    <span>{{ msgs.noSmtpServersAreConfigured() }}</span>\n                </div>\n                \x3c!-- SMTP Servers Table --\x3e\n                <mat-card class="smtp-servers-card" [hidden]="dataSource.data.length === 0">\n                    <mat-card-content>\n                        <table class="smtp-table striped-table" mat-table matSort [dataSource]="dataSource" [matSortActive]="defaultSort.id" [matSortDirection]="defaultSort.start" [matSortDisableClear]="defaultSort.disableClear">\n                            <ng-container [matColumnDef]="TableColumns.NAME">\n                                <th mat-header-cell *matHeaderCellDef mat-sort-header>{{ msgs.smtpName() }}</th>\n                                <td mat-cell *matCellDef="let smtpServer">{{ smtpServer.name }}</td>\n                            </ng-container>\n                            <ng-container [matColumnDef]="TableColumns.SERVER">\n                                <th mat-header-cell *matHeaderCellDef mat-sort-header>{{ msgs.smtpAddress() }}</th>\n                                <td mat-cell *matCellDef="let smtpServer">{{ smtpServer.server }}</td>\n                            </ng-container>\n                            <ng-container [matColumnDef]="TableColumns.ICONS">\n                                <th mat-header-cell *matHeaderCellDef></th>\n                                <td mat-cell *matCellDef="let smtpServer">\n                                    <div class="address-cell">\n                                        <button mat-icon-button (click)="editSmtpServer($event, smtpServer)">\n                                            <i class="fa fa-pencil"></i>\n                                        </button>\n                                        <button mat-icon-button (click)="deleteSmtpServer($event, smtpServer)">\n                                            <i class="fa-regular fa-trash-can"></i>\n                                        </button>\n                                    </div>\n                                </td>\n                            </ng-container>\n\n                            <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>\n                            <tr mat-row *matRowDef="let smtpServerRow; columns: displayedColumns" (click)="editSmtpServer($event, smtpServerRow)"></tr>\n                        </table>\n                    </mat-card-content>\n                </mat-card>\n            </ng-template>\n        </div>\n    </section>\n</section>\n'
        }
        ,
        59831: e => {
            e.exports = '<form name="testEmailForm">\n    <mat-toolbar color="primary">\n        <div class="md-toolbar-tools">\n            <span>{{ msgs.sendTestEmail() }}</span>\n            <button mat-icon-button type="button" disableRipple="true" (click)="cancel()">\n                <i class="fa fa-times fa-2x"></i>\n            </button>\n        </div>\n    </mat-toolbar>\n\n    <mat-dialog-content>\n        <mat-form-field class="email-form">\n            <mat-label>{{ msgs.recipientEmailAddress() }}</mat-label>\n            <input [formControl]="email" type="email" email cdkFocusInitial matInput>\n        </mat-form-field>\n        <mat-error [hidden]="email.valid || email.pristine">{{ msgs.aValidEmailAddressIsRequired() }}</mat-error>\n    </mat-dialog-content>\n\n    <mat-dialog-actions>\n        <button mat-button type="button" (click)="cancel()">{{ msgs.cancel() }}</button>\n        <button color="primary" mat-raised-button type="submit" (click)="ok()" [disabled]="email.invalid">\n            {{ msgs.send() }}\n        </button>\n    </mat-dialog-actions>\n</form>\n'
        }
        ,
        52592: e => {
            e.exports = '<mat-toolbar color="primary">\n    <span class="dialog-title"> {{ dialogTitle }} </span>\n    <button mat-icon-button [disabled]="processing" (click)="cancel()">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content (window:resize)="onWindowResize($event)">\n    <mat-drawer-container hasBackdrop="false">\n        <mat-drawer #drawer mode="over" position="end" class="webhook-instructions-drawer">\n            <div class="instructions-header">\n                <span class="bold"> {{ msgs.webhookInstructions() }} </span>\n\n                <button mat-icon-button (click)="drawer.close()">\n                    <i class="fa fa-times"></i>\n                </button>\n            </div>\n\n            <div class="instructions-container" [innerHtml]="msgs.webhookUsageInstructions()"></div>\n        </mat-drawer>\n\n        <mat-drawer-content>\n            <mat-stepper (animationDone)="onStepperAnimationComplete()" (selectionChange)="onStepperStepChange($event)" class="width-100" [selectedIndex]="dialogData.subscription === undefined ? 0 : 4" [linear]="true" #stepper>\n                \x3c!-- Step 1 - Type --\x3e\n                <mat-step label="{{ msgs.type() }}" [completed]="formType.value !== null">\n                    <div id="step-type">\n                        <div class="type-container">\n                            <div class="type-options-container">\n                                <mat-card class="type-option onvif mat-elevation-z5" (click)="selectEventType(\'onvif\')">\n                                    <tag [type]="\'onvif\'" [label]="msgs.onvif()"></tag>\n                                    <div class="type-description">{{ msgs.subscribeToAnOnvifEvent() }}</div>\n                                </mat-card>\n                                <mat-card class="type-option external mat-elevation-z5" (click)="selectEventType(\'external\')">\n                                    <tag [type]="\'external\'" [label]="msgs.external()"></tag>\n                                    <div class="type-description">{{ msgs.subscribeToAnExternalEvent() }}</div>\n                                </mat-card>\n                            </div>\n                        </div>\n                    </div>\n                </mat-step>\n\n                \x3c!-- Step 2 - Information --\x3e\n                <mat-step #informationStep label="{{ msgs.information() }}" editable [completed]="!formIsInvalid">\n                    <div id="step-information">\n                        <form [formGroup]="subscriptionForm">\n                            <div class="name-and-category-container" [class.wide-field]="formType.value === \'external\'">\n                                \x3c!-- Name Input --\x3e\n                                <mat-form-field class="name-field" [class.wide-field]="formType.value === \'external\'">\n                                    <mat-label> {{ msgs.subscriptionName() }} </mat-label>\n                                    <input matInput placeholder="{{msgs.enterSubscriptionName()}}" formControlName="name" id="formFocus1" required>\n                                    <mat-error> {{ msgs.nameIsRequired() }} </mat-error>\n                                </mat-form-field>\n\n                                \x3c!-- Category Selector --\x3e\n                                <mat-form-field class="category-field" [class.wide-field]="formType.value === \'external\'">\n                                    <mat-label> {{ msgs.category() }} </mat-label>\n                                    <mat-select formControlName="category" required>\n                                        <mat-option *ngFor="let categoryOption of dialogData.eventCategories" [value]="categoryOption">\n                                            <orchid-event-category [category]="categoryOption"></orchid-event-category>\n                                        </mat-option>\n                                    </mat-select>\n                                    <mat-error> {{ msgs.categoryIsRequired() }} </mat-error>\n                                </mat-form-field>\n                            </div>\n\n                            \x3c!-- ONVIF source camera selector --\x3e\n                            <div *ngIf="formType.value === \'onvif\'" class="source-camera-container">\n                                <div class="source-camera-header">\n                                    <div>{{ msgs.sourceCamera() }}</div>\n                                    <i class="fa fa-question-circle" matTooltip="{{ msgs.theSelectedCameraWillEmitAnOnvifEventWheneverTheOnvifTopicCriteriaIsMet() }}" [matTooltipPosition]="\'above\'"></i>\n                                </div>\n\n                                <orchid-camera-picker [orchid]="dialogData.orchid" [cameras]="onvifCamerasMetadata" [pageSizeOptions]="pageSizeOptions" [pageSize]="pageSize" [selectedCameras]="selectedSourceCamera" [multiSelect]="false" (cameraSelected)="onPrimaryCameraSelected($event)"></orchid-camera-picker>\n                            </div>\n\n                            <div class="onvif-topic-selector-container" *ngIf="formType.value === \'onvif\'">\n                                \x3c!-- ONVIF Topic Selector --\x3e\n                                <mat-form-field class="onvif-topic-selector">\n                                    <mat-label> {{ msgs.onvifTopic() }} </mat-label>\n                                    <mat-select formControlName="onvifTopic" required matTooltip="{{ formOnvifTopic.value | onvifTopic }}" matTooltipClass="add-edit-subscription-dialog-onvif-topic-custom-tooltip-class" matTooltipShowDelay="800">\n                                        <mat-option *ngFor="let topic of selectedCameraOnvifTopics" [value]="topic">\n                                            {{ topic | onvifTopic }}\n                                        </mat-option>\n                                    </mat-select>\n                                    <mat-error> {{ msgs.onvifTopicIsRequired() }} </mat-error>\n                                </mat-form-field>\n                            </div>\n                        </form>\n                        <tag-editor *ngIf="supportsResourceTagging" [existingTags]="existingTags" [newTags]="newTags" [resourceType]="ResourceType.EVENT_SUBSCRIPTION" [tags]="tags" [orchid]="dialogData.orchid"></tag-editor>\n                    </div>\n                </mat-step>\n\n                \x3c!-- Step 3 - Associated Cameras --\x3e\n                <mat-step #associatedCamerasStep editable optional>\n                    <div id="step-associated-cameras">\n                        <ng-template matStepLabel>\n                            <div class="show-gt-850">{{ msgs.associatedCameras() }}</div>\n                            <div class="hide-gt-850">{{ msgs.cameras() }}</div>\n                        </ng-template>\n                        <div class="associated-cameras-instructions">{{ msgs.associatedCamerasInstructions() }}</div>\n\n                        <orchid-camera-picker [orchid]="dialogData.orchid" [cameras]="allCamerasMetadata" [pageSizeOptions]="pageSizeOptions" [pageSize]="pageSize" [selectedCameras]="associatedCamerasMetadata" (cameraSelected)="onAssociatedCameraSelected($event)"></orchid-camera-picker>\n                    </div>\n                </mat-step>\n\n                \x3c!-- Step 4 - Review --\x3e\n                <mat-step #reviewStep label="{{ msgs.review() }}">\n                    <div id="step-review">\n                        <ng-container *ngTemplateOutlet="viewEditTemplate"></ng-container>\n                    </div>\n                </mat-step>\n\n                \x3c!-- Hidden view-only step --\x3e\n                <mat-step>\n                    <div id="step-summary">\n                        <ng-container *ngTemplateOutlet="viewEditTemplate"></ng-container>\n                    </div>\n                </mat-step>\n\n                <ng-template #viewEditTemplate>\n                    <tag class="event-summary-tag" [type]="formType.value === \'onvif\' ? \'onvif\' : \'external\'" [label]="formType.value === \'onvif\' ? msgs.onvif() : msgs.external()"></tag>\n                    <mat-card class="review-section information-section mat-elevation-z0">\n                        <div class="review-section-header">\n                            <span class="bold"> {{ msgs.information() }} </span>\n                            <button class="edit-button" mat-icon-button *ngIf="currentStepperStep === 4" (click)="navigateStepper(1)" matTooltip="{{msgs.edit()}}" [matTooltipShowDelay]="800" [matTooltipPosition]="\'above\'">\n                                <i class="fa-solid fa-pencil"></i>\n                            </button>\n                        </div>\n\n                        <div class="summary-table">\n                            \x3c!-- Name --\x3e\n                            <div class="summary-row name">\n                                <div class="field-column">\n                                    <span>{{ msgs.name() }}</span>\n                                </div>\n                                <div class="data-column">\n                                    <span>{{ formName.value === undefined ? \'\' : formName.value }}</span>\n                                </div>\n                            </div>\n\n                            \x3c!-- Category --\x3e\n                            <div class="summary-row category">\n                                <div class="field-column">\n                                    <span>{{ msgs.category() }}</span>\n                                </div>\n                                <div class="data-column">\n                                    <orchid-event-category [category]="formCategory.value"> </orchid-event-category>\n                                </div>\n                            </div>\n\n                            \x3c!-- Tags --\x3e\n                            <div class="summary-row tags" *ngIf="supportsResourceTagging && existingAndNewTags.length > 0">\n                                <div class="field-column">\n                                    <span>{{ msgs.eventSubscriptionTags() }}</span>\n                                </div>\n                                <div class="data-column">\n                                    <resource-tag-list [tags]="existingAndNewTags"></resource-tag-list>\n                                </div>\n                            </div>\n\n                            \x3c!-- Source Camera --\x3e\n                            <div class="summary-row source-camera" *ngIf="formType.value === \'onvif\'">\n                                <div class="field-column">\n                                    <span>{{ msgs.sourceCamera() }}</span>\n                                </div>\n                                <div class="data-column">\n                                    <span>\n                                        {{ formCamera.value === null || formCamera.value === undefined ?\n                                        msgs.noneSelected() : formCamera.value.cameraName }}\n                                    </span>\n                                </div>\n                            </div>\n\n                            \x3c!-- ONVIF Topic --\x3e\n                            <div class="summary-row onvif-topic" *ngIf="formType.value === \'onvif\'">\n                                <div class="field-column">\n                                    <span>{{ msgs.onvifTopic() }}</span>\n                                </div>\n                                <div class="data-column">\n                                    <span class="onvif-topic-text">{{ formOnvifTopic.value === null ? \'\' : formOnvifTopic.value | onvifTopic\n                                        }}</span>\n                                </div>\n                            </div>\n\n                            \x3c!-- Webhook URL --\x3e\n                            <div class="summary-row webhook-url" *ngIf="formType.value === \'external\'">\n                                <div class="field-column">\n                                    <span>{{ msgs.webhookApiUrl() }}</span>\n                                    <button class="edit-button medium-icon-button" mat-icon-button (click)="drawer.toggle()">\n                                        <i class="fa-solid fa-circle-question"></i>\n                                    </button>\n                                </div>\n                                <div class="data-column">\n                                    <span class="external-event-url-text">{{ externalEventUrl }}</span>\n                                    <button matSuffix mat-icon-button class="copy-url-button" disableRipple="true" *ngIf="dialogData.subscription !== undefined" #copiedTooltip="matTooltip" matTooltip [matTooltipPosition]="\'above\'" (click)="copyUrlToClipboard(copiedTooltip)">\n                                        <i class="fa-regular" [class.fa-copy]="copyUrlSuccess === undefined" [ngClass]="{\'fa-check success-text\': copyUrlSuccess === true}" [ngClass]="{\'fa-times fail-text\': copyUrlSuccess === false}"></i>\n                                    </button>\n                                </div>\n                            </div>\n                        </div>\n                    </mat-card>\n\n                    <mat-card class="review-section associated-cameras-container mat-elevation-z0">\n                        <div class="review-section-header">\n                            <span class="bold"> {{ msgs.associatedCameras() }} </span>\n                            <button class="edit-button" mat-icon-button *ngIf="currentStepperStep === 4" (click)="navigateStepper(2)" matTooltip="{{msgs.edit()}}" [matTooltipShowDelay]="800" [matTooltipPosition]="\'above\'">\n                                <i class="fa-solid fa-pencil"></i>\n                            </button>\n                        </div>\n\n                        <orchid-camera-picker *ngIf="associatedCamerasMetadata.length > 0" [orchid]="dialogData.orchid" [cameras]="associatedCamerasMetadata" [pageSizeOptions]="pageSizeOptions" [pageSize]="pageSize" [viewOnly]="true"></orchid-camera-picker>\n\n                        <div *ngIf="associatedCamerasMetadata.length === 0" class="hint-text no-associated-cameras-message">\n                            {{ msgs.noAssociatedCamerasWereSelected() }}\n                        </div>\n                    </mat-card>\n                </ng-template>\n\n                \x3c!-- Icon Overrides -  \n            Angular material stepper steps use angular material icons so we need\n            to override them with our own font awesome icons\n        --\x3e\n                <ng-template matStepperIcon="edit">\n                    <i class="fa-solid fa-pencil downscaled-icon"></i>\n                </ng-template>\n                <ng-template matStepperIcon="error">\n                    <i class="fa fa-exclamation-triangle downscaled-icon"></i>\n                </ng-template>\n                <ng-template matStepperIcon="done" let-index="index">\n                    <i class="fa-regular fa-check downscaled-icon"></i>\n                </ng-template>\n                <ng-template matStepperIcon="number" let-index="index"> {{ index }} </ng-template>\n            </mat-stepper>\n        </mat-drawer-content>\n    </mat-drawer-container>\n</mat-dialog-content>\n\n<sing-dialog-errors *ngIf="error !== undefined" [errmsg]="error" [canClose]="true" (onClose)="error = undefined"></sing-dialog-errors>\n\n<mat-dialog-actions *ngIf="currentStepperStep !== 0">\n    <button *ngIf="currentStepperStep !== 4 && currentStepperStep !== 1" [disabled]="processing" mat-raised-button (click)="stepper.previous()">\n        {{ msgs.back() }}\n    </button>\n\n    <button mat-button (click)="cancel()" *ngIf="currentStepperStep === 4">{{ msgs.ok() }}</button>\n\n    <button *ngIf="currentStepperStep === 3; else stepperButtonNext" mat-raised-button color="primary" [disabled]="processing || formIsInvalid" (click)="saveSubscription()">\n        <div [ngStyle]="{\'visibility\': processing ? \'hidden\' : \'visible\'}">{{ msgs.saveSubscription() }}</div>\n\n        <mat-spinner class="processing-spinner" *ngIf="processing; else notProcessing" mode="indeterminate" diameter="25"></mat-spinner>\n    </button>\n\n    <ng-template #stepperButtonNext>\n        <button *ngIf="currentStepperStep !== 3 && currentStepperStep !== 4" mat-raised-button color="primary" [disabled]="formIsInvalid" (click)="stepper.next()">\n            {{ msgs.next() }}\n        </button>\n    </ng-template>\n</mat-dialog-actions>\n'
        }
        ,
        53071: e => {
            e.exports = '<section class="external-events-manager-page dashboard-section">\n    <navigation class="dashboard-navigation" display="left"></navigation>\n\n    <div class="page-content">\n        \x3c!-- Loading Spinner --\x3e\n        <div *ngIf="loadingOrchidsPromise === ComponentState.Loading" class="loading-event-subscriptions-container">\n            <page-loading [progress]="msgs.loadingEventSubscriptions()"></page-loading>\n        </div>\n\n        \x3c!-- Error Message --\x3e\n        <div *ngIf="loadingOrchidsPromise === ComponentState.Failed" class="failed-to-load-message">\n            {{ msgs.failedToLoadEventSubscriptions() }}\n        </div>\n\n        \x3c!-- Loaded Content --\x3e\n        <div *ngIf="loadingOrchidsPromise === ComponentState.Loaded" [ngClass]="{ \'no-servers\': !checkServers() }">\n            <div *ngIf="checkServers(); else noServers" class="external-events-manager-content">\n                <div class="title-container">\n                    <h1 class="title-text">{{ msgs.eventSubscriptions() }}</h1>\n                    <button mat-raised-button color="primary" class="add-button new-event-button" (click)="addEvent()" [disabled]="\n                            !orchidSelected || loadingSubscriptionData !== ComponentState.Loaded || eventLoading\n                        ">\n                        <span class="show-gt-420">{{ msgs.new() + \' \' }}</span>\n                        <span>{{ msgs.subscription() }}</span>\n                    </button>\n                </div>\n\n                <div class="orchid-selector-container" *ngIf="!isOrchid">\n                    <orchid-selector [orchids]="orchids" (onSelectedOrchid)="onOrchidSelected($event)" [collapsible]="false" [requiredVersion]="minimumVersionFeature"></orchid-selector>\n                </div>\n\n                <div *ngIf="loadingOrchidsPromise === ComponentState.Loaded && !orchidSelected" class="centered-gray-text">\n                    {{ msgs.selectAnAPPNAMEServerToConfigureItsEventSubscriptions() }}\n                </div>\n\n                <div *ngIf="loadingSubscriptionData === ComponentState.Loading; else loadedSubscriptionContent" class="spinner-and-loading-message">\n                    <mat-spinner diameter="25" color="primary" mode="indeterminate"></mat-spinner>\n                    <span>\n                        {{ msgs.loadingSubscriptionData() }}\n                    </span>\n                </div>\n\n                <ng-template #loadedSubscriptionContent>\n                    \x3c!-- Something went wrong --\x3e\n                    <error-banner *ngIf="loadingSubscriptionData === ComponentState.Failed" type="generic-error"></error-banner>\n\n                    \x3c!-- No Subscriptions --\x3e\n                    <div *ngIf="orchidSelected && !hasSubscriptions()" class="no-matches-error-message">\n                        <span *ngIf="loadingSubscriptionData === ComponentState.Failed; else noTableData">\n                            {{\n                                msgs.failedToLoadSubscriptionDataForVALUE({\n                                    VALUE: isOrchid ? \'Orchid Hybrid VMS\' : orchid.name\n                                })\n                            }}\n                        </span>\n                        <ng-template #noTableData>\n                            {{ msgs.noSubscriptionsHaveBeenConfigured() }}\n                        </ng-template>\n                    </div>\n\n                    \x3c!-- Search/Filters Tools--\x3e\n                    <mat-card class="search-tools-card" *ngIf="loadingSubscriptionData !== ComponentState.Failed && orchidSelected && events.length > 0">\n                        <div class="search-tools-container">\n                            \x3c!-- Searchbar --\x3e\n                            <mat-form-field class="searchbar-container">\n                                <mat-label>{{ this.msgs.searchSubscriptions() }}</mat-label>\n                                <input matInput (keyup)="handleSearchKeyUp($event)" autocapitalize="none">\n                            </mat-form-field>\n\n                            \x3c!-- Filter buttons --\x3e\n                            <div class="filter-buttons-container">\n                                \x3c!-- TYPES --\x3e\n                                <filter-button-menu [filters]="eventTypeFilters" [filterLabel]="this.msgs.type()" (addFilter)="onAddFilter($event)" (removeFilter)="onRemoveFilter($event)"></filter-button-menu>\n\n                                \x3c!-- CATEGORIES --\x3e\n                                <filter-button-menu [filters]="eventCategoryFilters" [filterLabel]="this.msgs.category()" (addFilter)="onAddFilter($event)" (removeFilter)="onRemoveFilter($event)"></filter-button-menu>\n\n                                \x3c!-- TAGS --\x3e\n                                <filter-button-menu [filters]="eventTagFilters" [filterLabel]="this.msgs.tag()" (addFilter)="onAddFilter($event)" (removeFilter)="onRemoveFilter($event)"></filter-button-menu>\n                            </div>\n                        </div>\n                        <div *ngIf="activeFilters.length > 0" class="active-filters-container">\n                            <filter-chip *ngFor="let filter of activeFilters; let filterIndex = index" [filter]="filter" (onRemove)="removeFilter(filterIndex)"></filter-chip>\n                            <button class="filters-reset-button body-small mat-delete" matRipple (click)="removeAllFilters()">\n                                {{ this.msgs.reset() }}\n                            </button>\n                        </div>\n                    </mat-card>\n\n                    \x3c!-- Table --\x3e\n                    <div *ngIf="tableData.data.length > 0 && orchidSelected" class="mat-elevation-z1 subscriptions-table-container">\n                        <table #subscriptionTable *ngIf="\n                                loadingSubscriptionData !== ComponentState.Failed\n                            " mat-table matSort (matSortChange)="onSortChange($event)" [dataSource]="tableData" [matSortActive]="defaultSort.id" [matSortDirection]="defaultSort.start" [matSortDisableClear]="defaultSort.disableClear" class="external-events-table orchid-table interactive">\n                            \x3c!-- Name --\x3e\n                            <ng-container [matColumnDef]="TableColumns.NAME">\n                                <th mat-header-cell mat-sort-header *matHeaderCellDef>{{ msgs.name() }}</th>\n                                <td mat-cell *matCellDef="let event" matTooltip="{{ event.name }}" matTooltipPosition="below" matTooltipShowDelay="800">\n                                    <span class="event-name">{{ event.name }}</span>\n                                    <resource-tag-list *ngIf="event.tags && event.tags.length > 0" [tags]="event.tags" [maxTagsVisible]="MIN_TAG_LIST_LENGTH"></resource-tag-list>\n                                </td>\n                            </ng-container>\n\n                            \x3c!-- Category --\x3e\n                            <ng-container [matColumnDef]="TableColumns.CATEGORY">\n                                <th mat-header-cell mat-sort-header *matHeaderCellDef>{{ msgs.category() }}</th>\n                                <td mat-cell *matCellDef="let event">\n                                    <orchid-event-category [category]="{\n                                            id: event.categoryId,\n                                            name: eventCategoryIndex[event.categoryId].name,\n                                            translatedName: eventCategoryIndex[event.categoryId].translatedName\n                                        }">\n                                    </orchid-event-category>\n                                </td>\n                            </ng-container>\n\n                            \x3c!-- Type --\x3e\n                            <ng-container [matColumnDef]="TableColumns.TYPE">\n                                <th mat-header-cell mat-sort-header *matHeaderCellDef>{{ msgs.type() }}</th>\n                                <td mat-cell *matCellDef="let event" matTooltip="{{ msgs.subscriptionID({ ID: event.id }) }}" matTooltipPosition="below" matTooltipShowDelay="800">\n                                    <tag [type]="event.type" [label]="event.type === \'onvif\' ? msgs.onvif() : msgs.external()"></tag>\n                                </td>\n                            </ng-container>\n\n                            \x3c!-- Linked Cameras --\x3e\n                            <ng-container [matColumnDef]="TableColumns.CAMERAS">\n                                <th mat-header-cell mat-sort-header *matHeaderCellDef>{{ msgs.cameras() }}</th>\n                                <td mat-cell *matCellDef="let event">\n                                    <icon-total class="" [icon]="\'fa-video-camera\'" [number]="event.associatedCameraIds.length"></icon-total>\n                                </td>\n                            </ng-container>\n\n                            \x3c!-- ONVIF Topic --\x3e\n                            <ng-container [matColumnDef]="TableColumns.TOPIC">\n                                <th mat-header-cell mat-sort-header *matHeaderCellDef>{{ msgs.onvifTopic() }}</th>\n                                <td mat-cell *matCellDef="let event" matTooltip="{{ event.onvifTopic === null ? \'\' : (event.onvifTopic | onvifTopic) }}" matTooltipClass="add-edit-subscription-dialog-onvif-topic-custom-tooltip-class" matTooltipPosition="below" matTooltipShowDelay="800">\n                                    {{ event.onvifTopic === null ? \'--\' : (event.onvifTopic | onvifTopic) }}\n                                </td>\n                            </ng-container>\n\n                            \x3c!-- Delete Button --\x3e\n                            <ng-container [matColumnDef]="TableColumns.DELETE">\n                                <th mat-header-cell *matHeaderCellDef></th>\n                                <td mat-cell *matCellDef="let event">\n                                    <button mat-icon-button [disableRipple]="true" (click)="deleteSubscription(event, $event)">\n                                        <i class="fa-solid fa-trash-can"></i>\n                                    </button>\n                                </td>\n                            </ng-container>\n\n                            <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>\n                            <tr mat-row *matRowDef="let externalEventRow; columns: displayedColumns" (click)="editSubscription(externalEventRow)"></tr>\n                        </table>\n\n                        <mat-paginator *ngIf="tableData.data.length > pageSize" class="table-paginator" showFirstLastButtons [pageSizeOptions]="pageSizeOptions" [pageSize]="pageSize" [length]="tableData.data.length"></mat-paginator>\n                    </div>\n\n                    <ng-container *ngIf="tableData.data.length === 0 && orchidSelected">\n                        <error-banner *ngIf="hasSubscriptions()" [type]="\'empty-search-filters\'"></error-banner>\n                    </ng-container>\n                </ng-template>\n            </div>\n\n            <ng-template #noServers>\n                <div class="orchid-selector-hint-container">\n                    <i class="fa fa-server"></i>\n                    <div class="message-section">\n                        <span class="hint-text">{{ msgs.noServersConfigured() }}</span>\n                        <a class="text-link" href="#!/orchids" *ngIf="isAdmin">{{ msgs.registerAServer() }}</a>\n                    </div>\n                </div>\n            </ng-template>\n        </div>\n    </div>\n</section>\n'
        }
        ,
        74634: e => {
            e.exports = '<div class="event-details" *ngIf="event">\n    <div>\n        <h3>{{ event.name }}</h3>\n        <span class="datetime-label">{{ event.eventTime | date: \'MMM d, y, HH:mm:ss\' }}</span>\n    </div>\n    <div class="camera-thumbnails-container" *ngIf="event.cameras.length > 0">\n        <div class="camera-thumbnail" [ngClass]="{ selected: camera.id === event.selectedCamera.id }" (click)="handleSelectCamera.emit(camera)" *ngFor="let camera of cameras">\n            <sing-image-loader [src]="camera.thumbnail" class="tiny-thumbnail" [disabled]="!cameraIsEnabled(camera)"></sing-image-loader>\n        </div>\n    </div>\n\n    <div class="event-sub-details">\n        <orchid-event-category [category]="event.category"></orchid-event-category>\n        <tag [type]="event.type === \'onvif\' ? \'onvif\' : \'external\'"></tag>\n    </div>\n\n    <div class="event-information">\n        <mat-list class="field-list">\n            <div class="event-ids-container">\n                <mat-list-item class="field-list-item">\n                    <span matLine class="label">\n                        {{ msgs.eventId() }}\n                    </span>\n                    <span matLine class="information">\n                        {{ event.eventId }}\n                    </span>\n                </mat-list-item>\n                <mat-list-item class="field-list-item">\n                    <span matLine class="label">\n                        {{ msgs.subscriptionId() }}\n                    </span>\n                    <span matLine class="information">\n                        {{ event.subscriptionId }}\n                    </span>\n                </mat-list-item>\n            </div>\n            <mat-list-item class="field-list-item">\n                <span matLine class="label">\n                    {{ getEventSourceLabelText(event.type) }}\n                </span>\n                <span matLine class="information event-source-text">\n                    {{ event.source | onvifTopic }}\n                </span>\n            </mat-list-item>\n        </mat-list>\n    </div>\n\n    <mat-list-item class="field-list-item" *ngIf="event.details">\n        <span matLine class="label">\n            {{ msgs.eventDetails() }}\n        </span>\n        <mat-list>\n            <code class="event-details-data">\n                <stats-for-nerds [value]="event.details" [expandAll]="true"></stats-for-nerds>\n            </code>\n        </mat-list>\n    </mat-list-item>\n</div>\n'
        }
        ,
        81896: e => {
            e.exports = '\x3c!-- Dialog Header --\x3e\n<mat-toolbar color="primary" class="edit-password-dialog-toolbar">\n    \x3c!-- Title --\x3e\n    <span mat-dialog-title class="dialog-title">{{ msgs.selectDateRange() }}</span>\n\n    \x3c!-- Close Button --\x3e\n    <button mat-icon-button mat-dialog-close disableRipple="true" tabindex="-1">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content>\n    <mat-calendar [maxDate]="maxDate" [selected]="selectedRangeValue" (selectedChange)="selectedChange($event)">\n    </mat-calendar>\n    <div class="time-pickers-container">\n        <div class="time-picker">\n            <mat-form-field class="date-form-field" appearance="fill">\n                <mat-label>{{ msgs.from() }}</mat-label>\n                <input disabled="disabled" matInput [value]="getStartDateLabel()">\n            </mat-form-field>\n            <time-inputs [group]="startTimeFG" (isTimeInputsValid)="isStartTimeInputValid($event)"></time-inputs>\n        </div>\n        <div class="time-picker" [ngClass]="{\'mat-error\': !isDateTimeRangeValid()}">\n            <mat-form-field class="date-form-field" appearance="fill">\n                <mat-label>{{ msgs.to() }}</mat-label>\n                <input disabled="disabled" matInput [value]="getEndDateLabel()">\n            </mat-form-field>\n            <time-inputs [group]="endTimeFG" (isTimeInputsValid)="isEndTimeInputValid($event)">\n            </time-inputs>\n            <div class="end-time-error" *ngIf="!isDateTimeRangeValid()">{{ msgs.mustBeAValidDateRange() }}</div>\n        </div>\n    </div>\n</mat-dialog-content>\n\n\x3c!-- Dialog Buttons --\x3e\n<mat-dialog-actions align="end">\n    <button mat-button (click)="onCancelClick()">{{ msgs.cancel() }}</button>\n    <button id="okButton" mat-raised-button color="primary" (click)="onOkClick()" [disabled]="!isDateTimeRangeValid()">{{ msgs.ok() }}</button>\n</mat-dialog-actions>\n'
        }
        ,
        24490: e => {
            e.exports = '<div class="events-filters-menu">\n    <form [formGroup]="filtersForm">\n        <mat-accordion class="filters-container" [displayMode]="flat" multi hideToggle>\n            \x3c!-- Event Name filter section --\x3e\n            <mat-expansion-panel #eventNameFiltersPanel class="mat-elevation-z0">\n                <mat-expansion-panel-header>\n                    <mat-panel-title>\n                        <h5 [matBadge]="eventNameSearchTerms.length" [matBadgeHidden]="eventNameSearchTerms.length === 0">\n                            {{ msgs.filterByEventNames() }}\n                        </h5>\n                    </mat-panel-title>\n                    <mat-panel-description>\n                        <i class="fa-regular fa-chevron-right" [class.fa-rotate-90]="eventNameFiltersPanel.expanded"></i>\n                    </mat-panel-description>\n                </mat-expansion-panel-header>\n\n                <div class="menu-item event-name-menu">\n                    <mat-form-field appearance="standard" class="event-name-form-field">\n                        <mat-chip-list #eventNameChipList>\n                            <mat-chip *ngFor="let eventNameSearchTerm of eventNameSearchTerms" selectable="false" removable="true" (removed)="onSearchTermRemoved(eventNameSearchTerm, \'event\')">\n                                <span>{{eventNameSearchTerm}}</span>\n                                <i class="fa-solid fa-circle-xmark" matChipRemove></i>\n                            </mat-chip>\n                            <input matInput placeholder="{{ msgs.eventName() }}" [matChipInputFor]="eventNameChipList" [matChipInputSeparatorKeyCodes]="separatorKeysCodes" [matChipInputAddOnBlur]="true" (matChipInputTokenEnd)="onSearchTermAdded($event, \'event\')">\n                        </mat-chip-list>\n                    </mat-form-field>\n                </div>\n            </mat-expansion-panel>\n\n            \x3c!-- Event Category filter section --\x3e\n            <mat-expansion-panel #categoryFiltersPanel class="mat-elevation-z0">\n                <mat-expansion-panel-header>\n                    <mat-panel-title>\n                        <h5 [matBadge]="filtersForm.value.selectedCategories.length" [matBadgeHidden]="filtersForm.value.selectedCategories.length === 0">\n                            {{ msgs.filterByCategories() }}\n                        </h5>\n                    </mat-panel-title>\n                    <mat-panel-description>\n                        <i class="fa-regular fa-chevron-right" [class.fa-rotate-90]="categoryFiltersPanel.expanded"></i>\n                    </mat-panel-description>\n                </mat-expansion-panel-header>\n                <div class="menu-item categories-menu">\n                    <mat-form-field appearance="standard" class="categories-form-field">\n                        <mat-label>{{ msgs.categories() }}</mat-label>\n                        <mat-select multiple="multiple" formControlName="selectedCategories" panelClass="events-filters-categories-custom-select-panel-class">\n                            <mat-option *ngFor="let option of categories" [value]="option">\n                                <orchid-event-category class="categories-filter-menu" [category]="option"></orchid-event-category>\n                            </mat-option>\n                        </mat-select>\n                    </mat-form-field>\n                </div>\n            </mat-expansion-panel>\n\n            \x3c!-- Camera name filter section --\x3e\n            <mat-expansion-panel #cameraFiltersPanel class="mat-elevation-z0">\n                <mat-expansion-panel-header>\n                    <mat-panel-title>\n                        <h5 [matBadge]="cameraNameSearchTerms.length" [matBadgeHidden]="cameraNameSearchTerms.length === 0">\n                            {{ msgs.filterByCameras() }}\n                        </h5>\n                    </mat-panel-title>\n                    <mat-panel-description>\n                        <i class="fa-regular fa-chevron-right" [class.fa-rotate-90]="cameraFiltersPanel.expanded"></i>\n                    </mat-panel-description>\n                </mat-expansion-panel-header>\n\n                <div class="menu-item event-name-menu">\n                    <mat-form-field appearance="standard" class="event-name-form-field">\n                        <mat-chip-list #cameraNameChipList>\n                            <mat-chip *ngFor="let cameraNameSearchTerm of cameraNameSearchTerms" selectable="false" removable="true" (removed)="onSearchTermRemoved(cameraNameSearchTerm, \'camera\')">\n                                <span>{{cameraNameSearchTerm}}</span>\n                                <i class="fa-solid fa-circle-xmark" matChipRemove></i>\n                            </mat-chip>\n                            <input matInput placeholder="{{ msgs.cameraName() }}" [matChipInputFor]="cameraNameChipList" [matChipInputSeparatorKeyCodes]="separatorKeysCodes" [matChipInputAddOnBlur]="true" (matChipInputTokenEnd)="onSearchTermAdded($event, \'camera\')">\n                        </mat-chip-list>\n                    </mat-form-field>\n                </div>\n\n            </mat-expansion-panel>\n\n            \x3c!-- Date filter section --\x3e\n            <mat-expansion-panel #dateFiltersPanel class="mat-elevation-z0">\n                <mat-expansion-panel-header>\n                    <mat-panel-title>\n                        <h5 [matBadge]="dateFilterOptionSelected ? 1 : 0" [matBadgeHidden]="!dateFilterOptionSelected">\n                            {{ msgs.filterByDate() }}\n                        </h5>\n                    </mat-panel-title>\n                    <mat-panel-description>\n                        <i class="fa-regular fa-chevron-right" [class.fa-rotate-90]="dateFiltersPanel.expanded"></i>\n                    </mat-panel-description>\n                </mat-expansion-panel-header>\n\n                <mat-radio-group formControlName="selectedDateFilter">\n                    <mat-radio-button [value]="option.id" class="menu-item" *ngFor="let option of dateFilterOptions" (click)="handleDateRadioButtonClick(option)">\n                        <span *ngIf="option.id !== \'DATE_RANGE\'; else datePicker">{{option.label}}</span>\n\n                        <ng-template #datePicker>\n                            <div class="date-range-menu-item">\n                                <div class="date-range-button">{{ selectedDateRange.start.label }}</div> - <div class="date-range-button">{{ selectedDateRange.end.label }}</div>\n                            </div>\n                        </ng-template>\n\n                    </mat-radio-button>\n                </mat-radio-group>\n            </mat-expansion-panel>\n\n            \x3c!-- Status filter section --\x3e\n            <mat-expansion-panel #statusFiltersPanel class="mat-elevation-z0">\n                <mat-expansion-panel-header>\n                    <mat-panel-title>\n                        <h5 [matBadge]="eventStateFilters.length" [matBadgeHidden]="eventStateFilters.length === 0">\n                            {{ msgs.filterByState() }}\n                        </h5>\n                    </mat-panel-title>\n                    <mat-panel-description>\n                        <i class="fa-regular fa-chevron-right" [class.fa-rotate-90]="statusFiltersPanel.expanded"></i>\n                    </mat-panel-description>\n                </mat-expansion-panel-header>\n\n                <div class="status-slide-toggle-container">\n                    <mat-slide-toggle #activeToggle class="menu-item" (change)="onStatusToggleChange($event, \'active\')"> {{ msgs.active() }} </mat-slide-toggle>\n\n                    <mat-slide-toggle #inactiveToggle class="menu-item" (change)="onStatusToggleChange($event, \'inactive\')"> {{ msgs.inactive() }} </mat-slide-toggle>\n\n                    <mat-slide-toggle #nullToggle class="menu-item" (change)="onStatusToggleChange($event, \'no state\')"> {{ msgs.noState() }} </mat-slide-toggle>\n                </div>\n            </mat-expansion-panel>\n        </mat-accordion>\n        <div class="menu-item menu-footer">\n            <button mat-flat-button (click)="handleResetClick()">{{ msgs.reset() }}</button>\n            <button mat-flat-button color="primary" (click)="handleSearchClick()">{{ msgs.search() }}</button>\n        </div>\n    </form>\n</div>\n'
        }
        ,
        76241: e => {
            e.exports = '<mat-card *ngIf="state !== ComponentState.Failed && events.length > 0" class="table-container loaded">\n    <div class="table-card" #table>\n        <mat-table [dataSource]="events" matSort (matSortChange)="applySort($event)" [matSortActive]="sort.active" [matSortDirection]="sort.direction" matSortDisableClear class="orchid-table striped-table interactive">\n            \x3c!-- Event Name --\x3e\n            <ng-container matColumnDef="name">\n                <mat-header-cell *matHeaderCellDef>{{ msgs.event() }}</mat-header-cell>\n\n                <mat-cell *matCellDef="let event" class="name-cell">\n                    <span>{{ event.name }}</span>\n                </mat-cell>\n            </ng-container>\n\n            \x3c!-- Category --\x3e\n            <ng-container matColumnDef="category">\n                <mat-header-cell *matHeaderCellDef>{{ msgs.category() }}</mat-header-cell>\n\n                <mat-cell *matCellDef="let event" class="category-cell">\n                    <orchid-event-category [category]="event.category"></orchid-event-category>\n                </mat-cell>\n            </ng-container>\n\n            \x3c!-- Cameras --\x3e\n            <ng-container matColumnDef="camera">\n                <mat-header-cell *matHeaderCellDef>{{ msgs.cameras() }}</mat-header-cell>\n\n                <mat-cell *matCellDef="let event" class="cameras-cell">\n                    <span>{{ event.cameraNames | stringArrayFormatter:2 }}</span>\n                </mat-cell>\n            </ng-container>\n\n            \x3c!-- Date/Time --\x3e\n            <ng-container matColumnDef="eventtime">\n                <mat-header-cell *matHeaderCellDef mat-sort-header>{{ msgs.time() }}</mat-header-cell>\n\n                <mat-cell *matCellDef="let event" class="datetime-cell">\n                    <span class="datetime-label">{{ event.eventTime | date: \'MMM d, y, HH:mm:ss\'}}</span>\n                </mat-cell>\n            </ng-container>\n\n            \x3c!-- Active --\x3e\n            <ng-container matColumnDef="active">\n                <mat-header-cell *matHeaderCellDef>{{ msgs.state() }}</mat-header-cell>\n\n                <mat-cell *matCellDef="let event">\n                    <span>{{ event.active === true ? msgs.active() : event.active === false ? msgs.inactive() : msgs.none() }}</span>\n                </mat-cell>\n            </ng-container>\n\n            <ng-container matColumnDef="footer">\n                <td mat-footer-cell *matFooterCellDef>\n                    <table-indeterminate-footer [pageSize]="pageSize" [dataSource]="events" [showSpinner]="state === ComponentState.Loading" (moreClick)="more()"></table-indeterminate-footer>\n                </td>\n            </ng-container>\n\n            <mat-header-row *matHeaderRowDef="displayedColumns; sticky: true"></mat-header-row>\n            <mat-row id="{{row.id}}" [ngClass]="{selected: row === selectedEvent}" *matRowDef="let row; columns: displayedColumns;" (click)="onRowClick(row)"></mat-row>\n            <mat-footer-row *matFooterRowDef="[\'footer\']">\n            </mat-footer-row>\n\n        </mat-table>\n    </div>\n</mat-card>\n\n<div *ngIf="state === ComponentState.Loading" class="spinner-container">\n    <mat-spinner class="processing-spinner" mode="indeterminate" diameter="50">\n    </mat-spinner>\n</div>\n\n<div class="table-container empty" *ngIf="state === ComponentState.Failed">\n    <span class="no-matches-error-message">{{ errorMessage }}</span>\n</div>\n\n<div class="table-container empty" #empty *ngIf="state === ComponentState.Loaded && events.length === 0">\n    <span class="no-matches-error-message">{{ msgs.noEventsFound() }}</span>\n</div>\n\n\n<div class="top-container">\n    <button mat-mini-fab color="primary" *ngIf="events.length >= 0" (click)="top()">\n        <i class="fa-solid fa-arrow-up-to-line"></i>\n    </button>\n</div>\n'
        }
        ,
        39280: e => {
            e.exports = '<div (window:resize)="onResize()" class="events-viewer" [ngClass]="{ \'first-viewing\': firstViewing, loading: !pageReady }">\n    \x3c!-- Loader for fetching orchids --\x3e\n    <div *ngIf="!isOrchid && !orchids && !pageReady" class="orchids-loader-container">\n        <page-loading [progress]="msgs.loadingServers()"></page-loading>\n    </div>\n\n    \x3c!-- Loader for fetching data iframe player --\x3e\n    <div *ngIf="!iFrameReady" class="events-loader-container">\n        <page-loading [progress]="msgs.loadingEvents()"></page-loading>\n    </div>\n\n    \x3c!-- Events Viewer Available--\x3e\n    <div *ngIf="!pageUnavailable; else pageErrorContainer" class="events-viewer-content">\n        <as-split #sizer direction="vertical" (dragStart)="toggleSizerDragging()" (dragEnd)="toggleSizerDragging()" (contextmenu)="stopSizerDrag($event)">\n            \x3c!-- Player Section --\x3e\n            <as-split-area [size]="firstViewing ? 0 : 50" class="player-section">\n                <mat-drawer-container>\n                    \x3c!-- Player --\x3e\n                    <mat-drawer-content>\n                        <div class="player-container" [ngClass]="{ \'dragging-sizer\': draggingSizer, \'player-unavailable\': !checkValidPlayer() }" [style.visibility]="iFrameReady ? \'visible\' : \'hidden\'">\n                            <iframe-api-player [id]="selectedEvent?.eventId" [orchid]="orchid" [camera]="selectedEvent?.selectedCamera" [time]="selectedEvent?.eventTime" (onIFrameReady)="handleIFrameReady()"></iframe-api-player>\n                        </div>\n                        <div class="empty-player" *ngIf="!checkValidPlayer()">\n                            <i class="fa fa-video-camera"></i>\n                            <span class="empty-player-label">{{ msgs.noAssociatedCameras() }}</span>\n                        </div>\n\n                        <expand-button *ngIf="!!selectedEvent" class="event-details-expand-button" [expanded]="!detailsPanelDrawer?.opened" (click)="toggleDetailsPanel()" color="white" type="drawer"></expand-button>\n                    </mat-drawer-content>\n\n                    \x3c!-- Details Panel --\x3e\n                    <mat-drawer mode="side" position="end" opened class="details-panel-drawer" *ngIf="!!selectedEvent" #detailsPanelDrawer>\n                        <event-details [orchid]="orchid" [event]="selectedEvent" (handleSelectCamera)="setSelectedCamera($event)"></event-details>\n                    </mat-drawer>\n                </mat-drawer-container>\n            </as-split-area>\n\n            \x3c!-- Table Section --\x3e\n            <as-split-area [size]="firstViewing ? 100 : 50" [minSize]="25" class="table-section">\n                <mat-drawer-container>\n                    <mat-drawer *ngIf="orchid && orchidDataReady" #eventsFilterDrawer [mode]="drawerMode" [opened]="drawerMode === \'side\'" [disableClose]="drawerMode === \'side\'" class="events-filters-drawer" position="end">\n                        <events-filters [orchid]="orchid" [categories]="categories" [subscriptions]="subscriptions" (handleFiltersChanges)="onFiltersChanges($event)"></events-filters>\n                    </mat-drawer>\n\n                    \x3c!-- Table --\x3e\n                    <div *ngIf="checkServers(); else noServers" class="events-table-container" [ngClass]="{ \'empty-data\': !orchid, \'orchid-only\': isOrchid }">\n                        <div class="table-tools-container">\n                            <orchid-selector *ngIf="!isOrchid" [orchids]="orchids" [collapsible]="orchid" (onSelectedOrchid)="setSelectedOrchid($event)" [requiredVersion]="minimumVersionFeature"></orchid-selector>\n                            <div *ngIf="orchid" class="group-refresh-and-filters">\n                                <button *ngIf="!filterOptions.isDateRange; else refreshUnavailable" mat-mini-fab color="primary" (click)="refreshEvents(); numNewEvents = 0" [matBadge]="numNewEventsDisplay" [matBadgeHidden]="numNewEvents === 0" matBadgeColor="primary" matBadgeOverlap="true" [matTooltip]="\n                                        numNewEvents > 0\n                                            ? msgs.VALUENewEventsSinceLastRefresh({ VALUE: numNewEvents })\n                                            : \'\'\n                                    " matTooltipPosition="above">\n                                    <i class="fa-solid fa-arrows-rotate"></i>\n                                </button>\n                                <ng-template #refreshUnavailable>\n                                    <div #tooltip="matTooltip" [matTooltip]="msgs.refreshIsNotAvailable()" matTooltipPosition="left">\n                                        <button mat-mini-fab disabled="disabled">\n                                            <i class="fa-solid fa-arrows-rotate"></i>\n                                        </button>\n                                    </div>\n                                </ng-template>\n                                <button *ngIf="orchid && orchidDataReady && drawerMode === \'over\'" class="filters-button" [matBadge]="activeFilterCount" [matBadgeHidden]="activeFilterCount === 0" mat-raised-button data-testid="filters-menu" (click)="eventsFilterDrawer.toggle()" onclick="this.blur()">\n                                    <i class="fa fa-filter"></i>\n                                </button>\n                            </div>\n                        </div>\n\n                        <events-table *ngIf="orchid && orchidDataReady && iFrameReady" [orchids]="[orchid]" [subscriptions]="subscriptions" [filterOptions]="filterOptions" (handleEventSelect)="setSelectedEvent($event)"></events-table>\n\n                        <div *ngIf="!orchid" class="orchid-selector-hint-container">\n                            <i class="fa-kit fa-server-search"></i>\n                            <span class="hint-text">{{ msgs.selectAServer() }}</span>\n                        </div>\n                    </div>\n\n                    <ng-template #noServers>\n                        <div class="orchid-selector-hint-container no-servers-message">\n                            <i class="fa fa-server"></i>\n                            <div class="message-section">\n                                <span class="hint-text">{{ msgs.noServersConfigured() }}</span>\n                                <a class="text-link" href="#!/orchids" *ngIf="isAdmin">{{ msgs.registerAServer() }}</a>\n                            </div>\n                        </div>\n                    </ng-template>\n                </mat-drawer-container>\n            </as-split-area>\n        </as-split>\n    </div>\n\n    \x3c!-- Events Viewer is unavailable (for various reasons)--\x3e\n    <ng-template #pageErrorContainer>\n        <div class="events-error-container">\n            <error-banner type="generic-error">\n            </error-banner>\n        </div>\n\n\n    </ng-template>\n</div>\n'
        }
        ,
        17943: e => {
            e.exports = '<div class="orchid-event-category">\n    <i class="category-icon fa-{{ icon }}"></i>\n    <span class="category-label">{{ label }}</span>\n</div>\n'
        }
        ,
        81752: e => {
            e.exports = '<div class="selector-container" [ngClass]="{ collapsed: collapsed, \'full-width\': !collapsible }">\n    <mat-card>\n        <button mat-icon-button (click)="toggleContainerMode()" class="card-toggle-button">\n            <i class="fa-regular fa-chevron-down collapsed-icon"></i>\n            <i class="fa-kit fa-server-search server-icon"></i>\n        </button>\n        <mat-form-field class="server-form-field" floatLabel="always">\n            <mat-label>{{ msgs.server() }}</mat-label>\n            <input type="text" placeholder="{{ msgs.searchForServer() }}" matInput [formControl]="orchidsFormControl" [matAutocomplete]="auto" #trigger="matAutocompleteTrigger" #searchInput>\n            <button class="clear-button" *ngIf="orchidsFormControl.value" matSuffix mat-icon-button (click)="clearInput(trigger)">\n                <i class="fa fa-times"></i>\n            </button>\n            <mat-autocomplete #auto="matAutocomplete" [displayWith]="getOrchidOptionLabel" (optionSelected)="onSelect($event, trigger)">\n                <mat-option *ngFor="let option of filteredOrchids | async" [value]="option" [disabled]="option.disabled" class="orchid-option">\n                    <div class="server-info-container">\n                        <span>{{ option.name }}</span>\n                        <span class="unsupported-orchid-text" *ngIf="option.disabled">{{\n                            option.unavailableText\n                        }}</span>\n                    </div>\n                    <i *ngIf="isSelected(option)" class="fa fa-check success-text"></i>\n                </mat-option>\n            </mat-autocomplete>\n        </mat-form-field>\n    </mat-card>\n</div>\n'
        }
        ,
        45363: e => {
            e.exports = '<mat-toolbar color="primary">\n    <span mat-dialog-title class="toolbar-title">{{ dialogTitle }}</span>\n    <button class="add-lib-x-button" mat-icon-button disableRipple="true" (click)="close(\'cancel\')" [disabled]="processing">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content triggerCloseOnScroll>\n    <permission-group-form #permissionGroupForm [groups]="groups" [users]="users" [orchids]="data.orchids" [plugins]="data.plugins" [generalForm]="generalForm" [externalGroupForm]="externalGroupForm" [adminForm]="adminForm" [cameraPermissionsForm]="cameraPermissionsForm" [othersForm]="othersForm" [externalProviders]="data.externalProviders" [processing]="processing"></permission-group-form>\n</mat-dialog-content>\n\n\x3c!-- Dialog Error --\x3e\n<sing-dialog-errors class="error-banner" *ngIf="showError" (onClose)="dismissMe()" [errmsg]="error">\n</sing-dialog-errors>\n\n<mat-dialog-actions>\n    <button mat-button class="cancel-button" (click)="processing ? none : close(\'cancel\')" [disabled]="processing">\n        {{ msgs.cancel() }}\n    </button>\n    <spinner-button class="save-button" [disabled]="generalForm.value.name.trim().length === 0" [text]="msgs.saveGroup()" [color]="\'primary\'" (click)="handleFormSubmit()" [showSpinner]="processing"></spinner-button>\n</mat-dialog-actions>\n'
        }
        ,
        61715: e => {
            e.exports = '<div class="settings-tab">\n    <div class="settings-form-container external-group-form">\n        <div class="form-section" *ngIf="SAMLProviders.length > 0">\n            <div class="section-header-container">\n                <i class="section-title-icon {{ icons.cloud }}"></i>\n                <div class="section-title-container">\n                    <span class="label-medium">{{ msgs.attributeGroupMappings() }}</span>\n                    <span class="label-tiny hint-text">{{ externalSamlTooltip }}</span>\n                </div>\n            </div>\n\n            <alert-banner [type]="BANNER_TYPE.WARNING" *ngIf="hasDeprecatedAttributes">{{\n                msgs.groupHasInactiveAttributesWarningMessage()\n            }}</alert-banner>\n            <mat-accordion class="mappings-container saml-mappings-container">\n                <div *ngFor="let samlProvider of SAMLProviders; first as isFirst; last as isLast">\n                    <saml-mapping [class.first-panel]="isFirst" [class.last-panel]="isLast" [samlProvider]="samlProvider" [externalGroupForm]="externalGroupForm"></saml-mapping>\n                </div>\n            </mat-accordion>\n        </div>\n\n        \x3c!-- NON-SAML --\x3e\n        <div class="form-section external-group-form" *ngIf="externalProviders.length > SAMLProviders.length">\n            <div class="section-header-container">\n                <i class="section-title-icon {{ icons.website }}"></i>\n                <div class="section-title-container">\n                    <span class="label-medium">{{ msgs.domainGroupMappings() }}</span>\n                    <span class="label-tiny hint-text">{{ externalTooltip }}</span>\n                </div>\n            </div>\n\n            <div class="panel-content-container domain-mappings-container mappings-container">\n                <mat-card class="empty-attribute-set-card" *ngIf="domainData.length === 0">\n                    <error-banner type="error-data" [title]="msgs.noDomainMappings()" [description]="msgs.thisGroupHasNoDomainMappings()" [icon]="icons.ballot_check">\n                        <button mat-button class="add-domain-mapping-button" (click)="addDomainMap()">\n                            <span class="link-blue-text">{{ msgs.createADomainMapping() }}</span>\n                        </button>\n                    </error-banner>\n                </mat-card>\n                <div class="mapping-card-container" *ngFor="let mapping of domainData; let last = last; let index = index">\n                    <mat-card class="domain-mapping-card mat-elevation-z">\n                        <div class="mapping-row">\n                            <mat-form-field class="fill">\n                                <input matInput placeholder="{{ msgs.domain() }}" [(ngModel)]="mapping.domain">\n                            </mat-form-field>\n                            <mat-form-field class="fill">\n                                <input matInput placeholder="{{ msgs.group() }}" [(ngModel)]="mapping.group">\n                            </mat-form-field>\n                            <button class="mapping-remove-icon-button" mat-icon-button (click)="removeDomainMap(index)">\n                                <i class="{{ icons.delete }} mat-delete"></i>\n                            </button>\n                            <div class="mapping-remove-full-button-container mat-fail">\n                                <button class="mapping-remove-full-button" mat-button (click)="removeDomainMap(index)">\n                                    <span>{{ msgs.remove() }}</span>\n                                </button>\n                            </div>\n                        </div>\n                    </mat-card>\n                    <div class="card-separator" *ngIf="!last">\n                        <span class="label-small">{{ msgs.or() }}</span>\n                    </div>\n                </div>\n\n                <div class="card-button-container" *ngIf="domainData.length > 0">\n                    <button mat-stroked-button class="add-button add-domain-mapping-button" (click)="addDomainMap()">\n                        {{ msgs.domainMapping() }}\n                    </button>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n'
        }
        ,
        60361: e => {
            e.exports = '<mat-expansion-panel hideToggle class="mat-elevation-z0">\n    <mat-expansion-panel-header>\n        <mat-panel-title class="label-medium">{{ samlProvider.configuration.commonName }}\n            <i *ngIf="hasDeprecatedAttributes" class="{{ icons.system_alerts }} mat-error"></i>\n        </mat-panel-title>\n        <div [class.attribute-set-count-container]="attributeSetCountValue !== msgs.none()" [class.attribute-set-count-container-none]="attributeSetCountValue === msgs.none()">\n            <span [class.attribute-set-count]="attributeSetCountValue !== msgs.none()" [class.attribute-set-count-none]="attributeSetCountValue === msgs.none()">{{ attributeSetCountValue }}</span>\n        </div>\n    </mat-expansion-panel-header>\n\n    <div class="panel-content-container">\n        <mat-card class="empty-attribute-set-card mat-elevation-z0" *ngIf="attributeMappings.length === 0 && supportedAttributes.length > 0">\n            <error-banner type="error-data" [title]="msgs.noAttributeSetsConfigured()" [description]="msgs.thisProviderHasNoAttributeSets()" [icon]="icons.ballot_check">\n                <button class="create-attribute-set-button" mat-button (click)="addAttributeSet(samlProvider.configuration.commonName)">\n                    <span class="link-blue-text">{{ msgs.createAnAttributeSet() }}</span>\n                </button>\n            </error-banner>\n        </mat-card>\n\n        <error-banner *ngIf="supportedAttributes.length === 0" class="no-supported-attributes-error-banner" type="error-data" [title]="msgs.noSupportedAttributesConfigured()" [description]="msgs.thisProviderHasNoSupportedAttributes()" [icon]="\'fa-solid fa-cloud-exclamation\'"></error-banner>\n\n        <div class="mapping-card-container" *ngFor="let attributeMapping of attributeMappings; let last = last; let attributeMappingIndex = index">\n            <mat-card class="attribute-set-card mat-elevation-z">\n                \x3c!-- Header --\x3e\n                <div class="attribute-set-header">\n                    <div class="title-and-deprecated-warning-container">\n                        <i *ngIf="setContainsDeprecatedAttribute(attributeMapping.conditions)" class="{{ icons.error }} mat-error"></i>\n                        <div class="section-title-container">\n                            <span class="label-medium">{{\n                                msgs.attributeSetVALUE({ VALUE: attributeMappingIndex + 1 })\n                            }}</span>\n                            <span class="label-tiny hint-text">{{ msgs.attributeSetHintText() }}</span>\n                        </div>\n                    </div>\n\n                    <button mat-icon-button (click)="removeAttributeMapping(attributeMappingIndex)">\n                        <i class="{{ icons.delete }} mat-delete"></i>\n                    </button>\n                </div>\n                \x3c!-- Container --\x3e\n                <div class="attributes-container">\n                    <ng-container *ngFor="let condition of attributeMapping.conditions; let conditionIndex = index">\n                        \x3c!-- Valid Mapping --\x3e\n                        <div class="mapping-row" *ngIf="!isAttributeDeprecated(condition.attributeName); else deprecatedAttribute">\n                            <mat-form-field>\n                                <mat-label>{{ msgs.attribute() }}</mat-label>\n                                <mat-select [(value)]="condition.attributeName">\n                                    <mat-option *ngFor="let attribute of supportedAttributes" value="{{ attribute }}">\n                                        {{ attribute }}\n                                    </mat-option>\n                                </mat-select>\n                            </mat-form-field>\n                            <mat-form-field class="fill">\n                                <input matInput placeholder="{{ msgs.attributeValue() }}" [(ngModel)]="condition.attributeValue">\n                            </mat-form-field>\n\n                            <button class="mapping-remove-icon-button" mat-icon-button (click)="removeCondition(conditionIndex, attributeMappingIndex)">\n                                <i class="{{ icons.close }} mat-delete"></i>\n                            </button>\n\n                            <div class="mapping-remove-full-button-container mat-fail">\n                                <button class="mapping-remove-full-button" mat-button (click)="removeCondition(conditionIndex, attributeMappingIndex)">\n                                    <span>{{ msgs.remove() }}</span>\n                                </button>\n                            </div>\n                        </div>\n\n                        \x3c!-- Deprecated Mapping --\x3e\n                        <ng-template #deprecatedAttribute>\n                            <div class="deprecated-mapping-container">\n                                <tag type="warning" label="{{ msgs.inactiveAttribute() }}"></tag>\n                                <div class="mapping-row">\n                                    <mat-form-field>\n                                        <mat-label>{{ msgs.attribute() }}</mat-label>\n                                        <input matInput disabled="disabled" value="{{ condition.attributeName }}">\n                                    </mat-form-field>\n\n                                    <mat-form-field class="fill">\n                                        <mat-label>{{ msgs.attributeValue() }}</mat-label>\n                                        <input matInput disabled="disabled" value="{{ condition.attributeValue }}">\n                                    </mat-form-field>\n\n                                    <button class="mapping-remove-icon-button" mat-icon-button (click)="removeCondition(conditionIndex, attributeMappingIndex)">\n                                        <i class="{{ icons.close }} mat-delete"></i>\n                                    </button>\n                                    <div class="mapping-remove-full-button-container mat-fail">\n                                        <button class="mapping-remove-full-button" mat-button (click)="removeCondition(conditionIndex, attributeMappingIndex)">\n                                            <span>{{ msgs.remove() }}</span>\n                                        </button>\n                                    </div>\n                                </div>\n                            </div>\n                        </ng-template>\n                    </ng-container>\n                </div>\n                \x3c!-- Footer --\x3e\n                <div class="attribute-set-footer">\n                    <button mat-button [disabled]="supportedAttributes.length === 0" color="primary" class="add-button" (click)="addCondition(attributeMappingIndex)">\n                        {{ msgs.attribute() }}\n                    </button>\n                </div>\n            </mat-card>\n            <div class="card-separator" *ngIf="!last">\n                <span class="label-small">{{ msgs.or() }}</span>\n            </div>\n        </div>\n\n        <div class="card-button-container" *ngIf="attributeMappings.length > 0">\n            <button mat-stroked-button [disabled]="supportedAttributes.length === 0" class="add-button add-attribute-set-button" (click)="addAttributeSet(samlProvider.name)">\n                {{ msgs.attributeSet() }}\n            </button>\n        </div>\n    </div>\n</mat-expansion-panel>\n'
        }
        ,
        4893: e => {
            e.exports = '<mat-expansion-panel class="mat-elevation-z0" hideToggle>\n    <mat-expansion-panel-header>\n        <mat-panel-title class="label-medium">{{ samlProvider.configuration.commonName }}\n            <i *ngIf="hasDeprecatedAttributes" class="{{ icons.error }} mat-error"></i>\n        </mat-panel-title>\n        <div [class.attribute-set-count-container]="attributeSetCountValue !== msgs.none()" [class.attribute-set-count-container-none]="attributeSetCountValue === msgs.none()">\n            <span [class.attribute-set-count]="attributeSetCountValue !== msgs.none()" [class.attribute-set-count-none]="attributeSetCountValue === msgs.none()">{{ attributeSetCountValue }}</span>\n        </div>\n    </mat-expansion-panel-header>\n\n    <div class="panel-content-container">\n        <div class="mapping-card-container" *ngFor="let set of attributeSets; let setIndex = index; let last = last">\n            <mat-card class="attribute-set-card">\n                \x3c!-- Header --\x3e\n                <div class="section-title-container">\n                    <div class="title-and-deprecated-warning-container">\n                        <i *ngIf="setContainsDeprecatedAttribute(set)" class="{{ icons.error }} mat-error"></i>\n                        <div class="attribute-set-header">\n                            <span class="label-medium">{{ msgs.attributeSetVALUE({ VALUE: setIndex + 1 }) }}</span>\n                            <span class="label-tiny hint-text">{{ msgs.attributeSetHintText() }}</span>\n                        </div>\n                    </div>\n\n                    <div class="conditions-table-header">\n                        <div class="label-medium condition-attributes-column">{{ msgs.attributes() }}</div>\n                        <div class="label-medium condition-values-column">{{ msgs.values() }}</div>\n                    </div>\n                </div>\n\n                \x3c!-- Container --\x3e\n                <div class="condition-rows-container">\n                    <ng-container *ngFor="let condition of set | keyvalue">\n                        \x3c!-- Valid mapping --\x3e\n                        <div class="condition-row" *ngIf="attributeNotDeprecated(condition.key); else deprecatedAttribute">\n                            <div class="condition-attributes-column">{{ condition.key }}</div>\n                            <div class="condition-values-column">{{ condition.value }}</div>\n                        </div>\n\n                        <ng-template #deprecatedAttribute>\n                            <div class="deprecated-container">\n                                <div class="tag-container">\n                                    <tag type="warning" label="{{ msgs.inactiveAttribute() }}"></tag>\n                                </div>\n                                <div class="condition-row">\n                                    <div class="condition-attributes-column">{{ condition.key }}</div>\n                                    <div class="condition-values-column">{{ condition.value }}</div>\n                                </div>\n                            </div>\n                        </ng-template>\n                    </ng-container>\n                </div>\n            </mat-card>\n            <div class="card-separator" *ngIf="!last">\n                <span class="label-small">{{ msgs.or() }}</span>\n            </div>\n        </div>\n    </div>\n</mat-expansion-panel>\n'
        }
        ,
        15673: e => {
            e.exports = '<mat-tab-group animationDuration="0ms" [(selectedIndex)]="selectedTabIndex">\n    \x3c!-- General Settings --\x3e\n    <mat-tab [disabled]="processing">\n        <ng-template mat-tab-label class="general-form-tab">\n            <div class="tab-label-container" id="generalTab">\n                <span class="label-medium">{{ msgs.tabs.general() }}</span>\n            </div>\n        </ng-template>\n\n        <div class="settings-tab">\n            <form [formGroup]="generalForm">\n                <div class="settings-form-container">\n                    \x3c!-- Group Name --\x3e\n                    <mat-form-field class="group-name">\n                        <mat-label>{{ msgs.groupName() }}</mat-label>\n                        <input matInput type="text" required formControlName="name" cdkFocusInitial placeholder="{{ msgs.groupName() }}">\n                        <mat-error>\n                            {{ msgs.groupNameIsRequired() }}\n                        </mat-error>\n                    </mat-form-field>\n\n                    \x3c!-- Group Description --\x3e\n                    <mat-form-field class="group-description">\n                        <mat-label>{{ msgs.groupDescription() }}</mat-label>\n                        <input matInput formControlName="description" type="text" placeholder="{{ msgs.aGroupOfUsersForSpecifyingPermissions() }}">\n                    </mat-form-field>\n\n                    \x3c!-- Members --\x3e\n                    <autocomplete-chip-input class="users" [formGroup]="generalForm.controls[\'users\']" [data]="users" [dataName]="msgs.members()" [disabled]="processing"></autocomplete-chip-input>\n\n                    \x3c!-- Member Groups--\x3e\n                    <div class="form-section">\n                        <div class="section-header-container">\n                            <i class="section-title-icon {{ icons.users }}"></i>\n                            <div class="section-title-container">\n                                <span class="label-medium">{{ msgs.memberGroups() }}</span>\n                                <span class="label-tiny hint-text">{{\n                                    msgs.membersOfTheseGroupsAreAlsoAMemberOfThisGroup()\n                                }}</span>\n                            </div>\n                        </div>\n                        <autocomplete-chip-input class="groups" [formGroup]="generalForm.controls[\'groups\']" [data]="groups" [dataName]="msgs.memberGroups()" [disabled]="processing"></autocomplete-chip-input>\n                    </div>\n                </div>\n            </form>\n        </div>\n    </mat-tab>\n\n    \x3c!-- External Group Mappings --\x3e\n    <mat-tab *ngIf="externalProviders.length > 0" [disabled]="processing">\n        <ng-template mat-tab-label class="external-group-form-tab">\n            <div class="tab-label-container" id="externalGroupTab">\n                <div class="label-and-badges">\n                    <span class="label-medium">{{ msgs.externalGroupMappings() }}</span>\n                    <div class="badges-container" *ngIf="hasDeprecatedAttributes">\n                        <i class="{{ icons.error }} mat-error"></i>\n                    </div>\n                </div>\n            </div>\n        </ng-template>\n\n        \x3c!-- We conditionally render this tab\'s content when selected to prevent mat-expansion-panel bugs --\x3e\n        \x3c!-- See https://github.com/angular/components/issues/5269 for explanation of how this fixes it --\x3e\n        <div class="tab-wrapper" *ngIf="selectedTabIndex === 1">\n            <external-group-mappings [externalGroupForm]="externalGroupForm" [externalProviders]="externalProviders" [hasDeprecatedAttributes]="hasDeprecatedAttributes" [SAMLProviders]="SAMLProviders"></external-group-mappings>\n        </div>\n    </mat-tab>\n\n    \x3c!-- Admins Settings --\x3e\n    <mat-tab [disabled]="processing">\n        <ng-template mat-tab-label class="admin-form-tab">\n            <div class="tab-label-container" id="adminTab">\n                <div class="label-and-badges">\n                    <span class="label-medium">{{ msgs.tabs.admin() }}</span>\n                    <div class="badges-container" *ngIf="adminForm.value.role === adminPrivilege.RECORDER_ADMIN">\n                        <tag type="external" icon="{{ icons.servers.server }}" label="{{ getRecorderAdminTabLabel() }}">\n                        </tag>\n                    </div>\n                </div>\n            </div>\n        </ng-template>\n        <div class="settings-tab admin-settings-tab">\n            <form [formGroup]="adminForm">\n                <div class="form-section">\n                    <div class="section-header-container">\n                        <i class="section-title-icon {{ icons.lock }}"></i>\n                        <div class="section-title-container">\n                            <span class="label-medium">{{ msgs.adminPrivilege() }}</span>\n                            <span class="label-tiny hint-text">{{ msgs.grantThisGroupAdmin() }}</span>\n                        </div>\n                    </div>\n\n                    <mat-radio-group formControlName="role" class="radio-group" (change)="onAdminRoleChange($event)">\n                        \x3c!-- None --\x3e\n                        <mat-radio-button value="{{ adminPrivilege.NONE }}" class="radio-group-option none-option">\n                            <div class="section-title-container">\n                                <span class="label-medium">{{ msgs.none() }}</span>\n                            </div>\n                        </mat-radio-button>\n\n                        \x3c!-- Admin group --\x3e\n                        <mat-radio-button value="{{ adminPrivilege.ADMIN }}" class="radio-group-option admin-option">\n                            <div class="section-title-container">\n                                <span class="label-medium">{{ msgs.administratorGroup() }}</span>\n                                <span class="label-tiny hint-text">{{\n                                    msgs.grantAbilitiesAdmin({ APP: appName })\n                                }}</span>\n                            </div>\n                        </mat-radio-button>\n\n                        \x3c!-- Recorder Admin Group --\x3e\n                        <div class="subadmin-option-container">\n                            <mat-radio-button value="{{ adminPrivilege.RECORDER_ADMIN }}" class="radio-group-option subadmin-option">\n                                <div class="section-title-container">\n                                    <span class="label-medium">{{ msgs.recorderAdmin.recorderAdminGroup() }}</span>\n                                    <span class="label-tiny hint-text">{{ msgs.grantAbilitiesRecorderAdmin() }}</span>\n                                </div>\n                            </mat-radio-button>\n\n                            \x3c!-- Recorder Admin options --\x3e\n                            <div class="round-block recorders-admin" [formGroup]="adminForm.controls[\'managementConfig\']" *ngIf="adminForm.value.role === adminPrivilege.RECORDER_ADMIN">\n                                <div class="management-settings-container">\n                                    <div class="title-medium section-title">\n                                        {{ msgs.recorderAdmin.recorderAdminAbilities() }}\n                                    </div>\n                                    <mat-card class="recorder-admin-abilities-card">\n                                        <mat-checkbox [disabled]="processing" [checked]="isRegistrar()" (change)="onRegistrarToggle($event)">\n                                            <span class="body-medium">{{ msgs.recorderAdmin.canRegister() }}</span>\n                                        </mat-checkbox>\n                                    </mat-card>\n                                </div>\n\n                                <div class="management-settings-container">\n                                    <div class="title-medium section-title">\n                                        {{ msgs.recorderAdmin.recorder() }}\n                                    </div>\n                                    <mat-radio-group formControlName="selectedManageOption" (change)="onManageOptionChange($event)">\n                                        <mat-card>\n                                            <mat-radio-button value="{{ manageRecordersOptions.ALL }}">\n                                                <div class="title-medium">{{ msgs.recorderAdmin.all() }}</div>\n                                                <div class="body-tiny option-description">\n                                                    {{ msgs.recorderAdmin.grantThisGroup({ VMS: appName }) }}\n                                                </div>\n                                            </mat-radio-button>\n                                        </mat-card>\n                                        <mat-card class="selected-recorders-card">\n                                            <mat-radio-button value="{{ manageRecordersOptions.SELECTION }}">\n                                                <div class="title-medium">{{ msgs.recorderAdmin.selection() }}</div>\n                                                <div class="body-tiny option-description">\n                                                    {{ msgs.recorderAdmin.selectSpecificRecorder() }}\n                                                </div>\n                                            </mat-radio-button>\n\n                                            <recorder-picker [orchids]="orchids" [selectedOrchids]="selectedOrchids" (onOrchidSelect)="handleOrchidSelected($event)" [loaded]="true" [disabled]="processing" *ngIf="\n                                                    adminForm.controls[\'managementConfig\'].controls[\n                                                        \'selectedManageOption\'\n                                                    ].value === manageRecordersOptions.SELECTION\n                                                "></recorder-picker>\n                                        </mat-card>\n                                    </mat-radio-group>\n                                </div>\n                            </div>\n                        </div>\n                    </mat-radio-group>\n                </div>\n            </form>\n        </div>\n    </mat-tab>\n\n    \x3c!-- Cameras Permissions --\x3e\n    <mat-tab [disabled]="adminForm.value.role === adminPrivilege.ADMIN || processing">\n        <ng-template mat-tab-label class="permissions-form-tab">\n            <div class="tab-label-container" id="permissionsTab">\n                <div class="label-and-badges">\n                    <span class="label-medium">{{ msgs.tabs.permissions() }}</span>\n                    <div class="badges-container" *ngIf="adminForm.value.role !== adminPrivilege.ADMIN">\n                        <tag *ngIf="cameraPermissionsForm.value.permissions.grant.length > 0" type="success" [icon]="icons.add" label="{{ cameraPermissionsForm.value.permissions.grant.length }}"></tag>\n                        <tag *ngIf="cameraPermissionsForm.value.permissions.revoke.length > 0" type="error" [icon]="icons.remove" label="{{ cameraPermissionsForm.value.permissions.revoke.length }}">\n                        </tag>\n                    </div>\n                </div>\n            </div>\n        </ng-template>\n\n        <div class="settings-tab">\n            \x3c!-- Permissions columns --\x3e\n            <div class="form-section perm-columns">\n                <div class="section-header-container">\n                    <i class="section-title-icon {{ icons.lock }}"></i>\n                    <div class="section-title-container">\n                        <span class="label-medium">{{ msgs.managePermissions() }}</span>\n                        <span class="label-tiny hint-text">{{ msgs.grantOrRevoke() }}</span>\n                    </div>\n                </div>\n\n                <perm-columns [cardType]="Type.EDITING" [orchids]="orchids" [formGroup]="cameraPermissionsForm" [processing]="processing"></perm-columns>\n            </div>\n        </div>\n    </mat-tab>\n\n    \x3c!-- Other Permissions --\x3e\n    <mat-tab [disabled]="adminForm.value.role === adminPrivilege.ADMIN || processing">\n        <ng-template mat-tab-label class="other-form-tab">\n            <div class="tab-label-container" id="othersTab">\n                <div class="label-and-badges">\n                    <span class="label-medium">{{ msgs.tabs.other() }}</span>\n                </div>\n            </div>\n        </ng-template>\n\n        <div class="settings-tab">\n            <form [formGroup]="othersForm">\n                \x3c!-- Library access --\x3e\n                <div class="form-section library-access">\n                    <mat-checkbox formControlName="globalLibraryAccess">\n                        <i class="section-title-icon {{ icons.library }}"></i>\n                        <div class="section-title-container">\n                            <span class="label-medium"> {{ msgs.libraryAccess() }}</span>\n                            <span class="label-tiny hint-text">{{ msgs.libraryAccessTooltip() }}</span>\n                        </div>\n                    </mat-checkbox>\n                </div>\n\n                \x3c!-- Apps Access --\x3e\n                <div class="form-section apps-access">\n                    <div class="section-header-container">\n                        <i class="section-title-icon {{ icons.plugin }}"></i>\n                        <div class="section-title-container">\n                            <span class="label-medium">{{ msgs.appsAccess() }}</span>\n                            <span class="label-tiny hint-text">{{ msgs.grantThisGroupAccessToSpecificApps() }}</span>\n                        </div>\n                    </div>\n\n                    <mat-form-field>\n                        <mat-label>\n                            {{ msgs.apps() }}\n                        </mat-label>\n\n                        <mat-select [formControl]="appsFormCtrl" #selectApps multiple="multiple">\n                            <mat-option #allPlugins [value]="allPlugins" (click)="allAppSelect()">\n                                {{ msgs.allApps() }}\n                            </mat-option>\n                            <mat-option *ngFor="let app of plugins" [value]="app" id="{{ app.id }}" (click)="appSelect(app)">\n                                {{ app.name }}\n                            </mat-option>\n                        </mat-select>\n                    </mat-form-field>\n                </div>\n            </form>\n        </div>\n    </mat-tab>\n</mat-tab-group>\n'
        }
        ,
        6415: e => {
            e.exports = '<mat-card>\n    \x3c!-- Card badge --\x3e\n    <div *ngIf="columnType === TYPE.GRANTED" class="circle-tag granted mat-success">\n        <i class="fa fa-plus fa-2x"></i>\n    </div>\n    <div *ngIf="columnType === TYPE.REVOKED" class="circle-tag revoked mat-fail">\n        <i class="fa fa-minus fa-2x"></i>\n    </div>\n\n    \x3c!-- Card content READONLY and COMPLETED--\x3e\n    <div class="inner-card">\n        <mat-card-content class="readonly-card" *ngIf="cardType === TYPE.READONLY || cardType === TYPE.COMPLETED" [@.disabled]="cardType === TYPE.READONLY">\n            \x3c!-- Abilites --\x3e\n            <p class="info-title">{{ msgs.abilitiesTitle() }}</p>\n            <div class="abilities">\n                <chip-list class="rule-list" [listType]="\'chip\'" [data]="abilities" [hidePageSize]="true" [emptyMessageInput]="msgs.noAbilitiesSelected()" [emptyMessageRed]="true" [emptyMessageCross]="true"></chip-list>\n            </div>\n\n            \x3c!-- Scope --\x3e\n            <p class="info-title">{{ msgs.scopeTitle() }}</p>\n            <div class="scope">\n                \x3c!-- Server cards --\x3e\n                <mat-accordion *ngIf="cardType === TYPE.READONLY ? !data.allOrchids : !formGroup.value.allOrchids">\n                    <mat-expansion-panel *ngFor="let server of pagedData; let i = index" hideToggle #panel>\n                        \x3c!-- Card header --\x3e\n                        <mat-expansion-panel-header>\n                            <mat-panel-title class="readTitle">\n                                <span class="server-name info-title">\n                                    {{ server.name }}\n                                </span>\n                                <icon-total [icon]="\'fa-video-camera\'" [number]="server.cameras.length" [hidden]="server.allCameras"></icon-total>\n                                <icon-total [icon]="\'fa-server fa-regular\'" [hidden]="!server.allCameras"></icon-total>\n                            </mat-panel-title>\n                        </mat-expansion-panel-header>\n\n                        \x3c!-- Card contents --\x3e\n                        <ng-template matExpansionPanelContent>\n                            <chip-list *ngIf="cardType === TYPE.READONLY ? !data.allOrchids : !formGroup.value.allOrchids" [listType]="\'text\'" [data]="server.cameras" [chipWidth]="CHIPWIDTH.AUTO" [paginatorLabelInput]="msgs.cameras()"></chip-list>\n                        </ng-template>\n                    </mat-expansion-panel>\n                </mat-accordion>\n\n                \x3c!-- Pagination of servers --\x3e\n                <pagination *ngIf="cardType === TYPE.READONLY ? !data.allOrchids : !formGroup.value.allOrchids" class="pagination-total" (page)="handlePageEvent($event)" [dataSource]="cardData" (pagedData)="updatePagedData($event)" [pageSize]="pageSize" [pageSizeOptions]="[8, 16, 24, 32]">\n                </pagination>\n                <chip-list class="allDataSelected" *ngIf="cardType === TYPE.READONLY ? data.allOrchids : formGroup.value.allOrchids" [listType]="\'chip\'" [allItems]="true" [allItemsMessage]="msgs.allServersAndCameras()"></chip-list>\n                <chip-list *ngIf="\n                        cardType === TYPE.READONLY\n                            ? !data.allOrchids && cardData.length === 0\n                            : !formGroup.value.allOrchids && cardData.length === 0\n                    " class="noDataSelected" [listType]="\'chip\'" [data]="[]" [hidePageSize]="true" [emptyMessageInput]="msgs.noServersOrCamerasSelected()" [emptyMessageRed]="true" [emptyMessageCross]="true" [chipWidth]="CHIPWIDTH.AUTO"></chip-list>\n            </div>\n            <div class="card-buttons-editing" *ngIf="cardType === TYPE.COMPLETED">\n                <spinner-button [color]="\'primary\'" [text]="msgs.editGroupShort()" [icon]="\'fa-pencil\'" [disabled]="processing" (click)="processing ? none : getEditingView()"></spinner-button>\n            </div>\n        </mat-card-content>\n\n        \x3c!-- Card content EDITING--\x3e\n        <div *ngIf="cardType === TYPE.EDITING">\n            <mat-card-content [formGroup]="formGroup" class="content-edit">\n                \x3c!-- Abilities --\x3e\n                <p class="info-title">{{ msgs.abilitiesTitle() }}</p>\n                <div class="abilitiesForm">\n                    <mat-chip class="selectable-chip">\n                        <mat-checkbox (change)="updateRules($event)" (click)="$event.stopPropagation()" value="{{ rules[0] }}" [checked]="formGroup.value.rules.length === rulesOnly.length">\n                            {{ rules[0] }}\n                        </mat-checkbox>\n                    </mat-chip>\n\n                    <ng-container *ngFor="let rule of rulesOnly">\n                        <mat-chip class="selectable-chip">\n                            <mat-checkbox (change)="updateRules($event)" (click)="$event.stopPropagation()" value="{{ rule }}" [checked]="formGroup.value.rules.includes(rule)">\n                                {{ rule }}\n                            </mat-checkbox>\n                        </mat-chip>\n                    </ng-container>\n                </div>\n                <div class="rule-warning">\n                    <p class="warn-text" *ngIf="rulesWarn.playback">\n                        {{\n                            msgs.ruleConsiderAlsoIncluding({\n                                RULE: msgs.permissions.playback(),\n                                INCLUDE: msgs.permissions.live()\n                            })\n                        }}\n                    </p>\n                    <p class="warn-text" *ngIf="rulesWarn.ptz">\n                        {{\n                            msgs.ruleConsiderAlsoIncluding({\n                                RULE: msgs.permissions.ptz(),\n                                INCLUDE: msgs.permissions.live()\n                            })\n                        }}\n                    </p>\n                    <p class="warn-text" *ngIf="rulesWarn.talk">\n                        {{\n                            msgs.ruleConsiderAlsoIncluding({\n                                RULE: msgs.permissions.talk(),\n                                INCLUDE: msgs.permissions.live()\n                            })\n                        }}\n                    </p>\n                </div>\n\n                \x3c!-- Scope --\x3e\n                <p class="info-title">{{ msgs.scopeTitle() }}</p>\n                <div class="scope">\n                    <mat-chip-list>\n                        <mat-chip class="selectable-chip">\n                            <mat-checkbox formControlName="allOrchids">\n                                {{ msgs.allServersAndCameras() }}\n                            </mat-checkbox>\n                        </mat-chip>\n                    </mat-chip-list>\n                    \x3c!-- Camera Picker --\x3e\n                    <div class="cameraPicker">\n                        <camera-picker *ngIf="!formGroup.value.allOrchids" [editing]="existingPerm && (orchidsEditing.length > 0 || camerasEditing.length > 0)" [data]="orchids" [orchids]="orchidsEditing" [cameras]="camerasEditing" [loaded]="!formGroup.value.allOrchids" [hideSelectAllCameras]="true" [hideSelectAllServers]="true" [pageSizeOptions]="pageSizeOptions" [pageSizeCameras]="pageSizeCameras" (onTotalDataListChange)="updateCamerasAndServers($event)"></camera-picker>\n                    </div>\n                </div>\n                <div class="card-buttons">\n                    <div class="running-total">\n                        <button [hidden]="formGroup.value.allOrchids" [disabled]="orchidsEditing.length === 0 && camerasEditing.length === 0" mat-stroked-button color="primary">\n                            <span class="total-text">\n                                {{ msgs.totalServers({ SERVERS: orchidsEditing.length }) }} &nbsp;\n                                {{ msgs.totalCameras({ CAMERAS: camerasEditing.length }) }}\n                            </span>\n                            <span class="total-icons">\n                                <i class="fa fa-server fa-regular"></i>: {{ orchidsEditing.length }} &nbsp;<i class="fa fa-video-camera"></i>:\n                                {{ camerasEditing.length }}\n                            </span>\n                        </button>\n                    </div>\n                    <div class="action-buttons">\n                        <spinner-button [color]="\'warn\'" [textColor]="\'white\'" [text]="msgs.delete()" [icon]="\'fa-trash-can fa-regular\'" (click)="deletePermission()"></spinner-button>\n                        <spinner-button [color]="\'primary\'" [text]="msgs.save()" (click)="savePermission(formGroup)"></spinner-button>\n                    </div>\n                </div>\n            </mat-card-content>\n        </div>\n    </div>\n</mat-card>\n'
        }
        ,
        51911: e => {
            e.exports = '<div class="permissions" *ngIf="cardType === Type.READONLY">\n    <div class="perm-column perms-granted round-block" *ngIf="permissions.grant.length > 0">\n        <span class="info-title">{{ msgs.permissionsGranted() }}</span>\n        <div *ngFor="let permission of permissions.grant" class="permission-cards">\n            <perm-card class="perm-card" *ngIf="cardType === Type.READONLY" [columnType]="Type.GRANTED" [data]="permission" [cardType]="cardType"></perm-card>\n        </div>\n    </div>\n\n    <div class="perm-column perms-revoked round-block" *ngIf="permissions.revoke.length > 0">\n        <span class="info-title">{{ msgs.permissionsRevoked() }}</span>\n        <div *ngFor="let permission of permissions.revoke" class="permission-cards">\n            <perm-card class="perm-card" [columnType]="Type.REVOKED" [data]="permission" [cardType]="cardType"></perm-card>\n        </div>\n    </div>\n</div>\n\n<div *ngIf="cardType === Type.EDITING" class="permissions" [formGroup]="permissionControl">\n    <div class="perm-column perms-granted round-block">\n        <span class="info-title">{{ msgs.permissionsGranted() }}</span>\n        <div *ngFor="let permission of permissionControl.get(\'grant\').controls; let i = index" class="permission-cards">\n            <perm-card class="perm-card" [columnType]="Type.GRANTED" [cardType]="cardType" [orchids]="orchids" [formGroup]="permission" [processing]="processing" (deletePerm)="deletePermission(\'grant\', i)">\n            </perm-card>\n        </div>\n        <div class="add-perm" *ngIf="permissionControl.get(\'grant\').controls.length === 0">\n            <em>{{ msgs.needToGrantAccessToCamerasOrFeatures() }}</em>\n            <spinner-button class="grant-button" [color]="\'success\'" [textColor]="\'white\'" [icon]="\'fa-plus\'" [text]="msgs.grantPermission()" [disabled]="processing" (click)="processing ? none : newPermission(\'grant\')"></spinner-button>\n        </div>\n        <spinner-button *ngIf="permissionControl.get(\'grant\').controls.length !== 0" class="add-perm grant-another-button" [color]="\'success\'" [textColor]="\'white\'" [icon]="\'fa-plus\'" [text]="msgs.grantAnotherPermission({ VALUE: 1 })" [disabled]="processing" (click)="processing ? none : newPermission(\'grant\')"></spinner-button>\n    </div>\n\n    <div class="perm-column perms-revoked round-block">\n        <span class="info-title">{{ msgs.permissionsRevoked() }}</span>\n        <div *ngFor="let permission of permissionControl.get(\'revoke\').controls; let i = index" class="permission-cards">\n            <perm-card class="perm-card" [columnType]="Type.REVOKED" [cardType]="cardType" [orchids]="orchids" [formGroup]="permission" [processing]="processing" (deletePerm)="deletePermission(\'revoke\', i)"></perm-card>\n        </div>\n        <div *ngIf="permissionControl.get(\'revoke\').controls.length === 0" class="add-perm">\n            <em>{{ msgs.needToRevokeAccessToCamerasOrFeatures() }}</em>\n            <spinner-button class="revoke-button" [color]="\'fail\'" [textColor]="\'white\'" [icon]="\'fa-plus\'" [text]="msgs.revokePermission()" [disabled]="processing" (click)="processing ? none : newPermission(\'revoke\')"></spinner-button>\n        </div>\n        <spinner-button *ngIf="permissionControl.get(\'revoke\').controls.length !== 0" class="add-perm revoke-another-button" [color]="\'fail\'" [textColor]="\'white\'" [icon]="\'fa-plus\'" [text]="msgs.revokeAnotherPermission({ VALUE: 1 })" [disabled]="processing" (click)="processing ? none : newPermission(\'revoke\')"></spinner-button>\n    </div>\n</div>\n'
        }
        ,
        62266: e => {
            e.exports = '<div [@slideDownUp] class="group-content">\n    <div class="info-block">\n        \x3c!-- Member and Member Groups --\x3e\n        <span class="info-title">{{ msgs.members() }}</span>\n        <chip-list [listType]="\'chip\'" [data]="usernames" [paginatorLabelInput]="msgs.members()" [emptyMessageInput]="msgs.none()" [chipWidth]="CHIPWIDTH.FIXED_SMALL" [pageSize]="16" [pageSizeOptions]="[8, 16, 24, 32]"></chip-list>\n        <div>\n            <span class="info-title">{{ msgs.memberGroups() }}</span>\n            <button mat-icon-button (click)="showUsers()" *ngIf="relatedUsers.length > 0" class="moreMembersButton">\n                <mat-icon class="{{ listingUsers ? icons.users : icons.user_add }} fa-lg moreMembersIcon" [ngClass]="{ down: listingUsers }"></mat-icon>\n            </button>\n        </div>\n        <chip-list [listType]="\'chip\'" [data]="userGroups" [paginatorLabelInput]="msgs.groups()" [emptyMessageInput]="msgs.none()" [chipWidth]="CHIPWIDTH.FIXED_MEDIUM" [pageSize]="12" [pageSizeOptions]="[12, 24, 36, 44]"></chip-list>\n        <div [@slideDownUpBoolean]="listingUsers">\n            <span class="info-title included-members-title">{{ msgs.includedMembers() }}</span>\n            <chip-list class="included-members" [listType]="\'chip\'" [data]="relatedUsers" [paginatorLabelInput]="msgs.members()" [emptyMessageInput]="msgs.none()" [chipWidth]="CHIPWIDTH.FIXED_SMALL" [pageSize]="16" [pageSizeOptions]="[8, 16, 24, 32]"></chip-list>\n        </div>\n\n        \x3c!-- Extended SAML Attribute Sets--\x3e\n        <div class="attribute-group-mapping-container" *ngIf="SAMLProviders.length > 0">\n            <div class="info-title-container">\n                <span class="info-title">{{ msgs.attributeGroupMappings() }}</span>\n                <circle-hint class="circle-hint" [tooltip]="msgs.attributeGroupMappingsTooltip()"></circle-hint>\n            </div>\n            <chip-list *ngIf="!attributeGroupMappingsConfigured" [data]="[]" [listType]="\'chip\'" [emptyMessageInput]="msgs.none()" [chipWidth]="CHIPWIDTH.FIXED_SMALL"></chip-list>\n            <alert-banner [type]="BANNER_TYPE.WARNING" *ngIf="hasDeprecatedAttributes">{{\n                msgs.groupHasInactiveAttributesWarningMessage()\n            }}</alert-banner>\n            <div *ngIf="attributeGroupMappingsConfigured" class="accordion-container">\n                <mat-accordion class="mappings-summary-container">\n                    <div *ngFor="let samlProvider of SAMLProviders">\n                        <saml-mapping-summary *ngIf="attributeMappingsRecord[samlProvider.externalProviderId] !== undefined" [class]="getSAMLSummaryBorderClass(samlProvider)" [samlProvider]="samlProvider" [attributeMappings]="attributeMappingsRecord[samlProvider.externalProviderId]"></saml-mapping-summary>\n                    </div>\n                </mat-accordion>\n            </div>\n        </div>\n\n        \x3c!-- Azure Groups --\x3e\n        <div class="azure" *ngIf="externalProviders.length > SAMLProviders.length">\n            <span class="info-title">{{ msgs.domainGroupMappings() }}</span>\n            <circle-hint class="circle-hint" [tooltip]="msgs.usersInTheseExternalGroupsWillBeMembersOfThisPermissionGroup()"></circle-hint>\n            <div class="azure-group">\n                <chip-list [listType]="\'chip\'" [data]="domainData" [paginatorLabelInput]="msgs.groups()" [emptyMessageInput]="msgs.none()" [chipWidth]="CHIPWIDTH.FIXED_MEDIUM" [pageSize]="12" [pageSizeOptions]="[12, 24, 36, 44]"></chip-list>\n            </div>\n        </div>\n\n        \x3c!-- Permission group rules --\x3e\n        <div class="admin-group" *ngIf="permissionRules.length > 0">\n            <chip-list class="admin" [listType]="\'chip\'" [data]="permissionRules" [icon]="\'check\'" [style]="\'green\'"></chip-list>\n        </div>\n    </div>\n\n    \x3c!-- Two column spread of camera permissions --\x3e\n    <div class="perm-columns">\n        <perm-columns *ngIf="!group.admin" [permissions]="group.permissions" [cardType]="Type.READONLY"></perm-columns>\n    </div>\n\n    \x3c!-- Managed Recorders block --\x3e\n    <div class="managed-recorders-section" *ngIf="group.managementConfig.abilities.length > 0">\n        <div *ngIf="isRegistrar()">\n            <mat-chip class="blue-chip can-register-chip" disabled="disabled"><i class="{{ icons.success }}"></i>{{ msgs.recorderAdmin.canRegister() }}</mat-chip>\n        </div>\n\n        <div class="round-block-outlined managed-recorders">\n            <div class="header-container">\n                <div class="title-container">\n                    <div class="title-medium section-title">{{ msgs.recorderAdmin.recorder() }}</div>\n                    <div class="body-tiny section-subtitle">{{ msgs.recorderAdmin.recordersThisGroup() }}</div>\n                </div>\n                <div class="count">\n                    <i class="{{ icons.servers.server }}"></i>\n                    <span>{{ getServersCount() }}</span>\n                </div>\n            </div>\n            <div class="recorders-list">\n                <chip-list [listType]="\'chip\'" [data]="managedRecorders" [emptyMessageInput]="msgs.none()" [style]="\'blue\'"></chip-list>\n            </div>\n        </div>\n    </div>\n\n    \x3c!-- Action buttons --\x3e\n    <div class="card-buttons">\n        <spinner-button [color]="\'warn\'" [textColor]="\'white\'" [text]="msgs.delete()" [icon]="icons.delete" (click)="delete(group)"></spinner-button>\n        <spinner-button [color]="\'primary\'" [text]="msgs.editGroup()" [icon]="icons.edit" (click)="editPermissionGroup()"></spinner-button>\n    </div>\n</div>\n'
        }
        ,
        18104: e => {
            e.exports = '<div *ngIf="failedToLoad && !loaded" class="permission-groups-error-message">\n    {{ msgs.failedToLoadPermissionGroups() }}\n</div>\n\n<div class="perms-header">\n    <div class="add-group">\n        <spinner-button *ngIf="loaded" [color]="\'primary\'" [icon]="\'fa-plus\'" [text]="msgs.addPermissionGroup()" (click)="addPermissionGroup()"></spinner-button>\n    </div>\n</div>\n\n<div class="page-content">\n    <page-loading *ngIf="(!loaded && !failedToLoad) || refreshingPage" [progress]="msgs.loadingPermissionsGroups()">\n    </page-loading>\n</div>\n\n<div class="page-content" *ngIf="loaded && !refreshingPage && groups.length > 0">\n    <mat-card class="search-bar-card">\n        <mat-card-content>\n            <search-bar #searchBar [data]="groupNames" [searchPlaceholder]="msgs.searchForAGroup()" [searchLabel]="msgs.groupName()" (filteredData)="updateFilteredData($event)"></search-bar>\n        </mat-card-content>\n    </mat-card>\n\n    <div *ngIf="pagedGroups.length === 0" class="no-matches-error-message">{{ msgs.noGroupMatchesSearch() }}</div>\n\n    <div class="permission-title" *ngIf="pagedGroups.length > 0">{{ msgs.permissionGroups() }} {{ rangeLabel }}</div>\n\n    \x3c!-- Permission Group Cards --\x3e\n    <mat-accordion>\n        <mat-expansion-panel class="perms-main" hideToggle *ngFor="let group of pagedGroups; let i = index" (afterExpand)="handlePanelChange(group, group.id, true)" (closed)="handlePanelChange(undefined, group.id, false)" [expanded]="expandedPanels[group.id]">\n            <mat-expansion-panel-header class="perm-header">\n                <mat-panel-title class="perm-title">\n                    {{ group.name }}\n                </mat-panel-title>\n                <mat-panel-description class="perm-description">\n                    {{ group.description }}\n                </mat-panel-description>\n                <div class="updating" *ngIf="updating[group.id]">\n                    <mat-spinner mode="indeterminate" diameter="20"></mat-spinner>\n                </div>\n                <div class="icons">\n                    <icon-total class="azure-icon" *ngIf="group.numExternalMappings > 0" [primaryColor]="false" [icon]="\'fa-cloud\'"></icon-total>\n                    <icon-total *ngIf="group.numUsers > 0" [primaryColor]="false" [icon]="\'fa-user-circle\'" [number]="group.numUsers"></icon-total>\n                </div>\n            </mat-expansion-panel-header>\n\n            \x3c!-- Permission Card Content --\x3e\n            <ng-template matExpansionPanelContent>\n                <perm-group-card-content *ngIf="!updating[group.id] && groupData[group.id]" [group]="groupData[group.id]" [users]="users" [orchids]="orchids" [plugins]="plugins" [groups]="groupNamesIds" [externalProviders]="externalProviders" (removeGroup)="removeGroup($event)" (editGroup)="refreshPageData(group.id, $event)">\n                </perm-group-card-content>\n                \x3c!-- If data is not available --\x3e\n                <div [@openClose] *ngIf="failedToUpdate[group.id]" class="permission-groups-error-message">\n                    {{ msgs.failedToLoadPermissionGroup() }}\n                </div>\n            </ng-template>\n        </mat-expansion-panel>\n    </mat-accordion>\n\n    \x3c!-- Pagination of groups --\x3e\n    <pagination class="permissions-paginator" (page)="handlePageEvent($event)" [dataSource]="filteredGroups" (pagedData)="updatePagedData($event)" [pageSize]="pageSize" [pageSizeOptions]="pageSizeOptions">\n    </pagination>\n</div>\n\n<div *ngIf="loaded && groups.length === 0" class="permission-groups-error-message">\n    {{ msgs.noPermissionsGroupsExist() }}\n</div>\n'
        }
        ,
        76752: e => {
            e.exports = '<navigation display="left"></navigation>\n\n<section class="permissions-page">\n    <section class="permissions-groups">\n        <div *ngIf="failedToLoad" class="permission-groups-error-message">\n            {{ msgs.failedToLoadPermissionGroups() }}\n        </div>\n        <perm-group-page *ngIf="!failedToLoad" [loaded]="loaded" [users]="users" [groups]="groups" [groupNamesIds]="groupNamesIds" [orchids]="orchids" [plugins]="plugins" (newGroup)="reloadGroups()"></perm-group-page>\n    </section>\n</section>\n'
        }
        ,
        93936: e => {
            e.exports = '<div class="button-container" [class.active]="!isMuted">\n    \x3c!-- Mute / unmute button --\x3e\n    <button class="mic-toggle-button fa-stack fa-lg" [class.primary-hover]="canUnmute" (click)="isMuted ? onTalk() : onMute()" [disabled]="fetchingTrack || (isEnabled && (noMicrophonePermission || inputDeviceUnavailable))">\n        <i class="fa-circle fa-stack-2x" [class.active]="isEnabled" [class.microphone-permission-denied]="fetchingTrack || noMicrophonePermission || inputDeviceUnavailable" [ngClass]="microphoneIconClass"></i>\n        <i class="fa-solid fa-stack-1x" [class.fa-microphone]="isEnabled && !isMuted && !fetchingTrack" [class.fa-microphone-slash]="isEnabled && isMuted && !fetchingTrack"></i>\n        <mat-spinner class="fetching-track-spinner" mode="indeterminate" diameter="25" *ngIf="fetchingTrack"></mat-spinner>\n    </button>\n\n    \x3c!-- Input selector button --\x3e\n    <button class="mic-select-button fa-stack fa-lg primary-hover" (click)="onMicrophoneSelect()" *ngIf="isEnabled" [matBadgeHidden]="!noMicrophonePermission && !inputDeviceUnavailable" matBadge="!" matBadgeColor="warn" matBadgeOverlap="true" [matTooltip]="selectorWarningTooltip" matTooltipPosition="above" matTooltipShowDelay="800" [matTooltipDisabled]="!noMicrophonePermission && !inputDeviceUnavailable">\n        <i class="fa-light fa-gear fa-stack-1x"></i>\n        <i class="fa-regular fa-circle fa-stack-2x"></i>\n    </button>\n\n    \x3c!-- Close overlay button --\x3e\n    <button (click)="disableOverlay()" class="close-overlay-button fa-stack fa-lg primary-hover" *ngIf="isEnabled">\n        <i class="fa-light fa-xmark fa-stack-1x"></i>\n        <i class="fa-regular fa-circle fa-stack-2x"></i>\n    </button>\n</div>\n'
        }
        ,
        52515: e => {
            e.exports = '<mat-card>\n    <mat-spinner *ngIf="loading" class="loading-spinner" mode="indeterminate" diameter="40"></mat-spinner>\n\n    <span *ngIf="loading" class="loading-close-button">\n        <button (click)="close()" class="close-button">\n            <i class="fa-regular fa-xmark"></i>\n        </button>\n    </span>\n\n    <mat-card-content [ngStyle]="{\'visibility\': loading ? \'hidden\' : \'visible\'}">\n        <div class="close-button-container">\n            <span class="select-microphone-text">{{ msgs.selectMicrophone() }}</span>\n            <button (click)="close()" class="close-button">\n                <i class="fa-regular fa-xmark"></i>\n            </button>\n        </div>\n\n        <mat-form-field appearance="outline">\n            <mat-select [formControl]="selectedMicrophone" (selectionChange)="setNewMicrophone($event.value)" (openedChange)="onSelectOpenedChange($event)">\n                <mat-option *ngFor="let micOption of micOptions" [value]="micOption">\n                    {{ micOption.label.length > 0 ? micOption.label : msgs.unknownDevice() }}\n                </mat-option>\n            </mat-select>\n        </mat-form-field>\n    </mat-card-content>\n</mat-card>\n'
        }
        ,
        84091: e => {
            e.exports = '<div class="dialog-content">\n    <i class="fa-solid fa-microphone-slash fa-2x"></i>\n    <span class="text-span-1">{{ msgs.noDeviceFound() }}</span>\n    <span class="text-span-2">{{ msgs.oneOrMoreMicrophonesAreRequiredToGrantPermissions() }}</span>\n    <span class="text-span-3">{{ msgs.verifyMicrophoneIsPluggedIn() }}</span>\n</div>\n'
        }
        ,
        79117: e => {
            e.exports = '<div class="dialog-content">\n    <i class="fa-solid fa-microphone-slash fa-2x"></i>\n    <span class="text-span-1">{{ msgs.microphoneInaccessible() }}</span>\n    <span class="text-span-2">{{ msgs.APPNAMERequiresMicrophoneAccess() }}</span>\n    <span class="text-span-3">{{ msgs.youMayConfigureTheMicrophonePermission() }}</span>\n</div>\n'
        }
        ,
        21766: e => {
            e.exports = '<div #meter class="meter">\n    <div #left class="bar bar--lo"></div>\n    <div #middle class="bar bar--md"></div>\n    <div #right class="bar bar--hi"></div>\n</div>\n'
        }
        ,
        46408: e => {
            e.exports = "{{ error?.reason }}\n"
        }
        ,
        39646: e => {
            e.exports = "<mat-spinner></mat-spinner>\n"
        }
        ,
        95642: e => {
            e.exports = '<svg class="motion-regions-overlay__svg" preserveAspectRatio="none" viewBox="0 0 320 240" width="100%" height="100%">\n    <polygon *ngFor="let region of regionsData.regions" [attr.points]="parsePoints(region.vertices)" class="motion-regions-overlay__region"></polygon>\n</svg>\n'
        }
        ,
        24704: e => {
            e.exports = "<ng-content select=\"[toolbar]\"></ng-content>\n\n<video #videoPlayer playsinline [style.display]=\"source?.targetElementType ==='video' ? 'block' : 'none'\" muted=\"muted\">\n</video>\n\n<canvas #canvasPlayer [style.display]=\"source?.targetElementType === 'video' ? 'none' : 'block'\">\n</canvas>\n\n<ng-content select=\"[overlays]\"></ng-content>\n\n<ng-content select=\"[tools]\"></ng-content>\n"
        }
        ,
        37407: e => {
            e.exports = '<span class="fa-stack fa-lg player-frame-download-button" (click)="downloadFrame()">\n    <i class="fa-regular fa-circle fa-stack-2x"></i>\n    <i class="fa-regular fa-image fa-stack-1x"></i>\n</span>\n'
        }
        ,
        45386: e => {
            e.exports = '<span (click)="clear()" class="fa-stack fa-lg trash" [hidden]="regionCount === 0">\n    <i class="fa-regular fa-trash-can fa-stack-1x"></i>\n    <i class="fa-regular fa-circle fa-stack-2x"></i>\n</span>\n<span (click)="filter()" class="fa-stack fa-lg filter" [matBadge]="regionCount" matBadgeOverlap="true" matBadgeColor="accent" [matBadgeHidden]="regionCount === 0">\n    <i class="fa fa-filter fa-stack-1x"></i>\n    <i class="fa-regular fa-circle fa-stack-2x"></i>\n</span>\n'
        }
        ,
        14507: e => {
            e.exports = '<div class="toolbar">\n    <button *ngIf="isVertexActive" (click)="onDeleteVertex()"><i class="fa fa-times"></i></button>\n</div>\n<svg id="smart-search" #SVG preserveAspectRatio="xMidYMid meet" width="100%" height="100%">\n</svg>\n<div id="help" #help *ngIf="regionBounds.length === 0" class="help center hidden-control">\n\n    {{ msgs.drawRegionsToFilterForMotionInTheSpecifiedAreas() }}\n</div>\n'
        }
        ,
        79549: e => {
            e.exports = '<div #thumbnail matRipple (click)="clickPreview()" class="preview-container">\n    <div class="header-items">\n        <span class="time-text">{{ time | date: \'HH:mm\' }}</span>\n        <i class="fa-solid fa-chevron-right" *ngIf="state !== ComponentState.LOADING && type === PreviewType.HOUR"></i>\n        <div class="play-button-container" *ngIf="state !== ComponentState.LOADING && type === PreviewType.MINUTE">\n            <span class="fa-stack fa-1x">\n                <i class="fa-regular fa-circle fa-stack-2x"></i>\n                <i class="fa-solid fa-play fa-stack-1x"></i>\n            </span>\n        </div>\n    </div>\n    <div class="preview-image-container" [class.dark-background]="state === ComponentState.LOADED">\n        <img [class.hide-element]="hideThumbnailImage()" class="preview-image">\n        <mat-spinner [class.hide-element]="state !== ComponentState.LOADING" diameter="75"></mat-spinner>\n        <i class="fa-regular fa-frown" [class.hide-element]="hideFrownyFace()"></i>\n        <div class="motion-event-count-container" *ngIf="state !== ComponentState.LOADING && type === PreviewType.HOUR">\n            <span class="motion-event-count">\n                {{ numMinutePreviews }}\n            </span>\n        </div>\n    </div>\n</div>\n'
        }
        ,
        86781: e => {
            e.exports = '<div class="thumbnail-search-control-container" (click)="clickThumbnailSearchControl()">\n    <span class="fa-stack fa-lg filter">\n        <i class="fa-regular fa-table-cells-large fa-stack-1x"></i>\n        <i class="fa-regular fa-circle fa-stack-2x"></i>\n    </span>\n</div>\n'
        }
        ,
        36311: e => {
            e.exports = '<div class="overlay-card" #overlayCard>\n    <div class="header" #overlayHeader>\n        <div class="filtering-by-region-container" *ngIf="smartSearchActive">\n            <span class="filtering-by-region-text">\n                <i class="fa fa-filter"></i>\n                {{ msgs.filteringByRegion() }}\n            </span>\n        </div>\n\n        <div class="calendar-and-close-container">\n            <mat-form-field appearance="fill">\n                <mat-label>{{ msgs.chooseADate() }}</mat-label>\n                <input matInput [matDatepicker]="picker" [(ngModel)]="selectedDate" (dateChange)="setSelectedDate(selectedDate)">\n                <mat-datepicker-toggle class="datepicker-toggle" matIconSuffix [for]="picker"></mat-datepicker-toggle>\n                <mat-datepicker class="datepicker" #picker [dateClass]="dateClass" [calendarHeaderComponent]="thumbnailSearchCalendarHeader" (monthSelected)="handleMonthChange($event)">\n                </mat-datepicker>\n            </mat-form-field>\n            <i matRipple [matRippleCentered]="true" class="fa fa-times close-button" (click)="closeButtonClick()"> </i>\n        </div>\n\n        <div class="controls-container">\n            <div class="back-button-container">\n                <button class="back-button" *ngIf="thumbnailSearchState === ThumbnailSearchState.MINUTELY" (click)="backButtonClick()" mat-button>\n                    <i class="fa-light fa-chevron-left"> </i>\n                    <span class="back-button-text">\n                        {{ msgs.hourlyOverview() }}\n                    </span>\n                </button>\n            </div>\n\n            <div class="thumbnail-sizers-container">\n                <button mat-button [color]="thumbnailSizeState === ThumbnailSize.LARGE ? \'primary\' : \'\'" class="thumbnails-button-container thumbnail-large-sizer" [class.mat-raised-button]="thumbnailSizeState === ThumbnailSize.LARGE" (click)="toggleThumbnailSize(ThumbnailSize.LARGE)">\n                    <i class="fa fa-square"></i>\n                </button>\n\n                <button mat-button [color]="thumbnailSizeState === ThumbnailSize.SMALL ? \'primary\' : \'\'" class="thumbnails-button-container thumbnail-small-sizer" [class.mat-raised-button]="thumbnailSizeState === ThumbnailSize.SMALL" (click)="toggleThumbnailSize(ThumbnailSize.SMALL)">\n                    <i class="fa fa-th-large"></i>\n                </button>\n            </div>\n        </div>\n\n        <div class="hint-text-container">\n            <span class="hint-text">\n                {{ getHintText() }}\n            </span>\n        </div>\n    </div>\n\n    <div class="thumbnail-containers-container" [@hourlyMinutely]="getAnimationState()" (@hourlyMinutely.start)="handleStartOfSlideAnimation($event)" (@hourlyMinutely.done)="handleEndOfSlideAnimation($event)">\n        <div class="thumbnail-container">\n            <p class="no-thumbnails-message no-matches-error-message" *ngIf="showNoPreviewsMessage(ThumbnailSearchState.HOURLY)">\n                {{ msgs.noPreviewsAvailable() }}\n            </p>\n            <div #hoursSpinner class="spinner-container">\n                <mat-spinner class="spinner"> </mat-spinner>\n            </div>\n            <div *ngIf="previewsReady" #hoursContainer class="thumbnail-container-content hours-container" [class.thumbnail-container-content-large]="thumbnailSizeState === ThumbnailSize.LARGE" [class.thumbnail-container-content-small]="thumbnailSizeState === ThumbnailSize.SMALL">\n                <thumbnail *ngFor="let preview of hourThumbnailsToRender" id="thumbnail-hour-{{ preview.timeToJumpTo }}" (clickThumbnail)="handlePreviewClick($event)" [numEvents]="preview.numEvents" [time]="preview.time" [timeToJumpTo]="preview.timeToJumpTo" [type]="PreviewType.HOUR" [numMinutePreviews]="preview.numMinutePreviews" (onLoad)="handleThumbnailLoad()"></thumbnail>\n            </div>\n        </div>\n\n        <div class="thumbnail-container">\n            <p class="no-thumbnails-message no-matches-error-message" *ngIf="showNoPreviewsMessage(ThumbnailSearchState.MINUTELY)">\n                {{ msgs.noPreviewsAvailable() }}\n            </p>\n            <div #minutesSpinner class="minutes-spinner-container">\n                <mat-spinner class="spinner"> </mat-spinner>\n            </div>\n            <div #minutesContainer class="thumbnail-container-content minutes-container" [class.thumbnail-container-content-large]="thumbnailSizeState === ThumbnailSize.LARGE" [class.thumbnail-container-content-small]="thumbnailSizeState === ThumbnailSize.SMALL">\n                <thumbnail *ngFor="let preview of minuteThumbnailsToRender" id="thumbnail-minute-{{ preview.timeToJumpTo }}" (clickThumbnail)="handlePreviewClick($event)" [numEvents]="preview.numEvents" [time]="preview.time" [timeToJumpTo]="preview.timeToJumpTo" [type]="PreviewType.MINUTE" [numMinutePreviews]="preview.numMinutePreviews" (onLoad)="handleThumbnailLoad()"></thumbnail>\n            </div>\n        </div>\n    </div>\n</div>\n'
        }
        ,
        5333: e => {
            e.exports = '<div class="height-container" [style.aspectRatio]="aspectRatio">\n    <div class="width-container" [style.aspectRatio]="aspectRatio" [style.position]="relativeContainer ? \'relative\' : null">\n        <ng-content></ng-content>\n    </div>\n</div>\n'
        }
        ,
        47847: e => {
            e.exports = '<i class="fa fa-lg left-aligned" [ngClass]="buttonClass" (click)="doVolumeChange()"></i>\n'
        }
        ,
        8703: e => {
            e.exports = '<div class="recorder-perm-groups" [ngClass]="{ \'recorder-perm-groups--has-error\': !valid }">\n    <span class="recorder-perm-groups__header">\n        <i class="fa fa-users"></i>\n        <div class="recorder-perm-groups__header-copy">\n            <span class="recorder-perm-groups__headline label-medium">{{ msgs.headline() }}</span>\n            <span class="recorder-perm-groups__subheader label-tiny hint-text">{{ msgs.subheader() }}</span>\n        </div>\n    </span>\n\n    \x3c!-- Load spinner --\x3e\n    <mat-spinner class="recorder-perm-groups__spinner" *ngIf="loading" mode="indeterminate" diameter="16"></mat-spinner>\n\n    \x3c!-- Autocomplete chip list selector --\x3e\n    <autocomplete-chip-input class="recorder-perm-groups__autocomplete-chip-input" *ngIf="!loading && editable" [formGroup]="groupIdsControl" [data]="groups" [dataName]="msgs.inputLabel()" [valid]="valid" [invalidPrompt]="msgs.error()" [placeholderChip]="msgs.placeholderChip()" (keydown.enter)="handleKeydownEnter($event)"></autocomplete-chip-input>\n    \x3c!-- <mat-error class="recorder-perm-groups__error body-small" *ngIf="!valid">{{ msgs.error() }}</mat-error> --\x3e\n\n    \x3c!-- Read-only chip list --\x3e\n    <chip-list class="recorder-perm-groups__chip-list" *ngIf="!loading && !editable" [listType]="\'chip\'" [data]="groups" [emptyMessageInput]="msgs.empty()"></chip-list>\n</div>\n'
        }
        ,
        52467: e => {
            e.exports = '<mat-toolbar color="primary">\n    <span mat-dialog-title class="toolbar-title">{{ msgs.updateOrchidServerSettings({ VALUE: recorderName }) }}\n    </span>\n\n    <button class="add-lib-x-button" mat-icon-button disableRipple="true" (click)="cancel()" [disabled]="processing">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content>\n    <form class="recorder-edit-form" [formGroup]="formGroup" (keydown.enter)="update()">\n        \x3c!-- Name --\x3e\n        <mat-form-field class="form__field form__field--server-name">\n            <mat-label>{{ msgs.serverName() }}</mat-label>\n            <input matInput cdkFocusInitial #serverName type="text" formControlName="name" maxlength="99" required>\n            <mat-error>{{ msgs.serverNameIsRequired() }}</mat-error>\n            <mat-hint align="end">{{serverName.value.length}}/99</mat-hint>\n        </mat-form-field>\n\n        <recorder-perm-groups *ngIf="showManagementGroups" [recorderId]="recorder.id" [editable]="true" (selectionChange)="handlePermGroupsSelectionChange($event)"></recorder-perm-groups>\n    </form>\n</mat-dialog-content>\n\n\x3c!-- Dialog Error --\x3e\n<sing-dialog-errors class="error-banner" *ngIf="showError" (onClose)="dismissMe()" [errmsg]="error">\n</sing-dialog-errors>\n\n<mat-dialog-actions>\n    <div class="main-buttons">\n\n        <button mat-button (click)="cancel()" [disabled]="processing">{{ msgs.cancel() }}</button>\n\n        <spinner-button class="submit-recorder" [disabled]="formGroup.invalid" [text]="msgs.update()" [color]="\'primary\'" (click)="update()" [showSpinner]="processing" type="submit"></spinner-button>\n\n    </div>\n</mat-dialog-actions>\n'
        }
        ,
        49240: e => {
            e.exports = '<div class="mapping-summary-table">\n    <div class="mapping-summary-table-header">\n        <div class="old-cameras-header">\n            <span class="header-text">\n                {{ msgs.cameraMappingTable.oldCameras() }}\n            </span>\n        </div>\n\n        <div class="new-cameras-header">\n            <span class="header-text">\n                {{ msgs.cameraMappingTable.newCameras() }}\n            </span>\n        </div>\n\n        <div class="actions-header" (click)="toggleActionSort()">\n            <span class="header-text">\n                {{ msgs.cameraMappingTable.actions() }}\n            </span>\n            <i class="fa fa-xs" [ngClass]="sortActionsDescending ? \'fa-arrow-down\' : \'fa-arrow-up\'"></i>\n        </div>\n    </div>\n\n    <div class="mapping-summary-field" *ngFor="let field of paginatedMappingFields">\n        <div class="field-section old-camera-section">\n            <div class="section-details" *ngIf="field.filterType !== filterEnum.ADD">\n                <span class="section-name" [class.deleted-status-text]="field.filterType === filterEnum.DELETE">\n                    {{ field.oldCamera.name }}\n                </span>\n                <span class="section-ip" [class.deleted-status-text]="field.filterType === filterEnum.DELETE">\n                    {{ field.oldCamera.ipAddress }}\n                </span>\n            </div>\n            <i class="fa-regular arrow-icon" [class.fa-arrow-right]="field.filterType === filterEnum.MIGRATE" [class.mapped-status-text]="field.filterType === filterEnum.MIGRATE" [class.fa-minus]="field.filterType === filterEnum.DELETE" [class.deleted-status-text]="field.filterType === filterEnum.DELETE" [class.fa-plus]="field.filterType === filterEnum.ADD" [class.new-status-text]="field.filterType === filterEnum.ADD"></i>\n        </div>\n        <div class="field-section new-camera-section">\n            <div class="section-details mobile-deleted-camera-info" *ngIf="field.filterType === filterEnum.DELETE">\n                <span class="section-name deleted-status-text">\n                    {{ field.oldCamera.name }}\n                </span>\n                <span class="section-ip deleted-status-text">\n                    {{ field.oldCamera.ipAddress }}\n                </span>\n            </div>\n            <div class="section-details" *ngIf="field.filterType !== filterEnum.DELETE">\n                <span class="section-name">\n                    {{ field.newCamera.name }}\n                </span>\n                <span class="section-ip">\n                    {{ field.newCamera.ipAddress }}\n                </span>\n            </div>\n        </div>\n        <div class="action-section">\n            <div class="chip" [class.deleted-status]="field.filterType === filterEnum.DELETE" [class.mapped-status]="field.filterType === filterEnum.MIGRATE" [class.new-status]="field.filterType === filterEnum.ADD">\n                <span class="chip-text deleted-status-text" *ngIf="field.filterType === filterEnum.DELETE">\n                    {{ msgs.cameraMappingSummary.remove() }}\n                </span>\n                <span class="chip-text mapped-status-text" *ngIf="field.filterType === filterEnum.MIGRATE">\n                    {{ msgs.cameraMappingSummary.migrate() }}\n                </span>\n                <span class="chip-text new-status-text" *ngIf="field.filterType === filterEnum.ADD">\n                    {{ msgs.cameraMappingSummary.add() }}\n                </span>\n            </div>\n        </div>\n    </div>\n\n    <mat-paginator class="paginator" showFirstLastButtons [pageSizeOptions]="pageSizeOptions" [pageSize]="pageSize" [pageIndex]="pageIndex" [length]="allMappingFields.length" (page)="onPaginatorChange($event)">\n    </mat-paginator>\n</div>\n'
        }
        ,
        25520: e => {
            e.exports = '\x3c!-- Mapping buttons --\x3e\n<div class="mapping-function-buttons">\n    <div class="map-by-ip-and-name-container">\n        <button mat-stroked-button (click)="mapCamerasByName()">\n            <i class="fa-light fa-arrow-right-arrow-left"></i>\n            <span>{{ msgs.cameraMappingTable.mapByName() }}</span>\n        </button>\n\n        <button mat-stroked-button (click)="mapCamerasByIp()">\n            <i class="fa-light fa-arrow-right-arrow-left"></i>\n            <span>{{ msgs.cameraMappingTable.mapByIp() }}</span>\n        </button>\n\n        <span class="num-cams-mapped-message" *ngIf="showNumCamsMsg" [ngClass]="numCamsMapped > 0 ? \'success-green-text\' : \'error-red-text\'" [@fadeInOut]>\n            {{ numCamsMsg }}\n        </span>\n    </div>\n\n    <button mat-stroked-button (click)="clearAll()" class="clear-all-mappings-button">\n        {{ msgs.cameraMappingTable.clearAll() }}\n    </button>\n\n\n</div>\n\n\x3c!-- Search Bar --\x3e\n<div class="search-bar-container">\n    <search-bar [data]="oldCameras" [searchPlaceholder]="msgs.cameraMappingTable.searchOldCameras()" [selectorFunction]="getCameraNameAndAddress" (filteredData)="onOldCameraSearchChanged($event)"></search-bar>\n</div>\n\n\x3c!-- Camera map table header --\x3e\n<div class="camera-map-header">\n    <div class="old-cameras-header cameras-header">\n        <span>\n            {{ msgs.cameraMappingTable.oldCameras() }}\n        </span>\n        <span class="diy-badge" [class.warn-orange]="countOldCamerasUnmapped > 0" [class.success-green]="countOldCamerasUnmapped === 0">\n            {{ msgs.VALUEUnmapped({ VALUE: countOldCamerasUnmapped }) }}\n        </span>\n    </div>\n    <div class="new-cameras-header cameras-header">\n        <span>{{ msgs.cameraMappingTable.newCameras() }}</span>\n        <span class="diy-badge neutral-badge">\n            {{ msgs.VALUEUnmapped({ VALUE: countCamerasToAdd }) }}\n        </span>\n    </div>\n</div>\n\n<div class="search-matched-no-cams-container" *ngIf="oldCamerasPaginated.length === 0">\n    <span class="no-matches-error-message">\n        {{ msgs.cameraMappingTable.noCamerasMatchTheSearch() }}\n    </span>\n</div>\n\n\x3c!-- Table --\x3e\n<div class="camera-map-option" *ngFor="let oldCamera of oldCamerasPaginated">\n    <div class="old-camera-info">\n        <div class="old-camera-name-and-address">\n            <div class="old-camera-name camera-name">{{ oldCamera.name }}</div>\n            <div class="old-camera-address camera-address">{{ oldCamera.configuration.IPAddress }}</div>\n        </div>\n        <i class="fa-regular fa-arrow-right arrow-icon"></i>\n    </div>\n\n    \x3c!-- Repeated individual mapping rows --\x3e\n    <div class="new-camera-select">\n        <mat-form-field appearance="fill">\n            <div class="formatted-option-text" *ngIf="oldCamera.mappedCameraId">\n                <span class="option-name">{{ getNewCameraNameById(oldCamera.mappedCameraId) }}</span>\n                <span class="option-address">{{ getNewCameraAddressById(oldCamera.mappedCameraId) }}</span>\n            </div>\n\n            <input matInput #inputRef type="text" [style.display]="oldCamera.mappedCameraId ? \'none\' : \'\'" placeholder="{{ oldCamera.mappedCameraId ? \'\' : msgs.cameraMappingTable.noCameraSelected() }}" [matAutocomplete]="auto" [value]="oldCamera.mappedCameraId ? oldCamera.mappedCameraId : \'\'" (blur)="inputRef.value = \'\'">\n            <mat-autocomplete (optionSelected)="onNewCameraSelect($event, oldCamera)" class="advanced-recovery-autocomplete-custom-class" classList="advanced-recovery-autocomplete-custom-class" #auto="matAutocomplete">\n                <mat-option *ngFor="let newCamera of getCameraOptions(oldCamera.mappedCameraId, inputRef.value)" [value]="newCamera">\n                    <span class="option-name">{{ newCamera.name }}</span>\n                    <span class="option-address">\n                        {{ newCamera.configuration.IPAddress ?? newCamera.configuration.BaseUri }}\n                    </span>\n                </mat-option>\n                <mat-option *ngIf="getCameraOptions(oldCamera.mappedCameraId).length === 0" disabled="disabled">\n                    <span>{{ msgs.cameraMappingTable.noNewCamerasToMap() }}</span>\n                </mat-option>\n            </mat-autocomplete>\n        </mat-form-field>\n\n        <button mat-icon-button *ngIf="oldCamera.mappedCameraId" class="clear-mapping-button" disableRipple="true" (click)="clearMapping(oldCamera, inputRef)">\n            <i class="fa-regular fa-xmark"></i>\n        </button>\n    </div>\n</div>\n\n<mat-paginator class="paginator" showFirstLastButtons [pageSizeOptions]="pageSizeOptions" [pageSize]="pageSize" [pageIndex]="pageIndex" [length]="oldCamerasFiltered.length" (page)="onPaginatorChange($event)">\n</mat-paginator>\n'
        }
        ,
        74694: e => {
            e.exports = '<mat-toolbar class="recorder-recovery-dialog-toolbar" color="primary">\n    <span mat-dialog-title class="dialog-title">\n        {{ msgs.recoverVALUE({ VALUE: dialogData.recorder.name })}}\n    </span>\n\n    <button mat-icon-button mat-dialog-close [disabled]="processing" disableRipple="true" tabindex="-1">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content>\n    <mat-stepper #stepper>\n        \x3c!-- Initial recorder recovery --\x3e\n        <mat-step>\n            <form [formGroup]="recoveryForm" class="basic-recovery-form">\n                \x3c!-- Recorder URL form field --\x3e\n                <mat-form-field class="recorder-url" appearance="standard">\n                    <mat-label>\n                        {{ msgs.recorderUrl() }}\n                    </mat-label>\n                    <input matInput formControlName="url" required>\n                    <mat-error *ngIf="urlFormControl.invalid">\n                        {{ msgs.aValidHttpOrHttpsUrlIsRequired() }}\n                    </mat-error>\n                </mat-form-field>\n\n                \x3c!-- Username and password form fields --\x3e\n                <div class="username-and-password">\n                    <mat-form-field class="username-field" appearance="standard">\n                        <mat-label>\n                            {{ msgs.username() }}\n                        </mat-label>\n                        <input matInput formControlName="username" required>\n                        <mat-error *ngIf="usernameFormControl.invalid">\n                            {{ msgs.usernameIsRequired() }}\n                        </mat-error>\n                    </mat-form-field>\n\n                    <password-form-field class="password-field" formControlName="password" label="{{ msgs.password() }}" errorMessage="{{ msgs.passwordIsRequired() }}" [required]="true"></password-form-field>\n                </div>\n            </form>\n        </mat-step>\n\n        \x3c!-- Recovery summary & camera mapping --\x3e\n        <mat-step>\n            <recovery-summary *ngIf="stepIndex === 1" [oldRecorder]="currentRecorderSummary" [newRecorder]="newRecorderSummary"></recovery-summary>\n\n            <mat-card class="camera-map-card">\n                <mat-card-title class="camera-map-card-title">\n                    {{ msgs.cameraMapping() }}\n                </mat-card-title>\n\n                <mat-card-subtitle class="camera-map-card-subtitle">\n                    {{ msgs.cameraMappingNoticeMessage() }}\n                </mat-card-subtitle>\n\n                <camera-mapping-table [(oldCameras)]="oldCameras" [(newCameras)]="newCameras" [(mappedCameraIds)]="mappedCameraIds" (stateChange)="generateMappingSummary()" newRecorderSummary></camera-mapping-table>\n            </mat-card>\n        </mat-step>\n\n        \x3c!-- Final confirmation step --\x3e\n        <mat-step>\n            <recovery-summary *ngIf="stepIndex === 2" [readOnly]="true" [readData]="newRecorderSummary" [countCamerasToAdd]="countCamerasToAdd" [countCamerasToMigrate]="countCamerasToMigrate" [countCamerasToRemove]="countCamerasToRemove"></recovery-summary>\n\n            <mat-card class="camera-map-summary-card" *ngIf="stepIndex === 2">\n                <alert-banner class="mapping-summary-alert-banner" *ngIf="countCamerasToRemove > 0 && newRecorderSummary.recorderCameraCount > 0" [type]="\'warning\'" [faIcon]="\'triangle-exclamation\'">\n                    {{ msgs.thereAreVALUEUnmappedOldCamerasThatWillBeRemoved({ VALUE: countCamerasToRemove }) }}\n                </alert-banner>\n\n                <alert-banner class="mapping-summary-alert-banner" *ngIf="newRecorderSummary.recorderCameraCount === 0 && currentRecorderSummary.recorderCameraCount > 0" [title]="msgs.warning()" [type]="\'warning\'" [faIcon]="\'triangle-exclamation\'">\n                    {{ msgs.newRecorderHasNoCamerasWarning() }}\n                </alert-banner>\n\n                <camera-mapping-summary *ngIf="newCameras.length > 0 || oldCameras.length > 0" [mappingData]="mappingSummary" [newCameras]="newCameras" [oldCameras]="oldCameras"></camera-mapping-summary>\n            </mat-card>\n        </mat-step>\n    </mat-stepper>\n</mat-dialog-content>\n\n<sing-dialog-errors *ngIf="errorMessage.length > 0" (onClose)="errorMessage = \'\'" [errmsg]="errorMessage"></sing-dialog-errors>\n\n<mat-dialog-actions>\n    \x3c!-- Cancel button, only present on the basic recovery step --\x3e\n    <button *ngIf="stepIndex === 0; else backButton" mat-button mat-dialog-close class="cancel-button" color="primary" [disabled]="processing">\n        {{ msgs.cancel()}}\n    </button>\n\n    <ng-template #backButton>\n        <button mat-button color="primary" (click)="previousStep()" [disabled]="processing">\n            {{ msgs.back() }}\n        </button>\n    </ng-template>\n\n    <button *ngIf="stepIndex !== 2; else confirmButton" mat-raised-button color="primary" (click)="stepIndex === 0 ? recoverRecorder() : nextStep()" [disabled]="recoveryForm.invalid || processing">\n        <div [ngStyle]="{\'visibility\': processing ? \'hidden\' : \'visible\'}">\n            <span>{{ msgs.next() }}</span>\n        </div>\n        <mat-spinner class="processing-spinner" *ngIf="processing" mode="indeterminate" diameter="16"></mat-spinner>\n    </button>\n\n    <ng-template #confirmButton>\n        <button mat-raised-button color="primary" (click)="recoverRecorderWithMappings()" [disabled]="processing">\n            <div [ngStyle]="{\'visibility\': processing ? \'hidden\' : \'visible\'}">\n                <span>{{ msgs.confirm() }}</span>\n            </div>\n            <mat-spinner class="processing-spinner" *ngIf="processing" mode="indeterminate" diameter="16"></mat-spinner>\n        </button>\n    </ng-template>\n</mat-dialog-actions>\n'
        }
        ,
        66685: e => {
            e.exports = '<mat-card *ngIf="readOnly; else notReadOnly" class="recovery-summary-card read-only">\n    <div class="title-info">\n        <span class="recovery-summary-card-title">\n            {{ msgs.recoverySummary.confirmation() }}\n        </span>\n    </div>\n\n    <mat-card-content class="recovery-summary-card-content">\n        <div class="new-recorder-info recorder-info">\n            <div class="name-and-url-container">\n                <div class="recorder-name">\n                    <span class="recorder-name-title-text hint-text">\n                        {{ msgs.recoverySummary.serverName() }}\n                    </span>\n                    <span class="recorder-name-text body-text">\n                        {{ readData.recorderName }}\n                    </span>\n                </div>\n\n                <div class="recorder-url">\n                    <span class="recorder-url-title-text hint-text">\n                        {{ msgs.recoverySummary.serverUrl() }}\n                    </span>\n                    <a class="recorder-url-text body-text text-link" [href]="readData.recorderURL">\n                        {{ readData.recorderURL }}\n                    </a>\n                </div>\n            </div>\n\n            <div class="info-chips-container">\n                <div class="recorder-camera-count-label">\n                    <span class="recorder-camera-count-icon">\n                        <i class="fa fa-video-camera"></i>\n                    </span>\n                    <span class="recorder-camera-count-text body-text">\n                        {{ msgs.recoverySummary.totalCamerasVALUE({ VALUE: readData.recorderCameraCount })}}\n                    </span>\n                </div>\n\n                <div class="action-chips">\n                    <div class="chip to-delete-chip">\n                        <span class="to-delete-chip-text">\n                            {{ msgs.recoverySummary.VALUEToRemove({ VALUE: countCamerasToRemove }) }}\n                        </span>\n                    </div>\n\n                    <div class="chip to-migrate-chip">\n                        <span class="to-migrate-chip-text">\n                            {{ msgs.recoverySummary.VALUEToMigrate({ VALUE: countCamerasToMigrate }) }}\n                        </span>\n                    </div>\n\n                    <div class="chip to-add-chip">\n                        <span class="to-add-chip-text">\n                            {{ msgs.recoverySummary.VALUEToAdd({ VALUE: countCamerasToAdd }) }}\n                        </span>\n                    </div>\n                </div>\n            </div>\n\n        </div>\n    </mat-card-content>\n</mat-card>\n\n<ng-template #notReadOnly>\n    <mat-card class="recovery-summary-card">\n        <div class="title-info">\n            <span class="recovery-summary-card-title">\n                {{ msgs.recoverySummary.overview() }}\n            </span>\n            <span class="recovery-summary-card-subtitle hint-text">\n                {{ msgs.recoverySummary.summaryOfTheCurrentRecorderAndIncomingRecorder() }}\n            </span>\n        </div>\n\n        <mat-card-content class="recovery-summary-card-content">\n            <div class="current-recorder-info recorder-info">\n                <div class="current-recorder-label recorder-label">\n                    <span class="current-recorder-label-text recorder-label-text">\n                        {{ msgs.recoverySummary.oldRecorder() }}\n                    </span>\n                </div>\n\n                <div class="recorder-name">\n                    <span class="recorder-name-title-text hint-text">\n                        {{ msgs.recoverySummary.serverName() }}\n                    </span>\n                    <span class="recorder-name-text body-text">\n                        {{ oldRecorder.recorderName}}\n                    </span>\n                </div>\n\n                <div class="recorder-url">\n                    <span class="recorder-url-title-text hint-text">\n                        {{ msgs.recoverySummary.serverUrl() }}\n                    </span>\n                    <a class="recorder-url-text body-text text-link" [href]="oldRecorder.recorderURL">\n                        {{oldRecorder.recorderURL}}\n                    </a>\n                </div>\n\n                <div class="recorder-camera-count-label recorder-label">\n                    <span class="recorder-camera-count-icon">\n                        <i class="fa fa-video-camera"></i>\n                    </span>\n                    <span class="recorder-camera-count-text body-text">\n                        {{ msgs.recoverySummary.totalCamerasVALUE({ VALUE: oldRecorder.recorderCameraCount })}}\n                    </span>\n                </div>\n            </div>\n\n            <div class="new-recorder-info recorder-info">\n                <div class="new-recorder-label recorder-label">\n                    <span class="new-recorder-label-text recorder-label-text">\n                        {{ msgs.recoverySummary.newRecorder() }}\n                    </span>\n                </div>\n\n                <div class="recorder-name">\n                    <span class="recorder-name-title-text hint-text" *ngIf="!editNewRecorderName">\n                        {{ msgs.recoverySummary.serverName() }}\n                    </span>\n                    <div class="recorder-name-container">\n                        <span class="new-recorder-name-text recorder-name-text body-text">\n                            {{newRecorder.recorderName}}\n                        </span>\n                    </div>\n                </div>\n\n                <div class="recorder-url">\n                    <span class="recorder-url-title-text hint-text">\n                        {{ msgs.recoverySummary.serverUrl() }}\n                    </span>\n                    <a class="recorder-url-text body-text text-link" [href]="newRecorder.recorderURL">\n                        {{ newRecorder.recorderURL}}\n                    </a>\n                </div>\n\n                <div class="recorder-camera-count-label">\n                    <span class="recorder-camera-count-icon">\n                        <i class="fa fa-video-camera"></i>\n                    </span>\n                    <span class="recorder-camera-count-text body-text">\n                        {{ msgs.recoverySummary.totalCamerasVALUE({ VALUE: newRecorder.recorderCameraCount })}}\n                    </span>\n                </div>\n            </div>\n        </mat-card-content>\n    </mat-card>\n</ng-template>\n'
        }
        ,
        74962: e => {
            e.exports = '<mat-toolbar color="primary">\n    <span mat-dialog-title class="toolbar-title">{{ msgs.registerAOrAnVALUEServer({ VALUE: \'Orchid Recorder\' }) }}\n    </span>\n\n    <button class="add-lib-x-button" mat-icon-button disableRipple="true" (click)="cancel()" [disabled]="processing">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content>\n    <form class="register-recorder-form" [formGroup]="formGroup" (keydown.enter)="register()">\n        \x3c!-- Name --\x3e\n        <mat-form-field class="form__field form__field--server-name">\n            <mat-label>{{ msgs.serverName() }}</mat-label>\n            <input matInput cdkFocusInitial #serverName type="text" formControlName="name" maxlength="99" required>\n            <mat-error>{{ msgs.serverNameIsRequired() }}</mat-error>\n            <mat-hint align="end">{{serverName.value.length}}/99</mat-hint>\n        </mat-form-field>\n\n        \x3c!-- URI --\x3e\n        <mat-form-field class="form__field form__field--server-uri">\n            <mat-label>{{ msgs.serverUrl() }}</mat-label>\n            <input matInput #serverUrl type="text" formControlName="uri" required>\n            <mat-error>{{ msgs.aValidHttpOrHttpsUrlIsRequired() }}</mat-error>\n        </mat-form-field>\n\n        \x3c!-- Username --\x3e\n        <mat-form-field class="form__field form__field--username">\n            <mat-label>{{ msgs.username() }}</mat-label>\n            <input formControlName="username" matInput autocapitalize="off" autocorrect="off" required>\n            <mat-error>{{ msgs.usernameIsRequired() }}</mat-error>\n        </mat-form-field>\n\n        \x3c!-- Password --\x3e\n        <password-form-field class="form__field form__field--password" formControlName="password" label="{{ msgs.password() }}" [errorMessage]="msgs.passwordIsRequired()" [required]="true"></password-form-field>\n\n        <recorder-perm-groups class="register-recorder-form__perm-groups" *ngIf="showManagementGroups" [editable]="true" [preselectUserGroups]="true" (selectionChange)="handlePermGroupsSelectionChange($event)"></recorder-perm-groups>\n    </form>\n</mat-dialog-content>\n\n\x3c!-- Dialog Error --\x3e\n<sing-dialog-errors class="error-banner" *ngIf="showError" (onClose)="dismissMe()" [errmsg]="error">\n</sing-dialog-errors>\n\n<mat-dialog-actions>\n    <div class="main-buttons">\n        <button mat-button (click)="cancel()" [disabled]="processing">{{ msgs.cancel() }}</button>\n\n        <spinner-button class="submit-recorder" [disabled]="formGroup.invalid" [text]="msgs.register()" [color]="\'primary\'" (click)="register()" [showSpinner]="processing" type="submit"></spinner-button>\n    </div>\n</mat-dialog-actions>\n'
        }
        ,
        33851: e => {
            e.exports = '<navigation display="left"></navigation>\n<div class="page-content" *ngIf="{ operationInProgress: operationInProgress$ | async } as observables">\n    <div class="page-header-container">\n        <a class="server-return-container body-medium" (click)="navigateToServersPage()">\n            <i class="fa-solid fa-arrow-left"></i>\n            <span class="server-return-link">{{ msgs.backToServers() }}</span>\n        </a>\n        <span class="title-modal">{{ msgs.manageTags() }}</span>\n    </div>\n\n    <operation-in-progress *ngIf="observables.operationInProgress"></operation-in-progress>\n\n    <div class="data-control-buttons">\n        <div class="displayed-resource-toggles">\n            <button mat-flat-button [class.active-data]="displayedResource === TagResourceType.SERVER" (click)="changeDisplayedResource(TagResourceType.SERVER)">\n                {{ msgs.servers() }}\n            </button>\n            <button mat-flat-button [class.active-data]="displayedResource === TagResourceType.CAMERA" (click)="changeDisplayedResource(TagResourceType.CAMERA)">\n                {{ msgs.cameras() }}\n            </button>\n        </div>\n        <button *ngIf="componentState === ComponentState.LOADED" mat-raised-button color="primary" class="new-bulk-tag-button" (click)="displayedResource === TagResourceType.SERVER ? addBulkRecorderTag() : addBulkCameraTag()">\n            <i class="{{ icons.add }}"></i>\n            <span *ngIf="displayedResource === TagResourceType.SERVER">{{ msgs.serverTag() }}</span>\n            <span *ngIf="displayedResource === TagResourceType.CAMERA">{{ msgs.cameraTag() }}</span>\n        </button>\n    </div>\n\n    \x3c!-- Set animationDuration to 0 to effectively disable the default tab group animation and use our own fade in/out instead --\x3e\n    <mat-tab-group [selectedIndex]="activeTab" dynamicHeight="true" animationDuration="0">\n        \x3c!-- Server tags tab --\x3e\n        <mat-tab>\n            <ng-container *ngIf="componentState === ComponentState.LOADED; else loadingServers">\n                <ng-container *ngIf="recorderTags.length > 0; else noServerTagsExist">\n                    <mat-card class="search-tools-card">\n                        <mat-form-field class="searchbar-container">\n                            <mat-label>{{ msgs.searchServerTags() }}</mat-label>\n                            <input matInput type="text" (keyup)="handleSearchKeyUp($event, TagResourceType.SERVER)">\n                        </mat-form-field>\n                        <div class="active-filters-container" *ngIf="recorderTagsFilters.length > 0">\n                            <filter-chip *ngFor="let filter of recorderTagsFilters; let filterIndex = index" [filter]="filter" (onRemove)="removeFilter(filterIndex, TagResourceType.SERVER)"></filter-chip>\n                            <button class="filters-reset-button body-small mat-delete" matRipple (click)="removeAllFilters(TagResourceType.SERVER)">\n                                {{ this.msgs.reset() }}\n                            </button>\n                        </div>\n                    </mat-card>\n                    <ng-container *ngIf="recorderTagsFiltered.length > 0; else noServerTagsFound">\n                        <summary-table [resourceType]="TagResourceType.SERVER" [tableData]="recorderTagsFiltered" (onResourceTagClick)="editBulkRecorderTag($event)"></summary-table>\n                    </ng-container>\n                    <ng-template #noServerTagsFound>\n                        <error-banner [type]="ERROR_TYPE.EMPTY_SEARCH_FILTERS"></error-banner>\n                    </ng-template>\n                </ng-container>\n                <ng-template #noServerTagsExist>\n                    <ng-container *ngIf="!recorderTagsError; else error">\n                        <error-banner [title]="msgs.noServerTagsHaveBeenCreated()" [type]="ERROR_TYPE.EMPTY_DATA" [icon]="icons.tag">\n                            <a class="body-small text-link" (click)="addBulkRecorderTag()">\n                                {{ msgs.createServerTag() }}\n                            </a>\n                        </error-banner>\n                    </ng-container>\n                    <ng-template #error>\n                        <error-banner [description]="recorderTagsError" [icon]="icons.error" [title]="msgs.failedToFetchServerTags()" [type]="ERROR_TYPE.CUSTOM_ERROR"></error-banner>\n                    </ng-template>\n                </ng-template>\n            </ng-container>\n            <ng-template #loadingServers>\n                <div class="loading-container">\n                    <mat-spinner diameter="16" color="primary"></mat-spinner>\n                    <span>{{ msgs.loadingServerTags() }}</span>\n                </div>\n            </ng-template>\n        </mat-tab>\n\n        \x3c!-- Camera tags tab --\x3e\n        <mat-tab>\n            <ng-container *ngIf="componentState === ComponentState.LOADED; else loadingCameras">\n                <ng-container *ngIf="cameraTags.length > 0; else noCameraTagsExist">\n                    <mat-card class="search-tools-card">\n                        <mat-form-field class="searchbar-container">\n                            <mat-label>{{ msgs.searchCameraTags() }}</mat-label>\n                            <input matInput type="text" (keyup)="handleSearchKeyUp($event, TagResourceType.CAMERA)">\n                        </mat-form-field>\n                        <div class="active-filters-container" *ngIf="cameraTagsFilters.length > 0">\n                            <filter-chip *ngFor="let filter of cameraTagsFilters; let filterIndex = index" [filter]="filter" (onRemove)="removeFilter(filterIndex, TagResourceType.CAMERA)"></filter-chip>\n                            <button class="filters-reset-button body-small mat-delete" matRipple (click)="removeAllFilters(TagResourceType.CAMERA)">\n                                {{ this.msgs.reset() }}\n                            </button>\n                        </div>\n                    </mat-card>\n                    <ng-container *ngIf="cameraTagsFiltered.length > 0; else noCameraTagsFound">\n                        <summary-table [resourceType]="TagResourceType.CAMERA" [tableData]="cameraTagsFiltered" (onResourceTagClick)="editBulkCameraTag($event)"></summary-table>\n                    </ng-container>\n                    <ng-template #noCameraTagsFound>\n                        <error-banner [type]="ERROR_TYPE.EMPTY_SEARCH_FILTERS"></error-banner>\n                    </ng-template>\n                </ng-container>\n                <ng-template #noCameraTagsExist>\n                    <ng-container *ngIf="!cameraTagsError; else error">\n                        <error-banner [icon]="icons.tag" [title]="msgs.noCameraTagsHaveBeenCreated()" [type]="ERROR_TYPE.EMPTY_DATA">\n                            <a class="body-small text-link" (click)="addBulkCameraTag()">\n                                {{ msgs.createCameraTag() }}\n                            </a>\n                        </error-banner>\n                    </ng-container>\n                    <ng-template #error>\n                        <error-banner [description]="cameraTagsError" [icon]="icons.error" [title]="msgs.failedToFetchCameraTags()" [type]="ERROR_TYPE.CUSTOM_ERROR"></error-banner>\n                    </ng-template>\n                </ng-template>\n            </ng-container>\n            <ng-template #loadingCameras>\n                <div class="loading-container">\n                    <mat-spinner diameter="16" color="primary"></mat-spinner>\n                    <span>{{ msgs.loadingCameraTags() }}</span>\n                </div>\n            </ng-template>\n        </mat-tab>\n    </mat-tab-group>\n</div>\n'
        }
        ,
        32514: e => {
            e.exports = '<div class="recorder-row-header">\n    <span class="label-medium {{ operationType === TagOperationType.ADD ? \'mat-success\' : \'mat-fail\' }}">{{\n        recorder.recorderName\n        }}</span>\n    <tag [icon]="icons.camera" [label]="recorder.cameraRecords.length"></tag>\n</div>\n<div *ngFor="let camera of paginatedCameras" class="camera-row-container">\n    <div class="camera-info-container" [ngSwitch]="operationType">\n        <i *ngSwitchCase="TagOperationType.ADD" class="mat-success {{ icons.add }}"></i>\n        <i *ngSwitchDefault class="mat-fail {{ icons.remove }}"></i>\n        <div class="recorder-info">\n            <span class="label-medium">{{ camera.name }}</span>\n        </div>\n    </div>\n    <div class="failed-tag-container" *ngIf="camera.status === CameraTagOperationStatus.FAILED">\n        <tag class="failed-tag" [label]="msgs.failed()" type="error"></tag>\n    </div>\n    <div class="success-tag-container" *ngIf="camera.status === CameraTagOperationStatus.SUCCESS">\n        <tag class="success-tag" [label]="msgs.success()" type="success"></tag>\n    </div>\n    <div class="in-progress-tag-container" *ngIf="camera.status === CameraTagOperationStatus.IN_PROGRESS">\n        <tag class="in-progress-tag" [label]="msgs.inProgress()" type="external"></tag>\n    </div>\n    <div class="cancelled-tag-container" *ngIf="camera.status === CameraTagOperationStatus.CANCELED">\n        <tag class="canceled-tag" (click)="handleTagClick(CameraTagOperationStatus.CANCELED)" [label]="msgs.canceled()" type="warning" [icon]="icons.hint"></tag>\n    </div>\n    <div class="indeterminate-tag-container" *ngIf="camera.status === CameraTagOperationStatus.TIMED_OUT">\n        <tag class="timed-out-tag" (click)="handleTagClick(CameraTagOperationStatus.TIMED_OUT)" [label]="msgs.timedOut()" type="warning" [icon]="icons.hint"></tag>\n    </div>\n    <div class="ignored-tag-container" *ngIf="camera.status === CameraTagOperationStatus.UNSUPPORTED">\n        <tag class="in-progress-tag" [label]="msgs.unsupported()" type="disabled-camera"></tag>\n    </div>\n</div>\n\n<mat-paginator *ngIf="recorder.cameraRecords.length > pageSizeOptions[0]" [pageSize]="pageSize" [pageSizeOptions]="pageSizeOptions" showFirstLastButtons [hidden]="!isPaginationVisible" [length]="recorder.cameraRecords.length" (page)="onPaginatorChange($event)"></mat-paginator>\n'
        }
        ,
        70565: e => {
            e.exports = '<div *ngIf="recorderCameras.length > 0" class="affected-resources-container">\n    <div [ngSwitch]="operationType">\n        <div class="affected-resources-header" *ngSwitchCase="TagOperationType.ADD">\n            <span class="label-small mat-success">{{ msgs.add() }}</span>\n            <div class="badge-small mat-success">{{ count }}</div>\n        </div>\n        <div class="affected-resources-header" *ngSwitchDefault>\n            <span class="label-small mat-fail">{{ msgs.remove() }}</span>\n            <div class="badge-small mat-fail">{{ count }}</div>\n        </div>\n    </div>\n    <div class="affected-servers-container">\n        <affected-cameras class="affected-recorder-table-container" *ngFor="let recorder of paginatedRecorders" (onTagClick)="handleTagStatusClick($event)" [recorder]="recorder" [operationType]="operationType">\n        </affected-cameras>\n    </div>\n</div>\n\n<mat-paginator *ngIf="recorderCameras.length > pageSizeOptions[0]" [pageSize]="pageSize" [pageSizeOptions]="pageSizeOptions" showFirstLastButtons [hidden]="!isPaginationVisible" [length]="recorderCameras.length" (page)="onPaginatorChange($event)"></mat-paginator>\n'
        }
        ,
        69634: e => {
            e.exports = '<div *ngIf="orchids.length > 0" class="affected-resources-container">\n    <div [ngSwitch]="operationType">\n        <div class="affected-resources-header" *ngSwitchCase="TagOperationType.ADD">\n            <span class="label-small mat-success">{{ msgs.add() }}</span>\n            <div class="badge-small mat-success">{{ orchids.length }}</div>\n        </div>\n        <div class="affected-resources-header" *ngSwitchDefault>\n            <span class="label-small mat-fail">{{ msgs.remove() }}</span>\n            <div class="badge-small mat-fail">{{ orchids.length }}</div>\n        </div>\n    </div>\n    <div class="resources-container">\n        <div class="resource-row-container" *ngFor="let server of paginatedOrchids" [class]="{\'resource-row-container--disabled\': server.status === RecorderTagOperationStatus.UNSUPPORTED }">\n            <div [ngSwitch]="operationType" class="recorder-info-container">\n                <i class="mat-success {{ icons.add }}" *ngSwitchCase="TagOperationType.ADD"></i>\n                <i class="mat-fail {{ icons.remove }}" *ngSwitchDefault></i>\n                <div class="recorder-info">\n                    <span class="label-medium">{{ server.name }}</span>\n                    <a class="body-tiny text-link" href="{{ server.uri }}" target="_blank">{{ server.uri }}</a>\n                    <span *ngIf="server.status === RecorderTagOperationStatus.UNSUPPORTED" class="unsupported-orchid-text hint-text">\n                        {{ msgs.notAvailable({ VALUE: server.orchid.version.version }) }}\n                    </span>\n                </div>\n            </div>\n\n            <div class="camera-count-tag-container" *ngIf="server.status === RecorderTagOperationStatus.DEFAULT">\n                <tag class="camera-count-tag" [label]="server.cameraCount" [icon]="icons.camera"></tag>\n            </div>\n            <div class="failed-tag-container" *ngIf="server.status === RecorderTagOperationStatus.FAILED">\n                <tag class="failed-tag" [label]="msgs.failed()" type="error"></tag>\n            </div>\n            <div class="success-tag-container" *ngIf="server.status === RecorderTagOperationStatus.SUCCESS">\n                <tag class="success-tag" [label]="msgs.success()" type="success"></tag>\n            </div>\n            <div class="in-progress-tag-container" *ngIf="server.status === RecorderTagOperationStatus.IN_PROGRESS">\n                <tag class="in-progress-tag" [label]="msgs.inProgress()" type="external"></tag>\n            </div>\n            <div class="cancelled-tag-container" *ngIf="server.status === RecorderTagOperationStatus.CANCELED">\n                <tag (click)="handleTagClick(RecorderTagOperationStatus.CANCELED)" class="canceled-tag" [label]="msgs.canceled()" type="warning" [icon]="InformationIcons.hint"></tag>\n            </div>\n            <div class="indeterminate-tag-container" *ngIf="server.status === RecorderTagOperationStatus.TIMED_OUT">\n                <tag (click)="handleTagClick(RecorderTagOperationStatus.TIMED_OUT)" class="timed-out-tag" [label]="msgs.timedOut()" type="warning" [icon]="InformationIcons.hint"></tag>\n            </div>\n            <div class="ignored-tag-container" *ngIf="server.status === RecorderTagOperationStatus.UNSUPPORTED">\n                <tag class="in-progress-tag" [label]="msgs.unsupported()" type="disabled-camera"></tag>\n            </div>\n        </div>\n    </div>\n</div>\n<mat-paginator *ngIf="orchids.length > pageSizeOptions[0]" [pageSize]="pageSize" [pageSizeOptions]="pageSizeOptions" showFirstLastButtons [hidden]="!isPaginationVisible" [length]="orchids.length" (page)="onPaginatorChange($event)"></mat-paginator>\n'
        }
        ,
        98776: e => {
            e.exports = '<ng-container *ngIf="{operationInProgress: operationInProgress$ | async} as observables">\n    <mat-toolbar color="primary">\n        <span>{{ dialogTitle }}</span>\n\n        <button mat-icon-button [mat-dialog-close]="undefined" [disabled]="processing">\n            <i class="{{ icons.close }} fa-lg"></i>\n        </button>\n    </mat-toolbar>\n    <info-drawer [(showDrawer)]="showInfoPanel" [drawerTitle]="infoPanelTitle" [drawerInfoText]="infoPanelBodyText">\n        <mat-dialog-content>\n            <mat-stepper class="width-100" (selectionChange)="onStepperStepChange($event)" [linear]="true" #stepper>\n                \x3c!-- Step 1 - Tag Configuration and Resources Selector --\x3e\n                <mat-step>\n                    <form id="step-config" [formGroup]="resourceTagForm">\n                        <operation-in-progress *ngIf="observables.operationInProgress"></operation-in-progress>\n                        <div class="flat-card tag-configuration-container">\n                            <div class="section-header-container">\n                                <i class="section-title-icon {{ icons.tag }}"></i>\n                                <div class="section-title-container">\n                                    <span class="title-medium">{{ msgs.tagConfiguration() }}</span>\n                                    <span class="body-tiny hint-text">{{ msgs.tagNamesAndValuesAreCaseInsensitive()\n                                        }}</span>\n                                </div>\n                            </div>\n\n\n                            <div class="flat-card-content" [ngSwitch]="dialogData.dialogType">\n                                <multi-new-tag-form *ngSwitchCase="BulkTagDialogType.ADD" [existingTags]="allResourceTags" [newTags]="resourceTagForm.controls.tags.value" [resourceType]="resourceType" [tags]="tagConfigs" [canEditTags]="canEditTag && !observables.operationInProgress" [isSingleTag]="true">\n                                </multi-new-tag-form>\n                                <alert-banner *ngIf="isExistingTagSelected">\n                                    <div [innerHTML]="existingTagBannerMessage"></div>\n                                </alert-banner>\n\n                                <div class="summary-table" *ngSwitchDefault>\n                                    \x3c!-- Tag --\x3e\n                                    <div class="summary-row tags">\n                                        <div class="field-column">\n                                            <span>{{ msgs.tag() }}</span>\n                                        </div>\n                                        <div class="data-column">\n                                            <resource-tag-list [tags]="tagConfigs"></resource-tag-list>\n                                        </div>\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                        <div class="flat-card servers-picker-container">\n                            <div class="section-header-container">\n                                <i class="section-title-icon {{ dialogResourceIcon }}"></i>\n                                <div class="section-title-container">\n                                    <span class="title-medium">{{ dialogResourceTitle }}</span>\n                                    <span class="body-tiny hint-text">{{ dialogResourceHelperText }}</span>\n                                </div>\n                            </div>\n                            <div class="flat-card-content">\n                                <div class="resources-selector-container" *ngIf="componentState !== ComponentState.LOADING; else resourcesLoading" [ngSwitch]="componentState">\n                                    <ng-container *ngSwitchCase="ComponentState.LOADED">\n                                        \x3c!-- Only enable orchids who will support bulk tagging --\x3e\n                                        <recorder-picker [orchids]="orchids" [selectedOrchids]="selectedRecorders" [requiredOrchidVersion]="VersionSpecificFeature.BULK_TAGGING" (onOrchidSelect)="handleOrchidSelected($event)" [loaded]="true" [disabled]="false" [disableAll]="observables.operationInProgress" *ngIf="resourceType === TagResourceType.SERVER; else cameraPicker">\n                                        </recorder-picker>\n                                        <ng-template #cameraPicker>\n                                            <camera-picker [data]="orchids" [cameras]="selectedCameras" [loaded]="true" [camerasOnly]="true" [requiredOrchidVersion]="VersionSpecificFeature.BULK_TAGGING" (onTotalDataListChange)="handleCamerasAndServersSelected($event)">\n                                            </camera-picker>\n                                        </ng-template>\n                                    </ng-container>\n                                    <error-banner *ngSwitchCase="ComponentState.ERROR" [icon]="icons.error" [title]="msgs.failedToFetchServerTagDetails()" [description]="tagDetailsErrorMessage" [type]="ERROR_TYPE.CUSTOM_ERROR"></error-banner>\n                                </div>\n\n                                <ng-template #resourcesLoading>\n                                    <div class="loading-container">\n                                        <mat-spinner diameter="16" color="primary"></mat-spinner>\n                                        <span>{{ msgs.loading() }}</span>\n                                    </div>\n                                </ng-template>\n\n                            </div>\n                        </div>\n                    </form>\n                </mat-step>\n\n                \x3c!-- Step 2 - Review and In Progress --\x3e\n                <mat-step #reviewStep>\n                    <div id="step-review">\n                        <operation-in-progress *ngIf="observables.operationInProgress"></operation-in-progress>\n                        <div class="flat-card tag-configuration-container">\n                            <div class="section-header-container">\n                                <i class="section-title-icon {{ icons.tag }}"></i>\n                                <div class="section-title-container">\n                                    <span class="title-medium">{{ msgs.tagConfiguration() }}</span>\n                                    <span class="body-tiny hint-text">{{ msgs.tagNamesAndValuesAreCaseInsensitive()\n                                        }}</span>\n                                </div>\n                            </div>\n                            <div class="flat-card-content">\n                                <div class="summary-table">\n                                    \x3c!-- Tags --\x3e\n                                    <div class="summary-row tags">\n                                        <div class="field-column">\n                                            <span>{{ msgs.tags() }}</span>\n                                        </div>\n                                        <div class="data-column">\n                                            <resource-tag-list [tags]="tagConfigs"></resource-tag-list>\n                                        </div>\n                                    </div>\n                                </div>\n                            </div>\n                        </div>\n                        <div class="flat-card affected-resources-container">\n                            <div class="section-header-container">\n                                <i class="section-title-icon {{ dialogResourceIcon }}"></i>\n                                <div class="section-title-container">\n                                    <span class="title-medium">{{ dialogResourceTitle }}</span>\n                                    <span class="body-tiny hint-text">{{ dialogResourceSubtitle }}</span>\n                                </div>\n                            </div>\n                            <div class="flat-card-content" *ngIf="resourceType === TagResourceType.SERVER; else affectedCamerasContainer">\n                                \x3c!-- Retry failed operations banner --\x3e\n                                <alert-banner *ngIf="!processing && oneOrMoreRecordersFailed">\n                                    {{ msgs.oneOrMoreTagsCouldNotBeProcessed() }}\n                                    <a class="try-again-button" (click)="handleSave()">{{ msgs.tryAgain() }}</a>\n                                </alert-banner>\n                                <affected-recorders *ngIf="recordersToAdd.length > 0" (onTagClick)="handleTagStatusClick($event)" [orchids]="recordersToAdd" operationType="add"></affected-recorders>\n                                <affected-recorders *ngIf="recordersToRemove.length > 0" (onTagClick)="handleTagStatusClick($event)" [orchids]="recordersToRemove" operationType="remove"></affected-recorders>\n                            </div>\n\n                            <ng-template #affectedCamerasContainer>\n                                <div class="flat-card-content">\n                                    \x3c!-- Retry failed operations banner --\x3e\n                                    <alert-banner *ngIf="!processing && oneOrMoreCamerasFailed">\n                                        {{ msgs.oneOrMoreTagsCouldNotBeDeleted() }}\n                                        <a class="try-again-button" (click)="handleSave()">{{ msgs.tryAgain() }}</a>\n                                    </alert-banner>\n                                    <affected-recorder-cameras *ngIf="camerasToAddCount > 0" (onTagClick)="handleTagStatusClick($event)" [recorderCameras]="camerasToAdd" [count]="camerasToAddCount" operationType="add"></affected-recorder-cameras>\n                                    <affected-recorder-cameras *ngIf="camerasToRemoveCount > 0" (onTagClick)="handleTagStatusClick($event)" [recorderCameras]="camerasToRemove" [count]="camerasToRemoveCount" operationType="remove"></affected-recorder-cameras>\n                                </div>\n                            </ng-template>\n                        </div>\n                    </div>\n                </mat-step>\n            </mat-stepper>\n        </mat-dialog-content>\n\n        <sing-dialog-errors *ngIf="error" [errmsg]="error" [canClose]="true" (onClose)="error = undefined"></sing-dialog-errors>\n\n    </info-drawer>\n    <mat-dialog-actions>\n        <button *ngIf="showCancelButton" mat-button [mat-dialog-close]="undefined" [disabled]="processing">\n            {{ msgs.cancel() }}\n        </button>\n\n        <button *ngIf="stepper.selectedIndex === 0" mat-raised-button color="primary" [disabled]="formIsInvalid || !isDirty" (click)="stepper.next()">\n            {{ msgs.next() }}\n        </button>\n\n        <button *ngIf="stepper.selectedIndex === 1 && !tagOperationAttempted" mat-button [disabled]="processing" (click)="stepper.previous()">\n            {{ msgs.back() }}\n        </button>\n\n        <spinner-button *ngIf="stepper.selectedIndex === 1 && !showCloseButton" (click)="handleSave()" [text]="msgs.save()" [showSpinner]="processing" [disabled]="oneOrMoreTagsAreInvalid || processing"></spinner-button>\n\n        <button class="close-button-actions-bar" mat-raised-button *ngIf="stepper.selectedIndex === 1 && showCloseButton" [mat-dialog-close]="undefined" color="primary" [disabled]="processing || observables.operationInProgress">\n            {{ msgs.close() }}\n        </button>\n    </mat-dialog-actions>\n</ng-container>\n'
        }
        ,
        70: e => {
            e.exports = '<div class="operation-banner-header">\n    <div class="banner-header-title">\n        <i class="wait-icon {{ waitIcon }}"></i>\n        <span class="title-medium">{{ msgs.theServerIsCurrentlyBusy() }}</span>\n    </div>\n    <button mat-stroked-button [@fadeEnterLeave] *ngIf="!isExpanded" (click)="showDetails()" class="mat-fail cancel-button">\n        <span class="cancel-button-copy">{{ msgs.cancelOperation() }}</span>\n        <span class="cancel-button-copy-mobile">{{ msgs.cancel() }}</span>\n    </button>\n</div>\n<div *ngIf="isExpanded" [@expandEnterLeave] class="operation-banner-details-container">\n    <p class="body-small">{{ msgs.areYouSure() }}</p>\n    <p class="body-small" *ngIf="hasError">{{ cancelErrorMessage }}</p>\n\n    <div class="action-buttons-container">\n        <button mat-stroked-button mat-fail (click)="handleCancelOperation()" class="mat-fail cancel-button" [disabled]="processing">\n            <mat-progress-spinner class="processing-spinner" diameter="16" mode="indeterminate" *ngIf="processing"></mat-progress-spinner>\n            <span class="cancel-button-copy">{{ hasError ? msgs.tryAgain() : msgs.yesCancelAllRequests() }}</span>\n            <span class="cancel-button-copy-mobile">{{ hasError ? msgs.tryAgain() : msgs.cancelAll() }}</span>\n        </button>\n        <button mat-button (click)="hideDetails()" [disabled]="processing">{{ msgs.nevermind() }}</button>\n    </div>\n</div>\n'
        }
        ,
        85368: e => {
            e.exports = '<resource-tag-list [tags]="tags" [viewOnly]="false" (onEditTags)="editCameraTags()"></resource-tag-list>\n'
        }
        ,
        93479: e => {
            e.exports = '<div class="new-tags-container">\n    <div class="new-tags-accordion-container">\n        <mat-accordion [displayMode]="\'flat\'" multi>\n            <new-tag-form #newTagForm *ngFor="let newTagForm of newTags; index as newTagIndex; last as isLast" [tagName]="tagName" [tagValue]="tagValue" [newTagForm]="newTagForm" [filteredAutocompleteTags]="filteredAutocompleteTags[newTagIndex]" (onTagDelete)="deleteNewTag(newTagIndex)" [canDelete]="canEditTags && !isSingleTag"></new-tag-form>\n        </mat-accordion>\n        <button mat-stroked-button class="add-button add-new-tag-button" (click)="addNewTag()" *ngIf="canEditTags && !isSingleTag">\n            {{ msgs.addTag() }}\n        </button>\n    </div>\n</div>\n'
        }
        ,
        23488: e => {
            e.exports = '<mat-expansion-panel #panel hideToggle class="mat-elevation-z0" disabled="disabled">\n    <mat-expansion-panel-header>\n        <div class="new-tag-key-container">\n            <mat-form-field [floatLabel]="\'always\'">\n                <mat-label>{{ tagName }}</mat-label>\n                <input #keyInput class="new-tag-input" type="text" matInput [formControl]="newTagForm.controls.key" placeholder="{{ msgs.enterTagName() }}" (keydown)="$event.stopPropagation()" [matAutocomplete]="auto" (keydown.enter)="$event.preventDefault()" required>\n                <mat-autocomplete #auto="matAutocomplete" [autoActiveFirstOption]="!(filteredAutocompleteTags | async)[0]?.displayValue" (optionSelected)="markKeySelected(newTagForm, $event)" (closed)="clearInputIfNoKeySelected(newTagForm)" (opened)="revalidateTagKey(newTagForm)">\n                    <mat-option class="resource-tag-editor-autocomplete-option" *ngFor="let tagOption of filteredAutocompleteTags | async" [value]="tagOption.key" [disabled]="tagOption.disabled">\n                        {{ tagOption.displayValue ?? tagOption.key }}\n                    </mat-option>\n                </mat-autocomplete>\n                <mat-error *ngIf="newTagForm.controls.key.errors">\n                    {{ newTagForm.controls.key.errors.errMsg }}\n                </mat-error>\n            </mat-form-field>\n            <div class="tag-action-buttons-container">\n                <button mat-icon-button class="medium-icon-button new-tag-value-visibility-toggle" (click)="panel.toggle()" (keyup.enter)="panel.toggle()" (keyup.space)="panel.toggle()">\n                    <i class="fa-regular" [ngClass]="panel.expanded ? \'fa-chevron-down\' : \'fa-chevron-right\'"></i>\n                </button>\n                <button *ngIf="canDelete" mat-icon-button class="medium-icon-button mat-delete" (click)="deleteNewTag()" (keyup.enter)="deleteNewTag()" (keyup.space)="deleteNewTag()" matTooltip="{{ msgs.deleteTag() }}" matTooltipPosition="above" matTooltipShowDelay="800">\n                    <i class="{{ icons.delete }}"></i>\n                </button>\n            </div>\n        </div>\n    </mat-expansion-panel-header>\n    <mat-form-field [floatLabel]="\'always\'">\n        <mat-label>{{ tagValue }}</mat-label>\n        <input type="text" matInput [formControl]="newTagForm.controls.value" placeholder="{{ msgs.enterTagValue() }}" (keydown.enter)="$event.preventDefault()">\n        <mat-error *ngIf="newTagForm.controls.value.errors">\n            {{ newTagForm.controls.value.errors.errMsg }}\n        </mat-error>\n    </mat-form-field>\n    <mat-action-row class="tag-action-buttons-mobile-container">\n        <button mat-button class="new-tag-value-visibility-toggle" (click)="panel.toggle()">\n            <i class="fa-regular" [ngClass]="panel.expanded ? \'mat-delete fa-close\' : \'fa-plus\'"></i>\n            <span>{{ msgs.value() }}</span>\n        </button>\n        <button *ngIf="canDelete" mat-button class="mat-delete" (click)="deleteNewTag()">\n            <span>{{ msgs.remove() }}</span>\n        </button>\n    </mat-action-row>\n</mat-expansion-panel>\n'
        }
        ,
        35737: e => {
            e.exports = '<tag [class.key-tag]="tag.value" [type]="\'resource-tag-key\'" [label]="tag.key" [matTooltip]="tag.key" matTooltipPosition="above" matTooltipShowDelay="800" matTooltipClass="add-edit-subscription-dialog-onvif-topic-custom-tooltip-class"></tag>\n<tag *ngIf="tag.value" class="value-tag" [type]="\'resource-tag-val\'" [label]="tag.value" [matTooltip]="tag.value" matTooltipPosition="above" matTooltipShowDelay="800" matTooltipClass="add-edit-subscription-dialog-onvif-topic-custom-tooltip-class"></tag>\n'
        }
        ,
        68264: e => {
            e.exports = '<mat-chip-list *ngIf="!tags || tags.length === 0">\n    <mat-chip class="none-chip" disabled="disabled">\n        <span style="font-style: italic">{{ msgs.none() }}</span>\n    </mat-chip>\n</mat-chip-list>\n\n<div class="resource-tags-preview-container">\n    <resource-tag *ngFor="let tag of tags | slice: 0:maxTagsVisible" [tag]="tag"></resource-tag>\n    <tag *ngIf="tags.length > maxTagsVisible" type="primary" [label]="msgs.plusMore({ VALUE: tags.length - maxTagsVisible })"></tag>\n    <button *ngIf="!viewOnly" mat-icon-button class="small-icon-button" (click)="onEditTags.emit()">\n        <i class="{{ icons.edit }}"></i>\n    </button>\n</div>\n'
        }
        ,
        41092: e => {
            e.exports = '<mat-card>\n    <div class="section-header-container">\n        <i class="section-title-icon {{ icons.servers.settings }}"></i>\n        <div class="section-title-container">\n            <span class="title-medium">{{ msgs.serverSettings() }}</span>\n            <span class="body-tiny hint-text">{{ msgs.serverSettingsSubtext() }}</span>\n        </div>\n    </div>\n\n    <div class="tag-section">\n        <span class="label-medium">{{ msgs.serverTags() }}</span>\n        <resource-tag-list *ngIf="supportsResourceTags; else resourceTaggingUnsupported" [tags]="tags" [viewOnly]="false" (onEditTags)="editTags()"></resource-tag-list>\n\n        <ng-template #resourceTaggingUnsupported>\n            <span class="hint-text">{{ msgs.notAvailable({ VALUE: recorderVersion.version }) }}</span>\n        </ng-template>\n    </div>\n</mat-card>\n'
        }
        ,
        36506: e => {
            e.exports = '<mat-table [dataSource]="dataSource" class="mat-elevation-z1" matSort matSortDirection="asc" matSortActive="tag" (matSortChange)="handleSort($event)">\n    \x3c!-- Tag Column --\x3e\n    <ng-container matColumnDef="tag">\n        <mat-header-cell *matHeaderCellDef mat-sort-header>{{ msgs.label() }}</mat-header-cell>\n        <mat-cell *matCellDef="let uniqueResourceTag" (click)="handleResourceTagRowClick(uniqueResourceTag)">\n            <resource-tag [tag]="{ key: uniqueResourceTag.key, value: uniqueResourceTag.value }"></resource-tag>\n        </mat-cell>\n    </ng-container>\n\n    \x3c!-- Resource Column --\x3e\n    <ng-container matColumnDef="resource">\n        <mat-header-cell *matHeaderCellDef mat-sort-header>{{ resourceColumnName }}</mat-header-cell>\n        <mat-cell *matCellDef="let uniqueResourceTag" (click)="handleResourceTagRowClick(uniqueResourceTag)">\n            <tag [icon]="resourceIcon" [label]="uniqueResourceTag.resourceCount"></tag>\n        </mat-cell>\n    </ng-container>\n\n    \x3c!-- Actions Column --\x3e\n    <ng-container matColumnDef="actions">\n        <mat-header-cell *matHeaderCellDef></mat-header-cell>\n        <mat-cell *matCellDef="let uniqueResourceTag">\n            <button mat-icon-button (click)="openDeleteDialog(uniqueResourceTag)">\n                <i class="mat-delete {{ icons.delete }}"></i>\n            </button>\n        </mat-cell>\n    </ng-container>\n\n    <mat-header-row *matHeaderRowDef="[\'tag\', \'resource\', \'actions\']"></mat-header-row>\n\n    <mat-row *matRowDef="let row; columns: [\'tag\', \'resource\', \'actions\']"></mat-row>\n</mat-table>\n\n<mat-paginator [class.hide]="dataSource.data.length <= pageSizeOptions[0]" [pageSizeOptions]="pageSizeOptions" showFirstLastButtons></mat-paginator>\n'
        }
        ,
        19473: e => {
            e.exports = '<div class="tag-list-container">\n    <span class="label-large tags-header">{{ tagType }}</span>\n    <mat-chip-list>\n        <div class="tag-chip" *ngFor="let tag of tags; index as tagIndex">\n            <mat-chip class="tag-key-chip" [class.left-chip]="tag.value" disabled="disabled">\n                <span class="chip-text">{{ tag.key }}</span>\n                <button (click)="deleteTag(tagIndex)" matChipRemove *ngIf="!tag.value">\n                    <i class="fa-solid fa-circle-xmark"></i>\n                </button>\n            </mat-chip>\n            <mat-chip class="tag-value-chip" *ngIf="tag.value" disabled="disabled">\n                <span class="chip-text">{{ tag.value }}</span>\n                <button (click)="deleteTag(tagIndex)" matChipRemove>\n                    <i class="fa-solid fa-circle-xmark"></i>\n                </button>\n            </mat-chip>\n        </div>\n        <mat-chip class="none-chip" *ngIf="tags.length === 0" disabled="disabled">\n            <span style="font-style: italic">{{ msgs.none() }}</span>\n        </mat-chip>\n        <button mat-icon-button class="medium-icon-button add-new-tag-button" (click)="addNewTag()">\n            <i class="fa-regular fa-plus"></i>\n        </button>\n    </mat-chip-list>\n</div>\n\n<div class="new-tags-container" *ngIf="newTags.length > 0">\n    <mat-card class="mat-elevation-z0">\n        <div class="section-header-container">\n            <i class="section-title-icon fa-regular fa-tag"></i>\n            <div class="section-title-container">\n                <span class="title-medium">{{ tagTitle }}</span>\n                <span class="body-tiny hint-text">{{ nonAlphanumericTagValuesSupported ? msgs.tagNamesAreCaseInsensitive() : msgs.tagNamesAndValuesAreCaseInsensitive() }}</span>\n            </div>\n        </div>\n        <mat-card-content class="new-tags-accordion-container">\n            <mat-accordion [displayMode]="\'flat\'" multi>\n                <new-tag-form #newTagForm *ngFor="let newTagForm of newTags; index as newTagIndex; last as isLast" [tagName]="tagName" [tagValue]="tagValue" [newTagForm]="newTagForm" [filteredAutocompleteTags]="filteredAutocompleteTags[newTagIndex]" (onTagDelete)="deleteNewTag(newTagIndex)"></new-tag-form>\n            </mat-accordion>\n            <button mat-stroked-button class="add-button add-new-tag-button" (click)="addNewTag()">\n                {{ msgs.addTag() }}\n            </button>\n        </mat-card-content>\n    </mat-card>\n</div>\n'
        }
        ,
        89675: e => {
            e.exports = '<ng-container *ngIf="{ operationInProgress: operationInProgress$ | async } as observables">\n    <mat-toolbar color="primary">\n        <span>{{ msgs.deleteCameraTag() }}</span>\n\n        <button mat-icon-button [mat-dialog-close]="undefined" [disabled]="processing">\n            <i class="{{ icons.close }} fa-2x"></i>\n        </button>\n    </mat-toolbar>\n\n    <info-drawer [(showDrawer)]="showInfoPanel" [drawerTitle]="infoPanelTitle" [drawerInfoText]="infoPanelBodyText">\n\n        <mat-dialog-content>\n\n            <operation-in-progress *ngIf="observables.operationInProgress"></operation-in-progress>\n            <div class="flat-card tag-configuration-container">\n                <div class="section-header-container">\n                    <i class="section-title-icon {{ icons.delete }}"></i>\n                    <div class="section-title-container">\n                        <span class="title-medium">{{ msgs.tagConfiguration() }}</span>\n                        <span class="body-tiny hint-text">{{ msgs.thisTagWillBePermanentlyRemoved() }}</span>\n                    </div>\n                </div>\n\n                \x3c!-- Tag info content --\x3e\n                <div class="flat-card-content">\n                    <div class="summary-table">\n                        <div class="summary-row tags">\n                            <div class="field-column">\n                                <span>{{ msgs.tag() }}</span>\n                            </div>\n                            <div class="data-column">\n                                <resource-tag-list [tags]="[dialogData.tag]"></resource-tag-list>\n                            </div>\n                        </div>\n                        <div class="summary-row">\n                            <div class="field-column">\n                                <span>{{ msgs.currentlyTagged() }}</span>\n                            </div>\n                            <div class="data-column">\n                                <tag [icon]="icons.camera" [label]="dialogData.tag.resourceCount"></tag>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n\n            \x3c!-- Affected cameras summary card --\x3e\n            <div class="flat-card affected-resources-container">\n                <div class="section-header-container">\n                    <i class="section-title-icon {{ icons.camera }}"></i>\n                    <div class="section-title-container">\n                        <span class="title-medium">{{ msgs.affectedCameras() }}</span>\n                        <span class="body-tiny hint-text">{{ msgs.deletingThisTagWillRemoveItFromTheFollowingCameras() }}</span>\n                    </div>\n                </div>\n\n                <div class="flat-card-content">\n                    \x3c!-- Loading spinner while we await camera details --\x3e\n                    <ng-container *ngIf="loading; else loaded">\n                        <div class="loading-container">\n                            <mat-spinner diameter="16" color="primary"></mat-spinner>\n                            <span>{{ msgs.loading() }}</span>\n                        </div>\n                    </ng-container>\n                    <ng-template #loaded>\n                        <alert-banner *ngIf="hasSomeUnsupportedCameras">\n                            {{ msgs.theTagCannotBeDeletedCompletelyBecauseOneOrMoreOfTheserversItIsAssociatedWithAreRunningAVersionOlderThanVERSION({ VERSION: VersionSpecificFeature.BULK_TAGGING }) }}\n                        </alert-banner>\n                        \x3c!-- Error banner indicating the camera details fetch failed --\x3e\n                        <ng-container *ngIf="error; else noErrorContent">\n                            <error-banner [description]="error" [icon]="icons.error" [title]="msgs.failedToFetchResourceDetails()" [type]="custom-error-banner"></error-banner>\n                        </ng-container>\n                        <ng-template #noErrorContent>\n                            \x3c!-- Retry failed operations banner --\x3e\n                            <alert-banner *ngIf="!processing && oneOrMoreDeletesFailed">\n                                {{ msgs.oneOrMoreTagsCouldNotBeDeleted() }} <a class="try-again-button" (click)="retryFailedTags()">{{ msgs.tryAgain() }}</a>\n                            </alert-banner>\n\n                            <affected-recorder-cameras [recorderCameras]="recorderIdRecord" [count]="numTagsToDelete" operationType="remove" (onTagClick)="handleTagStatusClick($event)"></affected-recorder-cameras>\n\n                        </ng-template>\n                    </ng-template>\n                </div>\n            </div>\n        </mat-dialog-content>\n\n        <sing-dialog-errors *ngIf="deleteError" [errmsg]="deleteError" [canClose]="true" (onClose)="deleteError = undefined"></sing-dialog-errors>\n\n    </info-drawer>\n\n    <mat-dialog-actions>\n        <button mat-button [mat-dialog-close]="undefined" [disabled]="processing">\n            {{ msgs.cancel() }}\n        </button>\n\n        <ng-container *ngIf="!firstDeleteComplete && !hasAllUnsupportedCameras; else closeButton">\n            <spinner-button (click)="confirmDelete()" [text]="msgs.delete()" [disabled]="loading || processing || error || observables.operationInProgress" [showSpinner]="processing"></spinner-button>\n        </ng-container>\n        <ng-template #closeButton>\n            <spinner-button [mat-dialog-close]="undefined" [text]="msgs.close()" [disabled]="processing" [showSpinner]="processing"></spinner-button>\n        </ng-template>\n    </mat-dialog-actions>\n</ng-container>\n'
        }
        ,
        49016: e => {
            e.exports = '<ng-container *ngIf="{ operationInProgress: operationInProgress$ | async } as observables">\n    <mat-toolbar class="dialog-toolbar">\n        <h4 class="dialog-title-text">{{ msgs.deleteServerTag() }}</h4>\n\n        <button class="close-button" mat-icon-button [mat-dialog-close]="undefined" [disabled]="processing">\n            <i class="{{ ActionsIcons.close }} fa-lg close-button-icon"></i>\n        </button>\n    </mat-toolbar>\n\n    <info-drawer [(showDrawer)]="showInfoPanel" [drawerTitle]="infoPanelTitle" [drawerInfoText]="infoPanelBodyText">\n        <mat-dialog-content class="dialog-content">\n            <operation-in-progress *ngIf="observables.operationInProgress"></operation-in-progress>\n            <div class="flat-card tag-configuration-container">\n                <div class="section-header-container">\n                    <i class="section-title-icon {{ ActionsIcons.delete }}"></i>\n                    <div class="section-title-container">\n                        <span class="title-medium">{{ msgs.tagConfiguration() }}</span>\n                        <span class="body-tiny hint-text">{{ msgs.thisTagWillBePermanentlyRemoved() }}</span>\n                    </div>\n                </div>\n                <div class="flat-card-content">\n                    <div class="summary-table">\n                        <div class="summary-row tags">\n                            <div class="field-column">\n                                <span>{{ msgs.tag() }}</span>\n                            </div>\n                            <div class="data-column">\n                                <resource-tag [tag]="data.tag"></resource-tag>\n                            </div>\n                        </div>\n                        <div class="summary-row server-count">\n                            <div class="field-column">\n                                <span>{{ msgs.currentlyTagged() }}</span>\n                            </div>\n                            <div class="data-column">\n                                <tag class="server-count-tag" [label]="data.tag.resourceCount" [icon]="InformationIcons.servers.server"></tag>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n\n            <div class="loading-container" *ngIf="componentState === ComponentState.LOADING; else loadedState">\n                <mat-spinner diameter="16" color="primary"></mat-spinner>\n                <span>{{ msgs.loadingServerTags() }}</span>\n            </div>\n\n            <ng-template #loadedState>\n                <div class="flat-card affected-resources-container">\n                    <div class="section-header-container">\n                        <i class="section-title-icon {{InformationIcons.servers.server}}"></i>\n                        <div class="section-title-container">\n                            <span class="title-medium">{{ msgs.affectedServers() }}</span>\n                            <span class="body-tiny hint-text">{{ msgs.deletingThisTagWillAlsoRemoveTheTagFromTheFollowingServers() }}</span>\n                        </div>\n                    </div>\n                    <div class="flat-card-content">\n                        <alert-banner *ngIf="hasSomeUnsupportedOrchids">\n                            {{ msgs.theTagCannotBeDeletedCompletelyBecauseOneOrMoreOfTheserversItIsAssociatedWithAreRunningAVersionOlderThanVERSION({ VERSION: VersionSpecificFeature.BULK_TAGGING }) }}\n                        </alert-banner>\n                        <alert-banner *ngIf="numFailedTagDeletions > 0 && canShowBanner">\n                            {{ msgs.oneOrMoreTagsCouldNotBeDeleted() }}\n                            <a class="try-again-link" (click)="delete()">{{ msgs.tryAgain() }}?</a>\n                        </alert-banner>\n                        <affected-recorders *ngIf="componentState === ComponentState.LOADED" (onTagClick)="handleTagStatusClick($event)" [requiredOrchidVersion]="VersionSpecificFeature.BULK_TAGGING" [orchids]="orchidsAffected" operationType="remove"></affected-recorders>\n                        <error-banner *ngIf="componentState === ComponentState.ERROR" [description]="" [icon]="InformationIcons.error" [title]="msgs.failedToFetchServerTagDetails()" [description]="tagDetailsErrorMessage" [type]="ERROR_TYPE.CUSTOM_ERROR"></error-banner>\n                    </div>\n                </div>\n            </ng-template>\n        </mat-dialog-content>\n\n        <sing-dialog-errors *ngIf="bulkDeleteErrorMessage.length > 0" (onClose)="handleErrorMessageClose()" [errmsg]="bulkDeleteErrorMessage"></sing-dialog-errors>\n    </info-drawer>\n\n    <mat-dialog-actions class="dialog-actions">\n        <button mat-button [mat-dialog-close]="undefined" [disabled]="processing || componentState === ComponentState.LOADING" class="cancel-button">\n            {{ msgs.cancel() }}\n        </button>\n        <spinner-button *ngIf="showDeleteButton && !hasAllUnsupportedOrchids" (click)="delete()" [showSpinner]="processing" [disabled]="processing || componentState !== ComponentState.LOADED" [text]="msgs.delete()"></spinner-button>\n        <button class="close-button-actions-bar" mat-raised-button *ngIf="!showDeleteButton || hasAllUnsupportedOrchids" [mat-dialog-close]="undefined" color="primary" [disabled]="processing || observables.operationInProgress">\n            {{msgs.close()}}\n        </button>\n    </mat-dialog-actions>\n</ng-container>\n'
        }
        ,
        47587: e => {
            e.exports = '<mat-toolbar color="primary">\n    <span>{{ dialogTitle }}</span>\n\n    <button mat-icon-button [mat-dialog-close]="undefined" [disabled]="processing">\n        <i class="{{ icons.close }} fa-lg"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content>\n    <tag-editor [existingTags]="existingTags" [newTags]="newTags" [resourceType]="resourceType" [tags]="tags" [orchid]="dialogData.stubRecorder"></tag-editor>\n</mat-dialog-content>\n\n<sing-dialog-errors *ngIf="error" [errmsg]="error" [canClose]="true" (onClose)="error = undefined"></sing-dialog-errors>\n\n<mat-dialog-actions>\n    <button mat-button [mat-dialog-close]="undefined" [disabled]="processing">\n        {{ msgs.cancel() }}\n    </button>\n\n    <spinner-button (click)="save()" [text]="msgs.save()" [disabled]="processing || oneOrMoreTagsAreInvalid" [showSpinner]="processing"></spinner-button>\n</mat-dialog-actions>\n'
        }
        ,
        19343: e => {
            e.exports = '<div class="dialog-content">\n    <mat-icon color="warn" class="fa-light fa-triangle-exclamation"></mat-icon>\n    <p>{{ msgs.yourNewDesiredRetentionDurationWillResultIn() }}</p>\n\n    <div class="table-section">\n        <table mat-table [dataSource]="tableDataSource" class="striped-table">\n            <ng-container matColumnDef="camera">\n                <th mat-header-cell *matHeaderCellDef>{{ msgs.camera() }}</th>\n                <td mat-cell *matCellDef="let data">{{ data.cameraName }}</td>\n            </ng-container>\n            <ng-container matColumnDef="oldRetention">\n                <th mat-header-cell *matHeaderCellDef>{{ msgs.oldRetention() }}</th>\n                <td mat-cell *matCellDef="let data">\n                    <div class="old-retention-cell">\n                        <span *ngIf="data.oldRetention !== 0; else automaticText">\n                            {{ data.oldRetention }} {{ msgs.day({ VALUE: data.oldRetention }) }}\n                        </span>\n                        <div class="arrow-container">\n                            <i class="fa-regular fa-arrow-right arrow-icon"></i>\n                        </div>\n                    </div>\n                </td>\n            </ng-container>\n            <ng-container matColumnDef="newRetention">\n                <th mat-header-cell *matHeaderCellDef>{{ msgs.newRetention() }}</th>\n                <td mat-cell *matCellDef="let data">\n                    <ng-container *ngIf="data.newRetention !== 0; else automaticText">\n                        {{ data.newRetention }} {{ msgs.day({ VALUE: data.newRetention }) }}\n                    </ng-container>\n                </td>\n            </ng-container>\n            <ng-container matColumnDef="footageToDelete">\n                <th mat-header-cell *matHeaderCellDef>{{ msgs.footageToDelete() }}</th>\n                <td mat-cell *matCellDef="let data">\n                    {{ data.daysFootageToDelete | number: \'1.0-2\' }} {{ msgs.day({ VALUE: data.daysFootageToDelete }) }}\n                    <span *ngIf="shouldShowTimeSpan(data)">\n                        ({{ msgs.spans() }} {{ data.daysDeletionTimeSpan | number: \'1.0-2\' }}\n                        {{ msgs.day({ VALUE: data.daysDeletionTimeSpan }) }})\n                    </span>\n                </td>\n            </ng-container>\n\n            <tr mat-header-row *matHeaderRowDef="[\'camera\', \'oldRetention\', \'newRetention\', \'footageToDelete\']; sticky: true"></tr>\n            <tr mat-row *matRowDef="let row; columns: [\'camera\', \'oldRetention\', \'newRetention\', \'footageToDelete\'];"></tr>\n        </table>\n    </div>\n    <p>{{ msgs.areYouSureYouWantToProceed() }}</p>\n</div>\n\n<ng-template #automaticText>{{ msgs.automatic().toLocaleLowerCase() }}</ng-template>\n'
        }
        ,
        52939: e => {
            e.exports = '<mat-label class="bulk-update-label">{{ msgs.applyDesiredRetentionAllCameras() }}</mat-label>\n<mat-form-field floatLabel="always">\n    <mat-select [(value)]="dropdownState" [disableOptionCentering]="true" [disabled]="disabled" (selectionChange)="onDropdownStateChange($event.value)" #matSelect="matSelect">\n        <mat-select-trigger>\n            <ng-container *ngIf="matSelect.selected?.value === \'automatic\'; else customAmtForm">\n                {{ msgs.automatic().toLocaleUpperCase() }}\n            </ng-container>\n            <ng-template #customAmtForm>\n                <div class="custom-amount-form" (click)="captureCustomFormClick($event)">\n                    <input matInput type="number" min="0" max="10000" [(ngModel)]="customRetentionVal" (ngModelChange)="retentionAmtUpdater$.next()" (blur)="setRetentionToAutomaticIfZero()">\n                    <span>{{ msgs.day({ VALUE: customRetentionVal }) }}</span>\n                </div>\n            </ng-template>\n        </mat-select-trigger>\n        <mat-option value="automatic">{{ msgs.automatic() }}</mat-option>\n        <mat-option value="custom">{{ msgs.customAmount() }}</mat-option>\n    </mat-select>\n</mat-form-field>\n'
        }
        ,
        26979: e => {
            e.exports = '<section layout="row" class="admin-section" flex>\n    <navigation display="left"></navigation>\n    <custom [plugin]="plugin" [extension]="extension"></custom>\n</section>\n'
        }
        ,
        36673: e => {
            e.exports = '\x3c!-- logo + nav-bar --\x3e\n<app></app>\n\n\x3c!-- main view --\x3e\n<div class="router-container">\n    <section class="fusion-app" [class]="{ \'unsupported-browser\': isUnsupported }">\n        \x3c!-- Component --\x3e\n        <router-outlet *ngIf="!appDestroyed; else applicationDeath"></router-outlet>\n\n        \x3c!-- Application Death --\x3e\n        <ng-template #applicationDeath>\n            <application-death></application-death>\n        </ng-template>\n    </section>\n</div>\n'
        }
        ,
        65704: e => {
            e.exports = '<alert-banner type="warning" [title]="title" faIcon="exclamation-triangle" [dismissable]="true" (onDismiss)="onDismiss.next()">\n    {{ msgs.dataForThisRecorderMayBeOutOfDateOnThisPage() }}\n    <br>\n    {{ msgs.toFixThisSaveAnyChangesAnd() }} <b><a (click)="reload()">{{ msgs.refreshThePage() }}</a></b>.\n</alert-banner>\n'
        }
        ,
        63180: e => {
            e.exports = '<div class="dialog-wrapper">\n    <h2 mat-dialog-title>{{ data.title }}</h2>\n    <div mat-dialog-content>{{ data.message }}</div>\n    <div mat-dialog-actions>\n        <button mat-button color="primary" [mat-dialog-close]="true">{{ data.ok }}</button>\n    </div>\n</div>\n'
        }
        ,
        81649: e => {
            e.exports = '<div class="greeting-dialog">\n    <div class="greeting-preview-container">\n        <h1 mat-dialog-title>{{ data.title | titlecase }}</h1>\n        <mat-dialog-content>\n            <div class="lawyer-speak">{{ data.greeting }}</div>\n        </mat-dialog-content>\n        <mat-dialog-actions layout="row">\n            \x3c!-- dismiss button --\x3e\n            <button class="dismiss-button" mat-button color="primary" (click)="close()">{{ data.msgs[0] }}</button>\n\n            \x3c!-- accept button --\x3e\n            <button mat-raised-button class="accept-button" color="primary" (click)="accept()" cdkFocusInitial>\n                {{ data.msgs[1] }}\n            </button>\n        </mat-dialog-actions>\n    </div>\n</div>\n'
        }
        ,
        51850: e => {
            e.exports = '<div class="layout-column layout-align-start-center splash-container" [ngClass]="{ \'fusion-app\': true }">\n    \x3c!-- Logo --\x3e\n    <div class="layout-column layout-align-end-end logo">\n        <span class="md-caption">{{ version }}</span>\n        <div class="layout-row layout-align-start-center">\n            <img src="images/header_logo.svg" class="header-logo">\n            <span data-brand-name class="logo-text">{{ appLogo }}</span>\n        </div>\n        <span class="license">{{ license$ | async }}</span>\n    </div>\n\n    \x3c!-- Username and password --\x3e\n    <form class="sign-in-form" [formGroup]="signInForm" novalidate>\n        <mat-form-field>\n            <mat-label>{{ messages.username() }}</mat-label>\n            <input matInput #userInput formControlName="username" autocorrect="off" autocapitalize="off" autofocus>\n        </mat-form-field>\n\n        <password-form-field formControlName="password" label="{{ messages.password() }}"> </password-form-field>\n\n        \x3c!-- LBM --\x3e\n        <mat-checkbox class="font-small" (change)="toggleCompatibilityMode()" [checked]="lowBandwidthMode" *ngIf="hasLowBandwidthOption && showLowBandwidthMode">\n            {{ messages.lowBandwidthMode() }}\n        </mat-checkbox>\n\n        \x3c!-- Access agreement checkbox --\x3e\n        <mat-checkbox class="font-small agreement" (change)="toggleAcceptGreeting()" [checked]="isGreetingAccepted" *ngIf="greeting">\n            {{ messages.agreementMessage() }}\n            <a class="singularity-link text-link" (click)="showGreeting({ event: $event })"><b>{{ messages.accessAgreement() }}</b></a>\n        </mat-checkbox>\n\n        \x3c!-- Sign in button --\x3e\n        <button mat-raised-button type="submit" color="primary" class="sign-in-button" [ngClass]="{ \'align-self-end\': !isPWA, \'align-self-stretch\': isPWA }" [disabled]="signInForm.invalid || processing" (click)="signInWithPassword()">\n            <mat-progress-spinner diameter="25" mode="indeterminate" *ngIf="processing" class="processing-spinner">\n            </mat-progress-spinner>\n            <span class="sign-in-text" [ngStyle]="{ visibility: processing ? \'hidden\' : \'visible\' }">\n                {{ messages.signIn() }}\n            </span>\n        </button>\n\n        \x3c!-- External provider buttons --\x3e\n        <div class="provider-sign-in-container" *ngIf="providerSignIn">\n            <div class="divider">\n                <hr class="left">\n                <span class="font-small">\n                    {{ messages.or() }} {{ messages.signInWithVALUE({ VALUE: \'\' }) | lowercase }}</span>\n                <hr class="right">\n            </div>\n            <ul class="providers">\n                <li *ngFor="let provider of providers; let i = index">\n                    <button mat-stroked-button color="primary" (click)="signInWithExternalLogin({ provider: provider })" [disabled]="processing">\n                        <i *ngIf="provider.providerType === \'Google\'" class="fa-kit fa-google" aria-hidden="true"></i>\n                        <i *ngIf="provider.providerType === \'Azure\'" class="fa-kit fa-windows" aria-hidden="true"></i>\n                        <i *ngIf="provider.providerType !== \'Azure\' && provider.providerType !== \'Google\'" class="fa-solid fa-right-to-bracket"></i>\n                        <span>{{ provider.providerType }}</span>\n                    </button>\n                </li>\n            </ul>\n        </div>\n\n        \x3c!-- Change servers (PWA only) --\x3e\n        <div class="redirect-pwa" *ngIf="isPWA">\n            <span>{{ messages.differentServer() }}\n                <a [href]="urlRedirectPWA"><br>\n                    {{ messages.tryAnother() }}</a></span>\n        </div>\n    </form>\n\n    \x3c!-- Link to .com website --\x3e\n    <div class="link-wrapper">\n        <a href="http://www.ipconfigure.com">\n            <img src="images/company.svg" data-brand-logo-footer>\n        </a>\n    </div>\n</div>\n'
        }
        ,
        75615: e => {
            e.exports = '<cdk-virtual-scroll-viewport class="scroll-container" *ngIf="loading === false && orchidsLength > 0">\n    <div [ngClass]="item.type.toLowerCase()" [style.marginLeft.px]="item.nesting ? item.nesting * 10 : 0" *cdkVirtualFor="let item of renderInfo.renderItems; let itemIndex = index; templateCacheSize: 0; trackBy: getRowId">\n        <ng-container [ngSwitch]="item.type">\n            \x3c!-- Label --\x3e\n            <p *ngSwitchCase="BagItemType.Label" [ngClass]="getClassLabel(item.msgType)" [title]="getEmptyLabelMessageTooltip(item)" matTooltipPosition="right">\n                {{ item.name }}\n            </p>\n            \x3c!-- Group/Server Button --\x3e\n            <button *ngSwitchDefault mat-button [ngClass]="item.isMap ? \'map-item-button\' : \'item-button\'" [attr.data-group-id]="item.groupId" [title]="item.name" (click)="item.canExpand && handleItemClick.emit(itemIndex)" [style.paddingLeft.px]="item.nesting ? 8 : 16" [style.margin]="item.nesting ? \'0px 0px 0px 10px\' : \'0px 0px 0px 0px\'">\n                \x3c!-- Map Configuration Found - Enable Group Map --\x3e\n                <i *ngIf="item.isMap" class="fa fa-location-dot"></i>\n                <span class="btn-text">{{ item.name }}</span>\n                <i class="fa" [hidden]="item.type !== BagItemType.Server && !item.canExpand" [ngClass]="{ \'fa-chevron-right\': !item.isExpanded, \'fa-chevron-down\': item.isExpanded }"></i>\n                <i class="fa fa-triangle-exclamation" *ngIf="item.type === BagItemType.Server && item.serverError"></i>\n            </button>\n            <div *ngSwitchCase="BagItemType.Preview" [ngClass]="\n                    layout === BagViewMode.Large\n                        ? \'preview-large\'\n                        : layout === BagViewMode.Detail\n                        ? \'preview-detail\'\n                        : \'preview-grid\'\n                " [title]="item.name">\n                <stream-preview [orchidId]="item.orchidId" [cameraId]="item.cameraId" [isCameraActive]="item.active" [previewImagePixelWidth]="bigItemLargeHeight" [attr.data-orchid-id]="item.orchidId" [attr.data-camera-id]="item.cameraId" [retryOnError]="bagIsExpanded" (doubleClick)="onStreamPreviewDoubleClick(item, $event)" class="stream-preview no-background-color" [ngClass]="{ \'tiny-thumbnail\': layout === BagViewMode.Detail }">\n                </stream-preview>\n                <p class="preview-title">{{ item.name }}</p>\n                <ng-container *ngIf="layout === BagViewMode.Detail">\n                    <div class="preview-server">{{ item.orchidName }}</div>\n                    <div class="preview-info">{{ item.detail }}</div>\n                </ng-container>\n            </div>\n            \x3c!-- Preview Rows --\x3e\n            <div *ngSwitchCase="BagItemType.GridRow" class="preview-grid">\n                <ng-container *ngFor="let preview of item.previews">\n                    <stream-preview [title]="preview.name" [orchidId]="preview.orchidId" [cameraId]="preview.cameraId" [isCameraActive]="preview.active" [previewImagePixelWidth]="bigItemLargeHeight" [attr.data-orchid-id]="preview.orchidId" [attr.data-camera-id]="preview.cameraId" [retryOnError]="bagIsExpanded" (doubleClick)="onStreamPreviewDoubleClick(preview, $event)" class="stream-preview tiny-thumbnail">\n                    </stream-preview>\n                </ng-container>\n            </div>\n        </ng-container>\n    </div>\n</cdk-virtual-scroll-viewport>\n'
        }
        ,
        1196: e => {
            e.exports = '<div class="header">\n    <i (click)="toggleFullScreen()" class="fa fa-lg cell-icon {{ !fullscreenToggled ? \'fa-maximize\' : \'fa-minimize\' }}">\n    </i>\n\n    <ng-content select="[cell-header-left]"></ng-content>\n    <span class="flex-gap"></span>\n    <ng-content select="[cell-header-right]"></ng-content>\n    <i class="fa fa-lg fa-times cell-icon" (click)="close()"> </i>\n</div>\n<ng-content class="content" select="[cell-content]"></ng-content>\n\n<i class="fa-kit fa-lg fa-resize-horizontal hidden-control resize-e" [hidden]="fullscreenToggled"></i>\n<i class="fa-kit fa-lg fa-resize-vertical hidden-control resize-s" [hidden]="fullscreenToggled"></i>\n<i class="fa fa-2x fa-caret-down resize-se hidden-control"> </i>\n'
        }
        ,
        21481: e => {
            e.exports = '<cell id="{{ id }}">\n    <div *ngIf="cameraGroup" cell-header-left class="map-left-header">\n        <span class="md-truncate md-body-1 player-title">\n            <span id="map-name">{{ cameraGroup.name }}</span>\n        </span>\n        <i class="fa fa-location-dot header-icon"></i>\n    </div>\n    <div cell-content>\n        <map #mapElement *ngIf="cameraGroup && error === null" [mapConfiguration]="cameraGroup.mapConfiguration" [cameras]="mappedCameras$" (onError)="handleError($event)" mode="cell">\n        </map>\n        <div *ngIf="error !== null" class="error">\n            {{ error }}\n\n            <div *ngIf="showUserRetry" (click)="retry()">\n                {{ msgs.retry() }}\n            </div>\n        </div>\n    </div>\n</cell>\n'
        }
        ,
        32117: e => {
            e.exports = '<div class="image-preview-container" [ngClass]="{\n        show: state === ComponentState.Loaded,\n        hide: state !== ComponentState.Loaded,\n        disabled: !isCameraActive && cameraDisablementIsSupported\n    }">\n    <img #preview [ngClass]="{\n            \'wide-preview\': widePreview,\n            \'tall-preview\': !widePreview\n        }">\n    <div class="disable-camera-status-container">\n        <tag type="disabled-camera"></tag>\n    </div>\n</div>\n<div #loading class="image-error-container" [ngClass]="{ show: state === ComponentState.Loading, hide: state !== ComponentState.Loading }">\n    <div class="loading" *ngIf="state === ComponentState.Loading">\n        <mat-spinner mode="indeterminate" diameter="20"></mat-spinner>\n    </div>\n</div>\n<div #unavailable class="image-error-container" [ngClass]="{ show: state === ComponentState.Failed, hide: state !== ComponentState.Failed }">\n    <div *ngIf="!cameraDisablementIsSupported" class="unavailable-icon">\n        <i class="fa-regular fa-frown"></i>\n    </div>\n    <div *ngIf="isCameraActive && cameraDisablementIsSupported" class="unavailable-icon">\n        <i class="fa-regular fa-frown"></i>\n    </div>\n    <div *ngIf="!isCameraActive && cameraDisablementIsSupported" class="disabled-camera-no-preview-icon">\n        <i class="fa-solid fa-video-slash"></i>\n    </div>\n</div>\n'
        }
        ,
        35041: e => {
            e.exports = '<mat-card class="preview" (click)="imageClicked($event)">\n    <mat-card-content>\n        <div class="preview-header">\n            \x3c!-- camera name --\x3e\n            <div class="ellipsis preview-label" *ngIf="showCameraName">{{ cameraName }}</div>\n\n            \x3c!-- stream select menu --\x3e\n            <button mat-icon-button *ngIf="hideStreamSelect !== true" [class.invisible]="streamOptions.length <= 1" [matMenuTriggerFor]="menu" (click)="$event.stopPropagation()">\n                <mat-icon class="fa fa-ellipsis-v"></mat-icon>\n            </button>\n            <mat-menu class="preview-checkbox-stream-menu" #menu="matMenu" xPosition="before" yPosition="below">\n                <button mat-button class="menu-button" *ngFor="let option of streamOptions" (click)="onStreamSelect(option)">\n                    <span>{{ option.name }}</span>\n                    <i class="fa fa-circle-check" [class.invisible]="option.stream !== selectedStream"></i>\n                </button>\n            </mat-menu>\n        </div>\n\n        <div class="preview-container">\n            \x3c!-- stream preview --\x3e\n            <stream-preview [ngClass]="{ \'darken-preview\': streamPreviewFailed, \'disable-preview\': disablePreviewCheckbox }" [orchidId]="camera.orchidId" [cameraId]="camera.id" [isCameraActive]="camera.active" (stateChange)="onPreviewStateChange($event)">\n            </stream-preview>\n\n            \x3c!-- errors --\x3e\n            <div *ngIf="disablePreviewCheckbox || checkboxActionFailed" [ngClass]="{\n                    \'camera-action-error\': checkboxActionFailed,\n                    \'camera-no-streams-error\': disablePreviewCheckbox\n                }">\n                <i class="fa fa-2x fa-triangle-exclamation fail-text" matTooltip="{{ disablePreviewCheckbox ? msgs.noStreamsConfigured() : error }}"></i>\n            </div>\n        </div>\n\n        \x3c!-- checkbox --\x3e\n        <div class="checkbox-container">\n            <mat-checkbox [disabled]="disablePreviewCheckbox" [ngClass]="{ darken: streamPreviewFailed }" (change)="onCheckChange($event)" [indeterminate]="false" [value]="camera"><span>{{ label }}</span>\n            </mat-checkbox>\n            <mat-icon *ngIf="enableMotionWarning && isRecordingWithoutMotion" #tooltip="matTooltip" (click)="$event.stopPropagation(); tooltip.toggle()" fontSet="fa" fontIcon="fa-triangle-exclamation" class="fail-text" [matTooltip]="msgs.cameraNotConfiguredForMotion()"></mat-icon>\n        </div>\n    </mat-card-content>\n</mat-card>\n'
        }
        ,
        22344: e => {
            e.exports = '<h1>{{ msgs.logExport() }}</h1>\n\n<div>\n    <p class="export-label">{{ msgs.format() }}</p>\n    <mat-radio-group class="logExport-radio-group" [(ngModel)]="exportFormat">\n        <mat-radio-button value="gzip">{{ msgs.gzip() }}</mat-radio-button>\n        <mat-radio-button value="text">{{ msgs.text() }}</mat-radio-button>\n    </mat-radio-group>\n</div>\n\n<div class="export-range">\n    <mat-checkbox [(ngModel)]="range" (change)="toggleCheckbox()"><span class="export-label">{{ msgs.specifyRange() }}</span></mat-checkbox>\n    <div [hidden]="!range" class="logExport-calendar-controls">\n        <div class="row">\n            <div class="col">\n                <p class="ipc-date-time-label">{{ msgs.from() }}</p>\n            </div>\n            <div class="col to-calendar-text">\n                <p class="ipc-date-time-label">{{ msgs.to() }}</p>\n            </div>\n        </div>\n        <div class="row logExport-calendar-buttons">\n            <div class="col">\n                <button class="calendar-btn-from" id="buttonFrom" mat-raised-button (click)="showDatetimePicker(false)" color="primary"><i class="calendar-icon fa-regular fa-calendar-days"></i>{{ from.getTime() | date:dateTimeFormat }}</button>\n            </div>\n            <div class="col to-calendar-control">\n                <button class="calendar-btn-to" id="buttonTo" mat-raised-button (click)="showDatetimePicker(true)" color="primary"><i class="calendar-icon fa-regular fa-calendar-days"></i>{{ to.getTime() | date:dateTimeFormat }}</button>\n            </div>\n        </div>\n        <div style="clear:both"></div>\n    </div>\n</div>\n\n<div class="warn" *ngIf="from > to" style="padding-top: 10px; padding-bottom: 10px;">{{ msgs.timeRangeErrorSystemReport() }}</div>\n\n<button mat-raised-button class="mat-primary action-button download-button" [disabled]="from > to" (click)="exportLogs()">{{ msgs.exportLogs() }}</button>\n'
        }
        ,
        48913: e => {
            e.exports = '<mat-dialog-content class="stream-preview-dialog">\n    <player [cameraName]="title" [orchid]="orchid" [camera]="camera" [streamId]="streamId" [onClose]="close" [options]="options"></player>\n</mat-dialog-content>\n'
        }
        ,
        33931: e => {
            e.exports = '<section layout="row" class="admin-section system-status-page" style="display: flex">\n    <navigation class="navigation-padding" display="left" *ngIf="isOrchid"></navigation>\n\n    <div class="admin-content centered system-status-page-content">\n        <page-loading *ngIf="loading || utesLoading" [progress]="msgs.loadingSystemStatus()"></page-loading>\n\n        <mat-card class="system-reports-container admin-card" *ngIf="!loading && !utesLoading && (isOrchid || hasSessionId())">\n            <mat-card-content class="camera-admin-content">\n                <h1 class="disk-utilitzation-title">{{ msgs.diskUtilization() }}</h1>\n                <disk-utes-bar [orchid]="orchid" [loading]="utesLoading"></disk-utes-bar>\n\n                <h1 class="stream-status-title">{{ msgs.streamStatus() }}</h1>\n\n                \x3c!-- Loading spinner takes precedence over all other page content while loading --\x3e\n                <div *ngIf="orchid.cameras && orchid.cameras.length > 0 && (utesLoading || loading)" class="utes-loading">\n                    <mat-progress-spinner diameter="25" color="primary" mode="indeterminate" style="margin-left: auto; margin-right: auto"></mat-progress-spinner>\n                </div>\n\n                \x3c!-- Degraded license message takes precedence over no active streams and failed to load streams message --\x3e\n                <p *ngIf="orchidLicenseIsDegraded" class="text-danger">\n                    {{ msgs.allStreamsDisabled() }}\n                </p>\n\n                \x3c!-- Failed to load streams message takes precedence over no active streams message --\x3e\n                <div *ngIf="!orchidLicenseIsDegraded && failedToLoadStreams" class="mat-elevation-z0">\n                    <p class="stream-loading-failed-message">{{ msgs.failedToLoadStreams() }}</p>\n                </div>\n\n                \x3c!-- No active streams message takes precedence over the streams table --\x3e\n                <div class="utes-loading" *ngIf="!orchidLicenseIsDegraded && !failedToLoadStreams && orchidHasNoActiveStreams">\n                    <div class="no-active-streams-message">\n                        {{ msgs.noActiveStreams() }}\n                    </div>\n                </div>\n\n                \x3c!-- The streams table only displays if none of the above errors occur --\x3e\n                <mat-card *ngIf="\n                        !orchidLicenseIsDegraded &&\n                        orchid.cameras &&\n                        orchid.cameras.length > 0 &&\n                        !loading &&\n                        !utesLoading &&\n                        !streamTableError\n                    " class="mat-elevation-z0">\n                    <mat-table #systemStatusTable class="stream-status-table" matSort (matSortChange)="onSortChange($event)" [dataSource]="dataSource" [matSortActive]="defaultSort.id" [matSortDirection]="defaultSort.start" [matSortDisableClear]="defaultSort.disableClear" multiTemplateDataRows>\n                        \x3c!-- Expanded Row Indicator --\x3e\n                        <ng-container [matColumnDef]="SystemStatusTableColumns.CHEVRON">\n                            <mat-header-cell *matHeaderCellDef></mat-header-cell>\n                            <mat-cell *matCellDef="let cameraMeta">\n                                <i class="fa expanded-row-indicator" [class.disabled-icon]="cameraMeta.activeStreams.length === 0" [class.fa-chevron-down]="cameraMeta.rowExpanded === true" [class.fa-chevron-right]="cameraMeta.rowExpanded === false"></i>\n                            </mat-cell>\n                        </ng-container>\n\n                        \x3c!-- Camera Name Column --\x3e\n                        <ng-container [matColumnDef]="SystemStatusTableColumns.NAME">\n                            <mat-header-cell *matHeaderCellDef mat-sort-header>{{ msgs.camera() }}</mat-header-cell>\n\n                            <mat-cell *matCellDef="let cameraMeta" class="camera-name-cell" [class.disabled-camera-text]="!isCameraEnabled(cameraMeta)">\n                                <i *ngIf="!isCameraEnabled(cameraMeta)" [class]="playerIcons.camera_disabled"></i>\n                                <span [matTooltip]="cameraMeta.name" [matTooltipPosition]="\'above\'" [matTooltipShowDelay]="250" [matTooltipClass]="\'system-status-custom-tooltip\'" class="system-status-ellipsis">{{ cameraMeta.name }}</span>\n                            </mat-cell>\n                        </ng-container>\n\n                        \x3c!-- Bitrate Column --\x3e\n                        <ng-container [matColumnDef]="SystemStatusTableColumns.BITRATE">\n                            <mat-header-cell *matHeaderCellDef mat-sort-header [start]="\'desc\'">\n                                {{ msgs.videoBitrate() }}\n                                <i class="tooltip-icon fa-solid fa-circle-question pl-5" matTooltip="{{ msgs.averageVideoBitrateOverPast15Minutes() }}" [matTooltipPosition]="\'above\'"></i>\n                            </mat-header-cell>\n                            <mat-cell *matCellDef="let cameraMeta">\n                                <div *ngIf="isCameraEnabled(cameraMeta)" [class.invisible]="cameraMeta.rowExpanded === true">\n                                    {{ cameraMeta.streamBitrateSumHumanized }}\n                                </div>\n                            </mat-cell>\n                        </ng-container>\n\n                        \x3c!-- Stream Status Column --\x3e\n                        <ng-container [matColumnDef]="SystemStatusTableColumns.STATUS">\n                            <mat-header-cell *matHeaderCellDef mat-sort-header [start]="\'desc\'">{{\n                                msgs.streams()\n                            }}</mat-header-cell>\n                            <mat-cell *matCellDef="let cameraMeta">\n                                <div [class.invisible]="cameraMeta.rowExpanded === true">\n                                    <div *ngIf="cameraMeta.activeStreams.length === 0">{{ msgs.none() }}</div>\n                                    <div class="stream-status-overview" *ngIf="cameraMeta.activeStreams.length > 0">\n                                        <div class="num-streams-running">\n                                            <i class="fa fa-circle-up"></i>\n                                            <span>{{ cameraMeta.runningStreams }}</span>\n                                        </div>\n                                        <div class="num-streams-not-running" [class.invisible]="\n                                                cameraMeta.activeStreams.length - cameraMeta.runningStreams === 0\n                                            ">\n                                            <i class="fa fa-circle-down"></i>\n                                            <span>{{\n                                                cameraMeta.activeStreams.length - cameraMeta.runningStreams\n                                            }}</span>\n                                        </div>\n                                    </div>\n                                </div>\n                            </mat-cell>\n                        </ng-container>\n\n                        \x3c!-- Last Archive Column --\x3e\n                        <ng-container [matColumnDef]="SystemStatusTableColumns.LAST_ARCHIVE">\n                            <mat-header-cell *matHeaderCellDef mat-sort-header>{{\n                                msgs.lastArchive()\n                            }}</mat-header-cell>\n                            <mat-cell *matCellDef="let cameraMeta" [class.text-danger]="cameraMeta.lastArchiveWrittenIssue === true">\n                                <div class="text-center centered-triangle" [class.invisible]="cameraMeta.rowExpanded === true" *ngIf="cameraMeta.lastArchiveWrittenIssue === true; else noArchiveIssues">\n                                    <i class="fa fa-triangle-exclamation text-danger"></i>\n                                </div>\n                                <ng-template #noArchiveIssues>\n                                    <div [class.invisible]="cameraMeta.rowExpanded === true">\n                                        {{ cameraMeta.allStreamsAreProxyOnly ? msgs.na() : msgs.lessThan60Seconds() }}\n                                    </div>\n                                </ng-template>\n                            </mat-cell>\n                        </ng-container>\n\n                        \x3c!-- Actions Column --\x3e\n                        <ng-container [matColumnDef]="SystemStatusTableColumns.ACTIONS">\n                            <mat-header-cell *matHeaderCellDef> </mat-header-cell>\n                            <mat-cell *matCellDef="let cameraMeta">\n                                <button mat-button mat-raised-button [color]="getVerifyStatus(cameraMeta.verifyResult)" [disabled]="cameraMeta.processingVerify === true || !isCameraEnabled(cameraMeta)" (click)="verifyCamera(cameraMeta, $event)">\n                                    <span [class.invisible]="cameraMeta.processingVerify">{{ msgs.verify() }}</span>\n                                    <mat-progress-spinner class="centered-spinner" *ngIf="cameraMeta.processingVerify" diameter="25" color="primary" mode="indeterminate"></mat-progress-spinner>\n                                </button>\n                            </mat-cell>\n                        </ng-container>\n\n                        <ng-container matColumnDef="nestedStreams">\n                            <mat-cell *matCellDef="let cameraMeta" [attr.colspan]="displayedColumns.length">\n                                <div *ngIf="cameraMeta.rowExpanded && cameraMeta.activeStreams.length > 0" class="nested-stream-table mat-elevation-z0">\n                                    \x3c!-- Nested Table of Camera Streams --\x3e\n                                    <mat-table #nestedStreamsTable multiTemplateDataRows [dataSource]="cameraMeta.activeStreams">\n                                        \x3c!-- Stream Icon Column --\x3e\n                                        <ng-container matColumnDef="streamChevron">\n                                            <mat-cell *matCellDef="let streamMeta">\n                                                <div class="stream-icon">\n                                                    <i class="fa-kit" [class.disabled-camera-text]="!isCameraEnabled(cameraMeta)" [ngClass]="{\n                                                            \'fa-video-camera\':\n                                                                streamMeta.id !== cameraMeta.primaryStream.id,\n                                                            \'fa-primary-stream\':\n                                                                streamMeta.id === cameraMeta.primaryStream.id\n                                                        }"></i>\n                                                </div>\n                                            </mat-cell>\n                                        </ng-container>\n\n                                        \x3c!-- Stream Name Column --\x3e\n                                        <ng-container matColumnDef="streamName">\n                                            <mat-cell *matCellDef="let streamMeta">\n                                                <span [matTooltip]="streamMeta.name" [matTooltipPosition]="\'above\'" [matTooltipShowDelay]="250" [matTooltipClass]="\'system-status-custom-tooltip\'" class="system-status-ellipsis" [class.disabled-camera-text]="!isCameraEnabled(cameraMeta)">{{ streamMeta.name }}</span>\n                                            </mat-cell>\n                                        </ng-container>\n                                        \x3c!-- Stream Average Bitrate Column --\x3e\n                                        <ng-container matColumnDef="streamBitrate">\n                                            <mat-cell *matCellDef="let streamMeta" [class.disabled-camera-text]="!isCameraEnabled(cameraMeta)">\n                                                {{\n                                                    streamMeta.averageBitrateHumanized\n                                                        ? streamMeta.averageBitrateHumanized\n                                                        : \'-\'\n                                                }}\n                                            </mat-cell>\n                                        </ng-container>\n\n                                        \x3c!-- Stream Status Column --\x3e\n                                        <ng-container matColumnDef="streamStatus">\n                                            <mat-cell *matCellDef="let streamMeta">\n                                                <span [class.disabled-camera-text]="!isCameraEnabled(cameraMeta)">{{\n                                                    statusTrans(streamMeta.streamStatus)\n                                                }}</span>\n                                                <span [class.disabled-camera-text]="!isCameraEnabled(cameraMeta)" *ngIf="\n                                                        streamMeta.retryCount > 0 &&\n                                                        streamMeta.streamStatus !== \'running\'\n                                                    ">&nbsp;({{ streamMeta.retryCount }})</span>\n                                            </mat-cell>\n                                        </ng-container>\n\n                                        \x3c!-- Stream Last Archive Column --\x3e\n                                        <ng-container matColumnDef="streamLastArchive">\n                                            <mat-cell *matCellDef="let streamMeta" [class.fail-text]="streamMeta.lastArchiveWrittenIssue === true" [class.disabled-camera-text]="!isCameraEnabled(cameraMeta)">\n                                                {{ streamMeta.lastArchiveWrittenHumanized }}\n                                            </mat-cell>\n                                        </ng-container>\n\n                                        \x3c!-- Stream Actions Column --\x3e\n                                        <ng-container matColumnDef="streamActions">\n                                            <mat-cell *matCellDef="let streamMeta">\n                                                <div *ngIf="isAdmin; else previewOnly" class="stream-actions-container">\n                                                    <button mat-icon-button mat-raised-button color="primary" [matTooltip]="\n                                                            isCameraEnabled(cameraMeta) ? msgs.restart() : null\n                                                        " [matTooltipPosition]="\'above\'" [matTooltipShowDelay]="250" [disabled]="!isCameraEnabled(cameraMeta)" (click)="restartStream(streamMeta, cameraMeta)" class="action-icon-button restart-stream-button child-primary-color">\n                                                        <mat-icon fontSet="fa" fontIcon="fa-refresh" [ngClass]="{\n                                                                \'fa-spin\': streamMeta.streamStatus === \'restarting\'\n                                                            }"></mat-icon>\n                                                    </button>\n\n                                                    <button mat-icon-button mat-raised-button color="primary" class="action-icon-button child-primary-color" [matTooltip]="\n                                                            isCameraEnabled(cameraMeta) ? msgs.preview() : null\n                                                        " [matTooltipPosition]="\'above\'" [matTooltipShowDelay]="250" [disabled]="!isCameraEnabled(cameraMeta)" (click)="previewStream(cameraMeta, streamMeta.id)">\n                                                        <mat-icon class="stream-preview-icon" fontSet="fa" fontIcon="fa-play-circle"></mat-icon>\n                                                    </button>\n                                                </div>\n                                                <ng-template #previewOnly>\n                                                    <button mat-button mat-raised-button color="primary" (click)="previewStream(cameraMeta, streamMeta.id)">\n                                                        {{ msgs.preview() }}\n                                                    </button>\n                                                </ng-template>\n                                            </mat-cell>\n                                        </ng-container>\n\n                                        \x3c!-- Small width table, fit columns into rows --\x3e\n                                        <ng-container matColumnDef="condensedRow">\n                                            <mat-cell *matCellDef="let streamMeta" class="system-status-bottom-border">\n                                                <div class="container">\n                                                    <div *ngIf="streamMeta.id === cameraMeta.primaryStream.id" class="name">\n                                                        <span class="key">{{ msgs.primaryStream() }}: </span>\n                                                        <span class="value">{{ streamMeta.name }}</span>\n                                                    </div>\n                                                    <div *ngIf="streamMeta.id !== cameraMeta.primaryStream.id" class="name">\n                                                        <span class="key">{{ msgs.stream() }}: </span>\n                                                        <span class="value">{{ streamMeta.name }}</span>\n                                                    </div>\n                                                    <div>\n                                                        <span class="key">{{ msgs.videoBitrate() }}</span>\n                                                        <span class="value">\n                                                            {{\n                                                                streamMeta.averageBitrateHumanized\n                                                                    ? streamMeta.averageBitrateHumanized\n                                                                    : \'-\'\n                                                            }}\n                                                        </span>\n                                                    </div>\n                                                    <div>\n                                                        <span class="key">{{ msgs.streamStatus() }}: </span>\n                                                        <span class="value">\n                                                            <span>{{ statusTrans(streamMeta.streamStatus) }}</span>\n                                                            <span *ngIf="\n                                                                    streamMeta.retryCount > 0 &&\n                                                                    streamMeta.streamStatus !== \'running\'\n                                                                ">&nbsp;({{ streamMeta.retryCount }})</span>\n                                                        </span>\n                                                    </div>\n                                                    <div>\n                                                        <span class="key">{{ msgs.lastArchive() }}: </span>\n                                                        <span class="value" [class.text-danger]="\n                                                                streamMeta.lastArchiveWrittenIssue === true\n                                                            ">\n                                                            {{ streamMeta.lastArchiveWrittenHumanized }}\n                                                        </span>\n                                                    </div>\n                                                    <div style="display: flex; justify-content: center">\n                                                        <button mat-button mat-raised-button style="margin-right: 8px" color="primary" (click)="previewStream(cameraMeta, streamMeta.id)" [disabled]="!isCameraEnabled(cameraMeta)">\n                                                            {{ msgs.preview() }}\n                                                        </button>\n\n                                                        <button mat-button mat-raised-button style="margin-left: 8px" color="primary" *ngIf="isAdmin" (click)="restartStream(streamMeta, cameraMeta)" [disabled]="!isCameraEnabled(cameraMeta)">\n                                                            {{ msgs.restart() }}\n                                                        </button>\n                                                    </div>\n                                                </div>\n                                            </mat-cell>\n                                        </ng-container>\n\n                                        <mat-row class="hide-lt-600" *matRowDef="\n                                                let row;\n                                                columns: [\n                                                    \'streamChevron\',\n                                                    \'streamName\',\n                                                    \'streamBitrate\',\n                                                    \'streamStatus\',\n                                                    \'streamLastArchive\',\n                                                    \'streamActions\'\n                                                ]\n                                            "></mat-row>\n\n                                        <mat-row class="hide-gt-600" *matRowDef="let row; columns: [\'condensedRow\']">\n                                        </mat-row>\n                                    </mat-table>\n                                </div>\n                            </mat-cell>\n                        </ng-container>\n\n                        <mat-header-row *matHeaderRowDef="displayedColumns"></mat-header-row>\n                        <mat-row class="camera-row" [class.expanded-row]="row.rowExpanded === true" [class.no-click]="row.activeStreams.length === 0" *matRowDef="let row; columns: displayedColumns" (click)="toggleCameraExpanded(row)">\n                        </mat-row>\n                        <mat-row *matRowDef="let row2; columns: [\'nestedStreams\']" class="stream-row" [class.hide-row]="row2.rowExpanded === false"></mat-row>\n                    </mat-table>\n                </mat-card>\n            </mat-card-content>\n        </mat-card>\n    </div>\n</section>\n'
        }
        ,
        80620: e => {
            e.exports = '<section class="fusion-users-manager-page dashboard-section">\n    <navigation display="left" class="dashboard-navigation"></navigation>\n\n    <div class="page-content">\n        <div class="fusion-user-manager-list-container" *ngIf="!loading">\n            <user-manager-list [groups]="groups"></user-manager-list>\n        </div>\n\n        <div class="fusion-users-error-message" *ngIf="failedToLoad">\n            {{ msgs.failedToLoadUsers() }}\n        </div>\n    </div>\n</section>\n'
        }
        ,
        65993: e => {
            e.exports = '<mat-card class="orchid-roles-card" style="margin-top: 25px">\n    <mat-card-content>\n        <h2>{{ msgs.userRoles() }}</h2>\n        <ul>\n            <li [innerHTML]="msgs.aLiveViewerCan()"></li>\n            <li [innerHTML]="msgs.aViewerCan()"></li>\n            <li [innerHTML]="msgs.aManagerCan()"></li>\n            <li [innerHTML]="msgs.anAdministratorCan()"></li>\n        </ul>\n    </mat-card-content>\n</mat-card>\n'
        }
        ,
        29525: e => {
            e.exports = '<section class="dashboard-section orchid-users-manager-page">\n    <navigation class="dashboard-navigation" display="left"></navigation>\n\n    <div class="page-content">\n        <div class="orchid-user-manager-list-container" *ngIf="!loading">\n            <user-manager-list [orchid]="orchid"></user-manager-list>\n            <orchid-roles></orchid-roles>\n        </div>\n\n        <div class="orchid-users-error-message" *ngIf="failedToLoad">\n            {{ msgs.failedToLoadUsers() }}\n        </div>\n    </div>\n</section>\n'
        }
        ,
        40984: e => {
            e.exports = '<div *ngIf="isPWA" class="top-bar">\n    <a href="#!/version"><i class="fa fa-arrow-left"></i></a>\n</div>\n<div id="swagger-ui"></div>\n'
        }
        ,
        81827: e => {
            e.exports = '<mat-toolbar color="primary" style="min-height: 64px;">\n    <span>{{ msgs.updateClientDialog.updateUIPackage() }}</span>\n    <button id="update-client-x-button" mat-icon-button (click)="cancel()">\n        <i class="fa fa-times fa-2x"></i>\n    </button>\n</mat-toolbar>\n\n<mat-dialog-content style="overflow-x: hidden;">\n    <input id="file-input" type="file" accept=".zip" cdkFocusInitial (change)="selectFile($event)" text-overflow="ellipsis" style="width: 100%;">\n</mat-dialog-content>\n\n<sing-dialog-errors (onClose)="shouldClose($event)" [errmsg]="error"></sing-dialog-errors>\n\n\n<mat-dialog-actions>\n    <button mat-button id="close-button" (click)="cancel()">{{ msgs.cancel() }}</button>\n    <button mat-raised-button color="primary" id="update-button" (click)="updateClient()" [disabled]="!inputFileList || this.inputFileList.length === 0 || isProcessing">\n        <span *ngIf="!isProcessing else spinner"> {{ msgs.update() }}</span>\n        <ng-template #spinner>\n            <mat-progress-spinner diameter="35" color="primary" mode="indeterminate"></mat-progress-spinner>\n        </ng-template>\n    </button>\n\n</mat-dialog-actions>\n'
        }
        ,
        88832: e => {
            e.exports = '<section layout="row" class="dashboard-section" flex>\n    <navigation class="dashboard-navigation" *ngIf="isPageWithNavigation()" display="left"></navigation>\n    <div class="page-content">\n        <div class="centered" *ngIf="componentState === ComponentState.Loading">\n            <page-loading [progress]="msgs.loadingVersionInformation()"> </page-loading>\n        </div>\n\n        <div class="version-info-loading-failed" *ngIf="componentState === ComponentState.Failed">\n            {{ msgs.failedToLoadVersionInfo() }}\n        </div>\n\n        <mat-card class="centered" *ngIf="componentState === ComponentState.Loaded">\n            <mat-card-content>\n                <mat-card-title class="header">{{ msgs.versionInfo() }}</mat-card-title>\n                <mat-card-content class="info-card">\n                    <dl class="dl-horizontal">\n                        <dt>{{ msgs.versionInfo() }}</dt>\n                        <dd class="emphasis">{{ info.version }}</dd>\n                    </dl>\n\n                    <dl class="dl-horizontal">\n                        <dt>{{ msgs.targetArch() }}</dt>\n                        <dd class="emphasis">{{ info.buildInfo.target }}</dd>\n                    </dl>\n\n                    <dl class="dl-horizontal">\n                        <dt>{{ msgs.buildInfo() }}</dt>\n                        <dd class="emphasis">{{ info.buildInfo.hash }}</dd>\n                        <dd>{{ info.buildDate }}</dd>\n                        <dd>{{ info.buildInfo.user }}</dd>\n                        <dd>{{ info.buildInfo.host }}</dd>\n                    </dl>\n\n                    \x3c!-- We don\'t want to show "Client" section on servers page --\x3e\n                    <dl *ngIf="isPageWithNavigation()" class="dl-horizontal">\n                        <dt>{{ msgs.client() }}</dt>\n                        <dd class="emphasis">e4b6899735c581f02dbe2d1dd76dded118dd925c</dd>\n                        <dd class="emphasis">\n                            24.12.0\n                            <a class="dialog-singularity-link text-link" *ngIf="isAdmin && isOrchid" (click)="showUpdateClient()">{{ msgs.updateClient() }}</a>\n                        </dd>\n                    </dl>\n\n                    <dl class="dl-horizontal" *ngIf="true">\n                        <dt>{{ msgs.resources() }}</dt>\n                        <dd>\n                            <a class="singularity-link text-link" href="http://www.ipconfigure.com/manuals/" target="_blank">{{ msgs.userManuals() }}</a>\n                        </dd>\n                        <dd>\n                            <a class="singularity-link text-link" href="http://training.ipconfigure.com/" target="_blank">{{ msgs.userTraining() }}</a>\n                        </dd>\n                        <dd>\n                            <a class="singularity-link text-link" href="https://support.ipconfigure.com/" target="_blank">{{ msgs.knowledgeBase() }}</a>\n                        </dd>\n                    </dl>\n\n                    <dl class="dl-horizontal">\n                        <dt>{{ msgs.devDocs() }}</dt>\n\n                        <dd *ngIf="isOrchid || (!isOrchid && !orchid)">\n                            <a class="singularity-link text-link" [href]="getApiRoute()" target="_blank">{{\n                                getApiRouteLabel()\n                            }}</a>\n                        </dd>\n                        <dd>\n                            <a class="singularity-link text-link" href="OpenSourceAcknowledgment.pdf" target="_blank">{{\n                                msgs.openSourceAcks()\n                            }}</a>\n                        </dd>\n                    </dl>\n                </mat-card-content>\n\n                <mat-card-content class="info-card">\n                    <h2 style="font-size: 19px">{{ msgs.changeLog() }}</h2>\n                    <code class="change-log" [innerHtml]="info.changelog"></code>\n                </mat-card-content>\n\n                <mat-card-content class="info-card">\n                    <h2 style="font-size: 19px">{{ msgs.eula() }}</h2>\n                    <code class="eula" [innerHtml]="info.eula"></code>\n                </mat-card-content>\n\n                <p>&copy; {{ cpYear }} IPConfigure Inc.</p>\n            </mat-card-content>\n\n            <sing-dialog-errors *ngIf="componentState === ComponentState.Failed" [errmsg]="error" [canClose]="false"></sing-dialog-errors>\n        </mat-card>\n    </div>\n</section>\n'
        }
        ,
        44300: e => {
            e.exports = '<expand-button color="white" ng-click="bag.toggle()" [expanded]="bag.expanded" type="triangle" direction="right"></expand-button>\n\n<div class="layout-column bag-wrapper">\n    <md-tabs md-center md-dynamic-height md-border-bottom class="flex" ng-class="{ \'orchid-bag\': bag.isOrchid }">\n        \x3c!-- Cameras Tab --\x3e\n        <md-tab label="{{ bag.msgs.cameras() }}">\n            <md-content id="cameras-column" class="layout-column">\n                \x3c!-- Loading Spinner --\x3e\n                <div ng-if="bag.loading" class="list-loading">\n                    <md-progress-circular md-diameter="92"></md-progress-circular>\n                </div>\n\n                \x3c!-- Empty Servers --\x3e\n                <div ng-if="bag.loading === false && bag.orchids.length === 0" class="list-empty">\n                    <div ng-if="bag.canRegister">\n                        <error-banner type="empty-data" [title]="bag.msgs.noServersConfigured()" [icon]="bag.icons.servers.server">\n                            <a class="body-small text-link" href="#!/orchids">{{ bag.msgs.registerAServer() }}</a>\n                        </error-banner>\n                    </div>\n\n                    <div ng-if="!bag.canRegister">\n                        <error-banner type="empty-data" [title]="bag.msgs.noAccessibleServers()" [description]="bag.msgs.thereAreNoAccessibleServers()" [icon]="bag.icons.servers.error"></error-banner>\n                    </div>\n                </div>\n\n                \x3c!-- Empty Cameras --\x3e\n                <div ng-if="bag.isOrchid === true && bag.loading === false && bag.orchids[0].cameras.length === 0" class="list-empty">\n                    <error-banner ng-if="bag.isAdmin" type="empty-data" [title]="bag.msgs.noCamsConfigured()" [icon]="bag.icons.camera">\n                        <a class="body-small text-link" href="#!/cameras">{{ bag.msgs.addCamera() }}</a>\n                    </error-banner>\n                    <error-banner ng-if="!bag.isAdmin" type="empty-data" [title]="bag.msgs.noCamsConfigured()" [description]="bag.msgs.thereAreNoAccessibleCameras()" [icon]="bag.icons.camera">\n                    </error-banner>\n                </div>\n\n                \x3c!-- Bag Controls (Search, Thumbnail display mode) --\x3e\n                <div ng-if="!bag.loading && bag.orchids.length > 0">\n                    <div style="text-align: center" ng-if="!bag.isOrchid">\n                        <div style="margin: 0 15px" id="bag-search-container">\n                            <md-chips ng-model="bag.search" md-add-on-blur="true" placeholder="{{ ::bag.msgs.search() }}" secondary-placeholder="{{ ::bag.msgs.search() }}"></md-chips>\n                        </div>\n                        <div class="bag-modes">\n                            <md-button ng-class="{\'md-raised md-primary\': bag.layout === \'GRID\'}" ng-click="bag.layout = \'GRID\'">\n                                <i class="fa fa-th-large"></i>\n                            </md-button>\n                            <md-button ng-class="{\'md-raised md-primary\': bag.layout === \'LARGE\'}" ng-click="bag.layout = \'LARGE\'">\n                                <i class="fa fa-square"></i>\n                            </md-button>\n                            <md-button ng-class="{\'md-raised md-primary\': bag.layout === \'DETAIL\'}" ng-click="bag.layout = \'DETAIL\'">\n                                <i class="fa-solid fa-list"></i>\n                            </md-button>\n                        </div>\n                    </div>\n                </div>\n\n                \x3c!-- Main Content --\x3e\n                <bag-render id="bag-render" [render-info]="bag.bagRenderInfo" [layout]="bag.layout" [loading]="bag.loading" [orchids-length]="bag.orchids.length" [bag-is-expanded]="bag.expanded" (handle-stream-preview-double-click)="handleStreamPreviewDoubleClick($event)" (handle-item-click)="bag.handleRenderItemClick($event)"></bag-render>\n\n                <div md-whiteframe="3" class="bottom-buttons">\n                    <md-button class="md-raised md-primary action-button recycle-button" ng-click="bag.clearStage()">\n                        {{ bag.msgs.clearStage() }}\n                    </md-button>\n                </div>\n            </md-content>\n        </md-tab>\n\n        \x3c!-- Stages Tab --\x3e\n        <md-tab label="{{ bag.msgs.stages() }}">\n            <md-content class="stages-container layout-column">\n                \x3c!-- Stage Cycle Controls --\x3e\n                <div ng-show="bag.stages.length > 0" class="layout-row layout-align-start-center md-body-1" style="padding: 10px 0 10px 10px">\n                    <span>{{ ::bag.msgs.cycle() }}</span>\n                    <md-select ng-model="bag.stageCycle.speed" style="width: 120px; margin: 0 0 0 10px">\n                        <md-option ng-repeat="value in [0, 5, 10, 15, 20, 25, 30, 45, 60, 90, 120]" value="{{value}}">\n                            {{ ::value > 0 ? bag.msgs.valueSeconds({ VALUE: value }) : bag.msgs.disabled() }}\n                        </md-option>\n                    </md-select>\n                </div>\n\n                <div class="no-saved-stages-msg-container" ng-if="bag.stages.length == 0">\n                    <error-banner type="empty-data" [title]="bag.msgs.noSavedStages()" [icon]="bag.icons.info_light"></error-banner>\n                </div>\n\n                \x3c!-- Stage List --\x3e\n                <md-virtual-repeat-container id="vertical-container" class="stage-list-container" ng-if="bag.stages.length > 0">\n                    <div class="stage-row" md-virtual-repeat="stage in bag.stages" ng-class="{ current: !stage.isNew && bag.stageCycle.currentStage === stage.id }" ng-click="stage.editting || bag.selectStage(stage)">\n                        <form style="display: flex; justify-content: space-between; padding: 0 1px">\n                            <div ng-if="!stage.editting" class="stage-name-container">\n                                <md-checkbox md-no-ink ng-checked="!bag.stageCycle.excludeFromCycle[stage.id]" ng-click="$event.stopPropagation(); bag.toggleCycleInclude(stage)"></md-checkbox>\n                                <span class="stage-name">{{stage.name}}\n                                    <md-tooltip md-autohide md-direction="top" md-delay="500">{{stage.name}}\n                                    </md-tooltip>\n                                </span>\n                            </div>\n                            <div class="stage-share-toggle">\n                                <i ng-if="bag.isAdmin === true && stage.shared === true" class="fa fa-globe" style="padding-top: 12px">\n                                    <md-tooltip md-autohide md-direction="right" md-delay="500">{{ ::bag.msgs.thisStageVisibleToAllUsers() }}</md-tooltip>\n                                </i>\n                            </div>\n                            <div>\n                                <md-button class="md-icon-button" ng-if="bag.isAdmin === false && stage.shared === true" ng-disabled="true">\n                                    <i class="fa fa-lock">\n                                        <md-tooltip md-autohide md-direction="right" md-delay="500">{{ ::bag.msgs.stageSharedWithYouByAdmin() }}</md-tooltip>\n                                    </i>\n                                </md-button>\n                                <md-menu ng-if="(bag.isAdmin || stage.shared !== true) && stage.editting !== true">\n                                    <md-button class="md-icon-button stage-menu-toggle" ng-click="$mdMenu.open($event)">\n                                        <i class="fa fa-ellipsis-v"></i>\n                                    </md-button>\n                                    <md-menu-content>\n                                        <md-menu-item ng-if="!stage.shared && bag.isAdmin">\n                                            <md-button ng-click="bag.shareStage(stage)">\n                                                <i class="fa fa-level-up"></i>&nbsp;&nbsp;{{ ::bag.msgs.share() }}\n                                            </md-button>\n                                        </md-menu-item>\n                                        <md-menu-item ng-if="stage.shared && bag.isAdmin">\n                                            <md-button ng-click="bag.unshareStage(stage)">\n                                                <i class="fa fa-level-down"></i>&nbsp;&nbsp;{{ ::bag.msgs.unShare() }}\n                                            </md-button>\n                                        </md-menu-item>\n                                        <md-menu-item>\n                                            <md-button ng-click="bag.updateStage(stage)">\n                                                <i class="fa fa-save"></i>&nbsp;&nbsp;{{ ::bag.msgs.update() }}\n                                            </md-button>\n                                        </md-menu-item>\n                                        <md-menu-item>\n                                            <md-button ng-click="bag.editStage(stage)">\n                                                <i class="fa fa-pencil"></i>&nbsp;&nbsp;{{ ::bag.msgs.rename() }}\n                                            </md-button>\n                                        </md-menu-item>\n                                        <md-menu-item>\n                                            <md-button ng-click="bag.removeStage(stage)">\n                                                <i class="fa-regular fa-trash-can"></i>&nbsp;&nbsp;{{\n                                                ::bag.msgs.remove() }}\n                                            </md-button>\n                                        </md-menu-item>\n                                    </md-menu-content>\n                                </md-menu>\n                            </div>\n                        </form>\n                    </div>\n                </md-virtual-repeat-container>\n\n                <div md-whiteframe="3" class="bottom-buttons">\n                    <md-button class="md-raised md-primary action-button add-button" ng-click="bag.newStage()">\n                        {{ ::bag.msgs.saveStage() }}\n                    </md-button>\n                </div>\n            </md-content>\n        </md-tab>\n    </md-tabs>\n</div>\n'
        }
        ,
        48507: e => {
            e.exports = '<bag-cameras maybe-cameras="cameraGroup.group.cameras" search="cameraGroup.search" camera-layout="cameraGroup.cameraLayout" show-orchid="true" handle-double-click="cameraGroup.handleDoubleClick" update-my-camera-counts="cameraGroup.updateMyCameraCounts" path="cameraGroup.path"></bag-cameras>\n\n<div ng-if="cameraGroup.parentPath.length > 0 && cameraGroup.group.cameras.length === 0 && cameraGroup.group.groups.length === 0" class="md-margin md-caption no-cameras-message">\n    {{ ::cameraGroup.msgs.noCamerasConfiguredInGroup() }}\n</div>\n\n<div class="md-dense group-list" ng-if="cameraGroup.group">\n    <md-button ng-repeat-start="group in cameraGroup.group.groups | orderBy: \'name\' track by group.id" ng-click="cameraGroup.toggleExpand(group)" md-no-ink class="layout-row label-button group-button">\n        <div class="group-label" title="{{::group.name}}">\n            {{ ::group.name }}\n        </div>\n        <i ng-class="cameraGroup.expanded[group.id] ? \'fa-chevron-down\' : \'fa-chevron-right\'" class="md-margin fa"></i>\n    </md-button>\n    <div ng-repeat-end ng-if="cameraGroup.expanded[group.id]" class="sub-group-container">\n        <camera-group parent-path="cameraGroup.path" parent-id="cameraGroup.group.id" group="group" camera-layout="cameraGroup.cameraLayout" enter-group="cameraGroup.enterGroup" handle-double-click="cameraGroup.handleDoubleClick" expanded="cameraGroup.expanded[group.id] && cameraGroup.expanded"></camera-group>\n    </div>\n</div>\n'
        }
        ,
        67624: e => {
            e.exports = '<section layout="row" class="admin-section" flex>\n    <navigation display="left"></navigation>\n\n    \x3c!--<div class="camera-group-admin-container-area">\n        <md-content style="height: 100%">\n            <camera-group-view class="expanded" ng-if="cameraGroupConfig.groupsLoaded" root-group="cameraGroupConfig.rootGroup" group="cameraGroupConfig.rootGroup" parent-group="cameraGroupConfig.rootGroup" is-root="true" style="min-height: 100%; max-height: 999999999999999px">\n            </camera-group-view>\n        </md-content>\n    </div>--\x3e\n\n    <div class="generic-admin-container-area">\n        <md-content class="camera-groups-failed-loading-message" ng-if="cameraGroupConfig.failedLoading">{{ ::cameraGroupConfig.msgs.failedToLoadCameraGroups() }}</md-content>\n\n        <md-content class="centered" ng-if="!cameraGroupConfig.failedLoading">\n\n            <page-loading ng-if="cameraGroupConfig.loading" progress="cameraGroupConfig.msgs.loadingCameraGroups()">\n            </page-loading>\n\n            <div ng-if="!cameraGroupConfig.loading" class="camera-group-content">\n                <div class="generic-admin-header">\n                    <span class="spacer" flex></span>\n                    <camera-group-view class="camera-group-button-contatiner" root-group="cameraGroupConfig.rootGroup" group="cameraGroupConfig.rootGroup" display="root"></camera-group-view>\n                </div>\n                <md-card ng-if="filteredGroups.length > cameraGroupConfig.paging.paginatorLimit || cameraGroupConfig.filters.searchNames.length">\n                    <md-card-content class="camera-group-search-card-content">\n                        <md-input-container class="flex-100 camera-group-config-search-container">\n                            <label>{{ ::cameraGroupConfig.msgs.name() }}</label>\n                            <md-chips ng-model="cameraGroupConfig.filters.searchNames" md-add-on-blur="true" placeholder="{{ ::cameraGroupConfig.msgs.search() }}" secondary-placeholder="{{ ::cameraGroupConfig.msgs.search() }}" md-on-add="cameraGroupConfig.onFiltersChanged()" md-on-remove="cameraGroupConfig.onFiltersChanged()">\n                            </md-chips>\n                        </md-input-container>\n                    </md-card-content>\n                </md-card>\n\n                <md-content ng-if="cameraGroupConfig.rootGroup.groups.length === 0 || (cameraGroupConfig.rootGroup.groups.length !== 0 && filteredGroups.length === 0)">\n                    <div class="md-no-sticky no-bananas no-matches-error-message" ng-switch="cameraGroupConfig.noGroupsOrSearchDidNotMatchSwitchKey">\n                        <span ng-switch-default>{{ ::cameraGroupConfig.msgs.noCameraGroupsExist() }}</span>\n                        <span ng-switch-when="matches">{{ ::cameraGroupConfig.msgs.yourSearchDidNotMatchAnyGroups() }}</span>\n                    </div>\n                </md-content>\n                <div ng-if="filteredGroups.length > 0 && cameraGroupConfig.pagingPages(filteredGroups.length) > 0" class="content-list-counter">\n                    {{ cameraGroupConfig.msgs.cameraGroupsRange({ RANGE: cameraGroupConfig.pageRange(filteredGroups),\n                    LENGTH: filteredGroups.length}) }}\n                </div>\n                <md-card class="group-card camera-group-view card-view" ng-repeat="group in (filteredGroups = cameraGroupConfig.filteredGroups | orderBy : \'name\' |\n                    limitTo : cameraGroupConfig.paging.perPage : cameraGroupConfig.getStartFromIndex() ) track by group.id" big-summer-blowout="cameraGroupConfig.expanded[group.id]" id="{{group.id}}-row">\n                    <camera-group-view parent-group="cameraGroupConfig.rootGroup" root-group="cameraGroupConfig.rootGroup" group="group" expanded="cameraGroupConfig.expanded" display="card"></camera-group-view>\n                </md-card>\n                <mat-paginator ng-if="filteredGroups.length > cameraGroupConfig.paging.paginatorLimit" show-first-last-buttons [length]="cameraGroupConfig.filteredGroups.length" [page-index]="cameraGroupConfig.paging.current" [page-size]="cameraGroupConfig.paging.perPage" [page-size-options]="cameraGroupConfig.paging.pageSizeOptions" (page)="cameraGroupConfig.onPageChange($event)"></mat-paginator>\n                <div class="camera-group-settings">\n                    <md-button class="md-raised md-primary manage-button action-button" aria-label="{{ ::cameraGroupConfig.msgs.groupSettings() }}" ng-click="cameraGroupConfig.openSettingsDialog($event)">\n                        <span hide-xs>{{ ::cameraGroupConfig.msgs.cameraGroupSettings() }}</span>\n                        <span hide-gt-xs>{{ ::cameraGroupConfig.msgs.settings() }}</span>\n                    </md-button>\n\n                    <md-button ng-if="cameraGroupConfig.rootGroup.groups.length > 0" ng-show="cameraGroupConfig.ungroupedCameraCount !== -1" ng-disabled="cameraGroupConfig.ungroupedCameraCount === 0" class="md-raised md-primary inspect-button action-button" aria-label="{{ ::cameraGroupConfig.msgs.groupSettings() }}" ng-click="cameraGroupConfig.openUngroupedDialog($event)">\n                        <span hide-xs>{{ cameraGroupConfig.msgs.numUngroupedCameras({ VALUE: cameraGroupConfig.ungroupedCameraCount }) }}</span>\n                        <span hide-gt-xs>\n                            {{ cameraGroupConfig.msgs.numUngroupedCamerasShort({ VALUE: cameraGroupConfig.ungroupedCameraCount }) }}\n                        </span>\n                    </md-button>\n                </div>\n            </div>\n        </md-content>\n    </div>\n</section>\n'
        }
        ,
        94185: e => {
            e.exports = '<div ng-switch on="cameraGroup.display">\n    <new-camera-group ng-switch-when="root"></new-camera-group>\n    <camera-group-card ng-switch-when="card"></camera-group-card>\n    <baguette ng-switch-when="baguette"></baguette>\n</div>\n'
        }
        ,
        80167: e => {
            e.exports = '<div class="camera-group-view baguette" ng-class="{ \'odd-depth\': cameraGroup.parentPath.length % 2 === 1, \'even-depth\': cameraGroup.parentPath.length % 2 === 0 }">\n    <div class="group-title" ng-click="cameraGroup.toggle()">\n        <div class="group-toggle" md-no-ink>\n            <div class="toggle-text baguette-name">{{ cameraGroup.group.name }}</div>\n            <div ng-if="cameraGroup.group.mapConfiguration !== null" class="map-marker">\n                <i class="fa fa-location-dot"></i>\n            </div>\n            <div class="group-toggler">\n                <i ng-show="!cameraGroup.expanded[cameraGroup.group.id]" class="fa fa-chevron-right"></i>\n                <i ng-show="cameraGroup.expanded[cameraGroup.group.id]" class="fa fa-chevron-down"></i>\n            </div>\n        </div>\n        <div class="baguette-actions">\n            \x3c!-- Server Count --\x3e\n            <icon-total class="align-center pl-10 hide-xs" [number]="cameraGroup.group.contentCount.servers" [primary-color]="false" [icon]="\'fa-regular fa-server\'"></icon-total>\n\n            \x3c!-- Camera Count --\x3e\n            <icon-total class="align-center hide-xs" [number]="cameraGroup.group.contentCount.cameras" [primary-color]="false" [icon]="\'fa-video-camera\'"></icon-total>\n\n            <md-menu class="group-menu">\n                <md-button class="md-icon-button" ng-click="$mdMenu.open($event)">\n                    <i class="fa fa-ellipsis-v"></i>\n                </md-button>\n                <md-menu-content width="3">\n                    <md-menu-item>\n                        <md-button ng-click="cameraGroup.newGroup($event)">\n                            <i class="fa fa-plus"></i>&nbsp;&nbsp;&nbsp;{{ ::cameraGroup.msgs.addSubGroup() }}\n                        </md-button>\n                    </md-menu-item>\n                    <md-menu-item ng-if="cameraGroup.group.mapConfiguration === null">\n                        <md-button ng-click="cameraGroup.editMap($event)" ng-disabled="cameraGroup.processing">\n                            <i class="fa fa-location-dot"></i>&nbsp;&nbsp;&nbsp;{{ ::cameraGroup.msgs.addMap() }}\n                        </md-button>\n                    </md-menu-item>\n                    <md-menu-item ng-if="cameraGroup.group.mapConfiguration !== null">\n                        <md-button ng-click="cameraGroup.editMap($event)" ng-disabled="cameraGroup.processing">\n                            <i class="fa fa-location-dot"></i>&nbsp;&nbsp;&nbsp;{{ ::cameraGroup.msgs.editMap() }}\n                        </md-button>\n                    </md-menu-item>\n                    <md-menu-item>\n                        <md-button ng-click="cameraGroup.moveGroup($event)">\n                            <i class="fa fa-exchange"></i>&nbsp;&nbsp;&nbsp;{{ ::cameraGroup.msgs.moveGroup() }}\n                        </md-button>\n                    </md-menu-item>\n                    <md-menu-item>\n                        <md-button ng-click="cameraGroup.editGroup($event)">\n                            <i class="fa fa-pencil"></i>&nbsp;&nbsp;&nbsp;{{ ::cameraGroup.msgs.editGroup() }}\n                        </md-button>\n                    </md-menu-item>\n                    <md-menu-item>\n                        <md-button ng-click="cameraGroup.destroySelf($event)">\n                            <i class="fa-regular fa-trash-can"></i>&nbsp;&nbsp;&nbsp;{{ ::cameraGroup.msgs.deleteGroup()\n                            }}\n                        </md-button>\n                    </md-menu-item>\n                </md-menu-content>\n            </md-menu>\n        </div>\n    </div>\n    <div ng-if="cameraGroup.expanded[cameraGroup.group.id]" class="group-details">\n        <div class="mt-10 mb-10" ng-if="!cameraGroup.cameraCountExceedsThreshold" flex layout="row" layout-wrap>\n            <div>\n                <camera-group-cameras camera-map="cameraGroup.orchidCameraMap"></camera-group-cameras>\n            </div>\n        </div>\n\n        <div class="mt-10 mb-10" ng-if="cameraGroup.cameraCountExceedsThreshold">\n            <span class="empty-data-text mt-10">{{ ::cameraGroup.msgs.groupContainsVALUEOrMoreCameras({VALUE: cameraGroup.GROUP_SIZE_THRESHOLD})\n                }}</span>\n        </div>\n\n        \x3c!-- Empty group notice --\x3e\n        <div class="empty-data-text mt-10 mb-10" ng-if="cameraGroup.group.groups.length === 0 && cameraGroup.group.cameras.length === 0 && cameraGroup.group.orchids.length === 0">\n            {{ cameraGroup.msgs.thisGroupIsEmpty() }}\n        </div>\n\n        \x3c!-- Sub-groups --\x3e\n        <div ng-if="cameraGroup.path">\n            <camera-group-view ng-repeat="group in cameraGroup.group.groups | orderBy:\'name\'" group="group" parent-path="cameraGroup.path" root-group="cameraGroup.rootGroup" expanded="cameraGroup.expanded" display="baguette"></camera-group-view>\n        </div>\n    </div>\n</div>\n'
        }
        ,
        93053: e => {
            e.exports = '<div style="display: flex" layout="row" layout-wrap>\n    <div class="group-field-text" flex="100" style="font-size: 14px">\n        <div ng-repeat="orchidId in cameraGroupCameras.cameraMap | orderMapByOrchidName">\n            <div class="orchid-name sub-title" ng-if="!cameraGroupCameras.collapse">\n                <md-checkbox ng-if="cameraGroupCameras.selectable" ng-checked="cameraGroupCameras.selectedOrchids[orchidId]" ng-click="cameraGroupCameras.toggleSelectAll(orchidId, $event)" aria-hidden="true"></md-checkbox>\n                <i ng-if="!cameraGroupCameras.selectable" class="fa-regular fa-server"></i>\n                {{$root.orchids[$root.orcDict[orchidId].index].name}}:\n            </div>\n            <div class="orchid-name sub-title orchid-toggle" ng-if="cameraGroupCameras.collapse" ng-click="cameraGroupCameras.expanded[orchidId] = !cameraGroupCameras.expanded[orchidId]">\n                <div class="orchid-toggle-left-content">\n                    <md-checkbox ng-if="cameraGroupCameras.selectable" ng-checked="cameraGroupCameras.selectedOrchids[orchidId]" ng-click="cameraGroupCameras.toggleSelectAll(orchidId, $event)" aria-hidden="true"></md-checkbox>\n                    <i ng-if="!cameraGroupCameras.selectable" class="fa-regular fa-server"></i>\n                    {{$root.orchids[$root.orcDict[orchidId].index].name}}\n                    <i class="expand-icon fa" ng-class="{ \'fa-chevron-right\': !cameraGroupCameras.expanded[orchidId], \'fa-chevron-down\': cameraGroupCameras.expanded[orchidId] }"></i>\n                </div>\n                <div class="count-container">\n                    <div class="camera-count">{{ cameraGroupCameras.cameraMap[orchidId].cameras.length }}</div>\n                </div>\n            </div>\n            <div class="cameras-container" ng-class="{ \'selectable\': cameraGroupCameras.selectable }" ng-if="!cameraGroupCameras.collapse || cameraGroupCameras.expanded[orchidId] === true">\n                \x3c!-- Orchid Server image --\x3e\n                <div class="list-camera" ng-show="cameraGroupCameras.cameraMap[orchidId].all" ng-click="cameraGroupCameras.cameraMap[orchidId].showOrchidCameras[orchidId] = !cameraGroupCameras.cameraMap[orchidId].showOrchidCameras[orchidId]">\n                    <div class="orchid-logo-container">\n                        <img class="preview-image orchid-logo" src="images/logo_small_white.png">\n                    </div>\n                    <div class="orchid-toggle-name camera-name">\n                        <span ng-show="$root.orchids[$root.orcDict[orchidId].index].cameras.length === 0">{{ ::groupDialog.msgs.noCameras() }}</span>\n                        <span ng-hide="$root.orchids[$root.orcDict[orchidId].index].cameras.length === 0">\n                            <a href="javascript:void(0)" ng-hide="cameraGroupCameras.cameraMap[orchidId].showOrchidCameras[orchidId]">{{ groupDialog.msgs.showNCameras({ VALUE:\n                                $root.orchids[$root.orcDict[orchidId].index].cameras.length }) }}</a>\n                            <a href="javascript:void(0)" ng-show="cameraGroupCameras.cameraMap[orchidId].showOrchidCameras[orchidId]">{{ ::groupDialog.msgs.hideCameras() }}</a>\n                        </span>\n                    </div>\n                </div>\n\n                \x3c!-- All cameras registered to the Orchid --\x3e\n                <div class="list-camera" ng-if="cameraGroupCameras.cameraMap[orchidId].showOrchidCameras[orchidId] && $root.orchids[$root.orcDict[orchidId].index].cameras.length <= cameraGroupCameras.GROUP_SIZE_THRESHOLD" ng-repeat="camera in $root.orchids[$root.orcDict[orchidId].index].cameras | orderBy:sortingCameraNames" ng-click="cameraGroupCameras.toggleSelected(camera)">\n                    <stream-preview [camera-id]="camera.id" [orchid-id]="$root.orchids[$root.orcDict[orchidId].index].id" [is-camera-active]="camera.active" ng-class="{ \'good\': cameraGroupCameras.cameraMap[orchidId].isRunning(camera), \'clickable\': !cameraGroupCameras.selectable }" ng-click="cameraGroupCameras.selectable === \'true\' ? undefined : cameraGroupCameras.previewStream(camera, $event)">\n                    </stream-preview>\n                    <div class="camera-name">{{camera.name}}</div>\n                </div>\n\n                \x3c!-- Orchid has too many cameras to render message --\x3e\n                <div ng-if="cameraGroupCameras.cameraMap[orchidId].showOrchidCameras[orchidId] && $root.orchids[$root.orcDict[orchidId].index].cameras.length > cameraGroupCameras.GROUP_SIZE_THRESHOLD" class="list-camera hint-text">\n                    {{::cameraGroupCameras.msgs.orchidContainsVALUEOrMoreCameras({VALUE:\n                    cameraGroupCameras.GROUP_SIZE_THRESHOLD})}}\n                </div>\n\n                \x3c!-- Orchid has no cameras message --\x3e\n                <div ng-if="cameraGroupCameras.cameraMap[orchidId].showOrchidCameras[orchidId] && $root.orchids[$root.orcDict[orchidId].index].cameras.length === 0" class="list-camera gray-italic">\n                    {{::cameraGroupCameras.msgs.thereAreNoCamerasAssociatedWithThisServer()}}\n                </div>\n\n                \x3c!-- All individually grouped cameras --\x3e\n                <div class="list-camera" ng-repeat="camera in cameraGroupCameras.cameraMap[orchidId].cameras | orderBy:sortingCameraNames" ng-click="cameraGroupCameras.selectable ? cameraGroupCameras.toggleSelected(camera) : undefined">\n                    <md-checkbox ng-if="cameraGroupCameras.selectable" ng-checked="cameraGroupCameras.selected[cameraGroupCameras.makeCameraKey(orchidId, camera.id)]" aria-hidden="true"></md-checkbox>\n                    <stream-preview class="tiny-thumbnail" [camera-id]="camera.id" [orchid-id]="$root.orchids[$root.orcDict[orchidId].index].id" [is-camera-active]="camera.active" ng-click="cameraGroupCameras.selectable ? undefined : cameraGroupCameras.previewStream(camera, $event)">\n                    </stream-preview>\n                    <div class="camera-name">{{camera.name}}</div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n'
        }
        ,
        51414: e => {
            e.exports = '<div style="align-items: unset">\n    <md-list-item class="blowout-header md-no-proxy">\n        <table style="width: 100%" class="group-list">\n            <tr class="group-list-row">\n                <td class="group-name">\n                    <div style="word-break: break-word">\n                        {{ cameraGroup.group.name }}\n                        <i ng-if="cameraGroup.group.mapConfiguration !== null" class="fa fa-location-dot"></i>\n                    </div>\n                </td>\n                <td class="group-count hide-xs">\n                    <icon-total [number]="cameraGroup.group.contentCount.servers" [primary-color]="false" [icon]="\'fa-regular fa-server\'"></icon-total>\n                </td>\n                <td class="group-count hide-xs">\n                    <icon-total [number]="cameraGroup.group.contentCount.cameras" [primary-color]="false" [icon]="\'fa-video-camera\'"></icon-total>\n                </td>\n                <td class="group-menu-container">\n                    <md-menu class="group-menu">\n                        <md-button class="md-icon-button" ng-mouseup="$event.stopPropagation();" ng-click="$mdMenu.open($event)">\n                            <i class="fa fa-ellipsis-v"></i>\n                        </md-button>\n                        <md-menu-content width="3">\n                            \x3c!--<md-menu-item>\n                                <md-button ng-click="cameraGroup.enterGroup($event, cameraGroup.group)">\n                                    <i class="fa fa-level-down"></i>&nbsp;&nbsp;&nbsp;Enter Group\n                                </md-button>\n                            </md-menu-item>--\x3e\n                            <md-menu-item>\n                                <md-button ng-click="cameraGroup.newGroup($event)">\n                                    <i class="fa fa-plus"></i>&nbsp;&nbsp;&nbsp;{{ ::cameraGroup.msgs.addSubGroup() }}\n                                </md-button>\n                            </md-menu-item>\n                            <md-menu-item ng-if="cameraGroup.group.mapConfiguration === null">\n                                <md-button ng-click="cameraGroup.editMap($event)" ng-disabled="cameraGroup.processing">\n                                    <i class="fa fa-location-dot"></i>&nbsp;&nbsp;&nbsp;{{ ::cameraGroup.msgs.addMap()\n                                    }}\n                                </md-button>\n                            </md-menu-item>\n                            <md-menu-item ng-if="cameraGroup.group.mapConfiguration !== null">\n                                <md-button ng-click="cameraGroup.editMap($event)" ng-disabled="cameraGroup.processing">\n                                    <i class="fa fa-location-dot"></i>&nbsp;&nbsp;&nbsp;{{ ::cameraGroup.msgs.editMap()\n                                    }}\n                                </md-button>\n                            </md-menu-item>\n                            <md-menu-item>\n                                <md-button ng-click="cameraGroup.moveGroup($event)">\n                                    <i class="fa fa-exchange"></i>&nbsp;&nbsp;&nbsp;{{ ::cameraGroup.msgs.moveGroup() }}\n                                </md-button>\n                            </md-menu-item>\n                            <md-menu-item>\n                                <md-button ng-click="cameraGroup.editGroup($event)">\n                                    <i class="fa fa-pencil"></i>&nbsp;&nbsp;&nbsp;{{ ::cameraGroup.msgs.editGroup() }}\n                                </md-button>\n                            </md-menu-item>\n                            <md-menu-item>\n                                <md-button ng-click="cameraGroup.destroySelf($event)">\n                                    <i class="fa-regular fa-trash-can"></i>&nbsp;&nbsp;&nbsp;{{\n                                    ::cameraGroup.msgs.deleteGroup() }}\n                                </md-button>\n                            </md-menu-item>\n                        </md-menu-content>\n                    </md-menu>\n                </td>\n            </tr>\n            <tr class="group-list-row show-when-small">\n                <td colspan="3" class="group-description">{{ cameraGroup.currentGroup.description }}</td>\n            </tr>\n        </table>\n    </md-list-item>\n    <md-list-item class="blowout-container group-view-container" ng-if="cameraGroup.expanded[cameraGroup.group.id]" ng-mouseup="$event.stopPropagation()">\n        <md-content class="bread-crumb-container" ng-if="bag.groupCrumbs.length > 0">\n            <md-button class="bread-crumb" ng-disabled="bag.groupCrumbs.length === 0" ng-click="bag.exitGroups({ id: 0 })">{{ ::cameraGroup.msgs.home() }}</md-button>\n            <i class="crumb-divider fa fa-angle-double-right" ng-repeat-start="group in bag.groupCrumbs"></i>\n            <md-button class="bread-crumb" ng-disabled="$last" ng-click="bag.exitGroups(group)" ng-repeat-end>{{ group.name }}</md-button>\n        </md-content>\n\n        <div style="width: 100%; margin-top: 15px">\n            \x3c!-- Count of servers and cameras included in the group --\x3e\n            <div class="mt-10" ng-if="!cameraGroup.cameraCountExceedsThreshold" flex layout="row" layout-wrap>\n                <div>\n                    <camera-group-cameras camera-map="cameraGroup.orchidCameraMap"></camera-group-cameras>\n                </div>\n            </div>\n\n            <div class="mt-10" ng-if="cameraGroup.cameraCountExceedsThreshold">\n                <span class="empty-data-text mt-10">{{ ::cameraGroup.msgs.groupContainsVALUEOrMoreCameras({VALUE: cameraGroup.GROUP_SIZE_THRESHOLD})\n                    }}</span>\n            </div>\n\n            \x3c!-- Empty group notice --\x3e\n            <div class="empty-data-text no-matches-error-message" ng-if="cameraGroup.group.groups.length === 0 && cameraGroup.group.cameras.length === 0 && cameraGroup.group.orchids.length === 0">\n                {{ ::cameraGroup.msgs.thisGroupIsEmpty() }}\n            </div>\n\n            \x3c!-- Sub-groups --\x3e\n            <div style="margin-top: 20px" ng-if="cameraGroup.path">\n                <camera-group-view ng-repeat="group in cameraGroup.currentGroup.groups | orderBy:\'name\'" group="group" parent-path="cameraGroup.path" root-group="cameraGroup.rootGroup" expanded="cameraGroup.expanded" display="baguette"></camera-group-view>\n            </div>\n\n            <div style="display: flex; margin: 15px 0" layout="row" layout-wrap>\n                <span flex></span>\n                <md-button class="md-raised md-primary action-button map-button" ng-click="cameraGroup.editMap($event)" ng-disabled="cameraGroup.processing">\n                    <span hide-xs ng-if="cameraGroup.group.mapConfiguration === null">{{ ::cameraGroup.msgs.addMap() }}</span>\n                    <span hide-xs ng-if="cameraGroup.group.mapConfiguration !== null">{{ ::cameraGroup.msgs.editMap() }}</span>\n                    <span hide-gt-xs>{{ ::cameraGroup.msgs.map() }}</span>\n                </md-button>\n                <md-button class="md-raised md-primary action-button add-button" ng-click="cameraGroup.newGroup($event)" ng-disabled="cameraGroup.processing">\n                    <span hide-xs>{{ ::cameraGroup.msgs.addSubGroup() }}</span>\n                    <span hide-gt-xs>{{ ::cameraGroup.msgs.addSubGroupShort() }}</span>\n                </md-button>\n                <md-button class="md-raised md-primary action-button modify-button" ng-click="cameraGroup.editGroup($event)" ng-disabled="cameraGroup.processing">\n                    <span hide-xs>{{ ::cameraGroup.msgs.editGroup() }}</span>\n                    <span hide-gt-xs>{{ ::cameraGroup.msgs.editGroupShort() }}</span>\n                </md-button>\n                <md-button class="md-raised md-warn action-button remove-button" ng-click="cameraGroup.destroySelf($event)" ng-disabled="cameraGroup.processing">\n                    <span hide-xs>{{ ::cameraGroup.msgs.deleteGroup() }}</span>\n                    <span hide-gt-xs>{{ ::cameraGroup.msgs.deleteGroupShort() }}</span>\n                </md-button>\n            </div>\n        </div>\n    </md-list-item>\n</div>\n'
        }
        ,
        15869: e => {
            e.exports = '<md-button class="md-raised md-primary action-button add-button" aria-label="{{ cameraGroup.msgs.addGroup() }}" ng-click="cameraGroup.newGroup($event)">\n    <span hide-xs>{{ cameraGroup.msgs.addCameraGroup() }}</span><span hide-gt-xs>{{ cameraGroup.msgs.addCameraGroupShort() }}</span>\n</md-button>\n'
        }
        ,
        37446: e => {
            e.exports = '<md-dialog class="camera-group-dialog">\n    <form name="cameraGroupForm">\n        <md-toolbar>\n            <div class="md-toolbar-tools">\n                <h2>{{::groupDialog.title}}</h2>\n                <span flex></span>\n                <md-button class="md-icon-button" ng-click="groupDialog.cancel()" ng-disabled="groupDialog.processing">\n                    <i class="fa fa-times fa-2x"></i>\n                </md-button>\n            </div>\n        </md-toolbar>\n        <md-content class="md-padding" id="dialog-scroll-region" style="padding-bottom: 0">\n            <md-input-container class="md-block">\n                <label>{{ ::groupDialog.msgs.groupName() }}</label>\n                <input name="name" ng-model="groupDialog.shadowGroup.name" md-autofocus required>\n                <div ng-messages="cameraGroupForm.name.$error" role="alert" multiple="multiple">\n                    <div ng-message="required" class="my-message">{{ ::groupDialog.msgs.groupNameIsRequired() }}</div>\n                </div>\n            </md-input-container>\n\n            \x3c!-- Camera picker component --\x3e\n            <div class="md-block">\n                <camera-picker [loaded]="groupDialog.loaded" [editing]="groupDialog.editing" [data]="groupDialog.data" [orchids]="groupDialog.shadowGroup.orchids" [cameras]="groupDialog.shadowGroup.cameras" (on-selected-servers-change)="groupDialog.onSelectedServersChange($event)" (on-selected-cameras-change)="groupDialog.onSelectedCamerasChange($event)" (on-total-data-list-change)="groupDialog.onTotalDataListChange($event)"></camera-picker>\n            </div>\n        </md-content>\n\n        <dialog-errors target-object="groupDialog"></dialog-errors>\n        <md-dialog-actions layout="row">\n            \x3c!-- Tally of chosen cameras and servers --\x3e\n            <div class="running-total">\n                <md-button color="primary" ng-disabled="groupDialog.totalSelected < 1">\n                    <span class="total-text">\n                        {{ groupDialog.messages.totalServers({SERVERS: groupDialog.serversSelected }) }} &nbsp {{\n                        groupDialog.messages.totalCameras({CAMERAS: groupDialog. camerasSelected }) }}\n                    </span>\n                    <span class="total-icons">\n                        <i class="fa-regular fa-server"></i>: {{ groupDialog.serversSelected }} &nbsp\n                        <i class="fa fa-video-camera"></i>: {{ groupDialog.camerasSelected }}\n                    </span>\n                </md-button>\n            </div>\n            <span flex></span>\n            <md-button ng-click="groupDialog.cancel()">{{ ::groupDialog.msgs.cancel() }}</md-button>\n            <md-button class="md-raised md-primary" type="submit" ng-disabled="cameraGroupForm.$invalid || groupDialog.processing" ng-click="groupDialog.addOrUpdateGroup()">\n                <span ng-if="!groupDialog.processing">{{groupDialog.saveText}}</span>\n                <md-progress-circular md-mode="indeterminate" md-diameter="35px" ng-if="groupDialog.processing" style="margin: auto"></md-progress-circular>\n            </md-button>\n        </md-dialog-actions>\n    </form>\n</md-dialog>\n'
        }
        ,
        87592: e => {
            e.exports = '<section class="flex layout-row admin-section">\n    <navigation ng-if="cameraConfig.isOrchid" display="left"> </navigation>\n\n    <div class="camera-admin-container-area">\n        <md-content class="centered" ng-cloak>\n            <div class="camera-admin-header" ng-if="cameraConfig.camerasLoaded">\n                <div class="camera-count-text-container">\n                    <span class>{{ cameraConfig.createCamerasEnabledText() }}</span>\n                    <span class>{{ cameraConfig.createCamerasDisabledText() }}</span>\n                </div>\n                <md-button ng-click="cameraConfig.addCamera($event)" aria-label="{{ ::cameraConfig.msgs.addCamera() }}" ng-cloak class="md-raised md-primary add-orchid-button action-button add-button">\n                    <span> {{ ::cameraConfig.msgs.add() }} {{ ::cameraConfig.msgs.camera() }} </span>\n                </md-button>\n            </div>\n            <div ng-if="cameraConfig.deleteErrors.length > 0" class="bulk-delete-errors">\n                {{ ::cameraConfig.msgs.errors() }}\n                <ul>\n                    <li ng-repeat="error in cameraConfig.deleteErrors">{{error}}</li>\n                </ul>\n            </div>\n            \x3c!--No cameras have been configured--\x3e\n            <md-content ng-show="cameraConfig.orchid.cameras.length === 0 || !cameraConfig.camerasLoaded" class="no-cameras">\n                <div class="md-no-sticky no-matches-error-message">\n                    <div ng-hide="cameraConfig.camerasLoaded" class="loading-container">\n                        <md-progress-circular md-diameter="20" md-mode="indeterminate"> </md-progress-circular>\n                        <h2 style="margin-left: 10px">{{ ::cameraConfig.msgs.loadingCameras() }}</h2>\n                    </div>\n                    <div ng-show="cameraConfig.camerasLoaded" ng-cloak>\n                        {{ ::cameraConfig.msgs.noCamerasConfigured() }}\n                    </div>\n                </div>\n            </md-content>\n\n            \x3c!-- Search/Filters Tools--\x3e\n            <md-card class="search-tools-card" ng-if="cameraConfig.camerasLoaded && cameraConfig.orchid.cameras.length > 0">\n                <div class="search-tools-container">\n                    \x3c!-- Searchbar --\x3e\n                    <md-input-container class="searchbar-container md-input-container">\n                        <label>{{ cameraConfig.msgs.searchCameras() }}</label>\n                        <input ng-keyup="cameraConfig.handleSearchKeyUp($event)" autocapitalize="none" type="text">\n                    </md-input-container>\n\n                    \x3c!-- Filter buttons --\x3e\n                    <div class="filter-buttons-container">\n                        \x3c!-- STATUS --\x3e\n                        <filter-button-menu [filters]="cameraConfig.cameraStatusFilters" [filter-label]="cameraConfig.msgs.status()" (add-filter)="cameraConfig.onAddFilter($event)" (remove-filter)="cameraConfig.onRemoveFilter($event)"></filter-button-menu>\n\n                        \x3c!-- TAGS --\x3e\n                        <filter-button-menu [filters]="cameraConfig.cameraTagFilters" [filter-label]="cameraConfig.msgs.tag()" (add-filter)="cameraConfig.onAddFilter($event)" (remove-filter)="cameraConfig.onRemoveFilter($event)"></filter-button-menu>\n                    </div>\n                </div>\n                <div ng-if="cameraConfig.activeFilters.length > 0" class="active-filters-container">\n                    <filter-chip ng-repeat="filter in cameraConfig.activeFilters" [filter]="filter" (on-remove)="cameraConfig.removeFilter($index)"></filter-chip>\n                    <button class="filters-reset-button body-small mat-delete" matRipple ng-click="cameraConfig.removeAllFilters()">\n                        {{cameraConfig.msgs.common.reset()}}\n                    </button>\n                </div>\n            </md-card>\n\n            <md-card class="camera-card" big-summer-blowout="cameraConfig.isExpanded[camera.id]" ng-repeat="camera in (cameraConfig.filteredCameras | orderBy: sortingCameraNames |\n                limitTo: cameraConfig.paging.perPage :  cameraConfig.paging.perPage * cameraConfig.paging.current) track by camera.id" id="{{camera.name.toLowerCase().split(\' \').join(\'-\')}}-{{camera.id}}-row" ng-if="cameraConfig.camerasLoaded">\n                <md-content>\n                    <md-list-item ng-class="cameraConfig.shouldDelete[camera.id] ? \'selected\' : \'not-selected\'" class="blowout-header">\n                        <table style="width: 100%" class="camera-list">\n                            <tr class="camera-list-row">\n                                <td class="stream-status-cell">\n                                    <div ng-click="$event.stopPropagation()" ng-mouseup="$event.stopPropagation()" class="toggle-container">\n                                        <i ng-class="cameraConfig.getCameraStatusIconClass(camera)" class="stream-status fa-solid fa-2x" ng-hide="camera.deleteProcessing">\n                                        </i>\n                                        <md-checkbox ng-click="angular.noop()" ng-mouseup="cameraConfig.toggleSelected(camera)" ng-checked="cameraConfig.shouldDelete[camera.id] === true" ng-hide="camera.deleteProcessing" class="row-toggle">\n                                        </md-checkbox>\n                                        <md-progress-circular ng-if="camera.deleteProcessing" md-diameter="25" md-mode="indeterminate">\n                                        </md-progress-circular>\n                                    </div>\n                                </td>\n\n                                <td ng-click="cameraConfig.callback({ camera: camera })" ng-class="{ \'clickable\': cameraConfig.callback }" class="camera-label-cell">\n                                    <h4>{{camera.name}}</h4>\n                                    <span> {{cameraConfig.streamDetails(camera)}} </span>\n\n                                    <ng-container ng-if="cameraConfig.displayMode === cameraConfig.DISPLAY_MODE.LIST">\n                                        <resource-tag-list ng-if="camera.tags.length > 0" [tags]="camera.tags" [max-tags-visible]="cameraConfig.MIN_TAG_LIST_LENGTH"></resource-tag-list>\n                                    </ng-container>\n                                    <ng-container ng-if="cameraConfig.displayMode === cameraConfig.DISPLAY_MODE.SINGLE_CHIP">\n                                        <tag class="single-chip-tag" ng-if="camera.tags.length > 0" type="primary" [label]="cameraConfig.msgs.tags.AMOUNTtags({ AMOUNT: camera.tags.length })"></tag>\n                                    </ng-container>\n                                </td>\n\n                                <td ng-mouseup="$event.stopPropagation()" align="center" class="stream-preview-cell">\n                                    <md-tooltip md-autohide md-delay="1000" md-direction="left" md-z-index="1">\n                                        \x3c!-- Hacky solution for determining an object is empty. This avoids introducing an extra watcher calculating this conditional.--\x3e\n                                        \x3c!-- Possible refactor is to map the cameras when initialized to some property--\x3e\n                                        {{ cameraConfig.msgs.cameraStreamId({CID: camera.id, SID: camera.primaryStream\n                                        && (camera.primaryStream | json) !== \'{}\' ? camera.primaryStream.id : \'-\' }) }}\n                                    </md-tooltip>\n                                    <stream-preview ng-click="cameraConfig.previewStream(camera, $event)" [camera-id]="camera.id" [orchid-id]="cameraConfig.orchid.id" [is-camera-active]="camera.active" [no-cache]="true" class="no-background-color good dashboard-preview">\n                                    </stream-preview>\n                                </td>\n                            </tr>\n                        </table>\n                    </md-list-item>\n                    <md-list-item ng-if="cameraConfig.isExpanded[camera.id]" ng-mouseup="$event.stopPropagation()" class="blowout-container">\n                        <edit-camera orchid="cameraConfig.orchid" camera="camera" configured-cameras="cameraConfig.orchid.cameras" camera-tz-info="cameraConfig.cameraTzInfo">\n                        </edit-camera>\n                    </md-list-item>\n                </md-content>\n            </md-card>\n\n            <error-banner ng-if="cameraConfig.camerasLoaded && cameraConfig.orchid.cameras.length > 0 && cameraConfig.filteredCameras.length === 0" [type]="\'empty-search-filters\'"></error-banner>\n\n            <div class="footer-delete" ng-show="cameraConfig.camerasLoaded && cameraConfig.filteredCameras.length > 0" ng-cloak>\n                <div class="delete-selected-container">\n                    <md-checkbox ng-disabled="cameraConfig.processingDeletedCameras" ng-model="cameraConfig.selectAll" ng-change="cameraConfig.selectAllChanged(cameraConfig.selectAll)" class="select-page-toggle">\n                    </md-checkbox>\n                    <md-button ng-click="cameraConfig.deleteCameras()" ng-disabled="cameraConfig.camerasSelectedCount < 1 || cameraConfig.processingDeletedCameras" class="md-raised md-warn action-button" ng-class="{\'remove-button\': !editCamera.deleting}">\n                        <span> {{ ::cameraConfig.msgs.delete() }} </span>\n                    </md-button>\n                </div>\n                <div class="camera-pagination bottom-pager" ng-show="cameraConfig.filteredCameras.length > cameraConfig.paging.pageCameraLimit">\n                    <mat-paginator show-first-last-buttons [length]="cameraConfig.filteredCameras.length" [page-index]="cameraConfig.paging.current" [page-size]="cameraConfig.paging.perPage" [page-size-options]="cameraConfig.paging.pageSizeOptions" (page)="cameraConfig.updateCurrentPage($event)" aria-label="{{ ::cameraConfig.msgs.ariaLabels.selectCameraPage() }}">\n                    </mat-paginator>\n                </div>\n            </div>\n        </md-content>\n    </div>\n</section>\n'
        }
        ,
        67446: e => {
            e.exports = '<md-dialog id="dewarp-config-dialog">\n    <md-toolbar>\n        <div class="layout-row layout-align-space-between-center md-toolbar-tools">\n            <h2>{{ ::dewarpConfig.msgs.dewarpSettings() }}</h2>\n            <md-button ng-click="dewarpConfig.cancel()" class="md-icon-button">\n                <i class="fa fa-times fa-2x"></i>\n            </md-button>\n        </div>\n    </md-toolbar>\n    <md-dialog-content class="md-dialog-content flex layout-column">\n        <div class="flex dewarp-wrapper layout-column layout-align-center-center">\n            <div class="image-load-spinner layout-column layout-align-center-center" ng-if="dewarpConfig.loading === true">\n                <md-progress-circular md-mode="indeterminate" md-diameter="90"></md-progress-circular>\n            </div>\n            <div ng-if="dewarpConfig.imageLoadErrorMessage !== null" class="layout-column layout-align-center-center error-message">\n                {{ ::dewarpConfig.imageLoadErrorMessage }}\n            </div>\n            \x3c!-- The Dewarp Canvas will be appended here --\x3e\n        </div>\n        <md-tabs md-center-tabs>\n            <md-tab ng-click="dewarpConfig.enablePerspectiveMode()" label="{{ ::dewarpConfig.msgs.perspective() }}">\n                <md-content>\n                    <div class="layout-row layout-wrap">\n                        \x3c!-- Pan Settings --\x3e\n                        <div class="flex-100 flex-gt-sm-33 layout-padding padding-top-0 padding-sides-0 layout-row">\n                            <md-input-container class="flex-20 flex-gt-sm-40">\n                                <label> {{ ::dewarpConfig.msgs.defaultPan() }}&deg; </label>\n                                <input ng-model="dewarpConfig.pan" ng-model-options="{ getterSetter: true }" name="pan" type="number" min="{{dewarpConfig.viewLimits.pan.min}}" max="{{dewarpConfig.viewLimits.pan.max}}" step="1" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()">\n                            </md-input-container>\n                            <md-slider ng-model="dewarpConfig.pan" ng-model-options="{ getterSetter: true }" min="{{dewarpConfig.viewLimits.pan.min}}" max="{{dewarpConfig.viewLimits.pan.max}}" step="1" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()" class="margin-right-0 flex-60 flex-gt-sm-75 md-primary">\n                            </md-slider>\n                        </div>\n\n                        \x3c!-- Tilt Settings --\x3e\n                        <div class="flex-100 flex-gt-sm-33 layout-padding padding-top-0 padding-sides-0 layout-row">\n                            <md-input-container class="flex-20 flex-gt-sm-40">\n                                <label> {{ ::dewarpConfig.msgs.defaultTilt() }}&deg; </label>\n                                <input ng-model="dewarpConfig.tilt" ng-model-options="{ getterSetter: true }" name="tilt" type="number" min="{{dewarpConfig.viewLimits.tilt.min}}" max="{{dewarpConfig.viewLimits.tilt.max}}" step="1" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()">\n                            </md-input-container>\n                            <md-slider ng-model="dewarpConfig.tilt" ng-model-options="{ getterSetter: true }" min="{{dewarpConfig.viewLimits.tilt.min}}" max="{{dewarpConfig.viewLimits.tilt.max}}" step="1" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()" class="margin-right-0 flex-60 flex-gt-sm-75 md-primary">\n                            </md-slider>\n                        </div>\n\n                        \x3c!-- Zoom Settings --\x3e\n                        <div class="flex-100 flex-gt-sm-33 layout-padding padding-top-0 padding-sides-0 layout-row">\n                            <md-input-container class="flex-20 flex-gt-sm-40">\n                                <label> {{ ::dewarpConfig.msgs.defaultZoom() }} </label>\n                                <input ng-model="dewarpConfig.zoom" ng-model-options="{ getterSetter: true }" name="zoom" type="number" min="0.1" max="10" step="0.1" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()">\n                            </md-input-container>\n                            <md-slider ng-model="dewarpConfig.zoom" ng-model-options="{ getterSetter: true }" min="0.1" max="10" step="0.1" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()" class="margin-right-0 flex-60 flex-gt-sm-75 md-primary">\n                            </md-slider>\n                        </div>\n\n                        \x3c!-- Depth Settings --\x3e\n                        <div class="flex-100 flex-gt-sm-50 layout-padding padding-sides-0 layout-row">\n                            <md-input-container class="flex-40 flex-gt-sm-25">\n                                <label> {{ ::dewarpConfig.msgs.depth() }} </label>\n                                <input ng-model="dewarpConfig.depth" ng-model-options="{ getterSetter: true }" name="depth" type="number" min="0.1" max="9" step="0.1" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()">\n                            </md-input-container>\n                            <md-slider ng-model="dewarpConfig.depth" ng-model-options="{ getterSetter: true }" min="0.1" max="9" step="0.1" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()" class="margin-right-0 flex-60 flex-gt-sm-75 md-primary">\n                            </md-slider>\n                        </div>\n\n                        \x3c!-- Camera Position Settings --\x3e\n                        <md-input-container class="flex-100 flex-gt-sm-50">\n                            <label class="floating-label"> {{ ::dewarpConfig.msgs.cameraPosition() }} </label>\n                            <md-select ng-model="dewarpConfig.orientation" ng-model-options="{ getterSetter: true }" name="orientation" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()">\n                                <md-option value="ceiling"> {{ ::dewarpConfig.msgs.ceiling() }} </md-option>\n                                <md-option value="floor"> {{ ::dewarpConfig.msgs.floor() }} </md-option>\n                                \x3c!-- \n                                The values are intentionally flipped here so that our initial implementation (which was upside down) matches a correctly\n                                installed dome camera. Since we already have tons of cameras installed, we don\'t want to change the default behavior but \n                                we do want it to be correct going forward.\n                                --\x3e\n                                <md-option value="wall-flipped"> {{ ::dewarpConfig.msgs.wall() }} </md-option>\n                                <md-option value="wall"> {{ ::dewarpConfig.msgs.wallFlipped() }}</md-option>\n                            </md-select>\n                        </md-input-container>\n                    </div>\n                </md-content>\n            </md-tab>\n            <md-tab ng-click="dewarpConfig.enablePanoramaMode()" label="{{ ::dewarpConfig.msgs.panorama() }}">\n                <md-content>\n                    <div class="layout-row layout-wrap">\n                        \x3c!-- Aspect Ratio Settings --\x3e\n                        <div class="flex-100 flex-gt-sm-50 layout-padding padding-sides-0 layout-row">\n                            <md-input-container class="flex-40 flex-gt-sm-25">\n                                <label> {{ ::dewarpConfig.msgs.aspectRatio() }} </label>\n                                <input ng-model="dewarpConfig.panoramaAspectRatio" ng-model-options="{ getterSetter: true }" name="aspectRatio" type="number" min="0" max="10" step="0.1" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()">\n                            </md-input-container>\n                            <md-slider ng-model="dewarpConfig.panoramaAspectRatio" ng-model-options="{ getterSetter: true }" min="0" max="10" step="0.1" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()" class="margin-right-0 flex-60 flex-gt-sm-75 md-primary">\n                            </md-slider>\n                        </div>\n\n                        \x3c!-- Shift Settings --\x3e\n                        <div class="flex-100 flex-gt-sm-50 layout-padding padding-sides-0 layout-row">\n                            <md-input-container class="flex-40 flex-gt-sm-25">\n                                <label> {{ ::dewarpConfig.msgs.shift() }} </label>\n                                <input ng-model="dewarpConfig.panoramaShift" ng-model-options="{ getterSetter: true }" name="shift" type="number" min="-180" max="180" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()">\n                            </md-input-container>\n                            <md-slider ng-model="dewarpConfig.panoramaShift" ng-model-options="{ getterSetter: true }" min="-180" max="180" step="1" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()" class="margin-right-0 flex-60 flex-gt-sm-75 md-primary">\n                            </md-slider>\n                        </div>\n\n                        \x3c!-- Camera Position Settings --\x3e\n                        <md-input-container class="flex-100 flex-gt-sm-50">\n                            <label class="floating-label"> {{ ::dewarpConfig.msgs.cameraPosition() }} </label>\n                            <md-select ng-model="dewarpConfig.orientation" ng-model-options="{ getterSetter: true }" name="orientation" ng-disabled="!dewarpConfig.settings.enable || !dewarpConfig.isLoaded()">\n                                <md-option value="ceiling"> {{ ::dewarpConfig.msgs.ceiling() }} </md-option>\n                                <md-option value="floor"> {{ ::dewarpConfig.msgs.floor() }} </md-option>\n                                \x3c!-- \n                                The values are intentionally flipped here so that our initial implementation (which was upside down) matches a correctly\n                                installed dome camera. Since we already have tons of cameras installed, we don\'t want to change the default behavior but \n                                we do want it to be correct going forward.\n                                --\x3e\n                                <md-option value="wall-flipped"> {{ ::dewarpConfig.msgs.wall() }} </md-option>\n                                <md-option value="wall"> {{ ::dewarpConfig.msgs.wallFlipped() }}</md-option>\n                            </md-select>\n                        </md-input-container>\n                    </div>\n                </md-content>\n            </md-tab>\n        </md-tabs>\n    </md-dialog-content>\n\n    <dialog-errors target-object="dewarpConfig"></dialog-errors>\n\n    <md-dialog-actions layout="row" layout-align="start center" class="layout-row">\n        \x3c!-- Dewarp Enable Setting --\x3e\n        <md-checkbox ng-model="dewarpConfig.settings.enable" name="enableDewarping" class="flex-100 flex-gt-xs-50 layout-row layout-align-start-center md-primary" ng-disabled="!dewarpConfig.isLoaded()">\n            {{ ::dewarpConfig.msgs.enable() }}\n        </md-checkbox>\n\n        <span flex></span>\n        <md-button ng-click="dewarpConfig.cancel()"> {{ ::dewarpConfig.msgs.cancel() }} </md-button>\n        <md-button ng-click="dewarpConfig.save()" ng-disabled="!dewarpConfig.isLoaded()" class="md-raised md-primary">\n            {{ ::dewarpConfig.msgs.save() }}\n        </md-button>\n    </md-dialog-actions>\n</md-dialog>\n'
        }
        ,
        67764: e => {
            e.exports = '<md-dialog aria-label="{{ ::copyStreamDialog.msgs.registerCameras() }}" class="copy-stream-dialog">\n    <md-toolbar>\n        <div class="md-toolbar-tools">\n            <h2>{{ ::copyStreamDialog.msgs.copyWhatToCameras({ VALUE: copyStreamDialog.originalStream.name }) }}</h2>\n            <span flex></span>\n            <md-button class="md-icon-button" ng-disabled="copyStreamDialog.processing" ng-click="copyStreamDialog.cancel()">\n                <i class="fa fa-times fa-2x"></i>\n            </md-button>\n        </div>\n    </md-toolbar>\n    <md-dialog-content>\n        <md-content class="copy-stream-container">\n            <div style="padding-left: 10px">\n                <md-checkbox ng-model="copyStreamDialog.copyAllSettings" ng-hide="copyStreamDialog.processing || copyStreamDialog.reviewMode">\n                    {{ ::copyStreamDialog.msgs.copyAllSettings() }}\n                </md-checkbox>\n                <md-card ng-hide="copyStreamDialog.copyAllSettings || copyStreamDialog.processing || copyStreamDialog.reviewMode">\n                    <table md-table class="striped-table orchid-table" ng-class="{ \'interactive\': !copyStreamDialog.processing && !copyStreamDialog.reviewMode }">\n                        <thead md-head>\n                            <tr md-row>\n                                <th md-column>\n                                    <md-checkbox ng-checked="copyStreamDialog.allStreamSettings" ng-click="copyStreamDialog.toggleAllStreamSettings()"></md-checkbox>\n                                </th>\n                                <th md-column>{{ ::copyStreamDialog.msgs.setting() }}</th>\n                                <th md-column>{{ ::copyStreamDialog.msgs.value() }}</th>\n                            </tr>\n                        </thead>\n                        <tbody md-body>\n                            <tr md-row>\n                                <td md-cell>\n                                    <md-checkbox ng-model="copyStreamDialog.shouldCopyRecordingStyle"></md-checkbox>\n                                </td>\n                                <td md-cell>{{ ::copyStreamDialog.msgs.recordingStyle() }}</td>\n                                <td md-cell>{{copyStreamDialog.originalStreamRecordingStyle.localizedName()}}</td>\n                            </tr>\n                            <tr md-row ng-if="copyStreamDialog.originalStreamRecordingStyle.id !== copyStreamDialog.PROXY_ONLY && \n                            copyStreamDialog.originalStreamRecordingStyle.id !== copyStreamDialog.NO_MOTION">\n                                <td md-cell>\n                                    <md-checkbox ng-model="copyStreamDialog.shouldCopyMotionStyle"></md-checkbox>\n                                </td>\n                                <td md-cell>{{copyStreamDialog.msgs.motionStyle() }}</td>\n                                <td md-cell>{{copyStreamDialog.originalStreamMotionStyle.localizedName()}}</td>\n                            </tr>\n                        </tbody>\n                        <tbody md-body ng-repeat="arrayKey in [\'General\', \'Video\', \'Audio\']" ng-show="copyStreamDialog.originalStream.configuration[arrayKey]">\n                            <tr md-row>\n                                <th class="sub-header">\n                                    <md-checkbox ng-click="copyStreamDialog.selectSection(arrayKey)" ng-checked="copyStreamDialog.sectionSelected[arrayKey]"></md-checkbox>\n                                </th>\n                                <th class="sub-header" ng-click="copyStreamDialog.toggleShowSettings(arrayKey)">\n                                    {{::copyStreamDialog.msgs.whichSettings({ VALUE: arrayKey })}}\n                                </th>\n                                <th class="sub-header" ng-click="copyStreamDialog.toggleShowSettings(arrayKey)">\n                                    <span class="hideable-toggle">\n                                        <span ng-hide="copyStreamDialog.showSettings[arrayKey]"><i class="fa fa-plus-square"></i> {{\n                                            ::copyStreamDialog.msgs.showNHiddenFields({ VALUE:\n                                            copyStreamDialog.fieldCount(arrayKey) }) }}</span>\n                                        <span ng-show="copyStreamDialog.showSettings[arrayKey]"><i class="fa fa-minus-square"></i> {{ ::copyStreamDialog.msgs.hideFields()\n                                            }}</span>\n                                    </span>\n                                </th>\n                            </tr>\n                            <tr md-row class="hideable-row" ng-class="{ \'hideme\': !copyStreamDialog.showSettings[arrayKey] }" ng-repeat="(field, value) in copyStreamDialog.originalStream.configuration[arrayKey]" style="padding-left: 15px">\n                                <td md-cell>\n                                    <md-checkbox ng-disabled="!copyStreamDialog.showSettings[arrayKey]" ng-model="copyStreamDialog.shouldCopyStreamSetting[arrayKey][field]"></md-checkbox>\n                                </td>\n                                <td md-cell>{{copyStreamDialog.translateOnvifFieldId(field)}}</td>\n                                <td md-cell>{{value}}</td>\n                            </tr>\n                        </tbody>\n                        <tbody md-body ng-if="copyStreamDialog.originalStream.configuration.Video.Encoder === \'H264\'">\n                            <tr md-row>\n                                <td md-cell>\n                                    <md-checkbox ng-model="copyStreamDialog.shouldCopyDecodeAllFrames"></md-checkbox>\n                                </td>\n                                <td md-cell>{{ ::copyStreamDialog.msgs.decodeAllFrames() }}</td>\n                                <td md-cell>\n                                    {{ copyStreamDialog.originalStream.recordingConfiguration.decode.keyFramesOnly ===\n                                    \'true\' ? copyStreamDialog.msgs.disabled() : copyStreamDialog.msgs.enabled() }}\n                                </td>\n                            </tr>\n                        </tbody>\n                    </table>\n                </md-card>\n            </div>\n\n            <div style="padding: 10px 0 0 10px">\n                <div ng-show="copyStreamDialog.munged > 0 && !(copyStreamDialog.processing || copyStreamDialog.reviewMode)">\n                    {{ ::copyStreamDialog.msgs.streamSettingsWillBeAdapted() }}\n                </div>\n                <div style="padding-top: 10px" ng-show="copyStreamDialog.munged > 0 && copyStreamDialog.munged < copyStreamDialog.camerasCopy.length">\n                    <md-checkbox ng-model="copyStreamDialog.hideMunged" ng-hide="copyStreamDialog.processing || copyStreamDialog.reviewMode">\n                        {{ ::copyStreamDialog.msgs.showOnlyPerfectCopies() }}\n                    </md-checkbox>\n                </div>\n            </div>\n\n            <md-card>\n                <table md-table class="striped-table orchid-table" ng-class="{ \'interactive\': !copyStreamDialog.processing && !copyStreamDialog.reviewMode }">\n                    <thead md-head>\n                        <tr md-row>\n                            <th md-column>\n                                <md-checkbox ng-click="copyStreamDialog.selectAllCameras()" ng-checked="copyStreamDialog.allCamerasSelected" ng-hide="copyStreamDialog.processing || copyStreamDialog.reviewMode"></md-checkbox>\n                            </th>\n                            <th md-column>{{ ::copyStreamDialog.msgs.camera() }}</th>\n                            <th md-column>{{ ::copyStreamDialog.msgs.bestMatch() }}</th>\n                            <th md-column ng-if="copyStreamDialog.error">{{ ::copyStreamDialog.msgs.error() }}</th>\n                        </tr>\n                    </thead>\n                    <tbody md-body>\n                        <tr md-row ng-if="!copyStreamDialog.copyCamerasAreAvailable()">\n                            <td md-cell colspan="3">{{ ::copyStreamDialog.msgs.noCamerasForCopy() }}</td>\n                        </tr>\n                        <tr md-row ng-repeat="camera in copyStreamDialog.camerasCopy | orderBy:\'name\'" ng-click="copyStreamDialog.selectCamera(camera)" ng-if="copyStreamDialog.showCameraCopyOption(camera)">\n                            <td md-cell>\n                                <div>\n                                    <md-checkbox ng-hide="copyStreamDialog.processing || copyStreamDialog.reviewMode" ng-checked="camera.needsCopy"></md-checkbox>\n                                    <md-progress-circular md-mode="indeterminate" md-diameter="25px" ng-show="camera.processing"></md-progress-circular>\n                                    <i class="fa fa-2x fa-check" ng-show="camera.success"></i>\n                                    <i class="fa fa-2x fa-times red" ng-show="camera.error"></i>\n                                </div>\n                            </td>\n                            <td md-cell>\n                                <div class="camera-name">{{camera.name}}</div>\n                                <div class="hint-text">{{camera.configuration.Model}}</div>\n                            </td>\n                            <td md-cell>\n                                <div ng-repeat="(featureId, features) in camera.streamDiff">\n                                    <strong>{{copyStreamDialog.translateFeatureId(featureId)}}:</strong>\n                                    <div ng-repeat="(fieldId, diff) in features" class="feature-diff-detail">\n                                        {{copyStreamDialog.translateOnvifFieldId(fieldId)}}:\n                                        <span class="fail-text">{{diff.old}}</span> <i class="fa fa-arrow-right"></i>\n                                        <span class="success-text">{{diff.new}}</span>\n                                    </div>\n                                </div>\n                                <div ng-hide="camera.munged" class="success-text">\n                                    <i class="fa fa-check"></i> {{ ::copyStreamDialog.msgs.perfect() }}\n                                </div>\n                            </td>\n                            <td md-cell ng-if="copyStreamDialog.error">\n                                <div class="fail-text">{{camera.error}}</div>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </md-card>\n            <div style="padding: 10px 0 0 10px">\n                <md-checkbox ng-model="copyStreamDialog.makePrimary" ng-hide="copyStreamDialog.processing || copyStreamDialog.reviewMode">\n                    {{ ::copyStreamDialog.msgs.overwritePrimaryStream() }}\n                </md-checkbox>\n            </div>\n        </md-content>\n    </md-dialog-content>\n    <dialog-errors target-object="copyStreamDialog"></dialog-errors>\n    <md-dialog-actions>\n        <span flex></span>\n        <md-button ng-disabled="copyStreamDialog.processing" ng-click="copyStreamDialog.cancel()">\n            <span ng-if="!copyStreamDialog.reviewMode">{{ ::copyStreamDialog.msgs.cancel() }}</span>\n            <span ng-if="copyStreamDialog.reviewMode">{{ ::copyStreamDialog.msgs.done() }}</span>\n        </md-button>\n        <md-button class="md-raised md-primary" type="submit" ng-disabled="copyStreamDialog.copyCount < 1 || copyStreamDialog.processing" ng-click="copyStreamDialog.copyStream()" ng-hide="copyStreamDialog.reviewMode">\n            <span ng-if="!copyStreamDialog.processing">{{ ::copyStreamDialog.msgs.copy() }}</span>\n            <md-progress-circular md-mode="indeterminate" md-diameter="25px" ng-if="copyStreamDialog.processing" style="margin: auto"></md-progress-circular>\n        </md-button>\n    </md-dialog-actions>\n</md-dialog>\n'
        }
        ,
        54970: e => {
            e.exports = '<md-dialog class="disable-camera-dialog">\n    <md-content>\n        <md-dialog-content>\n            <p>{{::msgs.youAreAboutToDisableCamera({VALUE: cameraName})}}</p>\n            <p>{{::msgs.onceDisabled()}}</p>\n        </md-dialog-content>\n\n        <sing-dialog-errors ng-if="disableCameraDialog.error" errmsg="{{disableCameraDialog.error.reason}}" can-close="true" (on-close)="disableCameraDialog.error = undefined"></sing-dialog-errors>\n\n        <md-dialog-actions layout="row">\n            <md-button ng-click="cancel()" ng-disabled="cameraProcessing">{{::msgs.dialogs.cancel()}}</md-button>\n            <md-button class="md-raised md-primary" ng-click="ok()" ng-disabled="cameraProcessing">\n                <md-progress-circular md-mode="indeterminate" md-diameter="25px" ng-if="cameraProcessing" style="margin: auto"></md-progress-circular>\n                <span ng-if="!cameraProcessing">{{::msgs.disableCamera()}}</span>\n            </md-button>\n        </md-dialog-actions>\n    </md-content>\n</md-dialog>\n'
        }
        ,
        42909: e => {
            e.exports = '<md-dialog>\n    <form name="cameraForm" autocomplete="off" class="admin-dialog edit-camera-dialog">\n        <md-toolbar class="orchid-toolbar">\n            <div class="md-toolbar-tools">\n                <h2>{{ ::editCameraDialog.msgs.editCameraName() }}</h2>\n                <span flex></span>\n                <md-button class="md-icon-button" ng-disabled="editCameraDialog.camera.processing" ng-click="editCameraDialog.cancel()">\n                    <i class="fa fa-times fa-2x"></i>\n                </md-button>\n            </div>\n        </md-toolbar>\n        <md-dialog-content>\n            <md-content>\n                <md-input-container>\n                    <label for="name">{{ ::editCameraDialog.msgs.cameraName() }}</label>\n                    <input id="inputUrl" class="form-control" type="text" ng-model="editCameraDialog.camera.name" ng-keydown="editCameraDialog.handleKeyDown($event)" required md-autofocus>\n                    <div ng-messages="cameraForm.name.$error" role="alert" multiple="multiple">\n                        <div ng-message="required" class="my-message">\n                            {{ ::editCameraDialog.msgs.cameraNameRequired() }}\n                        </div>\n                    </div>\n                </md-input-container>\n            </md-content>\n        </md-dialog-content>\n\n        <dialog-errors target-object="editCameraDialog"></dialog-errors>\n        <md-dialog-actions>\n            <span flex></span>\n            <md-button ng-disabled="editCameraDialog.camera.processing" ng-click="editCameraDialog.cancel()">{{ ::editCameraDialog.msgs.cancel() }}</md-button>\n            <md-button class="md-raised md-primary" ng-disabled="cameraForm.$invalid || editCameraDialog.camera.processing" ng-click="editCameraDialog.updateCamera()">\n                <span ng-hide="editCameraDialog.camera.processing">{{ ::editCameraDialog.msgs.updateCamera() }}</span>\n                <md-progress-circular md-mode="indeterminate" md-diameter="25px" ng-if="editCameraDialog.camera.processing" style="margin: auto"></md-progress-circular>\n            </md-button>\n        </md-dialog-actions>\n    </form>\n</md-dialog>\n'
        }
        ,
        46185: e => {
            e.exports = '<md-dialog class="motion-detection-configuration">\n    <md-toolbar>\n        <div class="md-toolbar-tools">\n            <h2 sing-translated-msg="cameras.motionDetectionConfigurationTitle"></h2>\n            <span flex></span>\n            <md-button class="md-icon-button" ng-disabled="motionConfig.processing" ng-click="motionConfig.cancel()">\n                <i class="fa fa-times fa-2x"></i>\n            </md-button>\n        </div>\n    </md-toolbar>\n    <md-dialog-content class="md-dialog-content">\n        <form name="motionConfigForm">\n            <div class="mask-container layout-column layout-align-center-center">\n                <div ng-show="motionConfig.missingImage">{{ motionConfig.missingImage }}</div>\n                <img class="max-size transparent" id="mask-image" ng-hide="motionConfig.missingImage" ng-src="{{ motionConfig.backgroundImageSrc }}">\n                <md-progress-circular class="position-absolute" ng-show="motionConfig.loading" md-diameter="90" md-mode="indeterminate">\n                </md-progress-circular>\n                <motion-detection-object-size ng-show="selectedIndex === 1 && !motionConfig.missingImage" object-size="motionConfig.configuration.objectSize" fill-color="motionConfig.brushColor" container-size="motionConfig.dimensions">\n                </motion-detection-object-size>\n                <motion-detection-mask brush-color="motionConfig.brushColor" brush-size="motionConfig.brushSize" container-size="motionConfig.dimensions" mask-href="motionConfig.configuration.maskHref" mask-promise="motionConfig.maskPromise" drawing-mode="motionConfig.maskMode" disabled="motionConfig.loading" ng-show="selectedIndex === 0 && !motionConfig.missingImage">\n                </motion-detection-mask>\n            </div>\n            <md-tabs md-selected="selectedIndex" ng-model="selectedIndex" ng-init="selectedIndex = 0" md-center-tabs>\n                <md-tab label="{{ ::motionConfig.msgs.motionMask() }}">\n                    <md-content class="md-padding">\n                        <div class="layout-row layout-xs-column">\n                            <div class="md-caption">{{ ::motionConfig.msgs.motionMaskBrushUsage() }}</div>\n                        </div>\n                        <div class="layout-row layout-align-start-center flex-grow">\n                            <md-input-container class="flex-25 flex-gt-xs-15">\n                                <label><span class="hide show-gt-sm brush-label">{{ ::motionConfig.msgs.brush() }}</span>\n                                    {{ ::motionConfig.msgs.size() }}</label>\n                                <input type="number" min="1" max="200" ng-model="motionConfig.brushSize" oninput="this.value = Math.abs(this.value)">\n                            </md-input-container>\n                            <md-slider class="flex" ng-model="motionConfig.brushSize" min="1" max="200"> </md-slider>\n                            <div class="btn-group layout-padding">\n                                <label md-ink-ripple class="btn btn-primary" ng-model="motionConfig.maskMode" uib-btn-radio="\'draw\'" ng-click="motionConfig.maskMode = \'draw\'">\n                                    <i class="fa fa-paint-brush"></i>\n                                </label>\n                                <label md-ink-ripple class="btn btn-primary" ng-model="motionConfig.maskMode" uib-btn-radio="\'erase\'" ng-click="motionConfig.maskMode = \'erase\'">\n                                    <i class="fa fa-eraser"></i>\n                                </label>\n                            </div>\n                            <md-button class="clear-mask-btn" ng-click="motionConfig.clearMask()">\n                                <i class="fa-regular fa-trash-can fa-lg flex-none"></i> <span class="hide show-gt-sm">{{ ::motionConfig.msgs.clear() }}</span>\n                            </md-button>\n                        </div>\n                    </md-content>\n                </md-tab>\n                <md-tab label="{{ ::motionConfig.msgs.objectSize() }}">\n                    <md-content class="md-padding">\n                        <div class="md-caption">{{ ::motionConfig.msgs.objectSizeSliderUsage() }}</div>\n                        <div class="layout-row">\n                            <md-input-container class="flex-25 flex-gt-xs-15">\n                                <label>{{ ::motionConfig.msgs.size() }}</label>\n                                <input name="objectSize" ng-model="motionConfig.configuration.objectSize" max="100" min="0" type="number" ng-keydown="motionConfig.disallowFloats($event)" oninput="this.value = Math.trunc(Math.abs(this.value))">\n                            </md-input-container>\n                            <md-slider class="flex" id="objectSize" max="100" min="0" ng-model="motionConfig.configuration.objectSize">\n                            </md-slider>\n                        </div>\n                    </md-content>\n                </md-tab>\n            </md-tabs>\n        </form>\n    </md-dialog-content>\n    <dialog-errors target-object="motionConfig"></dialog-errors>\n    <md-dialog-actions>\n        <span flex></span>\n        <md-button ng-disabled="motionConfig.processing" ng-click="motionConfig.cancel()">{{ ::motionConfig.msgs.cancel() }}</md-button>\n        <md-button class="md-raised md-primary layout-row layout-align-center-center" ng-click="motionConfig.save()" ng-disabled="motionConfig.processing || motionConfig.missingImage || motionConfigForm.objectSize.$invalid" type="submit">\n            <span ng-hide="motionConfig.processing">{{ ::motionConfig.msgs.updateCamera() }}</span>\n            <md-progress-circular md-mode="indeterminate" md-diameter="25px" ng-if="motionConfig.processing">\n            </md-progress-circular>\n        </md-button>\n    </md-dialog-actions>\n</md-dialog>\n'
        }
        ,
        69115: e => {
            e.exports = '<canvas id="motion-mask-canvas">\n</canvas>\n<canvas id="motion-mask-cursor-canvas" class="no-mouse transparent">\n</canvas>\n<canvas id="full-scale-mirror" class="hide">\n</canvas>\n<md-progress-circular ng-show="mask.processing" md-diameter="90" md-mode="indeterminate"></md-progress-circular>\n'
        }
        ,
        63815: e => {
            e.exports = '<canvas id="motion-mask-object-size-canvas">\n</canvas>\n'
        }
        ,
        28918: e => {
            e.exports = '<div class="motion-reduction-warning">\n    <div ng-show="mafrEnabled === true">\n        <div class="fields-container" ng-show="driver === CameraDriverType.ONVIF && encoder === \'H264\'">\n            <md-slider-container>\n                <md-input-container md-no-float class="motion-reduction-input-container">\n                    <label class="slider-label">{{ ::msgs.frameRateDuringMotion() }}</label>\n                    <input id="Frame Rate During Motion" placeholder="" class="form-control" ng-model="frameRate" ng-disabled="readOnly">\n                </md-input-container>\n                <md-slider min="{{minFrameRate}}" max="{{maxFrameRate}}" ng-model="frameRate" ng-disabled="readOnly"></md-slider>\n            </md-slider-container>\n            <md-slider-container>\n                <md-input-container md-no-float class="motion-reduction-input-container">\n                    <label class="slider-label">{{ ::msgs.frameRateDuringNonMotion() }}</label>\n\n                    \x3c!-- Note that the input below is always disabled due to the slider having very specific values --\x3e\n                    <input id="Frame Rate During Non-Motion" placeholder="" class="form-control" type="text" value="{{nonMotionFrameRateValues[nonMotionFrameRateIndex]|number:2}}" disabled="disabled">\n                </md-input-container>\n                <md-slider type="range" min="0" max="{{nonMotionFrameRateValues.length - 1}}" ng-model="nonMotionFrameRateIndex" step="1" ng-disabled="readOnly"></md-slider>\n            </md-slider-container>\n        </div>\n        <div class="row" ng-show="driver === CameraDriverType.ONVIF && encoder !== \'H264\'">\n            <div class="form-group col-md-8 text-justify warn-text">\n                <em>{{ ::msgs.attention.motionReductionFeatureOnlyWorksWith() }}</em>\n            </div>\n        </div>\n        <div class="row" ng-show="driver === CameraDriverType.RTSP">\n            <div class="form-group col-md-8 text-justify">\n                <em>{{ ::msgs.attention.motionReductionFeatureOnlyWorksWithNote() }}</em>\n            </div>\n        </div>\n    </div>\n</div>\n'
        }
        ,
        42005: e => {
            e.exports = '<md-dialog ng-switch="$ctrl.dialogFor" class="ntp-tz-edit-dialog admin-dialog">\n    <md-toolbar class="orchid-toolbar">\n        <div class="md-toolbar-tools">\n            <h2>\n                <span ng-switch-when="ntp" sing-translated-msg="cameras.editCameraNTPSettings"></span>\n                <span ng-switch-when="tp" sing-translated-msg="cameras.editStreamTPSettings"></span>\n                <span ng-switch-default sing-translated-msg="cameras.editCameraTZSettings"></span>\n            </h2>\n            <span flex></span>\n            <md-button class="md-icon-button" ng-disabled="$ctrl.processing" ng-click="$ctrl.closeDialog()">\n                <i class="fa fa-times fa-2x"></i>\n            </md-button>\n        </div>\n    </md-toolbar>\n\n    <md-dialog-content>\n        <md-content class="ntp-tz-edit-dialog-content">\n            <camera-edit-ntp-form ng-switch-when="ntp" edit-dialog="$ctrl"></camera-edit-ntp-form>\n            <camera-edit-tp-form ng-switch-when="tp" edit-dialog="$ctrl"></camera-edit-tp-form>\n            <camera-edit-tz-form ng-switch-default edit-dialog="$ctrl"></camera-edit-tz-form>\n        </md-content>\n    </md-dialog-content>\n\n    <dialog-errors target-object="$ctrl"></dialog-errors>\n\n    <md-dialog-actions>\n        <span flex></span>\n        <md-button ng-disabled="$ctrl.processing" ng-click="$ctrl.cancel()" sing-translated-msg="dialogs.cancel"></md-button>\n        <sing-button with-spinner button-disabled="!$ctrl.valid || $ctrl.processing" show-spinner="$ctrl.processing" on-click="$ctrl.updateCamera()">\n            <span hide-xs>\n                <span ng-switch-when="ntp" sing-translated-msg="cameras.updateNTPSettings"></span>\n                <span ng-switch-when="tp" sing-translated-msg="cameras.updateTPSettings"></span>\n                <span ng-switch-default sing-translated-msg="cameras.updateTZSettings"></span>\n            </span>\n            <span hide-gt-xs sing-translated-msg="userManager.update"></span>\n        </sing-button>\n    </md-dialog-actions>\n</md-dialog>\n'
        }
        ,
        76719: e => {
            e.exports = '<form name="NTPForm" autocomplete="off" layout="column" class="edit-ntp-form">\n    <div layout="row" class="edit-ntp-form-checkbox-container">\n        <md-input-container>\n            <label sing-translated-msg="cameras.ntpSettings"></label>\n            <md-select ng-model="$ctrl.ntpMode" ng-disabled="$ctrl.editDialog.processing">\n                <md-option ng-value="$ctrl.NTPModes.Disabled" sing-translated-msg="bag.disabled"></md-option>\n                <md-option ng-value="$ctrl.NTPModes.Dhcp" sing-translated-msg="cameras.useNTPSettingsFromDHCPServer"></md-option>\n                <md-option ng-value="$ctrl.NTPModes.Manual" sing-translated-msg="cameras.manual"></md-option>\n            </md-select>\n        </md-input-container>\n    </div>\n    <div class="ntp-form-server-container" ng-if="$ctrl.ntpMode === $ctrl.NTPModes.Manual">\n        <md-input-container class="ntp-form-server-md-input">\n            <label tabindex="-1" aria-hidden="true" for="new-npt-server-input" sing-translated-msg="cameras.ntpServer"></label>\n            <input id="new-npt-server-input" class="form-control" type="text" placeholder="{{::$ctrl.ntpServerPlaceholder}}" name="ntpServer" ng-model="$ctrl.model.Server" ng-required="$ctrl.ntpServerRequired" ng-disabled="$ctrl.ntpServerDisabled || $ctrl.editDialog.processing" ng-trim="true">\n            <div ng-messages="NTPForm.ntpServer.$error" role="alert" multiple="multiple" ng-show="!ntpServer.$valid">\n                <div ng-message="required" class="my-message"><span sing-translated-msg="dialogs.required"></span></div>\n            </div>\n        </md-input-container>\n    </div>\n</form>\n'
        }
        ,
        176: e => {
            e.exports = '<form name="TPForm" autocomplete="off" layout="column" class="edit-tp-form">\n    <div layout="row" class="edit-tp-form-checkbox-container">\n        <md-input-container class="mw-100">\n            <label sing-translated-msg="cameras.streamTransportProtocol"></label>\n            <md-select ng-model="$ctrl.tpMode" ng-disabled="$ctrl.editDialog.processing">\n                <md-option ng-value="option" ng-repeat="option in $ctrl.camera.capabilities.camera.TransportProtocol.options">{{ option }}</md-option>\n            </md-select>\n        </md-input-container>\n    </div>\n</form>\n'
        }
        ,
        75977: e => {
            e.exports = '<form name="TZForm" autocomplete="off" layout="column" class="edit-tz-form">\n    <div class="tz-select-container">\n        <md-input-container class="tz-input-container">\n            <label><span sing-translated-msg="cameras.timeZone"></span></label>\n            <md-select ng-model="$ctrl.selectedTz" ng-model-options="{trackBy: \'$value.ianaTz\'}" ng-change="$ctrl.selectedTzChanged($ctrl.selectedTz)" ng-disabled="$ctrl.editDialog.processing">\n                <md-option ng-value="$ctrl.unknownTz" ng-if="$ctrl.initiallyUnknownTZ"><span sing-translated-msg="cameras.unknownTZ"></span></md-option>\n                <md-option ng-repeat="tz in $ctrl.tzList" ng-value="tz">{{ tz.ianaTz }}</md-option>\n            </md-select>\n        </md-input-container>\n    </div>\n    <div class="dst-checkbox-container">\n        <md-checkbox ng-model="$ctrl.model.DaylightSavings.value" class="dst-checkbox" id="dst-checkbox" aria-label="{{ ::$ctrl.msgs.daylightSavingsTime() }}" ng-disabled="$ctrl.dstDisabled || $ctrl.editDialog.processing">\n            <span sing-translated-msg="cameras.daylightSavingsTime"></span>\n        </md-checkbox>\n    </div>\n</form>\n'
        }
        ,
        98094: e => {
            e.exports = '<md-dialog class="reactivate-camera-dialog">\n    <md-content ng-if="!canReactivateCamera">\n        <md-dialog-content>\n            <p>{{::msgs.youveReachedTheMaximumNumberOfCamerasForYourCurrentLicense()}}</p>\n        </md-dialog-content>\n    </md-content>\n\n    <md-content ng-if="canReactivateCamera">\n        <md-dialog-content>\n            <p>{{::msgs.youAreAboutToReactivateCamera({VALUE: cameraName})}}</p>\n        </md-dialog-content>\n    </md-content>\n\n    <sing-dialog-errors ng-if="reactivateCameraDialog.error" errmsg="{{reactivateCameraDialog.error.reason}}" can-close="true" (on-close)="reactivateCameraDialog.error = undefined"></sing-dialog-errors>\n\n    <md-dialog-actions layout="row">\n        <md-button ng-click="cancel()" ng-disabled="cameraProcessing">{{::msgs.dialogs.cancel()}}</md-button>\n        <md-button class="md-raised md-primary" ng-if="canReactivateCamera" ng-click="ok()" ng-disabled="cameraProcessing">\n            <md-progress-circular md-mode="indeterminate" md-diameter="25px" ng-if="cameraProcessing" style="margin: auto"></md-progress-circular>\n            <span ng-if="!cameraProcessing">{{::msgs.reactivateCamera()}}</span>\n        </md-button>\n    </md-dialog-actions>\n</md-dialog>\n'
        }
        ,
        58496: e => {
            e.exports = '<md-dialog aria-label="{{ ::streamDialog.msgs.streamConfiguration() }}" class="tall-dialog" ng-class="{ \'dialog-ready\': streamDialog.bodyIsReady }">\n    <form name="streamConfigurationForm" ng-class="{ \'has-error\': failureStream }" class="stream-dialog admin-dialog">\n        <md-toolbar class="orchid-toolbar">\n            <div class="md-toolbar-tools">\n                <h2>{{ ::streamDialog.msgs.streamSettings() }}</h2>\n                <span flex></span>\n                <md-button class="md-icon-button" ng-disabled="streamDialog.stream.processing" ng-click="streamDialog.cancel()">\n                    <i class="fa fa-times fa-2x"></i>\n                </md-button>\n            </div>\n        </md-toolbar>\n\n        <div class="page-loading" ng-if="streamDialog.bodyIsReady !== true">\n            <md-progress-circular md-diameter="20" md-mode="indeterminate"></md-progress-circular>\n            <h4>{{streamDialog.msgs.loadingStreamSettings()}}</h4>\n        </div>\n\n        <md-dialog-content ng-if="streamDialog.bodyIsReady">\n            <md-content>\n                <div layout="row" style="flex-direction: column" layout-wrap>\n                    <md-input-container class="name-input">\n                        <label for="name">{{ ::streamDialog.msgs.name() }}</label>\n                        <input id="name" type="text" class="form-control" name="name" ng-model="streamDialog.stream.name" ng-disabled="processingStream || streamDialog.cameraIsDisabled" ng-required="true" md-autofocus>\n                        <div ng-messages="streamConfigurationForm.name.$error" role="alert" multiple="multiple">\n                            <div ng-message="required" class="my-message">\n                                {{ ::streamDialog.msgs.streamNameIsRequired() }}\n                            </div>\n                        </div>\n                    </md-input-container>\n\n                    <div class="recording-row" layout="row" layout-wrap ng-if="streamDialog.newStream || streamDialog.isSecondaryStream === false">\n                        <md-input-container class="recording-input">\n                            <label for="recordingStyle">{{ ::streamDialog.msgs.recordingStyle() }}</label>\n                            <md-select id="recordingStyle" class="form-control" ng-model="streamDialog.recordingStyle" ng-model-options="{ getterSetter: true }" ng-disabled="streamDialog.cameraIsDisabled">\n                                <md-option ng-repeat="recordingStyleId in streamDialog.RecordingStyleIds" ng-value="streamDialog.RecordingStyles[recordingStyleId]">{{ streamDialog.RecordingStyles[recordingStyleId].localizedName() }}</md-option>\n                            </md-select>\n                        </md-input-container>\n                        <md-input-container id="motionStyleContainer" ng-if="streamDialog.motionStyleOptions.length > 0">\n                            <label style="min-width: min-content" for="motionStyle">{{ ::streamDialog.msgs.motionStyle() }}</label>\n                            <md-select id="motionStyle" class="form-control" ng-model="streamDialog.motionStyle" ng-model-options="{ getterSetter: true }" ng-disabled="streamDialog.motionStyleOptions.length === 1 || streamDialog.cameraIsDisabled">\n                                <md-option ng-repeat="motionStyleId in streamDialog.motionStyleOptions" ng-value="streamDialog.MotionStyles[motionStyleId]">{{streamDialog.MotionStyles[motionStyleId].localizedName()}}</md-option>\n                            </md-select>\n                        </md-input-container>\n                    </div>\n                    <md-input-container layout="row" layout-wrap class="recording-input" ng-if="streamDialog.isSecondaryStream">\n                        <label for="secondaryStyle">{{ streamDialog.msgs.secondaryRecordingStyle() }}</label>\n                        <md-select id="secondaryStyle" class="form-control" ng-model="streamDialog.stream.recordWhenSecondary" ng-disabled="streamDialog.cameraIsDisabled">\n                            <md-option ng-value="true">{{ streamDialog.msgs.recording() }}</md-option>\n                            <md-option ng-value="false">{{ streamDialog.msgs.proxy() }}</md-option>\n                        </md-select>\n                    </md-input-container>\n                    <div class="camera-row" ng-if="streamDialog.isSecondaryStream === false && streamDialog.selectedMotionStyle === streamDialog.MotionStyleId.CAMERA && streamDialog.motionStyleOptions.length > 0">\n                        <md-input-container>\n                            <label style="min-width: min-content" for="eventStyle">{{::streamDialog.msgs.cameraEvent()}}</label>\n                            <md-select ng-change="streamDialog.changeMotionEvent()" ng-model="streamDialog.selectedMotionEvent" ng-model-options="{trackBy: \'$value.name + $value.data.name + $value.data.type\'}" ng-disabled="!streamDialog.hasMetaCapabilities || streamDialog.cameraIsDisabled">\n                                <md-option ng-value="event[1]" ng-repeat="event in streamDialog.motionEvents">{{ event[0] }}\n                                </md-option>\n                            </md-select>\n                        </md-input-container>\n                    </div>\n                    <div ng-if="streamDialog.showCamSideMotionSmartSearchWarning()" class="no-capabilities-warning">\n                        <div class="form-group col-md-8 text-justify warn-text">\n                            <em>\n                                {{\n                                ::streamDialog.msgs.attention.smartSearchIsOnlyAvailableWhenUsingServerMotionDetection()\n                                }}\n                            </em>\n                        </div>\n                    </div>\n                    <div ng-if="streamDialog.isSecondaryStream === false && streamDialog.selectedMotionStyle === streamDialog.MotionStyleId.CAMERA && !streamDialog.hasMetaCapabilities" class="no-capabilities-warning">\n                        <div class="form-group col-md-8 text-justify warn-text">\n                            <em> {{ ::streamDialog.msgs.attention.noCameraCapabilities() }} </em>\n                        </div>\n                    </div>\n                    <div ng-if="streamDialog.isSecondaryStream === false && streamDialog.checkRecordingStyle(streamDialog.RecordingStyleId.CONTINUOUS_NO_MOTION)" class="motion-reduction-warning">\n                        <div ng-if="streamDialog.showLBM" class="form-group col-md-8 text-justify warn-text">\n                            <em> {{ ::streamDialog.msgs.attention.whileMotionDetectionIsDisabled() }} </em>\n                        </div>\n                    </div>\n                    <div ng-if="streamDialog.isSecondaryStream === false && streamDialog.checkRecordingStyle(streamDialog.RecordingStyleId.MOTION_ONLY)" class="motion-reduction-warning">\n                        <div class="form-group col-md-8 text-justify warn-text">\n                            <em> {{ ::streamDialog.msgs.attention.recordOnlyWhenMotionDetected() }} </em>\n                        </div>\n                    </div>\n                    <div ng-if="streamDialog.isSecondaryStream === false && streamDialog.checkRecordingStyle(streamDialog.RecordingStyleId.PROXY_ONLY)" class="motion-reduction-warning">\n                        <div class="form-group col-md-8 text-justify warn-text">\n                            <em>\n                                {{ ::streamDialog.msgs.attention.whileInProxyMode() }}\n                                <ul>\n                                    <li>{{ ::streamDialog.msgs.recordingAndPlayback() }}</li>\n                                    <li ng-if="streamDialog.showLBM">\n                                        {{ ::streamDialog.msgs.liveViewLowBandwidthMode() }}\n                                    </li>\n                                    <li>{{ ::streamDialog.msgs.thumbnailPreview() }}</li>\n                                    <li>{{ ::streamDialog.msgs.dewarpConfiguration() }}</li>\n                                    <li>{{ ::streamDialog.msgs.motionDetectionConfiguration() }}</li>\n                                </ul>\n                            </em>\n                        </div>\n                    </div>\n                    <motion-reduction-support ng-if="streamDialog.isSecondaryStream === false" stream-id="streamDialog.stream.id" driver="streamDialog.camera.driver" encoder="streamDialog.stream.configuration.Video.Encoder" frame-rate="streamDialog.stream.configuration.Video.FrameRate" capabilities="streamDialog.camera.capabilities" gov-length="streamDialog.stream.configuration.Video.GOVLength" mafr-enabled="streamDialog.checkRecordingStyle(streamDialog.RecordingStyleId.CONTINUOUS_MOTION_ADAPTIVE)" read-only="streamDialog.cameraIsDisabled"></motion-reduction-support>\n                </div>\n\n                <div ng-repeat="arrayKey in [\'General\', \'Video\', \'Audio\']" ng-if="streamDialog.camera.capabilities.stream.categoryArrays[arrayKey + \'Array\'].length > 0">\n                    <h4>{{arrayKey}} {{ ::streamDialog.msgs.settings() }}</h4>\n                    <em ng-if="arrayKey === \'Video\' && streamDialog.isSecondaryStream === true && streamDialog.stream.configuration.Video.Encoder !== \'H264\'" class="jpeg-encoder warn-text">\n                        {{\n                        streamDialog.msgs.attention.secondaryStreamsConfiguredWithAVALUEEncoderWillNotBeAvailableForViewingOnTheStage({\n                        VALUE: streamDialog.stream.configuration.Video.Encoder }) }}\n                    </em>\n\n                    <em ng-if="arrayKey === \'Audio\' && streamDialog.audioIsTranscoded()" class="non-G711-audio-encoder warn-text">\n                        {{ streamDialog.msgs.attention.transcodedAudioWarningForEncoderOnPRODUCT( {PRODUCT:\n                        streamDialog.brandAppName} ) }}\n                    </em>\n\n                    <em ng-if="arrayKey === \'Audio\' && streamDialog.stream.configuration.Audio.Encoder === \'G726\'" class="G726-audio-not-supported warn-text">\n                        {{ streamDialog.msgs.attention.G726AudioNotSupportedWarning() }}\n                    </em>\n\n                    <div class="dynamic-input-container md-padding" layout="row" ng-if="streamDialog.orchidLoaded" layout-wrap>\n                        <dynamic-input ng-repeat-start="capabilities in streamDialog.camera.capabilities.stream.categoryArrays[arrayKey + \'Array\']" style="width: 33%; max-width: 33%" name="capabilities.key" value="streamDialog.stream.configuration[arrayKey][capabilities.key]" capability="capabilities.value" read-only="streamDialog.cameraIsDisabled"></dynamic-input>\n                        <dynamic-input ng-repeat-end name="subCapabilities.key" ng-if="::!(subCapabilities.key === \'EncoderInterval\' && subCapabilities.value.min === subCapabilities.value.max)" value="streamDialog.stream.configuration[arrayKey][subCapabilities.key]" capability="subCapabilities.value" read-only="streamDialog.cameraIsDisabled" ng-repeat="subCapabilities in streamDialog.camera.capabilities.stream[arrayKey][capabilities.key].capabilitiesArray[streamDialog.stream.configuration[arrayKey][capabilities.key]]"></dynamic-input>\n                    </div>\n                </div>\n\n                <div class="row dynamic-configuration" ng-if="streamDialog.stream.configuration.Video.Encoder === \'H264\' && streamDialog.isSecondaryStream === false">\n                    <h4 class="sub-legend col-md-12">{{ ::streamDialog.msgs.lowBandwithSettings() }}</h4>\n                    <div class="dynamic-input-container md-padding" layout="row" layout-wrap>\n                        <md-input-container style="width: 130px">\n                            <label for="keyFramesOnly">{{ ::streamDialog.msgs.decodeAllFrames() }}</label>\n                            <md-select id="keyFramesOnly" class="form-control" ng-model="streamDialog.stream.recordingConfiguration.decode.keyFramesOnly" ng-disabled="streamDialog.cameraIsDisabled">\n                                <md-option ng-value="false">{{ ::streamDialog.msgs.enabled() }}</md-option>\n                                <md-option ng-value="true">{{ ::streamDialog.msgs.disabled() }}</md-option>\n                            </md-select>\n                        </md-input-container>\n                    </div>\n                </div>\n\n                <div ng-if="streamDialog.newStream === false">\n                    <div class="advanced-toggle" ng-click="openAdvanced = !openAdvanced">\n                        <h4>{{ ::streamDialog.msgs.advanced() }}</h4>\n                        <i class="fa" ng-class="{\'fa-chevron-right\': !openAdvanced, \'fa-chevron-down\' : openAdvanced}"></i>\n                    </div>\n                    <md-card ng-show="openAdvanced" class="advanced-table">\n                        <div class="identifiers">\n                            <div flex-gt-xs="30">\n                                <label>{{ ::streamDialog.msgs.cameraId() }}</label>\n                                <span>{{ ::streamDialog.camera.id }}</span>\n                            </div>\n                            <div flex-gt-xs="30">\n                                <label>{{ ::streamDialog.msgs.streamId() }}</label>\n                                <span>{{ ::streamDialog.stream.id }}</span>\n                            </div>\n                        </div>\n                        <div class="urls" ng-if="streamDialog.streamRtspUrl">\n                            <div>\n                                <label>{{ ::streamDialog.msgs.cameraStreamRTSPURL() }}</label>\n                                <div>\n                                    <span id="rtsp-url-{{streamDialog.stream.id}}">{{streamDialog.streamRtspUrl}}</span>\n                                    <md-button class="md-icon-button clipboard copy-to-clipboard" data-clipboard-target="#rtsp-url-{{streamDialog.stream.id}}">\n                                        <md-tooltip class="edit-camera-tooltip" md-autohide md-direction="top" md-delay="250">{{ ::streamDialog.msgs.copyURL() }}</md-tooltip>\n                                        <i class="fa fa-clipboard"></i>\n                                    </md-button>\n                                </div>\n                            </div>\n                            <div ng-if="streamDialog.rtspProxyUrl">\n                                <label>{{ ::streamDialog.msgs.cameraStreamProxyRTSPURL() }}</label>\n                                <div>\n                                    <span id="proxy-rtsp-url-{{streamDialog.stream.id}}">{{streamDialog.rtspProxyUrl}}</span>\n                                    <md-button class="md-icon-button clipboard copy-proxy-to-clipboard" data-clipboard-target="#proxy-rtsp-url-{{streamDialog.stream.id}}">\n                                        <md-tooltip class="edit-camera-tooltip" md-autohide md-direction="top" md-delay="250">{{ ::streamDialog.msgs.copyURL() }}</md-tooltip>\n                                        <i class="fa fa-clipboard"></i>\n                                    </md-button>\n                                </div>\n                            </div>\n                        </div>\n                    </md-card>\n                    <div ng-show="failureStream">\n                        <div class="form-group fail-text">\n                            <label>{{ ::streamDialog.msgs.streamError() }}</label>\n\n                            <p>{{failureStream}}</p>\n                        </div>\n                    </div>\n                </div>\n            </md-content>\n        </md-dialog-content>\n\n        <dialog-errors target-object="streamDialog"></dialog-errors>\n        <md-dialog-actions>\n            <span flex></span>\n            <md-button ng-disabled="streamDialog.stream.processing" ng-click="streamDialog.cancel()">\n                {{ ::streamDialog.msgs.cancel() }}\n            </md-button>\n            <md-button class="md-raised md-primary" type="submit" ng-disabled="streamDialog.submitButtonIsDisabled()" ng-click="streamDialog.addOrUpdateStream()">\n                <span ng-if="!streamDialog.stream.processing">{{::streamDialog.buttonTitle}}</span>\n                <md-progress-circular md-mode="indeterminate" md-diameter="25px" ng-if="streamDialog.stream.processing" style="margin: auto"></md-progress-circular>\n            </md-button>\n        </md-dialog-actions>\n    </form>\n</md-dialog>\n'
        }
        ,
        59845: e => {
            e.exports = '<md-dialog flex="40" class="talkdown-permission-dialog">\n    <md-content>\n        <md-toolbar class="orchid-toolbar">\n            <div class="md-toolbar-tools">\n                <h2>{{::msgs.advancedSettings.talkDown()}}</h2>\n                <span flex></span>\n                <md-button class="md-icon-button" ng-disabled="cameraProcessing" ng-click="cancel()">\n                    <i class="fa fa-times fa-2x"></i>\n                </md-button>\n            </div>\n        </md-toolbar>\n        <md-dialog-content class="md-dialog-content flex layout-column">\n            <md-checkbox ng-model="talkDownEnabled" class="flex-100 flex-gt-xs-50 layout-row layout-align-start-center md-primary">\n                {{ ::msgs.enable() }}\n            </md-checkbox>\n        </md-dialog-content>\n\n        <dialog-errors target-object="talkdownPermissionDialog"></dialog-errors>\n\n        <md-dialog-actions layout="row">\n            <md-button ng-click="cancel()" ng-disabled="cameraProcessing">{{::msgs.dialogs.cancel()}}</md-button>\n            <md-button class="md-raised md-primary" ng-click="ok()" ng-disabled="cameraProcessing">\n                <span ng-if="!cameraProcessing">{{::msgs.updateCamera()}}</span>\n                <md-progress-circular md-mode="indeterminate" md-diameter="25px" ng-if="cameraProcessing" style="margin: auto"></md-progress-circular>\n            </md-button>\n        </md-dialog-actions>\n    </md-content>\n</md-dialog>\n'
        }
        ,
        28816: e => {
            e.exports = '<div shadow="editCamera.camera">\n    <div layout-gt-md="row" layout-wrap>\n        <div class="camera-info">\n            <h3>{{ ::editCamera.msgs.cameraInformation() }}</h3>\n            <div class="camera-information-container" layout="row" layout-wrap>\n                <div flex-gt-xs="40" class="camera-info-detail-container">\n                    <h5 class="data-label">{{ ::editCamera.msgs.cameraName() }}</h5>\n                    <div class="data-field margin-top-negative-4">\n                        <span class="span-text">{{editCamera.cameraCopy.name}}</span>\n                        <md-button class="md-icon-button custom-icon-button" ng-click="editCamera.editCamera($event)">\n                            <i class="{{editCamera.icons.edit}}"></i>\n                            <md-tooltip class="edit-camera-tooltip" md-autohide md-direction="top" md-delay="250">{{ ::editCamera.msgs.editName() }}</md-tooltip>\n                        </md-button>\n                    </div>\n                </div>\n                <div flex-gt-xs="30" class="camera-info-detail-container">\n                    {{cameraConfig.msgs.cameraModel()}}\n                    <h5 class="data-label">{{ ::editCamera.msgs.cameraModel() }}</h5>\n                    <div class="data-field margin-top-5">{{editCamera.camera.displayModel}}</div>\n                </div>\n                <div flex-gt-xs="30" ng-if="editCamera.isPrimaryStreamDefined" class="camera-info-detail-container">\n                    <h5 class="data-label">{{ editCamera.msgs.primaryStreamStatus() }}</h5>\n                    <div class="data-field margin-top-5">\n                        {{editCamera.cameraStatusTrans(editCamera.ActiveStreamStateService.activeStreamsMap[editCamera.camera.primaryStream.id].streamState)}}\n                    </div>\n                </div>\n                <div flex-gt-sm="40" ng-if="editCamera.supportsEditingNTP()" class="camera-info-detail-container">\n                    <h5 class="data-label">{{ editCamera.msgs.ntpSettings() }}</h5>\n                    <div class="data-field margin-top-negative-4">\n                        <span class="span-text">{{ editCamera.ntpDisplay() }}</span>\n                        <md-button class="md-icon-button custom-icon-button" ng-click="editCamera.showEditNtpOrTZDialog(\'ntp\', $event)" ng-if="(editCamera.cameraDisablementIsSupported && editCamera.camera.active) || !editCamera.cameraDisablementIsSupported">\n                            <i class="{{editCamera.icons.edit}}"></i>\n                            <md-tooltip class="edit-camera-tooltip" md-autohide md-direction="top" md-delay="250">{{ ::editCamera.msgs.editCameraNTPSettings() }}</md-tooltip>\n                        </md-button>\n                    </div>\n                </div>\n                <div ng-class="!editCamera.supportsEditingNTP() ? \'flex-gt-sm-40\' : \'flex-gt-sm-30\'" ng-if="editCamera.supportsEditingTZ()" class="camera-info-detail-container">\n                    <h5 class="data-label">{{ ::editCamera.msgs.timeZone() }}</h5>\n                    <div class="data-field margin-top-negative-4">\n                        <span class="span-text">{{ editCamera.tzDisplay() }}</span>\n                        <md-button class="md-icon-button custom-icon-button" ng-click="editCamera.showEditNtpOrTZDialog(\'tz\', $event)" ng-if="(editCamera.cameraDisablementIsSupported && editCamera.camera.active) || !editCamera.cameraDisablementIsSupported">\n                            <i class="{{editCamera.icons.edit}}"></i>\n                            <md-tooltip class="edit-camera-tooltip" md-autohide md-direction="top" md-delay="250">{{ ::editCamera.msgs.editCameraTZSettings() }}</md-tooltip>\n                        </md-button>\n                    </div>\n                </div>\n                <div flex-gt-xs="30" ng-if="editCamera.supportsEditingTP()" class="camera-info-detail-container">\n                    <h5 class="data-label">{{ ::editCamera.msgs.streamTransportProtocol() }}</h5>\n                    <div class="edit-tp-field">\n                        <span class="edit-tp-text">{{ editCamera.tpDisplay() }}</span>\n                        <md-button class="md-icon-button custom-icon-button" ng-click="editCamera.showEditNtpOrTZDialog(\'tp\', $event)" ng-if="(editCamera.cameraDisablementIsSupported && editCamera.camera.active) || !editCamera.cameraDisablementIsSupported">\n                            <i class="{{editCamera.icons.edit}}"></i>\n                            <md-tooltip class="edit-camera-tooltip" md-autohide md-direction="top" md-delay="250">{{ ::editCamera.msgs.editStreamTPSettings() }}</md-tooltip>\n                        </md-button>\n                    </div>\n                </div>\n\n                <div flex-gt-xs="40" ng-if="editCamera.cameraConnectionPreferenceIsSupported && editCamera.camera.driver === editCamera.CameraDriverType.ONVIF" class="camera-info-detail-container">\n                    <h5 class="data-label">{{ ::editCamera.msgs.configurationProtocol() }}</h5>\n                    <div class="edit-configuration-protocol-field">\n                        <span class="edit-configuration-protocol-text">{{editCamera.getConfigurationProtocol()}}</span>\n                        <md-button ng-click="editCamera.editConfigurationProtocol()" class="md-icon-button custom-icon-button" ng-if="(editCamera.cameraDisablementIsSupported && editCamera.camera.active) || !editCamera.cameraDisablementIsSupported">\n                            <i class="{{editCamera.icons.edit}}"></i>\n                            <md-tooltip class="edit-camera-tooltip" md-autohide md-direction="top" md-delay="250">{{ ::editCamera.msgs.editCameraConfigurationProtocol() }}</md-tooltip>\n                        </md-button>\n                    </div>\n                </div>\n\n                <div flex="100" class="pb-8 camera-info-detail-container" ng-if="editCamera.supportsResourceTagging">\n                    <h5 class="camera-tag-header">{{ ::editCamera.msgs.cameraTags() }}</h5>\n                    <camera-tagging class="data-field" [tags]="editCamera.camera.tags" [camera-id]="editCamera.camera.id" [recorder-id]="editCamera.orchid.id" [recorder-uri]="editCamera.orchid.uri" [recorder-version]="editCamera.orchid.version" (on-tags-change)="editCamera.updateCameraTags($event)"></camera-tagging>\n                </div>\n\n                <div flex="100" class="camera-info-detail-container">\n                    {{cameraConfig.msgs.cameraMacAddress()}}\n                    <h5 class="data-label">{{ ::editCamera.msgs.cameraMacAddress() }}</h5>\n                    <div class="mac-address-field">\n                        <span id="mac-address-{{editCamera.camera.id}}" class="data-field margin-top-5" ng-class="{\'data-mac-address\': editCamera.showMacAddressCopy}">{{editCamera.displayMacAddress}}</span>\n                        <md-button ng-if="editCamera.showMacAddressCopy" class="md-icon-button custom-icon-button clipboard copy-to-clipboard" data-clipboard-target="#mac-address-{{editCamera.camera.id}}">\n                            <md-tooltip class="edit-camera-tooltip" md-autohide md-direction="top" md-delay="250">{{ ::editCamera.msgs.copyMacAddress() }}</md-tooltip>\n                            <i class="{{editCamera.icons.clipboard}}"></i>\n                        </md-button>\n                    </div>\n                </div>\n\n                <div flex="100" class="camera-info-detail-container" ng-if="editCamera.camera.primaryStream && editCamera.camera.primaryStream.rtsp">\n                    <h5 class="data-label">{{ ::editCamera.msgs.primaryStreamRtspURL() }}</h5>\n                    <div>\n                        <span class="data-field data-url" id="rtsp-url-{{editCamera.camera.id}}">{{editCamera.camera.primaryStream.rtsp}}</span>\n                        <md-button class="md-icon-button custom-icon-button clipboard copy-to-clipboard" data-clipboard-target="#rtsp-url-{{editCamera.camera.id}}">\n                            <md-tooltip class="edit-camera-tooltip" md-autohide md-direction="top" md-delay="250">{{ ::editCamera.msgs.copyURL() }}</md-tooltip>\n                            <i class="{{editCamera.icons.clipboard}}"></i>\n                        </md-button>\n                    </div>\n                </div>\n                <div flex="100" class="camera-info-detail-container" ng-if="editCamera.isPrimaryStreamDefined">\n                    <h5 class="data-label">{{ ::editCamera.msgs.primaryStreamProxyRtspURL() }}</h5>\n                    <div>\n                        <span class="data-field data-url" id="proxy-rtsp-url-{{editCamera.camera.id}}">{{editCamera.rtspProxyUrl}}</span>\n                        <md-button class="md-icon-button custom-icon-button clipboard copy-proxy-to-clipboard" data-clipboard-target="#proxy-rtsp-url-{{editCamera.camera.id}}">\n                            <md-tooltip class="edit-camera-tooltip" md-autohide md-direction="top" md-delay="250">{{ ::editCamera.msgs.copyProxyURL() }}</md-tooltip>\n                            <i class="{{editCamera.icons.clipboard}}"></i>\n                        </md-button>\n                    </div>\n                </div>\n                <md-button class="stats-toggle" md-no-ink ng-click="editCamera.toggleStatsTable()" ng-show="editCamera.showStats && editCamera.isPrimaryStreamDefined" ng-disabled="editCamera.disableTable">\n                    {{ ::editCamera.msgs.recordingStatistics() }}\n                    <i class="fa" ng-class="{\'fa-chevron-right\': !editCamera.openStats, \'fa-chevron-down\' : editCamera.openStats}"></i>\n                </md-button>\n                <div ng-show="editCamera.openStats && editCamera.isPrimaryStreamDefined" class="stats-toggle-content">\n                    <span class="primary-stats-label">{{ ::editCamera.msgs.theFollowingStatisticsAreBasedOnThePrimaryStream() }}</span>\n                    <md-card class="stats-table">\n                        <table md-table class="striped-table orchid-table responsive-table-600" ng-if="editCamera.camera.active">\n                            <thead md-head>\n                                <tr md-row>\n                                    <th class="stats-header average-window" md-column>\n                                        {{ ::editCamera.msgs.averageWindow() }}\n                                    </th>\n                                    <th class="stats-header" md-column>{{ ::editCamera.msgs.packetLoss() }}</th>\n                                    <th md-column><span>{{ ::editCamera.msgs.bitrate() }}</span></th>\n                                </tr>\n                            </thead>\n                            <tbody md-body>\n                                <tr md-row ng-repeat="x in [].constructor(editCamera.numRowStats) track by $index">\n                                    <td data-title="{{ ::editCamera.msgs.averageWindow() }}" md-cell class="average-window">\n                                        {{editCamera.cameraStats[$index].windowSizeTime }}\n                                    </td>\n                                    <td data-title="{{ ::editCamera.msgs.packetLoss() }}" md-cell>\n                                        <div ng-if="editCamera.ActiveStreamStateService.activeStreamsMap[editCamera.camera.primaryStream.id].streamStatistics[$index].audio">\n                                            <p class="stats-video-audio">\n                                                {{ ::editCamera.msgs.statsVideo() }}: {{\n                                                editCamera.cameraStats[$index].packetLossVideo }}\n                                            </p>\n                                            <p class="stats-video-audio">\n                                                {{ ::editCamera.msgs.audio() }}: {{\n                                                editCamera.cameraStats[$index].packetLossAudio }}\n                                            </p>\n                                        </div>\n                                        <div ng-if="!editCamera.ActiveStreamStateService.activeStreamsMap[editCamera.camera.primaryStream.id].streamStatistics[$index].audio" class="no-audio">\n                                            <span> {{ editCamera.cameraStats[$index].packetLossVideo }} </span>\n                                        </div>\n                                    </td>\n                                    <td data-title="{{ ::editCamera.msgs.bitrate() }}" md-cell>\n                                        <div ng-if="editCamera.ActiveStreamStateService.activeStreamsMap[editCamera.camera.primaryStream.id].streamStatistics[$index].audio">\n                                            <p class="stats-video-audio">\n                                                {{ ::editCamera.msgs.statsVideo() }}:\n                                                {{editCamera.cameraStats[$index].averageBitsVideo}}\n                                            </p>\n                                            <p class="stats-video-audio">\n                                                {{ ::editCamera.msgs.audio() }}:\n                                                {{editCamera.cameraStats[$index].averageBitsAudio}}\n                                            </p>\n                                            <p class="stats-total">\n                                                {{ ::editCamera.msgs.statsTotal() }}: {{\n                                                editCamera.cameraStats[$index].averageBitsTotal }}\n                                            </p>\n                                        </div>\n                                        <div ng-if="!editCamera.ActiveStreamStateService.activeStreamsMap[editCamera.camera.primaryStream.id].streamStatistics[$index].audio" class="no-audio">\n                                            <span>{{ editCamera.cameraStats[$index].averageBitsVideo }}</span>\n                                        </div>\n                                    </td>\n                                </tr>\n                            </tbody>\n                        </table>\n                        <table md-table class="striped-table orchid-table responsive-table-600">\n                            <thead md-head>\n                                <tr md-row>\n                                    <th md-column>{{ ::editCamera.msgs.lastArchive() }}</th>\n                                </tr>\n                            </thead>\n                            <tbody md-body>\n                                <tr md-row>\n                                    <td md-cell data-title="{{ ::editCamera.msgs.lastArchive() }}" class="archive-cell">\n                                        <span class="archive-text"> {{ editCamera.lastVideoWritten }} </span>\n                                    </td>\n                                </tr>\n                            </tbody>\n                        </table>\n                        \x3c!-- Metadata statistics table --\x3e\n                    </md-card>\n                    <span class="primary-stats-label">{{ ::editCamera.msgs.metadataStatistics.metadataStatsBlurb() }}</span>\n                    <md-card class="stats-table">\n                        <table md-table class="striped-table orchid-table responsive-table-600">\n                            <thead md-head>\n                                <tr md-row>\n                                    <th md-column class="metadata-name">\n                                        {{ ::editCamera.msgs.metadataStatistics.metadata() }}\n                                    </th>\n                                    <th md-column class="metadata-timestamp" ng-if="!editCamera.noMetadataStats">\n                                        {{ ::editCamera.msgs.metadataStatistics.timestamp() }}\n                                    </th>\n                                </tr>\n                            </thead>\n                            <tbody md-body ng-if="!editCamera.noMetadataStats">\n                                <tr md-row ng-repeat="item in editCamera.metadataStats  | orderBy:\'name\'">\n                                    <td md-cell class="metadata-name">\n                                        <span>{{ item.name}}</span>\n                                    </td>\n                                    <td md-cell data-title="{{ item.name}}" class="metadata-timestamp">\n                                        <span class="archive-text"> {{ item.timestamp}} </span>\n                                    </td>\n                                </tr>\n                            </tbody>\n                            <tbody md-body ng-if="editCamera.noMetadataStats">\n                                <tr md-row>\n                                    <td md-cell class="metadata-timestamp" data-title="{{ ::editCamera.msgs.metadataStatistics.metadata() }}">\n                                        {{ ::editCamera.msgs.metadataStatistics.noData() }}\n                                    </td>\n                                </tr>\n                            </tbody>\n                        </table>\n                    </md-card>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <div class="camera-stream-admin">\n        <div layout="row" layout-xs="column" layout-align="space-between center" layout-align-xs="start start" layout-wrap class="add-stream-button-container">\n            <h3 class="inline-header">{{ ::editCamera.msgs.streams() }}</h3>\n            <md-button class="md-raised md-primary action-button add-button add-stream-button" ng-if="editCamera.initialized" ng-click="editCamera.addStream($event)" ng-disabled="editCamera.camera.streams === undefined || !editCamera.camera.active">{{ ::editCamera.msgs.addStream() }}</md-button>\n        </div>\n        <div class="no-streams-message" ng-if="!editCamera.isPrimaryStreamDefined">\n            {{ ::editCamera.msgs.noStreamsConfigured() }}\n        </div>\n        <div class="stream-progress" ng-if="editCamera.processingFusionCameraStreams">\n            <md-progress-circular md-diameter="50"></md-progress-circular>\n        </div>\n        <div class="clear-both"></div>\n        <md-card ng-if="!editCamera.processingFusionCameraStreams && editCamera.camera.streams.length > 0" class="edit-camera-card">\n            <table md-table class="striped-table orchid-table table-hover interactive">\n                <thead md-head>\n                    <tr md-row>\n                        <th md-column class="status-column">{{ ::editCamera.msgs.status() }}</th>\n                        <th md-column class="mode-column">{{ ::editCamera.msgs.mode() }}</th>\n                        <th md-column class="stream-name">{{ ::editCamera.msgs.name() }}</th>\n                        <th md-column class="stream-configuration-column">{{ ::editCamera.msgs.configuration() }}</th>\n                        <th md-column class="stream-actions"></th>\n                    </tr>\n                </thead>\n                <tbody md-body>\n                    <tr md-row ng-repeat="stream in editCamera.camera.streams | orderBy:\'name\'" ng-click="editCamera.editStream(stream, $event);" ng-class="{ success: (stream.id === editCamera.selectedStream.id) }">\n                        <td md-cell class="status-column">\n                            <i ng-show="!editCamera.streamsMap[stream.id].extras.isDisabled" ng-class="editCamera.ActiveStreamStateService.activeStreamsMap[stream.id].streamState === \'running\' ? editCamera.icons.stream_up : editCamera.icons.stream_down" class="fa-2x">\n                            </i>\n                            <i ng-show="editCamera.streamsMap[stream.id].extras.isDisabled" class="{{editCamera.icons.stream_disabled}}"></i>\n                        </td>\n                        <td md-cell class="mode-column">\n                            <md-progress-circular md-mode="indeterminate" md-diameter="25px" ng-if="editCamera.streamsMap[stream.id].processing" class="margin-left-10"></md-progress-circular>\n                            <md-menu md-position-mode="left target">\n                                <md-button class="md-icon-button mode-menu-icon" ng-click="$mdMenu.open($event)" ng-hide="editCamera.streamsMap[stream.id].processing" ng-disabled="!editCamera.canUpdateStream(stream)">\n                                    <i class="stream-icon" ng-class="{\n                                       \'primary {{editCamera.icons.stream_primary}}\': editCamera.streamsMap[stream.id].extras.isPrimary,\n                                       \'secondary {{editCamera.icons.stream}}\' : editCamera.streamsMap[stream.id].extras.isSecondary,\n                                       \'disabled-stream {{editCamera.icons.stream}}\': editCamera.streamsMap[stream.id].extras.isDisabled\n                                       }"></i>\n                                </md-button>\n                                <md-menu-content>\n                                    \x3c!-- Primary Button --\x3e\n                                    <md-menu-item>\n                                        <md-button ng-click="editCamera.makeStreamPrimary(stream, $event)">\n                                            <i class="{{editCamera.icons.stream_primary}} stream-icon"></i>\n                                            {{ ::editCamera.msgs.primary() }}\n                                        </md-button>\n                                    </md-menu-item>\n                                    \x3c!-- Secondary Button --\x3e\n                                    <md-menu-item>\n                                        <md-button ng-click="editCamera.makeStreamSecondary(stream, $event)" ng-disabled="editCamera.streamsMap[stream.id].extras.isSecondary || editCamera.streamsMap[stream.id].extras.isPrimary || editCamera.disableSecondaryStreamFeature">\n                                            <i class="{{editCamera.icons.stream}} stream-icon"></i>\n                                            {{ ::editCamera.msgs.secondary() }}\n                                        </md-button>\n                                    </md-menu-item>\n                                    \x3c!-- Disabled Button --\x3e\n                                    <md-menu-item>\n                                        <md-button ng-click="editCamera.makeStreamDisabled(stream, $event)" ng-disabled="editCamera.streamsMap[stream.id].extras.isPrimary || editCamera.streamsMap[stream.id].extras.isDisabled">\n                                            <i class="{{editCamera.icons.stream}} stream-icon disabled-stream"></i>\n                                            {{ ::editCamera.msgs.disabled() }}\n                                        </md-button>\n                                    </md-menu-item>\n                                </md-menu-content>\n                            </md-menu>\n                        </td>\n                        <td md-cell class="stream-name">{{stream.name}}</td>\n                        <td md-cell ng-if="editCamera.camera.driver === editCamera.CameraDriverType.ONVIF" class="stream-configuration-column">\n                            {{stream.configuration.Video.Resolution}}, {{stream.configuration.Video.FrameRate}}fps,\n                            {{stream.configuration.Video.Encoder}}\n                            <br>\n                            <em ng-class="stream.configuration.Video.Encoder !== \'H264\' && editCamera.streamsMap[stream.id].extras.isSecondary ? \'warn-text\': \'text-muted\'">{{::editCamera.getRecordingStyle(stream)}}</em>\n                        </td>\n                        <td md-cell ng-if="editCamera.camera.driver === editCamera.CameraDriverType.RTSP" class="stream-configuration-column">\n                            {{stream.configuration.General.Path}}\n                            <br>\n                            <em ng-class="stream.configuration.Video && stream.configuration.Video.Encoder !== \'H264\' && editCamera.streamsMap[stream.id].extras.isSecondary ? \'warn-text\': \'text-muted\'">{{::editCamera.getRecordingStyle(stream)}}</em>\n                        </td>\n                        <td md-cell class="action-cell stream-actions">\n                            <md-button class="md-icon-button" disabled="disabled">\n                                <i class="{{editCamera.icons.lock}}" ng-show="stream.configuration.Fixed === \'true\'" ng-click="$event.stopPropagation()">\n                                    <md-tooltip md-autohide md-direction="top" md-delay="250">\n                                        {{ ::editCamera.msgs.fixedStreamNoDelete() }}\n                                    </md-tooltip>\n                                </i>\n                            </md-button>\n                            <md-menu md-position-mode="left target">\n                                <md-button class="md-icon-button edit-menu-button" ng-click="$mdMenu.open($event)" ng-disabled="editCamera.processingDeleteStream[stream.id] || (editCamera.cameraDisablementIsSupported && !editCamera.camera.active)">\n                                    <i class="{{editCamera.icons.more_actions}}"></i>\n                                </md-button>\n                                <md-menu-content>\n                                    \x3c!-- Edit Button --\x3e\n                                    <md-menu-item>\n                                        <md-button ng-click="editCamera.editStream(stream, $event)">\n                                            <i class="{{editCamera.icons.edit}}"></i>\n                                            {{ ::editCamera.msgs.edit() }}\n                                        </md-button>\n                                    </md-menu-item>\n                                    \x3c!-- Copy Button --\x3e\n                                    <md-menu-item ng-show="editCamera.camera.driver === editCamera.CameraDriverType.ONVIF">\n                                        <md-button ng-click="editCamera.copyStream(stream, $event)">\n                                            <i class="{{editCamera.icons.copy}}"></i>\n                                            {{ ::editCamera.msgs.copy() }}\n                                        </md-button>\n                                    </md-menu-item>\n                                    \x3c!-- Restart Button --\x3e\n                                    <md-menu-item ng-show="editCamera.camera.driver === editCamera.CameraDriverType.ONVIF" ng-hide="editCamera.streamsMap[stream.id].extras.isDisabled || editCamera.disableSecondaryStreamFeature">\n                                        <md-button ng-click="editCamera.restartStream(stream, $event)">\n                                            <i class="{{editCamera.icons.repeat}}"></i>\n                                            {{ ::editCamera.msgs.restart() }}\n                                        </md-button>\n                                    </md-menu-item>\n                                    \x3c!-- Delete Button --\x3e\n                                    <md-menu-item ng-show="stream.configuration.Fixed !== \'true\'">\n                                        <md-button ng-click="editCamera.deleteStream(editCamera.camera, stream, $event)">\n                                            <i class="{{editCamera.icons.delete}}"> </i>\n                                            {{ ::editCamera.msgs.delete() }}\n                                        </md-button>\n                                    </md-menu-item>\n                                </md-menu-content>\n                            </md-menu>\n                        </td>\n                    </tr>\n                </tbody>\n            </table>\n        </md-card>\n    </div>\n    <h3>{{ ::editCamera.msgs.whichSettings({ VALUE: editCamera.msgs.advanced() }) }}</h3>\n\n    <div class="radio-group advanced-settings-section">\n        <div class="setting-row">\n            <div class="sing-list-item">\n                <i class="list-item-icon {{ editCamera.icons.camera_dewarp_control }}"></i>\n                <div class="list-item-text-container">\n                    <span class="label-medium">\n                        {{editCamera.msgs.advancedSettings.fisheyeDewarping()}}\n                        <tag ng-if="editCamera.isPrimaryStreamDewarped()" type="success" label="{{editCamera.msgs.advancedSettings.on()}}"></tag>\n                    </span>\n                    <span class="label-tiny hint-text"> {{editCamera.msgs.advancedSettings.configureDewarp()}}</span>\n                </div>\n            </div>\n            <md-button ng-click="editCamera.openDewarpDialog($event)" class="md-primary" ng-disabled="!editCamera.camera.active && editCamera.cameraDisablementIsSupported">\n                {{editCamera.msgs.advancedSettings.edit()}}\n            </md-button>\n        </div>\n        <div class="setting-row">\n            <div class="sing-list-item">\n                <i class="list-item-icon {{ editCamera.icons.camera_motion }}"></i>\n                <div class="list-item-text-container">\n                    <span class="label-medium">\n                        {{editCamera.msgs.advancedSettings.motionDetectionMask()}}\n                        <tag ng-if="editCamera.motionMaskEnabled" type="success" label="{{editCamera.msgs.advancedSettings.on()}}"></tag>\n                    </span>\n                    <span class="label-tiny hint-text">\n                        {{editCamera.msgs.advancedSettings.configureMaskedArea()}}</span>\n                </div>\n            </div>\n            <md-button ng-disabled="editCamera.currentMotionStyle.id === \'camera\' || !editCamera.camera.active && editCamera.cameraDisablementIsSupported" class="md-primary" ng-click="editCamera.openMotionDetectionDialog($event)">\n                {{editCamera.msgs.advancedSettings.edit()}}\n            </md-button>\n        </div>\n        <div class="setting-row" ng-if="editCamera.hasTalkDown">\n            <div class="sing-list-item">\n                <i class="list-item-icon {{ editCamera.icons.camera_mic_on }}"></i>\n                <div class="list-item-text-container">\n                    <span class="label-medium">\n                        {{editCamera.msgs.advancedSettings.talkDown()}}\n                        <tag ng-if="editCamera.talkDownEnabled" type="success" label="{{editCamera.msgs.advancedSettings.on()}}"></tag>\n                    </span>\n                    <span class="label-tiny hint-text"> {{editCamera.msgs.advancedSettings.allowUsersToTalk()}}</span>\n                </div>\n            </div>\n            <md-button ng-disabled="(!editCamera.camera.active && editCamera.cameraDisablementIsSupported) || editCamera.cameraProcessing" class="md-primary" ng-click="editCamera.openTalkPermissionDialog($event)">\n                {{editCamera.msgs.advancedSettings.edit()}}\n            </md-button>\n        </div>\n    </div>\n\n    <h3>{{ ::editCamera.msgs.actions() }}</h3>\n    <div layout="row" layout-align="start center" layout-wrap class="camera-actions">\n        <md-button ng-click="editCamera.deleteCamera($event)" ng-disabled="editCamera.deleting || editCamera.cameraProcessing" class="md-raised md-warn action-button" ng-class="{\'remove-button\': !editCamera.deleting}">\n            <span ng-if="!editCamera.deleting">{{ ::editCamera.msgs.deleteCamera() }}</span>\n            <md-progress-circular md-mode="indeterminate" md-diameter="25px" ng-if="editCamera.deleting">\n            </md-progress-circular>\n        </md-button>\n        <md-button ng-if="editCamera.canRecoverCamera" ng-click="editCamera.recoverCamera($event)" ng-disabled="editCamera.deleting || editCamera.cameraProcessing" class="md-raised md-primary action-button tweak-button">\n            <span ng-if="!editCamera.deleting">{{ ::editCamera.msgs.recoverCamera() }}</span>\n        </md-button>\n        <div ng-if="editCamera.cameraDisablementIsSupported">\n            <md-button ng-if="editCamera.camera.active" ng-click="editCamera.disableCamera($event)" ng-disabled="editCamera.deleting || editCamera.cameraProcessing" class="md-raised md-primary action-button">\n                <i class="{{ editCamera.icons.camera_disabled }} button-icon"></i>\n                <span>{{ ::editCamera.msgs.disableCamera() }}</span>\n            </md-button>\n            <md-button ng-if="!editCamera.camera.active" ng-click="editCamera.reactivateCamera($event)" ng-disabled="editCamera.deleting || editCamera.cameraProcessing" class="md-raised md-primary action-button">\n                <i class="{{ editCamera.icons.camera }}"></i>\n                <span>{{ ::editCamera.msgs.reactivateCamera() }}</span>\n            </md-button>\n        </div>\n    </div>\n</div>\n'
        }
        ,
        52896: e => {
            e.exports = '<section class="fusion-app" ng-class="{ \'unsupported-browser\': app.isUnsupported }">\n    <md-toolbar class="nav-bar md-whiteframe-4dp" ng-class="{ \'md-warn\': app.badLicense }">\n        <div class="md-toolbar-tools">\n            \x3c!-- Logo + Fail State Buttons --\x3e\n            <div class="logo-container">\n                <logo></logo>\n\n                <div class="fail-state-buttons-container">\n                    <md-button ng-cloak ng-disabled="true" ng-if="::app.isLowBandwidthForced()" class="md-icon-button">\n                        <i class="low-bandwidth fa-kit fa-turtle-land"></i>\n                        <md-tooltip md-autohide md-delay="500">{{ ::app.msgs.appInLowBandwidth() }}</md-tooltip>\n                    </md-button>\n                    <md-button ng-click="app.showTimeWarning($event)" ng-show="app.orchidTimeOffset > 5000 || app.orchidTimeOffset < -5000" class="md-icon-button">\n                        <i class="fa-regular fa-clock time-sync"></i>\n                    </md-button>\n                    <md-button ng-cloak ng-click="app.showErrorDialog()" ng-if="app.badLicense" class="md-icon-button degraded-warning">\n                        <i class="fa fa-triangle-exclamation"></i>\n                        <md-tooltip md-autohide md-delay="500"> {{ app.errorTitle }}. </md-tooltip>\n                    </md-button>\n                    <framerate-alert></framerate-alert>\n                </div>\n            </div>\n\n            \x3c!-- Username and Hamburger Menu --\x3e\n            <div class="menu-container">\n                <span flex>\n                    <span ng-if="app.isUnsupported" class="unsupported-text">{{ ::app.msgs.browserNotSupported() }}</span>\n                </span>\n                <md-menu class="user-menu hide-short" md-position-mode="target-right target" md-offset="0 40px">\n                    <div class="user-container" ng-click="$mdMenu.open($event)" md-ink-ripple>\n                        <span class="nav-user">\n                            <div>{{ app.msgs.signedInAs() }}</div>\n                            <div class="nav-name">{{ app.authenticationData.username }}</div>\n                        </span>\n                        <md-tooltip md-autohide md-delay="600">\n                            {{ app.msgs.signedInAsToolTip({ VALUE: app.authenticationData.username }) }}\n                        </md-tooltip>\n                    </div>\n                    <md-menu-content>\n                        <md-menu-item ng-if="app.isPWA">\n                            <md-button aria-label="{{ app.msgs.leave() }}" ng-click="app.leave()" class="sign-out-button">\n                                <md-icon md-font-icon="fa-sign-out sign-out-icon" class="fa s20 sign-out"></md-icon>\n                                {{ ::app.msgs.leave() }}\n                            </md-button>\n                        </md-menu-item>\n                        <md-menu-item>\n                            <md-button aria-label="{{ app.msgs.signOut() }}" ng-click="app.signOut()">\n                                <md-icon md-font-icon="fa-power-off" class="fa s20 sign-out"></md-icon> {{\n                                app.msgs.signOut() }}\n                            </md-button>\n                        </md-menu-item>\n                    </md-menu-content>\n                </md-menu>\n\n                <navigation on-sign-out="app.signOut" display="menu" style="margin-right: -10px; padding-left: 10px"></navigation>\n            </div>\n        </div>\n    </md-toolbar>\n</section>\n'
        }
        ,
        75027: e => {
            e.exports = '<div class="dialog-errors-content">\n    <div class="clear-errors" ng-click="targetObject.error = undefined; targetObject.errorFields = undefined;">\n        <i class="fa fa-times"></i>\n    </div>\n    <div class="error-display">\n        {{targetObject.error}}\n        <ul ng-if="targetObject.errorFields">\n            <li ng-repeat="(field, error) in targetObject.errorFields">{{field}}: {{error}}</li>\n        </ul>\n    </div>\n    <div class="triangle-container">\n        <i class="fa fa-triangle-exclamation"></i>\n    </div>\n</div>\n'
        }
        ,
        98737: e => {
            e.exports = '<md-content ng-repeat="orchid in orchidAdmin.orchids | orderBy: \'name\'" class="centered orchid-admin-container full-width-container" ng-switch="::orchidAdmin.component" style="overflow:hidden;">\n    <activation [orchid]="orchid" ng-switch-when="activation"></activation>\n    <camera-config orchid="orchid" ng-switch-when="camera-admin"></camera-config>\n    <system-status [orchid]="orchid" ng-switch-when="system-status"></system-status>\n    <system-report orchid="orchid" ng-switch-when="system-report"></system-report>\n    <audit-logs [orchid]="orchid" ng-switch-when="audit-logs"></audit-logs>\n    <retention-policy orchid="orchid" ng-switch-when="retention-policy"></retention-policy>\n    <property-editor orchid="orchid" route="orchidAdmin.route" ng-switch-when="advanced-settings"></property-editor>\n</md-content>\n'
        }
        ,
        97133: e => {
            e.exports = '<div class="password-form-field-lite">\n    <input ng-if="!passwordFormFieldLite.matchPassword" name="{{passwordFormFieldLite.fieldName}}" type="{{passwordFormFieldLite.type}}" ng-model="passwordFormFieldLite.value" ng-disabled="{{passwordFormFieldLite.disabled}}" ng-required="{{passwordFormFieldLite.required}}" minlength="{{passwordFormFieldLite.minlength}}" autocapitalize="off" autocomplete="off" autocorrect="off">\n\n    <input ng-if="passwordFormFieldLite.matchPassword" name="{{passwordFormFieldLite.fieldName}}" type="{{passwordFormFieldLite.type}}" ng-model="passwordFormFieldLite.value" ng-disabled="{{passwordFormFieldLite.disabled}}" ng-required="{{passwordFormFieldLite.required}}" minlength="{{passwordFormFieldLite.minlength}}" match-password="{{passwordFormFieldLite.matchPassword}}" autocapitalize="off" autocomplete="off" autocorrect="off">\n\n    \x3c!-- Visibility Toggle Button --\x3e\n    <md-button class="md-icon-button" ng-click="passwordFormFieldLite.onIconClick($event)" ng-disabled="{{passwordFormFieldLite.disabled}}" tabindex="-1" type="button">\n        <mat-icon>\n            <i class="fa-regular fa-{{ passwordFormFieldLite.icon }}"></i>\n        </mat-icon>\n    </md-button>\n</div>\n'
        }
        ,
        20466: e => {
            e.exports = '<section class="fusion-app">\n    <md-toolbar class="nav-bar md-whiteframe-4dp" style="position: fixed; top: 0; z-index: 78;">\n        <div class="md-toolbar-tools">\n            <span class="nav-bar-logo" layout="row" layout-align="center center" ng-click="signedOut.router.navigateByUrl(\'/stage\')" style="cursor: pointer;">\n                <img src="images/header_logo.svg" style="height:24px">\n                <span class="nav-bar-logo-text">Orchid Hybrid</span>\n            </span>\n            <span flex></span>\n        </div>\n    </md-toolbar>\n\n    <md-content class="ui-view-container" ng-transclude></md-content>\n</section>\n'
        }
        ,
        23166: e => {
            e.exports = '<div class="footer">\n    <div class="container" layout="row">\n        <div layout="column">\n            <div class="provided">{{ ::custom.msgs.appProvidedBy() }}</div>\n            <div style="display: flex">\n                <img ng-if="custom.supportInfo.provider.logo" ng-src="{{ custom.supportInfo.provider.logo }}" class="logo">\n                <span title="{{ custom.supportInfo.provider.name }}" class="provider">{{ custom.supportInfo.provider.name }}</span>\n            </div>\n        </div>\n        <div style="margin: auto 0">\n            <md-button ng-click="custom.showSupportLinks($event)" class="md-primary">{{ ::custom.msgs.support() }}</md-button>\n        </div>\n    </div>\n</div>\n\n<div class="frame-container">\n    <iframe ng-hide="custom.loading || custom.error" id="plugin-frame" class="open-frame" ng-src="{{custom.pluginSrc}}"></iframe>\n</div>\n\n<div ng-if="custom.loading" layout="row" layout-sm="column" layout-align="space-around" class="plugin-overlay plugin-loading">\n    <md-progress-circular md-mode="indeterminate"></md-progress-circular>\n</div>\n\n<div ng-if="custom.error" class="errors plugin-unavailable" layout-align="space-around">\n    <md-content>\n        <md-subheader class="md-no-sticky empty-data-text">\n            <h2>{{custom.error}}</h2>\n        </md-subheader>\n    </md-content>\n</div>\n'
        }
        ,
        76492: e => {
            e.exports = '<md-dialog aria-label="{{ ::customSupportDialog.msgs.contactSupport() }}" class="custom-support-dialog">\n    <md-dialog-content>\n        <md-toolbar>\n            <div class="md-toolbar-tools">\n                <h2>{{ ::customSupportDialog.msgs.supportOptions() }}</h2>\n                <span flex></span>\n                <md-button class="md-icon-button close-dialog-x" ng-click="customSupportDialog.close()">\n                    <i class="fa fa-times fa-2x"></i>\n                </md-button>\n            </div>\n        </md-toolbar>\n        <md-list ng-cloak>\n            <md-list-item>\n                <span class="support" flex layout="row">\n                    <div>{{ ::customSupportDialog.msgs.name() }}</div>\n                    <div title="{{ customSupportDialog.supportInfo.name }}" class="emphasis truncate">{{ customSupportDialog.supportInfo.name }}</div>\n                </span>\n            </md-list-item>\n            <md-list-item>\n                <span class="support" flex layout="row">\n                    <div>{{ ::customSupportDialog.msgs.version() }}</div>\n                    <div title="{{ customSupportDialog.supportInfo.version }}" class="emphasis truncate">{{ customSupportDialog.supportInfo.version }}</div>\n                </span>\n            </md-list-item>\n            <md-list-item>\n                <span class="support" flex layout="row">\n                    <div class="emphasis">{{ customSupportDialog.supportInfo.description }}</div>\n                </span>\n            </md-list-item>\n            <md-list-item ng-if="customSupportDialog.supportInfo.provider.support.url">\n                <a ng-href="{{ customSupportDialog.supportInfo.provider.support.url }}" target="_blank" class="support link" flex layout="row" layout-align="center center">\n                    <div><i class="fa fa-globe fa-2x"></i></div>\n                    <div>{{ customSupportDialog.supportInfo.provider.support.url }}</div>\n                </a>\n            </md-list-item>\n            <md-list-item ng-if="customSupportDialog.supportInfo.provider.support.phone">\n                <a ng-href="tel:{{ customSupportDialog.supportInfo.provider.support.phone }}" class="support link" flex layout="row" layout-align="center center">\n                    <div><i class="fa fa-phone fa-2x"></i></div>\n                    <div>{{ customSupportDialog.supportInfo.provider.support.phone }}</div>\n                </a>\n            </md-list-item>\n            <md-list-item ng-if="customSupportDialog.supportInfo.provider.support.email">\n                <a ng-href="mailto:{{ customSupportDialog.supportInfo.provider.support.email }}" class="support link" flex layout="row" layout-align="center center">\n                    <div><i class="fa fa-envelope fa-2x"></i></div>\n                    <div>{{ customSupportDialog.supportInfo.provider.support.email }}</div>\n                </a>\n            </md-list-item>\n        </md-list>\n    </md-dialog-content>\n    <md-dialog-actions>\n        <span flex></span>\n        <md-button ng-click="customSupportDialog.close()" class="md-primary close-dialog-button">\n            {{ ::customSupportDialog.msgs.done() }}\n        </md-button>\n    </md-dialog-actions>\n</md-dialog>\n'
        }
        ,
        89976: e => {
            e.exports = '<section layout="row" class="admin-section" flex>\n    <navigation display="left"></navigation>\n\n    <md-content class="centered generic-admin-container-area">\n        <div class="md-no-sticky add-orchid-container generic-admin-header">\n            <span flex></span>\n            <md-button class="md-raised md-primary add-orchid-button action-button add-button" aria-label="{{ dashboard.msgs.addOrchid() }}" ng-click="dashboard.registerOrchid($event);" ng-if="dashboard.userIsAdminOrRegistrar" ng-disabled="dashboard.error">\n                <span hide-xs>{{ dashboard.msgs.addChildName() }}</span>\n                <span hide-gt-xs>Orchid Recorder</span>\n            </md-button>\n            <md-button class="md-raised manage-tags-button action-button" ng-click="dashboard.manageTags()" ng-if="dashboard.isAdmin">\n                <i class="{{ dashboard.icons.tag }}"></i>\n                <span>{{ dashboard.msgs.manageTags() }}</span>\n            </md-button>\n        </div>\n\n        <md-content ng-if="dashboard.error">\n            <md-subheader class="md-no-sticky">\n                <h1>{{dashboard.error}}</h1>\n            </md-subheader>\n        </md-content>\n\n        <md-card ng-if="filteredOrchids.length > dashboard.paging.paginatorLimit || dashboard.filters.searchNames.length">\n            <md-card-content class="layout-column layout-gt-xs-row layout-align-gt-xs-center-end filters">\n                <md-input-container class="flex-100 flex-gt-xs-70 name-container">\n                    <label>{{ dashboard.msgs.name() }}</label>\n                    <md-chips ng-model="dashboard.filters.searchNames" md-add-on-blur="true" placeholder="{{ dashboard.msgs.search() }}" secondary-placeholder="{{ dashboard.msgs.search() }}" md-on-add="dashboard.filtersChanged()" md-on-remove="dashboard.filtersChanged()">\n                    </md-chips>\n                </md-input-container>\n                <md-input-container class="flex-100 flex-gt-xs-30 sort-container">\n                    <label>{{ dashboard.msgs.sort() }}</label>\n                    <md-select ng-model="dashboard.filters.sortBy" ng-change="dashboard.filtersChanged()">\n                        <md-option value="name"> {{ dashboard.msgs.name() }} </md-option>\n                        <md-option value="health"> {{ dashboard.msgs.health() }} </md-option>\n                        <md-option value="version"> {{ dashboard.msgs.version() }} </md-option>\n                    </md-select>\n                </md-input-container>\n            </md-card-content>\n        </md-card>\n\n        <md-content ng-if="dashboard.orchids.length === 0 || filteredOrchids.length === 0">\n            <div class="md-no-sticky no-bananas no-matches-error-message" ng-switch="dashboard.noServersOrSearchDidNotMatchSwitchKey">\n                <span ng-switch-when="matches">{{ dashboard.msgs.noServersMatchSearch() }}</span>\n                <span ng-switch-default>{{ dashboard.msgs.noChildNameServersHaveBeenRegistered() }}</span>\n            </div>\n        </md-content>\n\n        <div ng-if="filteredOrchids.length > 0 && dashboard.pagingPages(filteredOrchids.length) > 0" class="content-list-counter">\n            {{ dashboard.msgs.serversRange({ RANGE: dashboard.pageRange(filteredOrchids), LENGTH:\n            filteredOrchids.length}) }}\n        </div>\n        <md-content class="orchids-container">\n            <md-card ng-if="!dashboard.orchidsLoading" big-summer-blowout="dashboard.orchidData[orchid.id].expanded" on-expand="dashboard.getSessionId(orchid)" on-close="dashboard.onClose(orchid)" ng-repeat="orchid in filteredOrchids = (dashboard.orchids | filterByManaged:dashboard.orchidData | filterByNameSearch:dashboard.filters.searchNames) |\n                orderBy : \'valueOf()\' : false : dashboard.orchidComparator |\n                limitTo : dashboard.paging.perPage : dashboard.getStartFromIndex()\n                track by orchid.id">\n                <md-content>\n                    <md-list-item class="blowout-header">\n                        <div class="header-left">\n                            <div class="header-decor">\n                                <div class="header-version">{{orchid.version.version}}</div>\n                                <i class="fa header-icon" ng-class="dashboard.getOrchidState(orchid).iconStyle"></i>\n                            </div>\n                            <span class="title">\n                                <div class="layout-row layout-wrap">\n                                    <h3 class="title-header">{{orchid.name}}</h3>\n                                    <div class="error-chip" ng-if="dashboard.getOrchidState(orchid).id !== dashboard.ServerStateId.HEALTHY">\n                                        {{ dashboard.getOrchidState(orchid).displayText }} {{\n                                        dashboard.getOfflineSince(orchid) }}\n                                    </div>\n                                </div>\n                                <div class="orchid-uri-container desktop-link">\n                                    <a class="ng-binding text-link desktop-link" href="{{orchid.uri}}" target="_blank" ng-mouseup="$event.stopPropagation();">\n                                        <span class="orchid-uri">{{orchid.uri}}</span>\n                                        <i class="fa fa-external-link"></i>\n                                    </a>\n                                </div>\n\n                                <div class="orchid-uri-container mobile-link">\n                                    <span class="orchid-uri">{{orchid.uri}}</span>\n                                    <a class="ng-binding text-link" href="{{orchid.uri}}" target="_blank" ng-mouseup="$event.stopPropagation();"><i class="fa fa-external-link"></i></a>\n                                </div>\n                            </span>\n                        </div>\n                        <span class="header-right details">\n                            <div class="status-text">\n                                {{ dashboard.getOrchidState(orchid).generateCameraStatus(orchid) }}\n                            </div>\n                            <md-progress-linear class="fat" md-mode="determinate" value="{{ dashboard.calculateCamerasOnlinePercentage(orchid) }}" ng-class="{ \'md-warn\': orchid.isAvailable !== true }"></md-progress-linear>\n                            <span class="actions-container">\n                                <div class="actions" ng-if="!orchid.processing">\n                                    <span class="fa fa-refresh fa-lg refresh-orchid-button orchid-button" ng-class="{ \'fa-spin\': dashboard.orchidData[orchid.id].refreshing }" ng-mouseup="dashboard.refreshOrchid($event, orchid)">\n                                        <md-tooltip md-autohide md-delay="750" md-direction="top">{{ dashboard.msgs.refreshCameras() }}</md-tooltip>\n                                    </span>\n                                    <span class="fa fa-pencil fa-lg edit-orchid-button orchid-button" ng-mouseup="dashboard.editOrchid($event, orchid)" ng-if="dashboard.showEditButton">\n                                        <md-tooltip md-autohide md-delay="750" md-direction="top">{{ dashboard.msgs.editOrchid({ VALUE: orchid.name }) }}</md-tooltip>\n                                    </span>\n                                    <span class="fa fa-wrench fa-lg recover-orchid-button orchid-button" ng-mouseup="dashboard.recoverRecorder($event, orchid)" ng-if="dashboard.userIsAdminOrRegistrar">\n                                        <md-tooltip md-autohide md-delay="750" md-direction="top">{{ dashboard.msgs.recoverOrchid({ VALUE: orchid.name }) }}</md-tooltip>\n                                    </span>\n                                    <span class="fa-regular fa-trash-can fa-lg delete-orchid-button orchid-button" ng-mouseup="dashboard.deleteOrchid($event, orchid)" ng-if="dashboard.showDeleteButton">\n                                        <md-tooltip md-autohide md-delay="750" md-direction="top">{{ dashboard.msgs.deleteOrchid({ VALUE: orchid.name }) }}</md-tooltip>\n                                    </span>\n                                </div>\n                                <md-progress-circular ng-if="orchid.processing" md-mode="indeterminate" md-diameter="36px"></md-progress-circular>\n                            </span>\n                        </span>\n                    </md-list-item>\n\n                    \x3c!-- Show while fetching the session id --\x3e\n                    <md-list-item class="blowout-container orchid-blowout-container" ng-if="dashboard.orchidData[orchid.id].expanded && dashboard.orchidData[orchid.id].fetchingSessionId">\n                        <md-content class="orchid-admin-in-fusion fetching-session-id-spinner">\n                            <md-progress-circular md-mode="indeterminate" md-diameter="36px"></md-progress-circular>\n                        </md-content>\n                    </md-list-item>\n\n                    \x3c!-- Show if orchid is unavailable --\x3e\n                    <md-list-item class="blowout-container orchid-blowout-container" ng-if="dashboard.orchidData[orchid.id].expanded && !dashboard.orchidData[orchid.id].fetchingSessionId && orchid.isAvailable === false">\n                        <md-content class="orchid-admin-in-fusion">\n                            <ambulance [orchid]="orchid"></ambulance>\n                        </md-content>\n                    </md-list-item>\n\n                    \x3c!-- Show if there is no session id --\x3e\n                    <md-list-item class="blowout-container orchid-blowout-container" ng-if="dashboard.orchidData[orchid.id].expanded && !dashboard.orchidData[orchid.id].fetchingSessionId && !dashboard.hasSessionId(orchid.id) && orchid.isAvailable" ng-mouseup="$event.stopPropagation()">\n                        <md-content class="orchid-admin-in-fusion">\n                            \x3c!-- Error message for no session id --\x3e\n                            <md-card class="padded-card">\n                                <p style="text-align: center; opacity: 0.54">{{ dashboard.sessionError.message }}</p>\n                            </md-card>\n                        </md-content>\n                    </md-list-item>\n\n                    \x3c!-- Sub-Admin Permission Groups panel - Show if there is a session id --\x3e\n                    <md-list-item class="blowout-container orchid-blowout-container orchid-blowout-container--perm-groups" ng-if="dashboard.orchidData[orchid.id].expanded && !dashboard.orchidData[orchid.id].fetchingSessionId && dashboard.hasSessionId(orchid.id) && orchid.isAvailable" ng-mouseup="$event.stopPropagation()">\n                        <md-content class="orchid-admin-in-fusion">\n                            <recorder-perm-groups [recorder-id]="orchid.id" [editable]="false"></recorder-perm-groups>\n                        </md-content>\n                    </md-list-item>\n\n                    \x3c!-- Show if there is a session id --\x3e\n                    <md-list-item class="blowout-container orchid-blowout-container" ng-if="dashboard.orchidData[orchid.id].expanded && !dashboard.orchidData[orchid.id].fetchingSessionId && dashboard.hasSessionId(orchid.id) && orchid.isAvailable" ng-mouseup="$event.stopPropagation()">\n                        <md-content class="orchid-admin-in-fusion">\n                            \x3c!-- ** Unsupported Orchid Card ** --\x3e\n                            <md-content class="md-padding" ng-if="dashboard.getOrchidState(orchid).content === dashboard.DashboardOrchidContentType.UNSUPPORTED">\n                                <md-card class="padded-card">\n                                    <h4>{{ dashboard.msgs.unsupportedOrchid() }}</h4>\n                                    <p>\n                                        {{ dashboard.msgs.unsupportedOrchidDescription({ VALUE:\n                                        dashboard.minOrchidVersion }) }}\n                                    </p>\n                                    <div class="layout-row">\n                                        <li class="table-cell-pad"></li>\n                                        <li class="table-cell-title">{{ dashboard.msgs.currentVersion() }}</li>\n                                        <li class="table-cell-entry warn-bg">{{ orchid.version.version }}</li>\n                                        <li class="table-cell-pad"></li>\n                                    </div>\n                                    <div class="layout-row compatibility-table">\n                                        <li class="table-cell-pad"></li>\n                                        <li class="table-cell-title">{{ dashboard.msgs.minimumVersion() }}</li>\n                                        <li class="table-cell-entry mat-success">{{ dashboard.minOrchidVersion }}</li>\n                                        <li class="table-cell-pad"></li>\n                                    </div>\n                                </md-card>\n                            </md-content>\n                            \x3c!-- Tabs --\x3e\n                            <md-tabs ng-class="[ dashboard.brand.toLowerCase(), dashboard.auditLogsCompatibleOrchid(orchid) ? \'\' : \'disable-audit-logs\' ]" md-border-bottom md-selected="dashboard.orchidData[orchid.id].currentTab" ng-if="dashboard.getOrchidState(orchid).content === dashboard.DashboardOrchidContentType.ORCHID">\n                                <md-tab label="{{ dashboard.msgs.cameras() }}"></md-tab>\n                                <md-tab label="{{ dashboard.msgs.users() }}"></md-tab>\n                                <md-tab label="{{ dashboard.msgs.retentionPolicy() }}"></md-tab>\n                                <md-tab label="{{ dashboard.msgs.systemStatus() }}"></md-tab>\n                                <md-tab label="{{ dashboard.msgs.systemReport() }}"></md-tab>\n                                <md-tab label="{{ dashboard.msgs.auditLogs() }}"></md-tab>\n                                <md-tab>\n                                    <md-tab-label>\n                                        <i ng-if="orchid.discoverableOrchid.licenseSession.state.status === \'degraded\'" class="fa fa-triangle-exclamation"></i>\n                                        {{ dashboard.msgs.activation() }}\n                                    </md-tab-label>\n                                </md-tab>\n                                <md-tab ng-disabled="!dashboard.advancedSettingsCompatibleOrchid(orchid)" label="{{ dashboard.msgs.advancedSettings() }}"></md-tab>\n                                <md-tab label="{{ dashboard.msgs.versionInformation() }}"></md-tab>\n                            </md-tabs>\n                            \x3c!-- Tab Contents --\x3e\n                            <md-content class="dashboard-tab-content" ng-switch="dashboard.orchidData[orchid.id].currentTab" ng-if="dashboard.getOrchidState(orchid).content === dashboard.DashboardOrchidContentType.ORCHID">\n                                <div class="tab-body" ng-cloak ng-switch-when="0">\n                                    <camera-config orchid="orchid"></camera-config>\n                                </div>\n                                <div class="tab-body" ng-cloak ng-switch-when="1">\n                                    <user-manager-list orchid="orchid"></user-manager-list>\n                                    <orchid-roles></orchid-roles>\n                                </div>\n                                <div class="tab-body" ng-cloak ng-switch-when="2">\n                                    <retention-policy orchid="orchid"></retention-policy>\n                                </div>\n                                <div class="tab-body" ng-cloak ng-switch-when="3">\n                                    <system-status [orchid]="orchid"></system-status>\n                                </div>\n                                <div class="tab-body" ng-switch-when="4">\n                                    <system-report orchid="orchid"></system-report>\n                                </div>\n                                <div class="tab-body" ng-switch-when="5">\n                                    <audit-logs [orchid]="orchid"></audit-logs>\n                                </div>\n                                <div class="tab-body" ng-cloak ng-switch-when="6">\n                                    <activation [orchid]="orchid"></activation>\n                                </div>\n                                <div class="tab-body" ng-cloak ng-switch-when="7">\n                                    <property-editor route="dashboard.route" orchid="orchid"></property-editor>\n                                </div>\n                                <div class="tab-body" ng-cloak ng-switch-when="8">\n                                    <version [orchid]="orchid"></version>\n                                </div>\n                            </md-content>\n                        </md-content>\n                    </md-list-item>\n                </md-content>\n            </md-card>\n            <div ng-show="filteredOrchids.length > 0 && dashboard.pagingPages(filteredOrchids.length) === 0" style="text-align: center; padding-top: 40px">\n                {{ dashboard.msgs.noServersFound() }}\n            </div>\n            <div ng-if="dashboard.orchidsLoading" style="text-align: center; padding-top: 40px; display: flex; justify-content: center">\n                <md-progress-circular md-diameter="20" md-mode="indeterminate"></md-progress-circular>\n                <div style="padding-left: 5px">{{ dashboard.msgs.loadingServers() }}</div>\n            </div>\n        </md-content>\n        <mat-paginator ng-if="filteredOrchids.length > dashboard.paging.paginatorLimit && !dashboard.orchidsLoading" show-first-last-buttons [length]="filteredOrchids.length" [page-index]="dashboard.paging.current" [page-size]="dashboard.paging.perPage" [page-size-options]="dashboard.paging.pageSizeOptions" (page)="dashboard.onPageChange($event)">\n        </mat-paginator>\n    </md-content>\n</section>\n'
        }
        ,
        2610: e => {
            e.exports = '<div ng-if="navigation.display === \'left\'" class="left-nav" ng-class="{ \'nav-open\': navigation.navOpen }">\n    <div id="admin-nav" class="admin-nav">\n        <md-content class="admin-nav-content">\n            \x3c!-- Features --\x3e\n            <div class="nav-button" ng-repeat="menuItem in navigation.features" ng-if="menuItem.show">\n                \x3c!-- display a button for all menu items without sub menu items --\x3e\n                <md-button ng-if="menuItem.subMenuItems.length === 0" aria-label="{{ menuItem.name }}" ng-click="navigation.router.navigateByUrl(menuItem.state)" ng-class="{ \'current\': navigation.state === menuItem.state }">\n                    <md-icon ng-if="menuItem.faIcon" class="s20" ng-class="menuItem.faIcon"></md-icon>\n                    <md-icon ng-if="menuItem.svgSrc" md-svg-src="{{ menuItem.svgSrc }}" class="s20"></md-icon>\n                    <div class="menu-item-label">{{ menuItem.name }}</div>\n                </md-button>\n\n                \x3c!-- display a menu if the menu item is notifications --\x3e\n                <md-menu ng-if="menuItem.subMenuItems.length > 0" class="nested-menu" md-position-mode="target-right target" md-offset="192px 0">\n                    <md-button ng-click="navigation.open($mdMenu, $event, false)" aria-label="{{ menuItem.name }}" class="left-menu-item-with-chevron">\n                        <div class="menu-item-full-label">\n                            <md-icon class="s20" ng-class="menuItem.faIcon"></md-icon>\n                            <div class="menu-item-label">{{ menuItem.name }}</div>\n                        </div>\n                        <md-icon class="fa s15" md-font-icon="fa-chevron-right" style="text-align: end"></md-icon>\n                    </md-button>\n                    <md-menu-content class="navigation-sub-menu left-sub-menu">\n                        <md-menu-item ng-repeat="subMenuItem in menuItem.subMenuItems" ng-class="{ \'current\': navigation.state === subMenuItem.state }" ng-if="subMenuItem.show">\n                            <md-button ng-click="navigation.router.navigateByUrl(subMenuItem.state)">\n                                <md-icon class="s20" ng-class="subMenuItem.faIcon"></md-icon>\n                                <div class="menu-item-label">{{ subMenuItem.name }}</div>\n                            </md-button>\n                        </md-menu-item>\n                    </md-menu-content>\n                </md-menu>\n            </div>\n\n            <div class="divider" ng-if="navigation.menuItemsVisible()"></div>\n            \x3c!-- Menu Items --\x3e\n            <div class="nav-button" ng-repeat="menuItem in navigation.menuItems" ng-if="menuItem.show">\n                \x3c!-- display a button for all menu items without sub menu items --\x3e\n                <md-button ng-if="menuItem.subMenuItems.length === 0" aria-label="{{ menuItem.name }}" ng-click="navigation.router.navigateByUrl(menuItem.state)" ng-class="{ \'current\': navigation.state === menuItem.state || (navigation.state === \'/orchids/tags\' && menuItem.state === \'/orchids\') }">\n                    <md-icon ng-if="menuItem.faIcon" class="s20" ng-class="menuItem.faIcon"></md-icon>\n                    <md-icon ng-if="menuItem.svgSrc" md-svg-src="{{ menuItem.svgSrc }}" class="s20"></md-icon>\n                    <div class="menu-item-label">{{ menuItem.name }}</div>\n                </md-button>\n\n                \x3c!-- display a menu if the menu item is notifications --\x3e\n                <md-menu ng-if="menuItem.subMenuItems.length > 0" class="nested-menu" md-position-mode="target-right target" md-offset="192px 0">\n                    <md-button ng-click="navigation.open($mdMenu, $event, false)" aria-label="{{ menuItem.name }}" class="left-menu-item-with-chevron">\n                        <div class="menu-item-full-label">\n                            <md-icon class="s20" ng-class="menuItem.faIcon"></md-icon>\n                            <div class="menu-item-label">{{ menuItem.name }}</div>\n                        </div>\n                        <md-icon class="fa s15" md-font-icon="fa-chevron-right" style="text-align: end"></md-icon>\n                    </md-button>\n                    <md-menu-content class="navigation-sub-menu">\n                        <md-menu-item ng-repeat="subMenuItem in menuItem.subMenuItems" ng-class="{ \'current\': navigation.state === subMenuItem.state }" ng-if="subMenuItem.show">\n                            <md-button ng-click="navigation.router.navigateByUrl(subMenuItem.state)">\n                                <md-icon class="s20" ng-class="subMenuItem.faIcon"></md-icon>\n                                <div class="menu-item-label">{{ subMenuItem.name }}</div>\n                            </md-button>\n                        </md-menu-item>\n                    </md-menu-content>\n                </md-menu>\n            </div>\n\n            <div class="divider" ng-if="navigation.plugins.length > 0"></div>\n            \x3c!-- Plugins --\x3e\n            <div ng-repeat="feature in navigation.plugins" class="nav-button custom-nav-button">\n                <md-button aria-label="{{ navigation.msgs.customFeature() }}" ng-click="navigation.router.navigateByUrl(feature.state)" ng-class="{ \'current\': navigation.state === feature.state }" class="left-nav-plugin-button">\n                    <md-icon ng-if="!feature.appIcon || (feature.appIcon.indexOf(\'data\') !== 0)" md-font-icon="fa-puzzle-piece" class="fa s20"></md-icon>\n                    <img ng-if="feature.appIcon && (feature.appIcon.indexOf(\'data\') === 0)" ng-src="{{ feature.appIcon }}" class="plugin-icon pr-9 s20">\n                    <div class="menu-item-label">{{feature.name}}</div>\n                </md-button>\n            </div>\n\n            <div class="divider" ng-if="navigation.accountManagementSettings.length > 0 && !navigation.noEventsAccess"></div>\n            \x3c!-- Account Management Settings --\x3e\n            <div class="nav-button" ng-repeat="menuItem in navigation.accountManagementSettings" ng-if="menuItem.show">\n                <md-button ng-if="menuItem.subMenuItems.length === 0" aria-label="{{ menuItem.name }}" ng-click="navigation.router.navigateByUrl(menuItem.state)" ng-class="{ \'current\': navigation.state === menuItem.state }">\n                    <md-icon ng-if="menuItem.faIcon" class="s20" ng-class="menuItem.faIcon"></md-icon>\n                    <md-icon ng-if="menuItem.svgSrc" md-svg-src="{{ menuItem.svgSrc }}" class="s20"></md-icon>\n                    <div class="menu-item-label">{{ menuItem.name }}</div>\n                </md-button>\n            </div>\n        </md-content>\n    </div>\n    <expand-button class="admin-nav-toggle" ng-click="navigation.toggleNav()" type="triangle" direction="right" [expanded]="navigation.navOpen"></expand-button>\n</div>\n\n<md-menu ng-if="navigation.display === \'menu\'" md-position-mode="target-right target" md-offset="1 40px">\n    <md-button class="md-icon-button menu-button" aria-label="{{ navigation.msgs.menu() }}" ng-click="navigation.open($mdMenu, $event, false)">\n        <md-tooltip md-autohide md-direction="left" md-delay="750">{{ navigation.msgs.systemMenu() }} </md-tooltip>\n        <i class="fa fa-bars" style="font-size: 1.5em"></i>\n    </md-button>\n    <md-menu-content width="4" class="navigation-menu right-side">\n        \x3c!-- Features --\x3e\n        <md-menu-item ng-repeat="menuItem in navigation.features" ng-if="menuItem.show" ng-class="{ \'current\': navigation.state === menuItem.state }">\n            \x3c!-- display a button for all menu items other than notifications --\x3e\n            <md-button ng-if="menuItem.subMenuItems.length === 0" aria-label="{{ menuItem.name }}" ng-click="navigation.router.navigateByUrl(menuItem.state)">\n                <md-icon ng-if="menuItem.faIcon" class="s20" ng-class="menuItem.faIcon"></md-icon>\n                <md-icon ng-if="menuItem.svgSrc" md-svg-src="{{ menuItem.svgSrc }}" class="s20"></md-icon>\n                <div class="menu-item-label">{{ menuItem.name }}</div>\n            </md-button>\n\n            \x3c!-- display a menu if the menu item is notifications --\x3e\n            <md-menu ng-if="menuItem.subMenuItems.length > 0" class="nested-menu">\n                <md-button ng-click="navigation.open($mdMenu, $event, true)" aria-label="{{ menuItem.name }}">\n                    <md-icon class="s15" md-font-icon="fa fa-chevron-left"></md-icon>\n                    <div class="menu-item-label">{{ menuItem.name }}</div>\n                </md-button>\n                <md-menu-content width="3" class="navigation-sub-menu">\n                    <md-menu-item ng-repeat="subMenuItem in menuItem.subMenuItems" ng-class="{ \'current\': navigation.state === subMenuItem.state }" ng-if="subMenuItem.show">\n                        <md-button ng-click="navigation.router.navigateByUrl(subMenuItem.state)">\n                            <md-icon class="s20" ng-class="subMenuItem.faIcon"></md-icon>\n                            <div class="menu-item-label">{{ subMenuItem.name }}</div>\n                        </md-button>\n                    </md-menu-item>\n                </md-menu-content>\n            </md-menu>\n        </md-menu-item>\n\n        <md-menu-divider ng-if="navigation.menuItemsVisible()"></md-menu-divider>\n        \x3c!-- Menu Items --\x3e\n        <md-menu-item ng-repeat="menuItem in navigation.menuItems" ng-if="menuItem.show" ng-class="{ \'current\': navigation.state === menuItem.state || (navigation.state === \'/orchids/tags\' && menuItem.state === \'/orchids\') }">\n            \x3c!-- display a button for all menu items other than notifications --\x3e\n            <md-button ng-if="menuItem.subMenuItems.length === 0" aria-label="{{ menuItem.name }}" ng-click="navigation.router.navigateByUrl(menuItem.state)">\n                <md-icon ng-if="menuItem.faIcon" class="s20" ng-class="menuItem.faIcon"></md-icon>\n                <md-icon ng-if="menuItem.svgSrc" md-svg-src="{{ menuItem.svgSrc }}" class="s20"></md-icon>\n                <div class="menu-item-label">{{ menuItem.name }}</div>\n            </md-button>\n\n            \x3c!-- display a menu if the menu item is notifications --\x3e\n            <md-menu ng-if="menuItem.subMenuItems.length > 0" class="nested-menu">\n                <md-button ng-click="navigation.open($mdMenu, $event, true)" aria-label="{{ menuItem.name }}">\n                    <md-icon class="s15" md-font-icon="fa fa-chevron-left"></md-icon>\n                    <div class="menu-item-label">{{ menuItem.name }}</div>\n                </md-button>\n                <md-menu-content width="3" class="navigation-sub-menu">\n                    <md-menu-item ng-repeat="subMenuItem in menuItem.subMenuItems" ng-class="{ \'current\': navigation.state === subMenuItem.state }" ng-if="subMenuItem.show">\n                        <md-button ng-click="navigation.router.navigateByUrl(subMenuItem.state)">\n                            <md-icon class="s20" ng-class="subMenuItem.faIcon"></md-icon>\n                            <div class="menu-item-label">{{ subMenuItem.name }}</div>\n                        </md-button>\n                    </md-menu-item>\n                </md-menu-content>\n            </md-menu>\n        </md-menu-item>\n\n        <md-menu-divider ng-if="navigation.plugins.length > 0"></md-menu-divider>\n        \x3c!-- Plugins --\x3e\n        <md-menu-item ng-if="navigation.plugins.length > 0">\n            <md-menu class="nested-menu">\n                <md-button ng-click="navigation.open($mdMenu, $event, true)">\n                    <md-icon md-font-icon="fa-chevron-left" class="fa s18"></md-icon>\n                    <div class="menu-item-label">{{ navigation.msgs.apps() }}</div>\n                </md-button>\n                <md-menu-content width="3" class="navigation-sub-menu">\n                    <md-menu-item ng-repeat="feature in navigation.plugins" ng-class="{ \'current\': navigation.state === feature.state }">\n                        <md-button aria-label="{{ navigation.msgs.customFeature() }}" ng-click="navigation.router.navigateByUrl(feature.state)" class="plugin-button">\n                            <md-icon ng-if="!feature.appIcon || (feature.appIcon.indexOf(\'data\') !== 0)" md-font-icon="fa-puzzle-piece" class="fa s20"></md-icon>\n                            <img ng-src="{{ feature.appIcon }}" class="plugin-icon s20" ng-if="feature.appIcon && (feature.appIcon.indexOf(\'data\') === 0)">\n                            <span class="menu-item-label">{{ feature.name }}</span>\n                        </md-button>\n                    </md-menu-item>\n                </md-menu-content>\n            </md-menu>\n        </md-menu-item>\n\n        <md-menu-divider ng-if="navigation.accountManagementSettings.length > 0"></md-menu-divider>\n        \x3c!-- Account Management Settings --\x3e\n        <md-menu-item ng-repeat="menuItem in navigation.accountManagementSettings" ng-if="menuItem.show" ng-class="{ \'current\': navigation.state === menuItem.state }">\n            <md-button ng-if="menuItem.subMenuItems.length === 0" aria-label="{{ menuItem.name }}" ng-click="navigation.router.navigateByUrl(menuItem.state)">\n                <md-icon ng-if="menuItem.faIcon" class="s20" ng-class="menuItem.faIcon"></md-icon>\n                <md-icon ng-if="menuItem.svgSrc" md-svg-src="{{ menuItem.svgSrc }}" class="s20"></md-icon>\n                <div class="menu-item-label">{{ menuItem.name }}</div>\n            </md-button>\n        </md-menu-item>\n        <md-menu-item ng-if="navigation.isPWA">\n            <md-button aria-label="{{ navigation.msgs.leave() }}" ng-click="navigation.leave()" class="sign-out-button">\n                <md-icon md-font-icon="fa-sign-out sign-out-icon" class="fa s20 sign-out"></md-icon>\n                <div class="menu-item-label">{{ navigation.msgs.leave() }}</div>\n            </md-button>\n        </md-menu-item>\n        <md-menu-item>\n            <md-button aria-label="{{ navigation.msgs.signOut() }}" ng-click="navigation.signOut()" class="sign-out-button">\n                <md-icon md-font-icon="fa-power-off sign-out-icon" class="fa s20 sign-out"></md-icon>\n                <div class="menu-item-label">{{ navigation.msgs.signOut() }}</div>\n            </md-button>\n        </md-menu-item>\n    </md-menu-content>\n</md-menu>\n'
        }
        ,
        23169: e => {
            e.exports = '<div ng-class="{ \'orchids-and-cameras\': deviceForm.device === \'camera_state\', \'hide-me\': deviceForm.ruleDevices.all }" class="chips-container">\n    <h1 class="chips-label">\n        {{ deviceForm.msgs.verbTheseCamerasOrServers({VERB: deviceForm.verb, DEVICE: deviceForm.device}) }}\n    </h1>\n    <autocomplete-orchids-and-cameras-chips ng-if="deviceForm.device === \'camera_state\'" orchids="deviceForm.ruleDevices.orchids" cameras="deviceForm.ruleDevices.cameras" devices-updated-callback="deviceForm.buildOrchidDisplay">\n    </autocomplete-orchids-and-cameras-chips>\n\n    <autocomplete-orchid-chips ng-if="deviceForm.device !== \'camera_state\'" orchids="deviceForm.ruleDevices.orchids">\n    </autocomplete-orchid-chips>\n</div>\n'
        }
        ,
        19907: e => {
            e.exports = '<md-dialog class="notifications-dialog">\n    <md-toolbar>\n        <div class="md-toolbar-tools">\n            <h2 class="dialog-title">{{::notificationsDialog.title}}</h2>\n            <span flex></span>\n            <md-button class="md-icon-button" ng-disabled="notificationsDialog.processing" ng-click="notificationsDialog.cancel()">\n                <i class="fa fa-times fa-2x"></i>\n            </md-button>\n        </div>\n    </md-toolbar>\n    <md-content class="notification-dialog-content" id="dialog-scroll-region">\n        <div style="display: flex; padding: 10px" layout="row" layout-wrap>\n            <form name="notificationForm" autocomplete="off" style="width: 100%">\n                <div class="section-container" flex="100">\n                    <md-card style="padding: 20px" class="layout-row layout-wrap">\n                        <md-input-container class="flex-100 flex-gt-sm-40">\n                            <label>{{ ::notificationsDialog.msgs.nameSubject() }}</label>\n                            <input ng-model="notificationsDialog.shadowNotification.name" name="notificationName" required md-autofocus>\n                            <div ng-messages="notificationForm.notificationName.$error" role="alert" multiple="multiple">\n                                <div ng-message-exp="[\'required\']">\n                                    {{ ::notificationsDialog.msgs.nameIsRequired() }}\n                                </div>\n                            </div>\n                        </md-input-container>\n\n                        <md-input-container class="flex-100 flex-gt-sm-60">\n                            <label>{{ ::notificationsDialog.msgs.description() }}</label>\n                            <input ng-model="notificationsDialog.shadowNotification.description">\n                        </md-input-container>\n                    </md-card>\n                </div>\n                <div class="notification-subcard-container" flex="100" ng-cloak>\n                    <h3 class="section-header">{{ ::notificationsDialog.msgs.triggers() }}</h3>\n                    <div ng-if="notificationsDialog.shadowNotification.conditions.length === 0" class="no-triggers warn-text">\n                        <i class="fa fa-times"></i> {{ ::notificationsDialog.msgs.noTriggersHaveBeenConfigured() }}\n                    </div>\n                    <md-card ng-repeat="rule in notificationsDialog.shadowNotification.conditions" class="notification-subcard">\n                        <notification-trigger rule="rule" remove-trigger="notificationsDialog.removeTrigger" index="$index" trigger-sanity-warning="notificationsDialog.triggerSanityWarning"></notification-trigger>\n                    </md-card>\n\n                    <div class="notification-subcard-actions">\n                        <md-button style="margin-left: auto; margin-right: auto" class="md-raised md-primary action-button add-button" aria-label="{{ ::notificationDialog.msgs.addTrigger() }}" ng-click="notificationsDialog.newTrigger(\'camera_state\')">\n                            <span hide-xs>\n                                {{ notificationsDialog.shadowNotification.conditions.length > 0 ?\n                                notificationsDialog.msgs.addAnotherTrigger() : notificationsDialog.msgs.addTrigger()\n                                }}</span>\n                            <span hide-gt-xs>{{ notificationsDialog.msgs.addTrigger() }}</span>\n                        </md-button>\n                    </div>\n                </div>\n\n                <div class="notification-subcard-container" flex="100" ng-cloak>\n                    <h3 class="section-header">{{ ::notificationsDialog.msgs.actions() }}</h3>\n\n                    <div ng-if="notificationsDialog.shadowNotification.actions.length === 0" class="no-triggers warn-text">\n                        <i class="fa fa-times"></i> {{ ::notificationsDialog.msgs.noActionsHaveBeenConfigured() }}\n                    </div>\n\n                    <div flex="100" ng-repeat="action in notificationsDialog.shadowNotification.actions">\n                        <md-card class="notification-subcard">\n                            <notification-action action="action" digest-exists="notificationsDialog.hasDigest" update-digest="notificationsDialog.checkDigest" remove-action="notificationsDialog.removeAction" users="notificationsDialog.users" groups="notificationsDialog.groups" smtp-servers="notificationsDialog.smtpServers" index="$index"></notification-action>\n                        </md-card>\n                    </div>\n\n                    <div class="notification-subcard-actions">\n                        <md-button style="margin-left: auto; margin-right: auto" class="md-raised md-primary action-button add-button" aria-label="{{ ::notificationsDialog.msgs.addAction() }}" ng-click="notificationsDialog.newAction()">\n                            <span hide-xs>\n                                {{ notificationsDialog.shadowNotification.actions.length > 0 ?\n                                notificationsDialog.msgs.addAnotherAction() : notificationsDialog.msgs.addAction()\n                                }}</span>\n                            <span hide-gt-xs>{{ ::notificationsDialog.msgs.addAction() }}</span>\n                        </md-button>\n                    </div>\n                </div>\n            </form>\n        </div>\n    </md-content>\n\n    <dialog-errors target-object="notificationsDialog"></dialog-errors>\n    <md-dialog-actions layout="row">\n        <md-checkbox style="align-self: flex-end" ng-model="notificationsDialog.shadowNotification.isEnabled" aria-label="{{ ::notificationsDialog.msgs.enabled() }}">\n            {{ ::notificationsDialog.msgs.enabled() }}\n        </md-checkbox>\n        <span flex></span>\n        <div style="display: flex" class="action-buttons">\n            <md-button class="cancel-button" ng-disabled="notificationsDialog.processing" ng-click="notificationsDialog.cancel()">{{ ::notificationsDialog.msgs.cancel() }}</md-button>\n\n            <md-button class="md-raised md-primary" type="submit" ng-click="notificationsDialog.saveNotification()" ng-disabled="notificationForm.$invalid || notificationsDialog.notification.processing">\n                <span ng-if="!notificationsDialog.processing">\n                    <span hide-xs>{{ ::notificationsDialog.msgs.saveSystemAlert() }}</span>\n                    <span hide-gt-xs>{{ ::notificationsDialog.msgs.save() }}</span>\n                </span>\n                <md-progress-circular md-mode="indeterminate" md-diameter="35px" ng-if="notificationsDialog.processing" style="margin: auto"></md-progress-circular>\n            </md-button>\n        </div>\n    </md-dialog-actions>\n</md-dialog>\n'
        }
        ,
        11210: e => {
            e.exports = '<md-dialog class="smtp-dialog custom-smtp-dialog-width">\n    <md-toolbar class="md-toolbar-tools layout-row layout-align-space-between-center">\n        <h2 class="dialog-title">\n            {{:: smtpDialog.smtpServer.new ? smtpDialog.msgs.newSmtpServer() : smtpDialog.msgs.editNamedThing({ VALUE:\n            smtpDialog.smtpServer.name }) }}\n        </h2>\n        <md-button class="md-icon-button" ng-disabled="smtpDialog.processing" ng-click="smtpDialog.cancel()">\n            <i class="fa fa-times fa-2x"></i>\n        </md-button>\n    </md-toolbar>\n    <md-content class="smtp-dialog-content" id="dialog-scroll-region">\n        <div class="md-padding">\n            <form name="smtpSettingsForm" autocomplete="off" class="layout-row layout-wrap">\n                <md-input-container class="md-block flex-100">\n                    <label> {{ ::smtpDialog.msgs.smtpServerName() }} </label>\n                    <input ng-model="smtpDialog.smtpServer.name" name="smtpName" required md-autofocus>\n                    <div ng-messages="smtpSettingsForm.smtpName.$error" role="alert" multiple="multiple">\n                        <div ng-message-exp="[\'required\']">{{ ::smtpDialog.msgs.smtpServerNameIsRequired() }}</div>\n                    </div>\n                </md-input-container>\n\n                <md-input-container class="md-block flex-gt-xs-70 flex-xs-100">\n                    <label> {{ ::smtpDialog.msgs.smtpServerAddress() }} </label>\n                    <input ng-model="smtpDialog.smtpServer.server" placeholder="smtp-server.org:587" name="smtpServer" ng-pattern="/^[^ ]+$/" required>\n                    <div ng-messages="smtpSettingsForm.smtpServer.$error" role="alert" multiple="multiple">\n                        <div ng-message-exp="[\'required\', \'pattern\']">\n                            {{ ::smtpDialog.msgs.aValidSmtpAddressIsRequired() }}\n                        </div>\n                    </div>\n                </md-input-container>\n\n                <md-input-container class="md-block flex-gt-xs-30 flex-xs-100">\n                    <md-checkbox ng-model="smtpDialog.smtpServer.enableTls" aria-label="{{ ::smtpDialog.msgs.enableTls() }}">\n                        {{ ::smtpDialog.msgs.enableTls() }}\n                    </md-checkbox>\n                </md-input-container>\n\n                <md-input-container class="md-block flex-gt-xs-50 flex-xs-100">\n                    <label> {{ ::smtpDialog.msgs.smtpUsername() }} </label>\n                    <input ng-model="smtpDialog.smtpServer.username" name="smtpUsername">\n                </md-input-container>\n\n                <md-input-container class="md-block flex-gt-xs-50 flex-xs-100">\n                    <password-form-field-lite field-name="smtpPassword" model-name="smtpDialog.smtpServer.password" class="form-control" placeholder="{{ ::smtpDialog.msgs.smtpPassword() }}"></password-form-field-lite>\n                </md-input-container>\n            </form>\n\n            <md-button class="advanced-toggle" ng-click="smtpDialog.showAdvanced = !smtpDialog.showAdvanced">\n                {{ ::smtpDialog.msgs.customSettingsAdvanced() }}\n                <i class="fa" ng-class="{ \'fa-chevron-right\': !smtpDialog.showAdvanced, \'fa-chevron-down\': smtpDialog.showAdvanced }"></i>\n            </md-button>\n            <div class="advanced-settings" ng-class="{ \'show-me\': smtpDialog.showAdvanced }">\n                <div ng-repeat="(key, value) in smtpDialog.advancedSettings">\n                    <div style="display: flex">\n                        <div style="word-break: break-all; margin: auto 0">\n                            <span style="font-weight: bold">{{ key }}</span> : {{ value }}\n                        </div>\n                        <md-button class="delete-custom-setting md-icon-button" ng-click="smtpDialog.removeAdvancedSetting(key)">\n                            <i class="fa-regular fa-trash-can"></i>\n                        </md-button>\n                    </div>\n                </div>\n                <form>\n                    <div class="layout-xs-column layout-gt-xs-row">\n                        <div>\n                            <md-input-container>\n                                <label> {{ ::smtpDialog.msgs.key() }} </label>\n                                <input ng-model="smtpDialog.newSettingKey" id="key-field">\n                            </md-input-container>\n                        </div>\n                        <div>\n                            <md-input-container>\n                                <label> {{ ::smtpDialog.msgs.value() }} </label>\n                                <input ng-model="smtpDialog.newSettingValue">\n                            </md-input-container>\n                            <md-button class="md-icon-button" ng-click="smtpDialog.addAdvancedSetting()" type="submit">\n                                <i class="fa fa-plus"></i>\n                            </md-button>\n                        </div>\n                    </div>\n                </form>\n            </div>\n        </div>\n    </md-content>\n\n    <dialog-errors target-object="smtpDialog"></dialog-errors>\n    <md-dialog-actions class="layout-row">\n        <md-button class="md-raised md-primary" ng-class="{\'send-button\': !smtpDialog.processingTest}" ng-click="smtpDialog.testSmtpSettings($event)" ng-disabled="smtpSettingsForm.$invalid \n        || smtpDialog.processingTest \n        || smtpDialog.smtpServer.password === undefined\n        || smtpDialog.smtpServer.password === \'\'\n        || smtpDialog.smtpServer.username === undefined\n        || smtpDialog.smtpServer.username === \'\'">\n            <span ng-if="!smtpDialog.processingTest" class="hide-xs"> {{ ::smtpDialog.msgs.sendTestEmail() }} </span>\n            <span ng-if="!smtpDialog.processingTest" class="hide-gt-xs"> {{ ::smtpDialog.msgs.test() }} </span>\n            <md-progress-circular ng-if="smtpDialog.processingTest" md-mode="indeterminate" md-diameter="35px" style="margin: auto"></md-progress-circular>\n        </md-button>\n        <i class="fa fa-circle-question label-hint tooltip-icon">\n            <md-tooltip md-autohide md-direction="top">{{ ::smtpDialog.msgs.testRequiresUsernameAndPassword() }}</md-tooltip>\n        </i>\n        <span flex></span>\n        <md-button ng-disabled="smtpDialog.processing" ng-click="smtpDialog.cancel()">{{ ::smtpDialog.msgs.cancel() }}</md-button>\n        <md-button class="md-raised md-primary" type="submit" ng-click="smtpDialog.saveSmtpServer()" ng-disabled="smtpSettingsForm.$invalid || smtpDialog.processing || smtpDialog.processingTest">\n            <span ng-if="!smtpDialog.processing">\n                <span class="hide-xs"> {{ ::smtpDialog.msgs.saveSmtpSettings() }} </span>\n                <span class="hide-gt-xs"> {{ ::smtpDialog.msgs.save() }} </span>\n            </span>\n            <md-progress-circular md-mode="indeterminate" md-diameter="35px" ng-if="smtpDialog.processing" style="margin: auto"></md-progress-circular>\n        </md-button>\n    </md-dialog-actions>\n</md-dialog>\n'
        }
        ,
        20106: e => {
            e.exports = '<form name="notificationActionForm">\n    <div class="action-bubble mat-success">\n        <i class="bubble-icon fa" ng-class="{\n            \'fa-envelope\': notificationAction.action.type === \'email\',\n            \'fa-book\': notificationAction.action.type === \'email_digest\',\n        }"></i>\n    </div>\n    <div class="action-body" ng-class="{ \'expanded-form\': notificationAction.expanded, \'closed-form\': !notificationAction.expanded }">\n        <div class="action-view" style="padding-left: 15px">\n            <div style="margin-bottom: 10px; font-size: 15px" ng-if="notificationAction.action.type === \'email\'">\n                <h4>{{ ::notificationAction.msgs.immediateEmail() }}</h4>\n                {{\n                notificationAction.msgs.emailsWillBeSentToAppNameUsersPermissionGroupMembersAndAnyAdditionalEmailAddressesProvided()\n                }}\n                <br>\n                <p ng-if="notificationAction.action.configuration.oneEmailPerCondition === true">\n                    {{ ::notificationAction.msgs.emailTriggersSeparately() }}\n                </p>\n                <p ng-if="notificationAction.action.configuration.oneEmailPerCondition === false">\n                    {{ ::notificationAction.msgs.consolidateEmailsMessage() }}\n                </p>\n            </div>\n\n            <div style="margin-bottom: 10px; font-size: 15px" ng-if="notificationAction.action.type === \'email_digest\'">\n                <h4>{{ ::notificationAction.msgs.dailyEmailDigest() }}</h4>\n                {{\n                notificationAction.msgs.aDailyEmailContainingADigestOfAllTriggeredEventsWillBeSentAtDateTimeToAppNameUsersPermissionGroupMembersAndAnyAdditionalEmailAddressesProvided({DATE:\n                notificationAction.formatDate(notificationAction.digestAt()), TIME: notificationAction.localTimezone })\n                }}\n            </div>\n\n            <div class="scope">{{ ::notificationAction.msgs.recipients() }}</div>\n            <div class="indent-text">\n                <div>\n                    <div class="summary-text user-list" ng-if="notificationAction.action.users.length > 0">\n                        <span style="font-weight: bold">{{ ::notificationAction.msgs.users() }}</span>\n                        <span ng-repeat="user in notificationAction.action.users" class="user-item">{{ user.username }}{{$last ? \'\' : \', \'}}</span>\n                    </div>\n                    <div ng-if="notificationAction.usersWithoutEmails.length > 0" role="alert">\n                        <div class="warn-text">\n                            {{ ::notificationAction.msgs.usersWithoutEmailAddresses()}} {{\n                            notificationAction.usersWithoutEmails.join(\', \') }}\n                        </div>\n                    </div>\n                    <div class="summary-text group-list" ng-if="notificationAction.action.groups.length > 0">\n                        <span style="font-weight: bold">{{ ::notificationAction.msgs.groups() }}</span>\n                        <span ng-repeat="group in notificationAction.action.groups" class="group-item">{{ group.name }}{{$last ? \'\' : \', \'}}</span>\n                        <a class="link-text" ng-if="!notificationAction.showUsers" ng-click="notificationAction.showUsers = true">{{ ::notificationAction.msgs.showUsers() }}</a>\n                    </div>\n                    <div style="padding-left: 20px" class="summary-text groupies" ng-class="{ \'show-me\': notificationAction.showUsers }">\n                        <strong>{{ ::notificationAction.msgs.includedMembers() }}</strong>\n                        {{ notificationAction.groupies }}\n                        <a class="link-text" ng-click="notificationAction.showUsers = false">{{ ::notificationAction.msgs.hideUsers() }}</a>\n                    </div>\n                    <div ng-if="notificationAction.groupsWithoutEmails.length > 0" role="alert">\n                        <div class="warn-text">\n                            {{ ::notificationAction.msgs.groupsWithoutEmailAddresses() }} {{\n                            notificationAction.groupsWithoutEmails.join(\', \') }}\n                        </div>\n                    </div>\n                </div>\n                <div class="summary-text email-list" ng-if="notificationAction.action.configuration.recipients.length > 0">\n                    <span style="font-weight: bold">{{ ::notificationAction.msgs.emailsColon() }}</span>\n                    {{ notificationAction.action.configuration.recipients.join(\', \') }}\n                </div>\n                <div class="warn-text recipients-warning" ng-if="notificationAction.action.configuration.recipients.length === 0 && notificationAction.action.users.length === 0 && notificationAction.action.groups.length === 0">\n                    <i class="fa fa-times"></i>\n                    {{ ::notificationAction.msgs.noRecipientsHaveBeenSpecifiedNoEmailsWillBeSentForThisAction() }}\n                </div>\n            </div>\n\n            <div ng-if="notificationAction.action.smtpServerId === \'\'" class="warn-text smtp-warning" style="padding-top: 15px">\n                <i class="fa fa-times"></i>{{\n                ::notificationAction.msgs.noSmtpServerHasBeenSpecifiedNoEmailsWillBeSentForThisAction() }}\n            </div>\n\n            <div style="display: flex" ng-if="!notificationAction.static">\n                <span flex></span>\n                <md-button ng-click="notificationAction.expanded = true" class="md-icon-button show-form-button">\n                    <i class="fa fa-lg fa-pencil"></i>\n                </md-button>\n            </div>\n        </div>\n        <div class="action-form" ng-if="!notificationAction.static">\n            <div style="display: flex; flex-wrap: wrap">\n                <md-input-container style="padding-bottom: 6px" flex-gt-sm="40" flex-sm="100" flex-xs="100">\n                    <label>{{ ::notificationAction.msgs.triggerAction() }}</label>\n                    <md-select ng-model="notificationAction.action.type">\n                        <md-option ng-value="\'email\'">{{ ::notificationAction.msgs.immediateEmail() }}</md-option>\n                        <md-option ng-value="\'email_digest\'" ng-if="notificationAction.action.type === \'email_digest\' || !notificationAction.digestExists">{{ ::notificationAction.msgs.dailyEmailDigest() }}</md-option>\n                    </md-select>\n                </md-input-container>\n\n                <div class="digest-at-container" ng-if="notificationAction.action.type===\'email_digest\'" flex-gt-sm="60" flex-sm="100" flex-xs="100" style="margin-top: 11px; margin-bottom: 11px">\n                    <div class="send-at-label">\n                        {{ notificationAction.msgs.sendDigestAt({ VALUE: notificationAction.localTimezone }) }}\n                    </div>\n                    <div class="uib-timepicker" uib-timepicker show-spinners="false" show-meridian="false" ng-model="notificationAction.digestAt" ng-model-options="{ getterSetter: true }"></div>\n                </div>\n                <div ng-if="notificationAction.action.type !==\'email_digest\'" flex-gt-sm="60" flex-sm="100" flex-xs="100">\n                    <md-switch ng-model="notificationAction.action.configuration.oneEmailPerCondition" ng-true-value="false" ng-false-value="true">\n                        <md-tooltip> {{ ::notificationAction.msgs.consolidateTriggersToOneEmail() }} </md-tooltip>\n                        {{ ::notificationAction.msgs.consolidateTriggersToOneEmail() }}\n                    </md-switch>\n                </div>\n            </div>\n\n            <div class="form-description" style="padding-bottom: 17px; font-size: 16px" ng-if="notificationAction.action.type === \'email\'">\n                {{ notificationAction.msgs.emailsWillBeSentToValueEmailAddressesProvided({ VALUE:\n                notificationAction.msgs.appNameUsersPermissionGroupMembersAndAnyAdditional() }) }}\n            </div>\n\n            <div class="form-description" style="padding-bottom: 17px; font-size: 16px" ng-if="notificationAction.action.type === \'email_digest\'">\n                {{\n                notificationAction.msgs.aDailyEmailContainingADigestOfAllTriggeredEventsWillBeSentToValueEmailAddressesProvided({\n                VALUE: notificationAction.msgs.appNameUsersPermissionGroupMembersAndAnyAdditional() }) }}\n            </div>\n\n            \x3c!--\n            The following ng-if is an important workaround for an existing bug (SING-881). This ng-if allows the two\n            autocomplete-chips to get unique IDs for reasons we don\'t quite understand.\n            --\x3e\n            <md-input-container class="md-block" flex="100" ng-if="true">\n                <label>{{ ::notificationAction.msgs.users() }}</label>\n                <autocomplete-chips items="notificationAction.action.users" master-list="notificationAction.users" name-field="username" placeholder="{{ ::notificationAction.msgs.searchForAUser() }}" change-callback="notificationAction.onUsersChanged()">\n                </autocomplete-chips>\n                <div ng-if="notificationAction.usersWithoutEmails.length > 0" class="md-input-messages-animation" role="alert">\n                    <div class="md-input-message-animation">\n                        {{ ::notificationAction.msgs.usersWithoutEmailAddresses() }} {{\n                        notificationAction.usersWithoutEmails.join(\', \') }}\n                    </div>\n                </div>\n            </md-input-container>\n\n            <div style="position: relative; width: 100%; margin-top: 35px">\n                <i class="fa fa-circle-question label-hint permission-group-explain tooltip-icon">\n                    <md-tooltip md-direction="right">\n                        {{ ::notificationAction.msgs.emailsWillBeSentToAllUsersInSpecifiedPermissionGroups() }}\n                    </md-tooltip>\n                </i>\n                <md-input-container class="md-block" flex="100">\n                    <label>{{ ::notificationAction.msgs.permissionGroups() }}</label>\n                    <autocomplete-chips items="notificationAction.action.groups" master-list="notificationAction.groups" name-field="name" placeholder="{{ ::notificationAction.msgs.searchForAGroup() }}" change-callback="notificationAction.onGroupsChanged()">\n                    </autocomplete-chips>\n                    <div ng-if="notificationAction.groupsWithoutEmails.length > 0" class="md-input-messages-animation" role="alert">\n                        <div class="md-input-message-animation">\n                            {{ ::notificationAction.msgs.groupsWithoutEmailAddresses() }} {{\n                            notificationAction.groupsWithoutEmails.join(\', \') }}\n                        </div>\n                    </div>\n                </md-input-container>\n            </div>\n\n            <md-input-container style="width: 100%">\n                <label>{{ ::notificationAction.msgs.emails() }}</label>\n                <md-chips name="emails" class="notification-action-emails" ng-model="notificationAction.action.configuration.recipients" placeholder="{{ ::notificationAction.msgs.typeAnEmail() }}" md-separator-keys="notificationAction.customSeparatorKeys" md-transform-chip="notificationAction.validateEmailChip($chip)">\n                </md-chips>\n            </md-input-container>\n\n            <div class="layout-column layout-gt-sm-row">\n                <md-input-container class="flex-100 flex-gt-xs-50">\n                    <label>{{ ::notificationAction.msgs.smtpServer() }}</label>\n                    <md-select ng-model="notificationAction.action.smtpServerId">\n                        <md-option ng-value="\'\'"><em>{{ ::notificationAction.msgs.none() }}</em></md-option>\n                        <md-option ng-repeat="server in notificationAction.smtpServers" ng-value="server.id">\n                            {{ server.name }}\n                        </md-option>\n                    </md-select>\n                    <div ng-if="notificationAction.action.smtpServerId === \'\'" class="smtp-warning md-input-messages-animation" role="alert">\n                        <div class="md-input-message-animation">\n                            {{ ::notificationAction.msgs.noEmailsWillBeSentForThisActionUnlessAnSmtpServerIsSpecified()\n                            }}\n                        </div>\n                    </div>\n                </md-input-container>\n\n                <md-input-container class="flex-100 flex-gt-xs-50">\n                    <label>{{ ::notificationAction.msgs.smtpFromAddress() }}</label>\n                    <input ng-model="notificationAction.action.configuration.from" required name="smtpFrom" type="email">\n                    <div ng-messages="notificationActionForm.smtpFrom.$error" role="alert" multiple="">\n                        <div ng-message-exp="[\'required\', \'email\']">\n                            {{ ::notificationAction.msgs.aValidEmailAddressIsRequired() }}\n                        </div>\n                    </div>\n                </md-input-container>\n            </div>\n\n            <div class="layout-row" style="justify-content: flex-end">\n                <md-button class="md-raised md-warn action-button remove-button" ng-click="notificationAction.remove()">\n                    <span>{{ ::notificationAction.msgs.remove() }}</span>\n                </md-button>\n                <md-button class="md-primary md-raised hide-form-button" ng-click="notificationAction.expanded = false">\n                    {{ ::notificationAction.msgs.done() }}\n                </md-button>\n            </div>\n        </div>\n    </div>\n</form>\n'
        }
        ,
        14536: e => {
            e.exports = '<section layout="row" class="admin-section" flex="">\n    <navigation display="left"></navigation>\n\n    <div class="generic-admin-container-area">\n        <md-content class="generic-admin-content centered" ng-if="notificationSettings.loading || notificationSettings.loadingNotifications" style="padding-top: 40px">\n            <page-loading progress="notificationSettings.msgs.loadingNotifications()"></page-loading>\n        </md-content>\n\n        <md-content class="generic-admin-content centered" ng-if="!notificationSettings.loading && !notificationSettings.loadingNotifications">\n            <div ng-if="notificationSettings.error" class="failed-to-load-message">\n                {{ notificationSettings.error }}\n            </div>\n\n            <div ng-if="!notificationSettings.error">\n                \x3c!-- System Alerts --\x3e\n                <div class="notifications-tabs">\n                    <div class="generic-admin-header" style="margin-bottom: 20px">\n                        <span class="section-header mat-card-title notifications-count">\n                            {{ notificationSettings.msgs.systemAlerts() }}\n                        </span>\n                        <span class="spacer" flex></span>\n                        <md-button class="md-raised md-primary add-orchid-button action-button add-button" aria-label="{{ ::notificationSettings.msgs.addSystemAlert() }}" ng-click="notificationSettings.addNotification($event)">\n                            <span hide-xs>{{ ::notificationSettings.msgs.addSystemAlert() }}</span><span hide-gt-xs>{{ ::notificationSettings.msgs.addSystemAlert() }}</span>\n                        </md-button>\n                    </div>\n                    <md-content ng-if="notificationSettings.notifications.length === 0">\n                        <div class="md-no-sticky no-notifications-are-configured no-matches-error-message">\n                            <span>{{ ::notificationSettings.msgs.noSystemAlertsAreConfigured() }}</span>\n                        </div>\n                    </md-content>\n                    <md-card>\n                        <table md-table class="orchid-table">\n                            <tbody md-body>\n                                <tr md-row class="generic-admin-card no-side-margins notifications-table" big-summer-blowout="notificationSettings.expanded[notification.id]" on-expand="notificationSettings.onExpand(notification)" on-close="notificationSettings.onClose(notification)" ng-repeat="notification in notificationSettings.notifications | orderBy:\'name\'" id="{{notification.id}}-row" style="width: 100%">\n                                    <td md-cell style="padding: 0px">\n                                        <div class="notification-header blowout-header">\n                                            <table style="width: 100%" class="admin-card-header alert-row-inner-table">\n                                                <tr class="notification-header-row admin-card-header-row">\n                                                    <td class="admin-card-title">\n                                                        <span>{{ notification.name }}</span>\n                                                    </td>\n                                                    <td class="admin-card-description">\n                                                        <span class="hide-when-small">{{ notification.description }}</span>\n                                                    </td>\n                                                    <td class="notification-status" ng-mouseup="$event.stopPropagation()">\n                                                        <div style="margin-top: -5px; padding-right: 8px" ng-if="notification.isEnabled && notificationSettings.notificationError[notification.id].length === 0">\n                                                            <i class="fa fa-envelope"></i>\n                                                            <md-tooltip md-delay="500">\n                                                                {{\n                                                                ::notificationSettings.msgs.notificationIsConfiguredCorrectlyNotificationsWillBeSent()\n                                                                }}\n                                                            </md-tooltip>\n                                                        </div>\n                                                        <div class="fa-stack" style="margin-top: -5px" ng-if="notification.isEnabled && notificationSettings.notificationError[notification.id].length > 0">\n                                                            <i class="fa fa-envelope fa-stack-1x"></i>\n                                                            <i class="fa fa-ban fa-stack-2x red"></i>\n                                                            <md-tooltip md-delay="500">\n                                                                {{\n                                                                notificationSettings.notificationError[notification.id][0]\n                                                                }} {{\n                                                                ::notificationSettings.msgs.noNotificationsWillBeSent()\n                                                                }}\n                                                            </md-tooltip>\n                                                        </div>\n                                                        <div style="margin-top: -5px; padding-right: 8px" ng-if="!notification.isEnabled">\n                                                            <i class="fa fa-envelope" style="color: #dfdfdf"></i>\n                                                            <md-tooltip md-delay="500">\n                                                                {{\n                                                                ::notificationSettings.msgs.notificationIsDisabledNoNotificationsWillBeSent()\n                                                                }}\n                                                            </md-tooltip>\n                                                        </div>\n                                                    </td>\n                                                </tr>\n                                                <tr class="notification-header-description admin-card-header-row show-when-small" ng-if="notification.description">\n                                                    <td colspan="2" class="admin-card-description">\n                                                        {{ notification.description}}\n                                                    </td>\n                                                </tr>\n                                            </table>\n                                        </div>\n                                        <div class="notification-container blowout-container group-view-container" ng-show="notificationSettings.expanded[notification.id]" ng-mouseup="$event.stopPropagation()" style="flex-direction: column">\n                                            <div style="width: 100%" class="notification-summary" ng-cloak>\n                                                <h3 class="summary-header">\n                                                    {{ ::notificationSettings.msgs.triggers() }}\n                                                </h3>\n                                                <div ng-if="notification.conditions.length === 0" class="warn-text indent-text">\n                                                    <i class="fa fa-times"></i>\n                                                    {{\n                                                    ::notificationSettings.msgs.noTriggersHaveBeenConfiguredNoNotificationsWillBeSent()\n                                                    }}\n                                                </div>\n                                                <md-card class="trigger-card" ng-repeat="rule in notification.conditions">\n                                                    <notification-trigger rule="rule" static="true"></notification-trigger>\n                                                </md-card>\n\n                                                <h3 class="summary-header">\n                                                    {{ ::notificationSettings.msgs.actions() }}\n                                                </h3>\n                                                <div ng-if="notification.actions.length === 0" class="warn-text indent-text">\n                                                    <i class="fa fa-times"></i>\n                                                    {{\n                                                    ::notificationSettings.msgs.noActionsHaveBeenConfiguredNoNotificationsWillBeSent()\n                                                    }}\n                                                </div>\n                                                <md-card class="trigger-card" ng-repeat="action in notification.actions" ng-if="!notificationSettings.loadingGroups">\n                                                    <notification-action action="action" static="true" groups="notificationSettings.groups" users="notificationSettings.users"></notification-action>\n                                                </md-card>\n                                            </div>\n                                            <div class="controls" layout="row" layout-wrap style="justify-content: flex-end;">\n                                                <md-button class="md-raised md-warn remove-button" ng-click="notificationSettings.deleteNotification($event, notification)" ng-disabled="notificationSettings.processing[notification.id]">\n                                                    <span hide-xs>{{ ::notificationSettings.msgs.deleteSystemAlert() }}</span>\n                                                    <span hide-gt-xs>{{ ::notificationSettings.msgs.delete() }}</span>\n                                                </md-button>\n                                                <md-button class="md-raised md-primary modify-button" ng-click="notificationSettings.editNotification($event, notification)" ng-disabled="notificationSettings.processing[notification.id]">\n                                                    <span hide-xs>{{ ::notificationSettings.msgs.editSystemAlert() }}</span>\n                                                    <span hide-gt-xs>{{ ::notificationSettings.msgs.edit() }}</span>\n                                                </md-button>\n                                            </div>\n                                        </div>\n                                    </td>\n                                </tr>\n                            </tbody>\n                        </table>\n                    </md-card>\n                </div>\n            </div>\n        </md-content>\n    </div>\n</section>\n'
        }
        ,
        27623: e => {
            e.exports = '<div class="md-whiteframe-3dp layout-column layout-align-center-center trigger-bubble">\n    <i ng-class="{\n        \'fa-video-camera\': notificationTrigger.rule.type === \'camera_state\',\n        \'fa-regular fa-server\': notificationTrigger.rule.type === \'server_error\' || notificationTrigger.rule.type === \'device_state\',\n        \'fa-save\': notificationTrigger.rule.type === \'io_error\'\n    }" class="fa">\n    </i>\n</div>\n<div class="trigger-body" ng-class="{ \'expanded-form\': notificationTrigger.expanded, \'closed-form\': !notificationTrigger.expanded }">\n    <div class="trigger-form" ng-if="!notificationTrigger.static">\n        <md-input-container style="padding-bottom: 6px">\n            <label>{{ ::notificationTrigger.msgs.triggerEvent() }}</label>\n            <md-select ng-model="notificationTrigger.rule.type">\n                <md-option ng-value="\'camera_state\'" sing-translated-msg="notifications.cameraUnreachable"></md-option>\n                <md-option ng-value="\'device_state\'" sing-translated-msg="notifications.serverUnreachable"></md-option>\n                <md-option ng-value="\'server_error\'" sing-translated-msg="notifications.serverError"></md-option>\n                <md-option ng-value="\'io_error\'" sing-translated-msg="notifications.iOError"></md-option>\n            </md-select>\n        </md-input-container>\n        <div ng-if="notificationTrigger.rule.type === \'camera_state\' || notificationTrigger.rule.type === \'device_state\'">\n            <div class="send-conditions">\n                <span>{{ notificationTrigger.msgs.aNotificationWillBeSentWhenACameraOrServerBecomesUnreachableFor({\n                    VALUE: notificationTrigger.deviceLabels[notificationTrigger.rule.type].toLowerCase() }) }}</span>\n                <md-input-container class="inline-input">\n                    <input type="number" ng-model="notificationTrigger.thresholdMinutes" ng-model-options="{ getterSetter: true }" min="1" ng-focus="notificationTrigger.selectInputText($event)" onchange="this.value = (this.value >= 1) ? Math.floor(Math.abs(this.value)) : 1" autocomplete="off" required>\n                </md-input-container>\n                <span sing-translated-msg="notifications.minutesPeriod"></span>\n            </div>\n            <div class="send-conditions">\n                <span>{{ notificationTrigger.msgs.notificationTriggerCameraServerState({ VALUE:\n                    notificationTrigger.deviceLabels[notificationTrigger.rule.type].toLowerCase() }) }}</span>\n                <md-input-container class="inline-input">\n                    <input type="number" ng-model="notificationTrigger.refractoryMinutes" ng-model-options="{ getterSetter: true }" min="1" ng-focus="notificationTrigger.selectInputText($event)" onchange="this.value = (this.value >= 1) ? Math.floor(Math.abs(this.value)) : 1" autocomplete="off" required>\n                </md-input-container>\n                <span sing-translated-msg="notifications.minutesPeriod"></span>\n            </div>\n        </div>\n        <div ng-if="notificationTrigger.rule.type === \'server_error\' || notificationTrigger.rule.type === \'io_error\'" class="send-conditions">\n            <span ng-switch on="notificationTrigger.rule.type">\n                <span ng-switch-when="server_error" sing-translated-msg="notifications.notificationTriggerServerError"></span>\n                <span ng-switch-default sing-translated-msg="notifications.notificationTriggerIOError"></span>\n            </span>\n            <md-input-container class="inline-input">\n                <input type="number" ng-model="notificationTrigger.throttleMinutes" ng-model-options="{ getterSetter: true }" min="1" ng-focus="notificationTrigger.selectInputText($event)" onchange="this.value = (this.value >= 1) ? Math.floor(Math.abs(this.value)) : 1" autocomplete="off" required>\n            </md-input-container>\n            <span sing-translated-msg="notifications.minutesPeriod"></span>\n        </div>\n        <div class="send-conditions send-conditions-without-input" ng-if="notificationTrigger.rule.type === \'camera_state\'">\n            <span sing-translated-msg="notifications.camerasThatBecomeUnreachableBecauseAServerBecomesUnreachableWillNotSendNotifications"></span>\n        </div>\n\n        <md-checkbox md-no-ink ng-model="notificationTrigger.rule.configuration.all">\n            <strong>{{ notificationTrigger.msgs.anyValue({ VALUE:\n                notificationTrigger.deviceLabels[notificationTrigger.rule.type] }) }}</strong>\n        </md-checkbox>\n        <device-form ng-if="!notificationTrigger.rule.configuration.all" rule-devices="notificationTrigger.rule.include" device="notificationTrigger.rule.type" type="add">\n        </device-form>\n        <device-form ng-if="notificationTrigger.rule.configuration.all" rule-devices="notificationTrigger.rule.exclude" device="notificationTrigger.rule.type" type="remove">\n        </device-form>\n        <div class="layout-row" style="justify-content: flex-end;">\n            <md-button class="md-raised md-warn action-button remove-button" ng-click="notificationTrigger.remove()">\n                <span sing-translated-msg="notifications.remove"></span>\n            </md-button>\n            <md-button class="md-primary md-raised close-form-button action-button" ng-click="notificationTrigger.expanded = false">\n                <span sing-translated-msg="notifications.done"></span>\n            </md-button>\n        </div>\n    </div>\n    <div class="trigger-view">\n        <div class="indent-text trigger-summary">\n            <div ng-if="notificationTrigger.rule.type === \'io_error\' || notificationTrigger.rule.type === \'server_error\'">\n                <h4 ng-switch on="notificationTrigger.rule.type">\n                    <span ng-switch-when="io_error" sing-translated-msg="notifications.iOError"></span>\n                    <span ng-switch-default sing-translated-msg="notifications.serverError"></span>\n                </h4>\n                <span ng-if="notificationTrigger.rule.type === \'io_error\'" sing-translated-msg="notifications.aNotificationWillBeSentWhenVideoFilesCannotBeWrittenToDiskDueToInsufficientStorageThroughput"></span>\n                <span ng-if="notificationTrigger.rule.type === \'server_error\'" sing-translated-msg="notifications.aNotificationWillBeSentWhenAServerRestartsEntersDegradedModeDueToAStorageErrorOrLicenseExpirationOrStopsWritingVideoFiles"></span>\n                <span>{{ notificationTrigger.msgs.thereWillBeAtLeastVALUEMinutesOfDelayBetweenNotifications({ VALUE:\n                    notificationTrigger.throttleMinutes() }) }}</span>\n            </div>\n            <div ng-if="notificationTrigger.rule.type === \'camera_state\' || notificationTrigger.rule.type === \'device_state\'">\n                <h4 ng-switch on="notificationTrigger.rule.type">\n                    <span ng-switch-when="camera_state" sing-translated-msg="notifications.cameraUnreachable"></span>\n                    <span ng-switch-default sing-translated-msg="notifications.serverUnreachable"></span>\n                </h4>\n                <span>{{\n                    notificationTrigger.msgs.aNotificationWillBeSentWhenACameraOrServerBecomesUnreachableForNMinutes({\n                    VALUE: notificationTrigger.deviceLabels[notificationTrigger.rule.type].toLowerCase(), MINUTES:\n                    notificationTrigger.thresholdMinutes() }) }}</span>\n                <span>{{\n                    notificationTrigger.msgs.valueMustBeOnlineForRefractoryMinuteBeforeAnotherNotificationWllBeSent({\n                    VALUE: notificationTrigger.deviceLabels[notificationTrigger.rule.type].toLowerCase(), MINUTES:\n                    notificationTrigger.refractoryMinutes() }) }}</span>\n                <span ng-if="notificationTrigger.rule.type === \'camera_state\'" sing-translated-msg="notifications.camerasThatBecomeUnreachableBecauseAServerBecomesUnreachableWillNotSendNotifications"></span>\n            </div>\n\n            <div class="scope">{{ notificationTrigger.deviceLabels[notificationTrigger.rule.type] }}s:</div>\n\n            <div ng-hide="notificationTrigger.rule.configuration.all || notificationTrigger.rule.include.orchids.length > 0 || notificationTrigger.rule.include.cameras.length > 0" class="indent-text warn-text">\n                <i class="fa fa-times"></i>\n                {{ notificationTrigger.msgs.noDeviceNotificationsAreConfiguredForTrigger({ VALUE:\n                notificationTrigger.deviceLabels[notificationTrigger.rule.type] }) }}\n            </div>\n\n            <div ng-show="notificationTrigger.rule.configuration.all" class="indent-text md-body-1">\n                <strong>\n                    <i class="fa fa-check"></i>{{ notificationTrigger.msgs.anyValue({ VALUE:\n                    notificationTrigger.deviceLabels[notificationTrigger.rule.type] }) }}</strong>\n                <span ng-if="notificationTrigger.excludeList.list && notificationTrigger.rule.type !== \'camera_state\'">\n                    <span style="font-style: italic">{{ ::notificationTrigger.msgs.excludingLower() }}</span>\n                    {{ notificationTrigger.excludeList.list }}\n                </span>\n                <div class="form-text-list" ng-if="notificationTrigger.rule.type === \'camera_state\'" ng-repeat="(orchidName, cameras) in notificationTrigger.excludeList">\n                    <strong>{{ orchidName }}:</strong>\n                    <span><span style="font-style: italic">{{ ::notificationTrigger.msgs.excludingLower() }}</span> {{\n                        cameras }}</span>\n                </div>\n            </div>\n\n            <div ng-if="!notificationTrigger.rule.configuration.all && notificationTrigger.rule.type !== \'camera_state\'" class="indent-text form-text-list">\n                {{ notificationTrigger.includeList.list }}\n            </div>\n\n            <div class="md-body-1 chips-container" ng-if="notificationTrigger.rule.type === \'camera_state\' && !notificationTrigger.rule.configuration.all" style="padding-left: 10px">\n                <div class="form-text-list" ng-repeat="(orchidName, cameras) in notificationTrigger.includeList">\n                    <strong>{{ orchidName }}:</strong> {{ cameras }}\n                </div>\n            </div>\n        </div>\n        <div ng-if="!notificationTrigger.static" class="layout-row layout-align-end-center">\n            <md-button ng-click="notificationTrigger.expanded = true" class="md-icon-button open-form-button">\n                <i class="fa fa-lg fa-pencil"></i>\n            </md-button>\n        </div>\n    </div>\n</div>\n'
        }
        ,
        49610: e => {
            e.exports = '<md-card ng-class="::$ctrl.cardClass">\n    <div ng-if="!$ctrl.errorState" ng-class="::$ctrl.loadingContainerClass">\n        <md-progress-circular md-diameter="20" md-mode="indeterminate"></md-progress-circular>\n        <h4 ng-class="::$ctrl.loadingMsgClass" ng-if="$ctrl.progress">{{$ctrl.progress}}</h4>\n    </div>\n    <ng-transclude ng-if="$ctrl.errorState">\n        <error-page message="{{$ctrl.error}}"></error-page>\n    </ng-transclude>\n</md-card>\n'
        }
        ,
        93324: e => {
            e.exports = '<div class="text" sing-watch-translated-text="$ctrl.videoStartsIn()"></div>\n<md-progress-circular md-mode="determinate" md-diameter="90" value="{{$ctrl.percentComplete}}"></md-progress-circular>\n'
        }
        ,
        84373: e => {
            e.exports = '<div class="ptz-container" ng-class="{ crosshair: ptz.panable || ptz.tiltable }">\n    <pan-tilt-arrows ng-if="ptz.panable || ptz.tiltable" arrow-coordinates="ptz.arrowCoordinates" fill-style="ptz.arrowsFillStyle"></pan-tilt-arrows>\n\n    <ripple position="ptz.position"></ripple>\n\n    <div class="layout-row layout-align-center-center hidden-control mode-controls ptz-controls">\n        <md-button ng-show="ptz.zoomable" class="md-raised md-primary left-button ptz-zoom-in">\n            <i class="fa-regular fa-lg fa-search-plus"></i>\n        </md-button>\n        <md-button ng-show="ptz.zoomable" class="md-raised md-primary right-button ptz-zoom-out">\n            <i class="fa-regular fa-lg fa-search-minus"></i>\n        </md-button>\n    </div>\n</div>\n'
        }
        ,
        82952: e => {
            e.exports = '<div class="player-sizer layout-row layout-align-center-center" ng-class="[player.playerSize, { \'child-player\': player.childPlayer, \'bidirectional-audio-muted\': player.bidirectionalAudioMuted }]">\n    <header ng-click="player.onHeaderClick()" ng-if="player.options.showHeader" ng-class="{ \n        \'zoomed-header\': player.digitalPtzPosition.scale > 1 && player.bidirectionalAudioMuted, \n        \'no-hide\': player.noHideHeader,\n        \'bidirectional-audio-active\': player.showBidirectionalAudio && !player.bidirectionalAudioMuted,\n        \'md-whiteframe-2dp\': !player.showBidirectionalAudio || player.bidirectionalAudioMuted\n    }" class="layout-row layout-align-space-between-stretch">\n        <div ng-if="player.options.showFullScreen" ng-click="player.toggleFullScreen($event)" ng-class="{ \'selected-mode\': player.isFullScreen }" class="layout-column layout-align-center-center player-icon">\n            <i class="fa fa-lg" ng-class="{\n                    \'fa-maximize\': !player.isFullScreen,\n                    \'fa-minimize\': player.isFullScreen\n                }"></i>\n        </div>\n        <span class="md-truncate md-body-1 player-title">\n            &nbsp;{{ player.cameraName }}\n            <span ng-if="player.digitalPtzPosition.scale > 1">\n                &nbsp;{{ (player.digitalPtzPosition.scale * 100).toFixed(0) }}%\n            </span>\n        </span>\n        <span class="flex"></span>\n        <i ng-if="player.bidirectionalAudioAvailable && player.showBidirectionalAudio && player.overlayState === player.overlayStates.NONE" ng-click="player.toggleBidirectionalAudio()" ng-class="{ \'selected-mode\': player.bidirectionalAudioEnabled }" class="fa-solid fa-lg fa-microphone player-icon"></i>\n        <i ng-if="player.dewarpAvailable" ng-click="player.toggleDewarp()" ng-class="{ \'selected-mode\': player.showDewarpControls }" class="layout-column layout-align-center-center player-icon fa-kit fa-dewarp"></i>\n        <i ng-if="player.ptzAvailable && player.dewarpAvailable !== true" ng-click="player.toggleShowPtzControls()" ng-class="{ \'selected-mode\': player.showPtzControls }" class="fa fa-lg fa-crosshairs player-icon"></i>\n        <volume-button ng-if="player.volumeAvailable && player.overlayState === player.overlayStates.NONE" class="layout-column layout-align-center-center player-icon volume-icon-button" [volume]="player.volume" (on-volume-change)="player.updateVolume($event)"></volume-button>\n        \x3c!-- Don\'t use ng-ifs for the individual rabbit / turtle imgs --\x3e\n        \x3c!-- https://github.com/ipconfigure/singularity/pull/396 --\x3e\n        <i ng-if="player.canShowPlayerModeIcon" ng-click="player.onPlayerModeClick($event)" ng-class="{ \n            \'header-button-disabled\': player.streamOptions.length === 0 && player.isOnvif, \n            \'selected-mode\': player.hasPlayerModeSelected, \n            \'fa-turtle-land turtle-color\': player.playerType === \'lowbandwidth\',\n            \'fa-sitting-rabbit\': player.playerType === \'webrtc\'\n        }" class="layout-column layout-align-center-center player-icon fa-kit fa-lg"></i>\n        <i ng-if="player.options.showStats" ng-click="player.toggleStats($event)" ng-class="{ \'selected-mode\': player.showStats }" class="fa fa-lg fa-chart-column player-icon"></i>\n        <i ng-click="player.close($event)" ng-show="player.options.showClose" class="fa fa-lg fa-times player-icon"></i>\n    </header>\n\n    <div class="top-left-container hidden-control undraggable">\n        <span class="timezone-alert-overlay" ng-click="player.expandTzAlert = !player.expandTzAlert">\n            <p class="tz-summary" ng-if="player.timeOffsetDisplayText">{{ ::player.timeOffsetDisplayText }}</p>\n            <div class="tz-body" ng-if="player.expandTzAlert === true">\n                <table>\n                    <tr>\n                        <td>{{ ::player.msgs.serverTimezone() }}:</td>\n                        <td>{{ ::player.serverTimezone }}</td>\n                    </tr>\n                    <tr>\n                        <td>{{ ::player.msgs.clientTimezone() }}:</td>\n                        <td>{{ ::player.clientTimezone }}</td>\n                    </tr>\n                </table>\n            </div>\n        </span>\n        <span ng-if="player.activeMicrophoneStream && player.overlayState === player.overlayStates.NONE">\n            <decibel-meter [media-stream]="player.activeMicrophoneStream"></decibel-meter>\n        </span>\n    </div>\n\n    <div class="player-visuals-container">\n        <div class="player-visuals-container" ng-class="{\n        \'two-way-audio-active\': player.showBidirectionalAudio && player.bidirectionalAudioMuted === false,\n        \'thumbnail-search-active\': player.showThumbnailSearchOverlay\n    }">\n            <div class="player-visuals-content player-sizer">\n                <div class="layout-row layout-align-center-center w-full h-full player-video-container" ng-class="{ \'unlinked\' : player.unlinked }" digital-ptz position="player.digitalPtzPosition" target="(player.playerType === \'webrtc\' && player.mode !== \'rip\') ? \'video.player\' : \'canvas.player\'">\n                    <video class="player" muted="muted" playsinline ng-show="((player.playerType === \'webrtc\' && player.mode !== \'rip\'))"></video>\n\n                    <canvas class="player" ng-show="((player.playerType === \'lowbandwidth\' || player.mode === \'rip\') && player.overlayState === player.overlayStates.NONE)" ensure-aspect-ratio="{{ player.aspectRatio }}">\n                    </canvas>\n\n                    <video-overlay-sizer [aspect-ratio]="player.aspectRatio" [relative-container]="true">\n                        <motion-regions-overlay ng-if="player.showLiveMotionRegions && player.aspectRatio && player.overlayState === player.overlayStates.NONE && player.digitalPtzPosition.scale === 1" [regions-data]="player.liveMotionRegions"></motion-regions-overlay>\n                    </video-overlay-sizer>\n\n                    <video-overlay-sizer [aspect-ratio]="player.aspectRatio">\n                        <smart-search-overlay ng-if="player.isSmartSearchAvailable && player.showSmartSearch && player.overlayState === player.overlayStates.NONE && player.digitalPtzPosition.scale === 1" (on-regions-change)="player.onSmartSearchRegionsChanged($event)" [region-bounds]="player.smartSearchRegionBounds" [aspect-ratio]="player.aspectRatio">\n                        </smart-search-overlay>\n                    </video-overlay-sizer>\n\n                    <pan-tilt-zoom ng-if="player.ptzAvailable && player.showPtzControls" class="ptz-container" orchid="player.orchid" camera="player.camera" quirks="player.stream.configuration.Options" resolution="player.dimensions" capabilities="player.ptzConfig" control-color="player.ptzControlColor" ng-class="{ \'open\': player.expandPresets }">\n                    </pan-tilt-zoom>\n                </div>\n\n                <camera-dewarper ng-if="player.dewarpAvailable && player.dewarpMode !== 0" dewarp-config="::player.dewarpConfig" is-interactive="true" mode="player.dewarpMode" source="player.source" on-error="player.onDewarpError(error)" class="layout-column layout-align-center-center dewarp-zone" ng-class="{ \'unlinked\' : player.unlinked }">\n                </camera-dewarper>\n                <div class="player-connecting layout-row layout-sm-column layout-align-space-around info-mask" ng-if="player.overlayState === player.overlayStates.CONNECTING">\n                    <md-progress-circular md-mode="indeterminate" md-diameter="90"></md-progress-circular>\n                </div>\n\n                <div class="hidden-control controls" ng-if="player.canDisplayControls() && player.controls === player.controlsLayout.SINGLE">\n                    <player-frame-downloader ng-if="player.image" ng-class="{\'downloader-hidden\': !player.showPlayerFrameDownloader}" [camera-name]="player.camera.name" [orchid]="player.orchid" [image]="player.image" [time]="player.pausedTime">\n                    </player-frame-downloader>\n\n                    <thumbnail-search-control ng-if="player.isThumbnailSearchAvailable && player.canPlayback" ng-class="{\'active\': player.showThumbnailSearchOverlay, \'inactive\': !player.showThumbnailSearchOverlay}" (activate)="player.toggleThumbnailSearch()">\n                    </thumbnail-search-control>\n\n                    <smart-search-control ng-if="player.isSmartSearchAvailable && player.canPlayback" ng-class="{\'active\': player.showSmartSearch, \'inactive\': !player.showSmartSearch }" [region-count]="player.smartSearchRegionBounds.length" (on-clear)="player.clearSmartSearch()" (on-filter)="player.toggleSmartSearch()"></smart-search-control>\n                </div>\n\n                <div class="controls hidden-control" (click)="player.clickControlExpander()" ng-if="player.canDisplayControls() && player.controls === player.controlsLayout.EXPANDER">\n                    <player-frame-downloader ng-if="player.image" ng-class="{\'downloader-hidden\': !player.showPlayerFrameDownloader}" [camera-name]="player.camera.name" [orchid]="player.orchid" [image]="player.image" [time]="player.pausedTime">\n                    </player-frame-downloader>\n\n                    <thumbnail-search-control ng-if="player.controlsExpanded && player.canPlayback && player.isThumbnailSearchAvailable" ng-class="{\'active\': player.showThumbnailSearchOverlay, \'inactive\': !player.showThumbnailSearchOverlay}" (activate)="player.toggleThumbnailSearch()">\n                    </thumbnail-search-control>\n\n                    <smart-search-control ng-if="player.isSmartSearchAvailable && player.canPlayback && player.controlsExpanded" ng-class="{\'active\': player.showSmartSearch, \'inactive\': !player.showSmartSearch }" [region-count]="player.smartSearchRegionBounds.length" (on-clear)="player.clearSmartSearch()" (on-filter)="player.toggleSmartSearch()"></smart-search-control>\n\n                    <div class="control-expander-container" ng-class="{\'active\': player.controlsExpanded, \'inactive\': !player.controlsExpanded}">\n                        <span class="fa-stack fa-lg filter control-expander" ng-click="player.clickControlExpander()">\n                            <i class="fa-solid fa-magnifying-glass fa-stack-1x"></i>\n                            <i class="fa-regular fa-circle fa-stack-2x"></i>\n                        </span>\n                    </div>\n                </div>\n            </div>\n            <div class="thumbnail-search-drawer ios-allow-drag" ng-if="player.canPlayback && player.isThumbnailSearchAvailable">\n                <thumbnail-search-overlay ng-if="!player.thumbnailSearchDisabled" [timeline-value]="player.timelineContext.getTime()" [stream]="player.camera.primaryStream" [orchid]="player.orchid" [smart-search-active]="player.smartSearchRegionBounds.length > 0" [search-region-bounds]="player.smartSearchRegionBounds" [smart-search-canvas-size]="player.smartSearchCanvasSize" (minute-preview-click)="player.handleMinutePreviewClick($event)" (close)="player.toggleThumbnailSearch()">\n                </thumbnail-search-overlay>\n            </div>\n        </div>\n\n        <div ng-if="player.showStreamSelectControls" class="layout-row layout-align-center-center hidden-control stream-options-menu" prevent-drag>\n            <md-button ng-click="player.onStreamSelect()" ng-if="player.showLBM" class="md-raised stream-option-button lbm-option-button" ng-disabled="player.playerType === \'lowbandwidth\'" ng-class="{ \'stream-option-selected\': player.playerType === \'lowbandwidth\' }">\n                <span class="stream-option-icon lbm-option-icon">\n                    <i class="fa-kit fa-turtle-land turtle-color"></i>\n                </span>\n                <div class="stream-option-label lbm-option-label">\n                    <span class="stream-option-text lbm-option-text"> {{ ::player.msgs.lowBandwidth() }} </span>\n                    <span class="stream-option-primary"> {{ ::player.msgs.primary() }} </span>\n                </div>\n            </md-button>\n\n            <md-button ng-click="player.onStreamSelect(option)" ng-repeat="option in player.streamOptions" class="md-raised md-primary stream-option-button" ng-disabled="option.id === player.streamId && player.playerType !== \'lowbandwidth\'" ng-class="{ \'stream-option-selected\': option.id === player.streamId && player.playerType !== \'lowbandwidth\' }">\n                <div class="stream-option-label">\n                    <span class="stream-option-text">{{ ::option.name }}</span>\n                    <span class="stream-option-primary" ng-if="option.description.length > 0">\n                        {{ ::option.description.join(\', \') }}\n                    </span>\n                </div>\n                <span class="stream-option-icon">\n                    <i ng-if="option.isRecording" class="fa fa-circle stream-option-record"></i>\n                </span>\n            </md-button>\n        </div>\n\n        <div ng-if="player.showDewarpControls" class="layout-row layout-align-center-center hidden-control mode-controls">\n            <md-button ng-click="player.setDewarpMode(0)" md-no-ink ng-class="{ \'selected-mode\': player.dewarpMode === 0 }" class="md-raised md-primary left-button">\n                {{ ::player.msgs.off() }}\n            </md-button>\n            <md-button ng-click="player.setDewarpMode(1)" md-no-ink ng-class="{ \'selected-mode\': player.dewarpMode === 1 }" class="md-raised md-primary middle-button">\n                {{ ::player.msgs.perspective() }}\n            </md-button>\n            <md-button ng-click="player.setDewarpMode(2)" md-no-ink ng-class="{ \'selected-mode\': player.dewarpMode === 2 }" class="md-raised md-primary right-button">\n                {{ ::player.msgs.panorama() }}\n            </md-button>\n        </div>\n\n        <div ng-if="player.ptzAvailable && player.showPtzControls && player.ptzConfig.maxPresets > 0" ng-class="{ \'open\': player.expandPresets }" class="presets-pane undraggable">\n            <md-button ng-click="player.expandPresets = !player.expandPresets" class="md-raised md-primary hidden-control left-button ptz-presets-toggle">\n                <i class="fa-solid fa-lg fa-list"></i>\n            </md-button>\n            <md-content class="md-whiteframe-4dp ptz-presets-container" md-theme="{{$root.theme}}">\n                <ptz-presets orchid="player.orchid" camera="player.camera" view-only="!player.canManagePtzPresets" class="layout-column"></ptz-presets>\n            </md-content>\n        </div>\n\n        <div ng-if="player.options.showStats && player.showStats" class="md-padding stats" prevent-drag>\n            <div class="buttons-container">\n                <a ng-if="player.liveMotionRegionsAreSupported" class="motion-regions-toggle" ng-click="player.toggleShowLiveMotionRegions()">\n                    {{ player.showLiveMotionRegions ? player.msgs.motionRegionsHide() : player.msgs.motionRegionsShow()\n                    }}\n                </a>\n            </div>\n\n            <stats-for-nerds value="player.stats"> </stats-for-nerds>\n\n            <span class="md-subhead" ng-if="player.playingSourceStatistics$.value"> {{ ::player.msgs.stream() }} </span>\n            <stats-for-nerds value="player.playingSourceStatistics$.value" class="stats-indented"> </stats-for-nerds>\n            <span class="md-subhead"> {{ ::player.msgs.diagnostics() }} </span>\n            <stats-for-nerds value="player.diagnostics" class="stats-indented"> </stats-for-nerds>\n        </div>\n\n        <slow-network-alert hide-after="2000" ng-if="player.playerType !== \'lowbandwidth\'"> </slow-network-alert>\n\n        <div class="source-error layout-column layout-align-center-center layout-padding info-mask" ng-if="player.overlayState === player.overlayStates.ERROR">\n            <div class="layout-row layout-align-center-center icon-container">\n                <i ng-if="!player.cameraDisablementIsSupported || (player.cameraDisablementIsSupported && player.camera.active)" ng-class="{ \n                    \'fa-ban\': player.error.state === \'not_available\', \n                    \'fa-triangle-exclamation\': player.error.state !== \'not_available\' }" class="fa fa-2x mat-fail">\n                </i>\n                <i ng-if="player.cameraDisablementIsSupported && !player.camera.active" class="fa-solid fa-2x fa-video-slash player-disabled-camera-icon"></i>\n            </div>\n            <div>{{ player.error.message }}</div>\n            <div class="layout-margin layout-padding layout-row layout-align-space-around-center" ng-if="player.shouldShowLBMLink()">\n                <div class="fake-link" ng-click="player.togglePlayerMode(true)">\n                    {{ ::player.msgs.tryLowBandwidthMode() }}\n                </div>\n            </div>\n        </div>\n\n        <div class="source-error layout-column layout-align-center-center layout-padding info-mask" ng-if="player.overlayState === player.overlayStates.UNSUPPORTED">\n            <div class="layout-row layout-align-center-center icon-container">\n                <i class="fa fa-2x fa-triangle-exclamation"> </i>\n            </div>\n            <div>{{ ::player.msgs.unsupportedLowBandwidthMode() }}</div>\n        </div>\n\n        <countdown ng-if="player.overlayState === player.overlayStates.DELAY" class="info-mask layout-align-space-around-stretch layout-row layout-sm-column" time-remaining="player.countdownTimeRemaining" percent-complete="player.countdownPercentComplete">\n        </countdown>\n\n        <div class="layout-row layout-align-center-center info-mask" ng-if="player.overlayState === player.overlayStates.NO_VIDEO">\n            {{ ::player.msgs.noVideoToDisplay() }}\n        </div>\n    </div>\n    <div class="timeline-container" ng-if="player.options.showTimeline && player.unlinked">\n        <timeline fine-only="true" context-id="player.id"></timeline>\n    </div>\n\n    \x3c!-- TODO: Hide from events viewer --\x3e\n    <bidirectional-audio-overlay ng-if="player.showBidirectionalAudio && player.bidirectionalAudioEnabled" class="hidden-control" ng-class="{\'thumbnail-search-offset\': player.showThumbnailSearchOverlay}" (talk)="player.onTalk($event)" (mute)="player.onMute($event)" (mic-select)="player.showMicrophoneSelector = true" (close)="player.bidirectionalAudioEnabled = false;" (media-stream-change)="player.onMediaStreamChange($event)" [source]="player.source" [is-enabled]="player.bidirectionalAudioEnabled" [mute-by-player]="player.muteBidirectionalAudio$"></bidirectional-audio-overlay>\n\n    <microphone-selector ng-if="player.showMicrophoneSelector" class="hidden-control" ng-class="{\'thumbnail-search-offset\': player.showThumbnailSearchOverlay}" (on-close)="player.showMicrophoneSelector = false" (on-select)="player.toggleForcedHoverState($event)"></microphone-selector>\n\n    <i class="fa-kit fa-lg hidden-control player-control" ng-class="player.unlinked ? \'fa-link unlinked-icons\' : \'fa-unlink\'" ng-click="player.toggleLink()" ng-show="!player.isFullScreen && player.canPlayback">\n    </i>\n    \x3c!-- this should be moved into a Cell component --\x3e\n    <i class="fa-kit fa-lg fa-resize-horizontal hidden-control resize-e" ng-hide="player.isFullScreen"></i>\n    <i class="fa-kit fa-lg fa-resize-vertical hidden-control resize-s" ng-hide="player.isFullScreen"></i>\n    <i ng-hide="player.isFullScreen" ng-class="{ \'unlinked-icons\': player.unlinked }" class="fa fa-2x fa-caret-down resize-se hidden-control"></i>\n</div>\n'
        }
        ,
        20220: e => {
            e.exports = '<md-dialog>\n    <form name="ptzPresetForm" autocomplete="off" class="admin-dialog edit-camera-dialog ptz-preset-dialog">\n        <md-toolbar>\n            <div class="md-toolbar-tools">\n                <h2>{{ptzPresetsDialog.dialogTitle}}</h2>\n                <span flex></span>\n                <md-button class="md-icon-button" ng-disabled="ptzPresetsDialog.processing" ng-click="ptzPresetsDialog.cancel()">\n                    <i class="fa fa-times fa-2x"></i>\n                </md-button>\n            </div>\n        </md-toolbar>\n        <md-dialog-content>\n            <md-content>\n                <md-input-container class="ptz-preset-dialog-name-input">\n                    <label for="name">{{ ::ptzPresetsDialog.msgs.presetName() }}</label>\n                    <input name="name" id="inputUrl" class="form-control" type="text" ng-model="ptzPresetsDialog.preset.name" md-maxlength="32" required md-autofocus ng-pattern="/^[a-zA-Z0-9 ]+$/" autocorrect="off" autocapitalize="off" autocomplete="off">\n                    <div ng-messages="ptzPresetForm.name.$error" role="alert" multiple="multiple" ng-if="ptzPresetForm.name.$dirty">\n                        <div ng-message-exp="[\'required\']">{{ ::ptzPresetsDialog.msgs.presetNameIsRequired() }}</div>\n                        <div ng-message="md-maxlength">{{ ::ptzPresetsDialog.msgs.presetNameMustBe() }}</div>\n                        <div ng-message="pattern" class="my-message">{{ ::ptzPresetsDialog.msgs.invalidUserName() }}</div>\n                    </div>\n                </md-input-container>\n            </md-content>\n        </md-dialog-content>\n\n        <dialog-errors target-object="ptzPresetsDialog"></dialog-errors>\n        <md-dialog-actions>\n            <span flex></span>\n            <md-button ng-disabled="ptzPresetsDialog.processing" ng-click="ptzPresetsDialog.cancel()">{{ ::ptzPresetsDialog.msgs.cancel() }}</md-button>\n            <md-button class="md-raised md-primary" type="submit" ng-disabled="ptzPresetForm.$invalid || ptzPresetsDialog.processing || ptzPresetsDialog.preset.name.length < 1" ng-click="ptzPresetsDialog.savePreset()">\n                <span ng-hide="ptzPresetsDialog.processing">{{ptzPresetsDialog.saveText}}</span>\n                <md-progress-circular md-mode="indeterminate" md-diameter="25px" ng-if="ptzPresetsDialog.processing" style="margin:auto"></md-progress-circular>\n            </md-button>\n        </md-dialog-actions>\n    </form>\n</md-dialog>\n'
        }
        ,
        30816: e => {
            e.exports = '<div class="flex layout-column md-subhead ios-allow-drag">\n    <md-toolbar class="hide-xs md-whiteframe-2dp layout-row layout-align-center-center md-subhead" sing-translated-msg="player.ptzPresets"></md-toolbar>\n    <div ng-if="ptzPresetsContainer.camera.features.ptzPresets.length === 0" class="flex layout-column layout-align-center-center">\n        <i class="fa-regular fa-3x fa-bookmark"></i>\n        <span class="empty-state" sing-translated-msg="player.noSavedPresets"></span>\n    </div>\n    <div class="presets-wrapper">\n        <div ng-repeat="preset in ptzPresetsContainer.camera.features.ptzPresets | orderBy: \'name\'" ng-class="{ \'disabled\' : ptzPresetsContainer.moving, \'\' : !ptzPresetsContainer.moving }" class="layout-row layout-align-space-between-center ptz-presets-row">\n            <div ng-click="ptzPresetsContainer.selectPtzPreset(preset)" class="layout-padding flex md-truncate ptz-preset-name">\n                {{ preset.name && preset.name.length > 0 ? preset.name : ptzPresetsContainer.msgs.preset() + \' \' +\n                preset.token }}\n            </div>\n            <md-button ng-if="!ptzPresetsContainer.viewOnly" ng-click="ptzPresetsContainer.removePtzPreset(preset)" ng-disabled="ptzPresetsContainer.editing" class="flex-none md-icon-button">\n                <i class="fa-regular fa-trash-can"></i>\n            </md-button>\n        </div>\n    </div>\n</div>\n\n<div ng-if="!ptzPresetsContainer.viewOnly" class="md-whiteframe-3dp layout-row layout-align-center-center ptz-presets-footer-container">\n    <md-button ng-click="ptzPresetsContainer.newPtzPreset($event)" ng-disabled="ptzPresetsContainer.moving || ptzPresetsContainer.camera.ptzPresets.length >= ptzPresetsContainer.maxPtzPresets || ptzPresetsContainer.editing" class="md-raised md-primary" layout="row" layout-align="center center" flex-grow>\n        <span ng-hide="ptzPresetsContainer.editing || ptzPresetsContainer.moving" layout="row" layout-align="center center" flex-grow><i class="fa fa-lg fa-save"></i>{{ ::ptzPresetsContainer.msgs.save() }}</span>\n        <md-progress-circular ng-if="ptzPresetsContainer.editing || ptzPresetsContainer.moving" md-diameter="20" md-mode="indeterminate">\n        </md-progress-circular>\n    </md-button>\n</div>\n'
        }
        ,
        19602: e => {
            e.exports = '<md-toolbar>\n    <div class="md-toolbar-tools">\n        <h2>{{ ::bandwidthExplain.msgs.problemsStreamingVideo() }}</h2>\n        <span flex></span>\n        <md-button class="md-icon-button" ng-click="bandwidthExplain.close()">\n            <i class="fa fa-times fa-2x"></i>\n        </md-button>\n    </div>\n</md-toolbar>\n<md-dialog-content layout-padding>\n    <p>{{ ::bandwidthExplain.msgs.bandwidthIssuesForCam() }}</p>\n    <ul style="padding-left: 25px">\n        <li>{{ ::bandwidthExplain.msgs.insufficientUploadSpeed() }}</li>\n        <li>{{ ::bandwidthExplain.msgs.insufficientDownloadSpeed() }}</li>\n        <li>{{ ::bandwidthExplain.msgs.insufficientProcessingSpeed() }}</li>\n    </ul>\n    <p>{{ ::bandwidthExplain.msgs.troubleshootingSteps() }}</p>\n    <ul style="padding-left: 25px">\n        <li>{{ ::bandwidthExplain.msgs.tryDecreasingBitrate() }}</li>\n        <li ng-show="bandwidthExplain.showLBM">{{ ::bandwidthExplain.msgs.ifAllEleseFailsLowB() }}</li>\n    </ul>\n</md-dialog-content>\n<md-dialog-actions layout="row">\n    <md-button ng-click="bandwidthExplain.dismiss()">\n        <span class="hide-xs hide-sm">{{ ::bandwidthExplain.msgs.hideTheseError() }}</span>\n        <span class="hide-gt-sm">{{ ::bandwidthExplain.msgs.hide() }}</span>\n    </md-button>\n    <md-button ng-show="bandwidthExplain.showLBM" ng-click="bandwidthExplain.reloadLowBandwidth()">\n        <span class="hide-xs hide-sm">{{ ::bandwidthExplain.msgs.reloadPlayerInLowBandwidthMode() }}</span>\n        <span class="hide-gt-sm">{{ ::bandwidthExplain.msgs.reload() }}</span>\n    </md-button>\n    <span flex></span>\n    <md-button class="md-raised md-primary" ng-click="bandwidthExplain.close()">\n        {{ ::bandwidthExplain.msgs.ok() }}\n    </md-button>\n</md-dialog-actions>\n'
        }
        ,
        78900: e => {
            e.exports = '<div ng-show="$ctrl.showWarning && !$ctrl.suppressBandwidthWarning" class="warning-message">\n    {{ ::$ctrl.msgs.alertSlowNetwork() }}\n    <a href="#" ng-click="$ctrl.showBandwidthExplanation($event)">{{ ::$ctrl.msgs.learnMore() }}</a>\n</div>\n'
        }
        ,
        70791: e => {
            e.exports = '<div ng-repeat="key in $ctrl.keys">\n    <div ng-if="!$ctrl.isObject($ctrl.value[key]) && !$ctrl.isArray($ctrl.value[key])" class="md-caption margin-bottom-4">\n        {{ ::key }} : {{ $ctrl.value[key] }}\n    </div>\n    <div ng-if="$ctrl.isArray($ctrl.value[key])">\n        <div ng-model="expanded" ng-click="$ctrl.expandAll ? false : expanded = !expanded" class="layout-row layout-align-start-center stats-header">\n            <span class="md-subhead">\n                {{ ::key }}\n            </span>\n            <i ng-if="!$ctrl.expandAll" ng-class="{ \'expanded\': $ctrl.expandAll ? true : expanded}" class="fa fa-chevron-right toggle"> </i>\n        </div>\n        <div ng-if="$ctrl.expandAll ? true : expanded" ng-repeat="item in $ctrl.value[key] track by $index" class="md-caption margin-bottom-4 stats-indented">\n            <div ng-if="$ctrl.isObject(item)">\n                <stats-for-nerds ng-if="$ctrl.expandAll ? true : expanded" value="item"> </stats-for-nerds>\n            </div>\n            <div ng-if="!$ctrl.isObject(item)">\n                {{ item }}\n            </div>\n        </div>\n    </div>\n    <div ng-if="$ctrl.isObject($ctrl.value[key])">\n        <div ng-model="expanded" ng-click="$ctrl.expandAll ? false : expanded = !expanded" class="layout-row layout-align-start-center stats-header">\n            <span class="md-subhead">\n                {{ ::key }}\n            </span>\n            <i ng-if="!$ctrl.expandAll" ng-class="{ \'expanded\': expanded }" class="fa fa-chevron-right toggle"> </i>\n        </div>\n        <stats-for-nerds ng-if="$ctrl.expandAll ? true : expanded" value="$ctrl.value[key]" class="stats-indented"> </stats-for-nerds>\n    </div>\n</div>\n'
        }
        ,
        52386: e => {
            e.exports = '<md-dialog class="sing-save-confirm-dialog _md md-transition-in" md-theme="{{$ctrl.theme}}">\n    <md-toolbar class="orchid-toolbar">\n        <div class="md-toolbar-tools">\n            <h2 class="sing-save-confirm-dialog-title" sing-translated-msg="propertyEditor.dialogs.saving.title"></h2>\n        </div>\n    </md-toolbar>\n    <md-dialog-content>\n        <div class="md-dialog-content">\n            <controlled-server-shutdown cardless></controlled-server-shutdown>\n        </div>\n    </md-dialog-content>\n</md-dialog>\n'
        }
        ,
        8986: e => {
            e.exports = '<section class="admin-section">\n    <navigation display="left" ng-if="::propertyEditor.isOrchid"></navigation>\n    <md-content class="admin-content centered overflow-x-hidden">\n        <server-tagging [discoverable-orchid-id]="propertyEditor.orchid.discoverableOrchid.id" [orchid]="propertyEditor.orchid" [recorder-id]="propertyEditor.orchid.id" [recorder-uri]="propertyEditor.orchid.uri" [recorder-version]="propertyEditor.orchid.version" [tags]="propertyEditor.serverTags" (on-tags-changed)="propertyEditor.updateServerTags($event)"></server-tagging>\n\n        <div class="properties-editor-container">\n            <property-editor-init>\n                <page-loading progress="propertyEditor.initProgress" error="propertyEditor.actionError">\n                    <div class="col-sm-12">\n                        <h3 sing-translated-msg="propertyEditor.failedToLoadPropertyFileData"></h3>\n                        <p class="text-danger" sing-translated-msg="propertyEditor.theFollowingErrorOccurred"></p>\n                        <p class="text-danger"><strong>{{propertyEditor.actionError}}</strong></p>\n                    </div>\n                </page-loading>\n                <property-editor-confirm></property-editor-confirm>\n                <form name="propertiesEditingForm" class="properties-form-container">\n                    <div class="properties-button" layout="column" layout-align="start end">\n                        <div layout="row" layout-align="end center" layout-wrap>\n                            <sing-button button-class="add-button" on-click="propertyEditor.addNewProperty()" button-disabled="propertyEditor.buttonsDisabled">\n                                <span hide-xs sing-translated-msg="propertyEditor.newProperty"></span>\n                                <span hide-gt-xs sing-translated-msg="propertyEditor.property"></span>\n                            </sing-button>\n                            <sing-button with-spinner button-class="save-button" on-click="propertyEditor.saveOrConfirmProperties($event)" button-disabled="propertyEditor.saveButtonDisabled(propertiesEditingForm)" show-spinner="propertyEditor.showingActionSpinner">\n                                <span hide-xs sing-translated-msg="propertyEditor.saveProperties"></span>\n                                <span hide-gt-xs sing-translated-msg="propertyEditor.save"></span>\n                            </sing-button>\n                        </div>\n                        <sing-action-error ng-if="!propertyEditor.actionFailed" clear-error="propertyEditor.clearActionErrors()" action-error="propertyEditor.actionError"></sing-action-error>\n                    </div>\n                    <md-card>\n                        <md-card-content class="property-editor-search-card-content">\n                            <search-bar class="property-editor-search-bar" [data]="propertyEditor.propertyNames" [search-placeholder]="propertyEditor.propertyMsgs.propertyPlaceholder" [search-label]="propertyEditor.propertyMsgs.propertyLabel" [search-mode]="propertyEditor.searchMode" (filtered-data)="propertyEditor.updateFilteredData($event)" [(search-terms)]="propertyEditor.searchTerms"></search-bar>\n                        </md-card-content>\n                    </md-card>\n                    <error-banner ng-if="propertyEditor.propertiesDisplay.length === 0" [type]="\'empty-search\'"></error-banner>\n                    <md-card>\n                        <ul class="property-list property-list-divider" ng-if="propertyEditor.propertiesDisplay.length !== 0">\n                            <li ng-repeat="property in propertyEditor.propertiesDisplay track by property.id" ng-class="{ \'locked\': property.locked, \'custom-prop-flex\': property.custom, hidden: propertyEditor.getHiddenClass(property)}" class="property-list-item" layout="row" layout-xs="column" layout-sm="column" layout-align="start center" layout-align-xs="start start" layout-align-sm="start start" layout-wrap>\n                                <div flex="5" flex-xs="100" flex-sm="100" class="property-buttons">\n                                    <span>\n                                        <i class="locked-icon fa fa-lock" ng-if="::property.locked"></i>\n                                        <md-checkbox class="property-active" ng-model="property.active" name="{{ ::property.activeKey }}" ng-if="::!property.locked" validate-property-active-state="property">\n                                        </md-checkbox>\n                                        <md-tooltip md-autohide md-delay="1000" md-direction="{{propertyEditor.isSmallScreen() ? \'right\' : \'top\'}}">{{ propertyEditor.getTooltipText(property) }}</md-tooltip>\n                                    </span>\n                                </div>\n                                <p flex="50" flex-xs="100" flex-sm="100" class="property-name" ng-if="::!property.custom">\n                                    <b>{{::property.name}}</b>\n                                </p>\n                                <md-input-container flex="40" flex-xs="100" flex-sm="100" class="property-name md-block" ng-if="::property.custom" md-no-float>\n                                    <input name="{{ ::property.nameKey }}" ng-model="property.name" validate-property-name="property" validate-property-input-characters="{regex: \'.*[\\\\s:=].*\', invalid: true, property: property}" type="text" placeholder="{{ ::propertyEditor.propertyMsgs.propertyNamePlaceholder }}" aria-label="{{ ::propertyEditor.propertyMsgs.propertyNamePlaceholder }}" ng-change="propertyEditor.updateNames(propertiesEditingForm, $index)">\n                                    <div ng-messages="propertiesEditingForm[property.nameKey].$error" role="alert" multiple="multiple">\n                                        <span ng-message="uniquePropertyName" sing-translated-msg="propertyEditor.aPropertyWithThisNameAlreadyExists"></span>\n                                        <span ng-message="propertyNameNotEmpty" sing-translated-msg="propertyEditor.thisPropertyIsMarkedAsActiveButHasNoName"></span>\n                                        <span ng-message="propertyPrefixValid" sing-translated-msg="propertyEditor.thisPropertyHasInvalidPrefix"></span>\n                                        <span ng-message="badCharacters" sing-translated-msg="propertyEditor.badCharsPropertyInput.name"></span>\n                                    </div>\n                                </md-input-container>\n                                <md-input-container class="property-value md-block" flex="40" flex-xs="100" flex-sm="100" md-no-float ng-if="::property.showInput">\n                                    <input name="{{ ::property.valueKey }}" ng-disabled="::property.locked" ng-model="property.value" validate-property-value="property" validate-property-input-characters="{regex: \'.*[\\\\n\\\\r\\\\b].*\', invalid: true, property: property}" type="text" placeholder="{{ ::propertyEditor.propertyMsgs.propertyValuePlaceholder }}" aria-label="{{ ::propertyEditor.propertyMsgs.propertyValuePlaceholder }}">\n                                    <div ng-messages="propertiesEditingForm[property.valueKey].$error" role="alert" multiple="multiple">\n                                        <span ng-message="propertyValueNotEmpty" sing-translated-msg="propertyEditor.thisPropertyIsMarkedAsActiveButHasNoValue"></span>\n                                        <span ng-message="badCharacters" sing-translated-msg="propertyEditor.badCharsPropertyInput.value"></span>\n                                    </div>\n                                </md-input-container>\n                                <div ng-if="::!property.showInput" class="property-value md-block" flex="40" flex-xs="100" flex-sm="100" md-no-float></div>\n                                <span ng-if="::property.custom" class="delete-custom-prop-container">\n                                    <md-button class="md-icon-button delete-custom-prop" ng-click="propertyEditor.removeCustomProperty($index, propertiesEditingForm)">\n                                        <i class="fa-regular fa-trash-can"></i>\n                                    </md-button>\n                                    <md-tooltip md-autohide md-delay="1000" md-direction="{{propertyEditor.isSmallScreen() ? \'right\' : \'top\'}}" sing-translated-msg="propertyEditor.removeCustomProperty"></md-tooltip>\n                                </span>\n                                <p class="property-description" flex="100">{{::property.description}}</p>\n                            </li>\n                        </ul>\n                    </md-card>\n                </form>\n            </property-editor-init>\n        </div>\n    </md-content>\n</section>\n'
        }
        ,
        50127: e => {
            e.exports = '<md-card style="min-height: 400px; padding: 40px;" layout="column" layout-align="center center">\n    <p sing-translated-msg="propertyEditor.dialogs.confirm.body"></p>\n    <div class="properties-button" layout="column" layout-align="start end">\n        <div layout="row" layout-align="start center" layout-wrap>\n            <sing-button with-spinner button-class="confirm-properties-button" on-click="$ctrl.confirmProperties()" button-disabled="$ctrl.showingActionSpinner" show-spinner="$ctrl.showingActionSpinner">\n                <span sing-translated-msg="propertyEditor.confirmProperties"></span>\n            </sing-button>\n        </div>\n        <sing-action-error ng-if="$ctrl.actionFailed" clear-error="$ctrl.clearActionErrors()" action-error="$ctrl.actionError"></sing-action-error>\n    </div>\n</md-card>\n'
        }
        ,
        62532: e => {
            e.exports = '<section layout="row" class="admin-section" flex>\n    <navigation display="left" ng-if="retentionPolicy.isOrchid"></navigation>\n    <md-content class="admin-content centered">\n        <div class="centered" ng-if="retentionPolicy.processing">\n            <page-loading progress="retentionPolicy.msgs.loading()"> </page-loading>\n        </div>\n\n        <md-card class="system-reports-container admin-card" ng-if="retentionPolicy.processing === false">\n            <div>\n                <form name="retentionPolicyForm" class="row retention-policy">\n                    <processing-shade show="retentionPolicy.processing"></processing-shade>\n\n                    <div ng-show="retentionPolicy.processingFailed === true" ng-cloak>\n                        <div class="col-sm-12">\n                            <h3>{{ ::retentionPolicy.msgs.failedPolicyData() }}</h3>\n                            <p class="text-danger">{{ ::retentionPolicy.msgs.failedTheError() }}</p>\n                            <p class="text-danger"><strong>{{retentionPolicy.processingFailedMessage}}</strong></p>\n                        </div>\n                    </div>\n\n                    <div ng-show="retentionPolicy.processing === false && retentionPolicy.processingFailed === false && retentionPolicy.retentionData.cameras.length === 0" ng-cloak>\n                        <div class="col-sm-12">\n                            <h3>{{ ::retentionPolicy.msgs.noCamerasConfigured() }}</h3>\n                            <p>{{ ::retentionPolicy.msgs.noCamerasFix() }}</p>\n                        </div>\n                    </div>\n                    <div ng-show="retentionPolicy.processing === false && retentionPolicy.processingFailed === false && retentionPolicy.retentionData.cameras.length > 0" ng-cloak>\n                        <div>\n                            <div class="col-sm-12">\n                                <h1 style="font-size: 19px; margin-top: 6px">{{ ::retentionPolicy.msgs.header() }}</h1>\n                                <div class="utes-bar" ng-show="retentionPolicy.retentionData.estimatedStorageUsage + retentionPolicy.retentionData.unavailable <= retentionPolicy.retentionData.storageThreshold + 1">\n                                    <uib-progress class="progress-striped" progressbar-threshold="retentionPolicy.retentionData.thresholdPercentage">\n                                        <uib-bar value="retentionPolicy.retentionData.unavailablePercentage" type="dull" title="{{ ::retentionPolicy.msgs.unusableSpace() }} - {{retentionPolicy.retentionData.unavailable | bytes}}"></uib-bar>\n                                        <uib-bar ng-repeat="camera in retentionPolicy.retentionData.cameras" value="camera.bytesEstimatedPercentage" class="color-{{camera.id % 26 ? camera.id % 26 : 1 }} {{retentionPolicy.getBorderClass($index)}}" title="{{camera.name}} - {{camera.bytesEstimated | bytes}}"></uib-bar>\n                                    </uib-progress>\n                                    <div class="bar-legend-container">\n                                        <div class="legend-item">\n                                            <div class="legend-box progress-bar-dull"></div>\n                                            <div>\n                                                {{ ::retentionPolicy.msgs.unavailableSpace({ VALUE:\n                                                retentionPolicy.retentionData.unavailablePiped }) }}\n                                            </div>\n                                        </div>\n                                        <div class="legend-item">\n                                            <div class="threshold-icon"></div>\n                                            <div>\n                                                {{ ::retentionPolicy.msgs.maxArchiveThreshold({ VALUE:\n                                                retentionPolicy.retentionData.cleanerThresholdPiped }) }}\n                                            </div>\n                                        </div>\n                                        <div class="legend-item">\n                                            <div class="legend-box legend-container"></div>\n                                            <div>\n                                                {{ retentionPolicy.msgs.freeSpace({ VALUE:\n                                                retentionPolicy.retentionData.maxUsagePiped }) }}\n                                            </div>\n                                        </div>\n                                    </div>\n                                </div>\n                                <div class="utes-bar" ng-show="retentionPolicy.retentionData.estimatedStorageUsage + retentionPolicy.retentionData.unavailable > retentionPolicy.retentionData.storageThreshold + 1">\n                                    <uib-progress class="progress-striped" progressbar-threshold="retentionPolicy.retentionData.thresholdPercentage">\n                                        <uib-bar value="retentionPolicy.retentionData.estimatedStorageUsagePercentage" style="background-color: #cc0000"></uib-bar>\n                                    </uib-progress>\n                                    <p class="text-danger" sing-translated-msg="retentionPolicy.currentConfigNotPossible"></p>\n                                    <p class="text-danger" ng-show="retentionPolicy.licenseSession.license.edition === \'trial\'" sing-translated-msg="retentionPolicy.expandThreshPleaseActivate"></p>\n                                </div>\n                                <div class="retention-bulk-update-container">\n                                    <retention-bulk-update [disabled]="retentionPolicy.isRetentionBulkUpdaterDisabled()" [resetter]="retentionPolicy.bulkUpdateResetter$" (bulk-update)="retentionPolicy.retentionBulkUpdate($event.updateType, $event.updateVal, retentionPolicyForm)"></retention-bulk-update>\n                                </div>\n                            </div>\n\n                            <div>\n                                <md-card>\n                                    <table class="orchid-table striped-table responsive-table-550" md-table>\n                                        <thead md-head>\n                                            <tr md-row>\n                                                <th md-column>{{ ::retentionPolicy.msgs.camera() }}</th>\n                                                <th md-column>{{ ::retentionPolicy.msgs.estimatedRetention() }}</th>\n                                                <th md-column>{{ ::retentionPolicy.msgs.desiredRetention() }}</th>\n                                            </tr>\n                                        </thead>\n                                        <tbody md-body>\n                                            <tr ng-repeat="camera in retentionPolicy.retentionData.cameras | orderBy : sortingCameraNames track by $index" md-row>\n                                                <td data-title="{{ ::retentionPolicy.msgs.camera() }}" class="camera-name" md-cell>\n                                                    <div class="camera-label">\n                                                        <div>\n                                                            <span class="legend-box color-{{camera.id % 26 ? camera.id % 26 : 1 }}"></span>\n                                                        </div>\n                                                        <span class="name-text" ng-class="{ \'is-disabled\' : !retentionPolicy.isCameraActive(camera.id) }">\n                                                            <i ng-if="!retentionPolicy.isCameraActive(camera.id)" ng-class="retentionPolicy.disabledCameraIcon">\n                                                            </i>\n                                                            <md-tooltip md-direction="top" md-autohide md-delay="500">\n                                                                {{camera.name}}\n                                                            </md-tooltip>\n                                                            {{camera.name}}\n                                                        </span>\n                                                    </div>\n                                                </td>\n                                                <td data-title="{{ ::retentionPolicy.msgs.estimatedRetention() }}" md-cell class="camera-retention">\n                                                    <p class="camera-retention-value" ng-if="camera.isRecording && !camera.isNewCamera">\n                                                        {{ retentionPolicy.msgs.days({ VALUE: camera.daysEstimated }) }}\n                                                        ({{ retentionPolicy.msgs.slashDay({ VALUE:\n                                                        camera.bytesEstimatedPerDayPiped }) }})\n                                                        {{camera.recordingStyle.id ===\n                                                        retentionPolicy.RecordingStyleId.MOTION_ONLY ? \'**\' : \'\'}}\n                                                    </p>\n\n                                                    <p class="camera-retention-value" ng-if="camera.isRecording === false">\n                                                        {{ retentionPolicy.msgs.noStreamsAreRecording() }}\n                                                    </p>\n                                                    <p class="camera-retention-value" ng-if="camera.isRecording && camera.isNewCamera">\n                                                        {{ retentionPolicy.msgs.notEnoughRetentionHistory() }}\n                                                    </p>\n                                                </td>\n                                                <td data-title="{{ ::retentionPolicy.msgs.desiredRetention() }}" md-cell ng-class="{ \'has-error\': retentionPolicyForm[\'override\' + $index].$invalid }">\n                                                    <md-button class="md-primary" ng-disabled="camera.isRecording === false || !retentionPolicy.isCameraActive(camera.id)" ng-if="!camera.override" ng-click="retentionPolicy.toggleRetentionOverride(camera, retentionPolicyForm)">{{ ::retentionPolicy.msgs.automatic() }}</md-button>\n\n                                                    <div class="retention-override" ng-if="camera.override" style="width: 115px">\n                                                        <md-input-container>\n                                                            <input style="width: 60px" class="form-control" name="override{{$index}}" type="number" min="0" max="10000" required ng-change="retentionPolicy.recalculateEstimates(true)" ng-blur="retentionPolicy.setRetentionToAutomaticIfZero(camera, retentionPolicyForm)" ng-model="camera.daysDesired" ng-disabled="camera.isRecording === false">\n                                                        </md-input-container>\n                                                        <md-button class="md-icon-button" ng-disabled="camera.isRecording === false" ng-click="retentionPolicy.toggleRetentionOverride(camera, retentionPolicyForm)"><i class="fa fa-times"></i></md-button>\n                                                    </div>\n\n                                                    <span class="text-danger" ng-show="camera.override && retentionPolicyForm[\'override\' + $index].$invalid">\n                                                        {{ ::retentionPolicy.msgs.minMax() }}\n                                                    </span>\n                                                </td>\n                                            </tr>\n                                        </tbody>\n                                    </table>\n                                </md-card>\n                                <div class="row" ng-show="retentionPolicy.processingSaveFailed">\n                                    <div class="col-xs-12 text-danger">\n                                        <p>{{retentionPolicy.processingSaveFailedMessage}}</p>\n                                    </div>\n                                </div>\n                                <div class="form-group">\n                                    <spinner-button class="save-button" [text]="retentionPolicy.msgs.saveConfig()" [disabled]="retentionPolicy.processingSave || !retentionPolicyForm.$dirty || retentionPolicyForm.$invalid" ng-click="retentionPolicy.saveConfiguration(retentionPolicyForm)" [show-spinner]="retentionPolicy.processingSave">\n                                    </spinner-button>\n                                    <spinner-button class="cancel-button" ng-click="retentionPolicy.revertChanges(retentionPolicyForm)" [disabled]="retentionPolicy.processingSave || !retentionPolicyForm.$dirty" [text]="retentionPolicy.msgs.cancelChanges()">\n                                    </spinner-button>\n                                </div>\n                            </div>\n                            <p class="motion-note">\n                                * {{ ::retentionPolicy.msgs.retentionEstimatesAreBasedOnLast24Hours() }}\n                            </p>\n                            <p ng-if="retentionPolicy.hasMotionOnlyStreams" class="motion-note">\n                                ** {{\n                                ::retentionPolicy.msgs.retentionEstimatesAssumeConstantMotionForStreamsConfiguredToRecordMotionOnly()\n                                }}\n                            </p>\n                        </div>\n                    </div>\n                </form>\n            </div>\n        </md-card>\n        <md-card ng-show="retentionPolicy.retentionData.storageThreshold" ng-cloak class="system-reports-container admin-card">\n            <div style="padding: 12px">\n                <div class="col-sm-12">\n                    <h3>{{ ::retentionPolicy.msgs.currentDiskUsage() }}</h3>\n                    <div class="utes-bar">\n                        <uib-progress class="progress-striped" progressbar-threshold="retentionPolicy.retentionData.thresholdPercentage">\n                            <uib-bar value="retentionPolicy.retentionData.unavailablePercentage" type="dull" title="{{ ::retentionPolicy.msgs.unavailableSpaceTitle() }} - {{retentionPolicy.retentionData.unavailable | bytes}}"></uib-bar>\n                            <uib-bar value="retentionPolicy.retentionData.bytesFromDeletedCamerasPercentage" style="background-color: #3f3f3f" title="{{ ::retentionPolicy.msgs.deletedCameras() }} - {{retentionPolicy.retentionData.bytesFromDeletedCameras | bytes}}"></uib-bar>\n                            <uib-bar ng-repeat="camera in retentionPolicy.retentionData.cameras" value="camera.bytesRecordedPercentage" class="color-{{camera.id % 26 ? camera.id % 26 : 1 }} {{retentionPolicy.getBorderClass($index)}}" title="{{camera.name}} - {{camera.bytesRecorded | bytes}}"></uib-bar>\n                        </uib-progress>\n                        <div class="bar-legend-container">\n                            <div class="legend-item">\n                                <div class="legend-box progress-bar-dull"></div>\n                                <div>\n                                    {{ retentionPolicy.msgs.unavailableSpace({ VALUE:\n                                    retentionPolicy.retentionData.unavailablePiped }) }}\n                                </div>\n                            </div>\n                            <div class="legend-item" ng-show="retentionPolicy.retentionData.bytesFromDeletedCameras > 0">\n                                <div class="legend-box" style="background-color: #3f3f3f"></div>\n                                <div>\n                                    {{ retentionPolicy.msgs.usedByDeletedCams({ VALUE:\n                                    retentionPolicy.retentionData.bytesFromDeletedCamerasPiped }) }}\n                                </div>\n                            </div>\n                            <div class="legend-item">\n                                <div class="threshold-icon"></div>\n                                <div>\n                                    {{ retentionPolicy.msgs.maxArchiveThreshold({ VALUE:\n                                    retentionPolicy.retentionData.cleanerThresholdPiped }) }}\n                                </div>\n                            </div>\n                            <div class="legend-item">\n                                <div class="legend-box legend-container"></div>\n                                <div>\n                                    {{ retentionPolicy.msgs.freeSpace({ VALUE: retentionPolicy.retentionData.freePiped\n                                    }) }}\n                                </div>\n                            </div>\n                        </div>\n                    </div>\n                </div>\n\n                <div class="col-sm-12">\n                    <div ng-if="retentionPolicy.retentionData.cameras.length === 0" style="padding-top: 20px">\n                        {{ ::retentionPolicy.msgs.noCamerasConfigured() }}\n                    </div>\n\n                    <md-card style="margin-left: 0; margin-right: 0" ng-if="retentionPolicy.retentionData.cameras.length > 0">\n                        <table md-table class="orchid-table striped-table responsive-table-550">\n                            <thead md-head>\n                                <tr md-row>\n                                    <th md-column>{{ ::retentionPolicy.msgs.camera() }}</th>\n                                    <th md-column>{{ ::retentionPolicy.msgs.actualRetention() }}</th>\n                                    <th md-column>{{ ::retentionPolicy.msgs.retentionSpan() }}</th>\n                                </tr>\n                            </thead>\n                            <tbody md-body>\n                                <tr ng-repeat="camera in retentionPolicy.retentionData.cameras | orderBy : sortingCameraNames " md-row>\n                                    <td data-title="{{ ::retentionPolicy.msgs.camera() }}" class="camera-name" md-cell>\n                                        <div class="camera-label">\n                                            <div>\n                                                <span class="legend-box color-{{camera.id % 26 ? camera.id % 26 : 1 }}"></span>\n                                            </div>\n                                            <span class="name-text" ng-class="{ \'is-disabled\' : !retentionPolicy.isCameraActive(camera.id) }">\n                                                <i ng-if="!retentionPolicy.isCameraActive(camera.id)" ng-class="retentionPolicy.disabledCameraIcon">\n                                                </i>\n                                                <md-tooltip md-direction="top" md-autohide md-delay="500">\n                                                    {{camera.name}}\n                                                </md-tooltip>\n                                                {{camera.name}}\n                                            </span>\n                                        </div>\n                                    </td>\n                                    <td data-title="{{ ::retentionPolicy.msgs.actualRetention() }}" md-cell class="camera-retention">\n                                        <p class="camera-retention-value">\n                                            {{ ::retentionPolicy.msgs.days({ VALUE: camera.daysRecorded }) }} {{\n                                            ::retentionPolicy.msgs.actualRetentionTotal({ VALUE:\n                                            camera.bytesRecordedPiped }) }}\n                                        </p>\n                                    </td>\n                                    <td ng-if="retentionPolicy.processing === false" data-title="{{ ::retentionPolicy.msgs.retentionSpan() }}" md-cell>\n                                        {{ ::retentionPolicy.msgs.days({ VALUE: camera.retentionSpanDays }) }}\n                                    </td>\n                                </tr>\n                            </tbody>\n                        </table>\n                    </md-card>\n                </div>\n            </div>\n        </md-card>\n    </md-content>\n</section>\n'
        }
        ,
        74817: e => {
            e.exports = '<section class="fusion-app" style="height: 100vh; overflow: hidden" ng-if="::$ctrl.isOrchid">\n    <md-content class="ui-view-container" style="height: 80vh; overflow: hidden">\n        <md-content class="centered" layout-margin layout-padding layout="column" layout-align="center center" style="height: inherit; overflow: hidden">\n            <p>{{$ctrl.body}}</p>\n            <md-progress-circular md-mode="indeterminate" md-diameter="75px"></md-progress-circular>\n        </md-content>\n    </md-content>\n</section>\n<section class="admin-section overflow-x-hidden" ng-if="::!$ctrl.isOrchid && $ctrl.showWithCard" style="padding: 40px">\n    <md-content style="min-height: 400px" class="admin-content centered overflow-x-hidden">\n        <md-card style="min-height: 400px" layout-margin layout-padding layout="column" layout-align="center center">\n            <p>{{$ctrl.body}}</p>\n            <md-progress-circular md-mode="indeterminate" md-diameter="75px"></md-progress-circular>\n        </md-card>\n    </md-content>\n</section>\n<div ng-if="::!$ctrl.isOrchid && !$ctrl.showWithCard" layout-margin layout-padding layout="column" layout-align="center center">\n    <p>{{$ctrl.body}}</p>\n    <md-progress-circular md-mode="indeterminate" md-diameter="75px"></md-progress-circular>\n</div>\n'
        }
        ,
        26574: e => {
            e.exports = '<md-button class="md-icon-button orchid-controlled-server-shutdown-alert" md-no-ink>\n    <i class="fa fa-refresh fa-spin" aria-hidden="true"></i>\n    <md-tooltip md-autohide md-delay="500" sing-translated-msg="serverShutdown.shutdownAlertTooltip"> </md-tooltip>\n</md-button>\n'
        }
        ,
        91090: e => {
            e.exports = '<player play-control="singlePlayer.playControl" id="{{ singlePlayer.containerId }}" orchid="singlePlayer.orchid" camera="singlePlayer.camera" stream-id="singlePlayer.streamId" options="singlePlayer.options" camera-name="{{ singlePlayer.cameraName }}" ng-if="singlePlayer.options && singlePlayer.orchid && singlePlayer.camera && singlePlayer.ready" class="pinned-header" do-not-start="singlePlayer.doNotStart" ng-class="{\'show-timeline\': singlePlayer.displayTimeline }">\n</player>\n\x3c!-- Note that the stage control is always present (ng-show is used instead of ng-if). This is so that we always have\na master timeline context which is required in order to have the player reconnect logic and set the start time with\nthe timeline hidden. Also the ng-show uses displayTimeline rather than options.showTimeline since this option must be\nset to true for single-player-mode for the same reasons. --\x3e\n<stage-control selection-mode="singlePlayer.selectionMode" hide-controls="!singlePlayer.options.showControls" ng-show="singlePlayer.displayTimeline && singlePlayer.ready"></stage-control>\n'
        }
        ,
        79871: e => {
            e.exports = '<md-dialog class="export-dialog">\n    <md-toolbar>\n        <div class="md-toolbar-tools">\n            <h2>{{ ::exportDialog.msgs.saveVideo() }}</h2>\n            <span flex></span>\n            <md-button class="md-icon-button" ng-click="exportDialog.close()">\n                <i class="fa fa-times fa-2x"></i>\n            </md-button>\n        </div>\n    </md-toolbar>\n\n    <md-dialog-content>\n        <div ng-if="exportDialog.orchidStreamPairs.length === 0">\n            <div class="p-24">\n                {{ ::exportDialog.msgs.unfortunatelyThereAreNoLinkedCamerasOnTheStageThatYouHavePermissionToSave() }}\n            </div>\n        </div>\n\n        <md-tabs md-dynamic-height="true" md-border-bottom md-selected="exportDialog.selectedTab" ng-class="{ \'no-library\': !exportDialog.showLibrary }" ng-if="exportDialog.orchidStreamPairs.length > 0">\n            <md-tab>\n                <md-tab-label> <i class="fa fa-download"></i>{{::exportDialog.msgs.download()}} </md-tab-label>\n                <md-tab-body>\n                    <div class="export-dialog-tab">\n                        <div ng-if="exportDialog.orchidStreamPairs.length > 0">\n                            <p class="info">\n                                {{ ::exportDialog.msgs.directlyDownloadExportedClips() }}\n                                <a class="text-link" href="javascript:void(0);" ng-click="exportDialog.showFormats = !exportDialog.showFormats">{{ ::exportDialog.msgs.learnMoreAboutFormats() }}</a>\n                            </p>\n                            <table md-table style="border: 1px solid #dfdfdf; margin-bottom: 15px" ng-show="exportDialog.showFormats">\n                                <thead md-head>\n                                    <tr md-row>\n                                        <th md-column colspan="2" style="text-align: left; padding-left: 24px">\n                                            {{ ::exportDialog.msgs.format() }}\n                                        </th>\n                                        <th md-column style="text-align: left">\n                                            {{ ::exportDialog.msgs.recommendedPlayers() }}\n                                        </th>\n                                    </tr>\n                                </thead>\n                                <tbody md-body>\n                                    <tr md-row>\n                                        <td md-cell>.mkv</td>\n                                        <td md-cell>{{ ::exportDialog.msgs.matroskaMultimediaContainer() }}</td>\n                                        <td md-cell>\n                                            <a class="text-link" href="http://www.videolan.org/vlc/" target="_blank" rel="noopener noreferrer">VideoLAN VLC</a>\n                                        </td>\n                                    </tr>\n                                    <tr md-row ng-if="exportDialog.browser.name !== \'Safari\' || exportDialog.canExportSafari">\n                                        <td md-cell>.mov</td>\n                                        <td md-cell>{{ ::exportDialog.msgs.quickTimeFileFormat() }}</td>\n                                        <td md-cell>\n                                            <a class="text-link" href="http://www.videolan.org/vlc/" target="_blank" rel="noopener noreferrer">VideoLAN VLC</a>\n                                        </td>\n                                    </tr>\n                                    <tr md-row>\n                                        <td md-cell>.html</td>\n                                        <td md-cell>{{ ::exportDialog.msgs.dewarpPlayerFormat() }}</td>\n                                        <td md-cell>\n                                            <a class="text-link" href="https://www.google.com/chrome/" target="_blank" rel="noopener noreferrer">Chrome</a>,\n                                            <a class="text-link" href="https://www.mozilla.org/en-US/firefox/" target="_blank" rel="noopener noreferrer">Firefox</a>\n                                        </td>\n                                    </tr>\n                                </tbody>\n                            </table>\n                        </div>\n                        <div class="full-width-date">\n                            <div class="date-row">\n                                <label class="inside">{{ ::exportDialog.msgs.from()}}</label>\n                                <md-button class="inside md-raised md-primary" ng-click="exportDialog.showDateTimePicker(false)">\n                                    <i class="calendar-icon fa-regular fa-calendar-days"></i>\n                                    {{ exportDialog.startTime | date:exportDialog.dateTimeFormat }}\n                                </md-button>\n                            </div>\n                            <div class="date-row">\n                                <label class="inside">{{ ::exportDialog.msgs.to() }}</label>\n                                <md-button class="inside md-raised md-primary" ng-click="exportDialog.showDateTimePicker(true)">\n                                    <i class="calendar-icon fa-regular fa-calendar-days"></i>\n                                    {{ exportDialog.stopTime | date:exportDialog.dateTimeFormat }}\n                                </md-button>\n                            </div>\n                            <div class="duration-text">\n                                <span ng-if="exportDialog.stopTimeEpoch > exportDialog.startTimeEpoch">\n                                    ({{exportDialog.stopTimeEpoch - exportDialog.startTimeEpoch | timeDuration : true}})\n                                </span>\n                            </div>\n                        </div>\n                        <div class="warn" ng-if="exportDialog.error">{{exportDialog.error}}</div>\n                        <div class="preview export">\n                            <div class="exports card-grid">\n                                <md-card class="export-preview full-card" ng-repeat="pair in exportDialog.orchidStreamPairs">\n                                    <md-card-content>\n                                        <div class="card-header" ng-class="{ \'fusion-header\': !exportDialog.isOrchid }">\n                                            <div class="stream-label-container">\n                                                \x3c!-- orchid name --\x3e\n                                                <div class="ellipsis stream-label" ng-hide="exportDialog.isOrchid">\n                                                    {{pair.orchid.name}}\n                                                </div>\n                                                \x3c!-- camera name --\x3e\n                                                <div class="ellipsis stream-label">{{pair.camera.name}}</div>\n                                            </div>\n\n                                            \x3c!-- stream selection menu --\x3e\n                                            <md-menu ng-class="{ \'hidden\': pair.streamOptions.length < 2 }" md-position-mode="right bottom" md-offset="-16 -8">\n                                                \x3c!-- trigger --\x3e\n                                                <md-button class="md-icon-button export-stream-menu-trigger" ng-click="$mdMenu.open($event)">\n                                                    <i class="fa fa-ellipsis-v"></i>\n                                                </md-button>\n\n                                                \x3c!-- menu content --\x3e\n                                                <md-menu-content class="export-stream-menu">\n                                                    \x3c!-- menu title --\x3e\n                                                    <md-menu-item md-autofocus="" class="menu-header">\n                                                        {{ ::exportDialog.msgs.availableStreams() }}\n                                                    </md-menu-item>\n\n                                                    \x3c!-- menu items --\x3e\n                                                    <md-menu-item ng-class="{ selected: option === pair.selectedDownloadOption }" ng-repeat="option in pair.streamOptions">\n                                                        <md-button ng-click="exportDialog.onDownloadOptionSelect(pair, option)">\n                                                            {{ option.name }}\n                                                            <i class="fa fa-lg fa-circle-check selected-icon" ng-class="{ invisible: option !== pair.selectedDownloadOption }"></i>\n                                                        </md-button>\n                                                    </md-menu-item>\n                                                </md-menu-content>\n                                            </md-menu>\n                                        </div>\n\n                                        <div class="preview-container">\n                                            <stream-preview class="card-preview-image" [orchid-id]="pair.orchid.id" [camera-id]="pair.camera.id" [is-camera-active]="pair.camera.active">\n                                            </stream-preview>\n\n                                            <div class="export-error" ng-if="pair.error">\n                                                <i class="fa fa-ban fa-3x">\n                                                    <md-tooltip md-direction="bottom">{{pair.error}}</md-tooltip>\n                                                </i>\n                                            </div>\n                                        </div>\n\n                                        <div class="card-actions">\n                                            <md-button class="md-raised md-primary" aria-label="{{ ::exportDialog.msgs.exportFileKind({ VALUE: \'.mkv\' }) }}" ng-click="exportDialog.exportStream(pair, \'mkv\')" ng-disabled="exportDialog.error || pair.error">\n                                                mkv\n                                            </md-button>\n\n                                            <md-button ng-if="exportDialog.browser.name !== \'Safari\' || exportDialog.canExportSafari" class="md-raised md-primary" aria-label="{{ ::exportDialog.msgs.exportFileKind({ VALUE: \'.mov\' }) }}" ng-click="exportDialog.exportStream(pair, \'mov\')" ng-disabled="exportDialog.error || pair.error">\n                                                mov\n                                            </md-button>\n\n                                            <md-button ng-if="exportDialog.hasDewarpOption && pair.isDewarp" class="md-raised md-primary" aria-label="{{ ::exportDialog.msgs.exportFileKind({ VALUE: \'.html\' }) }}" ng-click="exportDialog.exportStream(pair, \'dewarp\')" ng-disabled="exportDialog.error || pair.error">\n                                                {{ ::exportDialog.msgs.dewarp() }}\n                                            </md-button>\n                                        </div>\n                                    </md-card-content>\n                                </md-card>\n                            </div>\n                        </div>\n                        <div class="footer-warning">\n                            <i class="fa fa-circle-question tooltip-icon"></i>\n                            {{ ::exportDialog.msgs.theCameraStreamWithTheHighestResolutionAvailableIsPreSelected() }}\n                        </div>\n                    </div>\n                </md-tab-body>\n            </md-tab>\n            <md-tab ng-if="exportDialog.showLibrary" md-on-select="exportDialog.setLibraryFocus()">\n                <md-tab-label> <i class="fa fa-bookmark"></i>{{::exportDialog.msgs.library()}} </md-tab-label>\n                <md-tab-body>\n                    <div class="library export-dialog-tab">\n                        <p sing-translated-msg="library.storeClipsToViewAndDownloadLater" class="info"></p>\n                        <div class="full-width-item">\n                            <md-input-container class="full-width-item">\n                                <label>{{ ::exportDialog.msgs.libraryItemName() }}</label>\n                                <input class="library-focus" placeholder="{{::exportDialog.msgs.egParkingLotIncident()}}" ng-model="exportDialog.libraryItemName" ng-disabled="exportDialog.orchidStreamPairs.length === 0" required>\n                            </md-input-container>\n                        </div>\n                        <div class="full-width-date">\n                            <div class="date-row">\n                                <label class="inside">{{ ::exportDialog.msgs.from()}}</label>\n                                <md-button class="inside md-raised md-primary" ng-click="exportDialog.showDateTimePicker(false)">\n                                    <i class="calendar-icon fa-regular fa-calendar-days"></i>\n                                    {{ exportDialog.libraryStartTime | date:exportDialog.dateTimeFormat }}\n                                </md-button>\n                            </div>\n                            <div class="date-row">\n                                <label class="inside">{{ ::exportDialog.msgs.to() }}</label>\n                                <md-button class="inside md-raised md-primary" ng-click="exportDialog.showDateTimePicker(true)">\n                                    <i class="calendar-icon fa-regular fa-calendar-days"></i>\n                                    {{ exportDialog.libraryStopTime | date:exportDialog.dateTimeFormat }}\n                                </md-button>\n                            </div>\n                            <div class="duration-text">\n                                <span ng-if=" exportDialog.libraryStopTime > exportDialog.libraryStartTime">\n                                    ({{ exportDialog.libraryStopTime.getTime() - exportDialog.libraryStartTime.getTime()\n                                    | timeDuration : true}})\n                                </span>\n                            </div>\n                        </div>\n\n                        <div class="warn" ng-if="exportDialog.libraryError">{{exportDialog.libraryError}}</div>\n\n                        <div class="preview card-grid">\n                            <md-card ng-repeat="pair in exportDialog.orchidStreamPairs" class="export-preview full-card" ng-click="exportDialog.onLibraryCardClick(pair)" ng-class="{ \'disable-click\': pair.disableLibraryExport }">\n                                <md-card-content>\n                                    <div class="card-header">\n                                        <div class="stream-label-container">\n                                            \x3c!-- orchid name --\x3e\n                                            <div class="ellipsis stream-label">{{pair.orchid.name}}</div>\n                                            \x3c!-- camera name --\x3e\n                                            <div class="ellipsis stream-label">{{pair.camera.name}}</div>\n                                        </div>\n\n                                        \x3c!-- stream selection menu --\x3e\n                                        <md-menu ng-class="{ \'hidden\': pair.streamOptions.length < 2 }" md-position-mode="right bottom" md-offset="-16 -8">\n                                            \x3c!-- trigger --\x3e\n                                            <md-button class="md-icon-button export-stream-menu-trigger" ng-click="$mdMenu.open($event)">\n                                                <i class="fa fa-ellipsis-v"></i>\n                                            </md-button>\n\n                                            \x3c!-- menu content --\x3e\n                                            <md-menu-content class="export-stream-menu">\n                                                \x3c!-- menu title --\x3e\n                                                <md-menu-item md-autofocus="" class="menu-header">\n                                                    {{ ::exportDialog.msgs.availableStreams() }}\n                                                </md-menu-item>\n\n                                                \x3c!-- menu items --\x3e\n                                                <md-menu-item ng-class="{ selected: option === pair.selectedLibraryOption }" ng-repeat="option in pair.streamOptions">\n                                                    <md-button ng-click="exportDialog.onLibraryOptionSelect(pair, option)">\n                                                        {{ option.name }}\n                                                        <i class="fa fa-lg fa-circle-check selected-icon" ng-class="{ invisible: option !== pair.selectedLibraryOption }"></i>\n                                                    </md-button>\n                                                </md-menu-item>\n                                            </md-menu-content>\n                                        </md-menu>\n                                    </div>\n\n                                    <div class="preview-container">\n                                        <div class="library-error" ng-if="pair.libraryError" ng-class="{\'darken-preview\': pair.disableLibraryExport}">\n                                            <i class="fa fa-triangle-exclamation fa-2x">\n                                                <md-tooltip md-direction="bottom">{{pair.libraryError}}</md-tooltip>\n                                            </i>\n                                        </div>\n                                        <stream-preview class="card-preview-image" [orchid-id]="pair.orchid.id" [camera-id]="pair.camera.id" [is-camera-active]="pair.camera.active">\n                                        </stream-preview>\n                                    </div>\n                                    <div class="card-actions library-actions" ng-disabled="pair.disableLibraryExport">\n                                        <md-checkbox ng-model="pair.librarySelected" style="margin-top: 1px" ng-disabled="pair.disableLibraryExport" ng-click="pair.librarySelected = !pair.librarySelected">{{ exportDialog.msgs.addToLibrary() }}</md-checkbox>\n                                    </div>\n                                </md-card-content>\n                            </md-card>\n                        </div>\n                        <div class="footer-warning">\n                            <i class="fa fa-circle-question tooltip-icon"></i>\n                            {{ ::exportDialog.msgs.theCameraStreamWithTheHighestResolutionAvailableIsPreSelected() }}\n                        </div>\n                    </div>\n                </md-tab-body>\n            </md-tab>\n        </md-tabs>\n    </md-dialog-content>\n\n    <md-dialog-actions>\n        <div class="action" ng-if="exportDialog.selectedTab === 0">\n            <md-button ng-click="exportDialog.close()"> {{ ::exportDialog.msgs.done() }} </md-button>\n        </div>\n\n        <div class="action" ng-if="exportDialog.selectedTab === 1">\n            <md-button class="md-raised md-primary" ng-disabled="!exportDialog.isLibraryFormValid()" ng-click="exportDialog.saveToLibrary()">\n                {{ exportDialog.msgs.addToLibrary() }}\n            </md-button>\n            <md-button ng-click="exportDialog.close()"> {{ exportDialog.msgs.cancel() }} </md-button>\n        </div>\n    </md-dialog-actions>\n</md-dialog>\n'
        }
        ,
        55608: e => {
            e.exports = '<bag class="md-whiteframe-4dp ios-allow-drag collapsed" ng-style="{\'visibility\': stage.aPlayerIsFullscreen === true ? \'hidden\' : \'visible\'}" orchids="stage.orchids" selection-mode="stage.selectionMode" ng-class="{\'full-height\': stage.hideTimeline }"></bag>\n<speed-control></speed-control>\n<matrix ng-class="{\'full-height\': stage.hideTimeline }"></matrix>\n<stage-control selection-mode="stage.selectionMode" ng-show="!stage.hideTimeline"></stage-control>\n'
        }
        ,
        81708: e => {
            e.exports = '<div id="speed-control-container" ng-hide="stageControl.hideControls" ng-class="{ \'visible-speed-control-container\': stageControl.showSpeedControl, \'visibler-speed-control-container\': (stageControl.showSpeedControl && stageControl.selectionMode) }">\n    <div class="layout-row btn-group">\n        <button ng-model="stageControl.speedDirection" ng-click="stageControl.updateSpeed(-1)" uib-btn-radio="-1" md-ink-ripple class="flex-50 layout-column layout-align-center-center btn">\n            <i class="fa fa-caret-left"></i>\n        </button>\n        <button ng-model="stageControl.speedDirection" ng-click="stageControl.updateSpeed(1)" uib-btn-radio="1" md-ink-ripple class="flex-50 layout-column layout-align-center-center btn">\n            <i class="fa fa-caret-right"></i>\n        </button>\n    </div>\n    <rzslider rz-slider-model="stageControl.speedDisplay" rz-slider-options="stageControl.speedSliderOptions">\n    </rzslider>\n</div>\n\n<div ng-hide="stageControl.hideControls" class="layout-row layout-align-center-center button-container-left">\n    <md-button ng-click="stageControl.toggleSpeedControl()" ng-class="{ \'toggle-on\': stageControl.showSpeedControl }" class="md-icon-button speed-menu-toggle">\n        {{ stageControl.speedDirection !== 1 ? \'-\' : \'\' }}{{ stageControl.speedDisplay + \'x\' }}\n    </md-button>\n    <md-button ng-click="stageControl.nextMotionEvent(\'prev\')" ng-disabled="stageControl.processing" aria-label="{{ ::stageControl.msgs.previousMotionEvent() }}" class="md-icon-button prev-motion">\n        <i class="fa fa-step-backward md-title"></i>\n    </md-button>\n    <md-button ng-click="stageControl.togglePaused()" ng-disabled="stageControl.processing" aria-label="{{ ::stageControl.msgs.playPause() }}" ng-cloak ng-class="{ \'toggle-on\': stageControl.paused }" class="md-icon-button play-pause-button">\n        <i aria-label="{{ ::stageControl.msgs.play() }}" ng-show="stageControl.paused" class="fa fa-play md-title">\n        </i>\n        <i aria-label="{{ ::stageControl.msgs.pause() }}" ng-hide="stageControl.paused" class="fa fa-pause md-title">\n        </i>\n    </md-button>\n    <md-button ng-click="stageControl.nextMotionEvent(\'next\')" ng-disabled="stageControl.processing" aria-label="{{ ::stageControl.msgs.nextMotionEvent() }}" class="md-icon-button next-motion">\n        <i class="fa fa-step-forward md-title"></i>\n    </md-button>\n</div>\n\n\n<div flex>\n    <timeline context-id="\'master\'" selection-mode="stageControl.selectionMode">\n    </timeline>\n</div>\n\n<div ng-show="!stageControl.hideControls" class="layout-column layout-align-center-center button-container-right">\n    <div class="layout-row layout-align-center-center">\n        <md-button ng-click="stageControl.toggleSelectionMode()" aria-label="{{ ::stageControl.msgs.toggleSelectionMode() }}" ng-class="{ \'toggle-on\': stageControl.selectionMode }" class="md-icon-button hide-when-small">\n            <i ng-class="stageControl.selectionMode ? \'fa-chevron-down\' : \'fa-chevron-up\'" class="fa md-title">\n            </i>\n        </md-button>\n        <md-button ng-click="stageControl.showDatePicker($event)" aria-label="{{ ::stageControl.msgs.dateSearch() }}" class="md-icon-button date-search-button">\n            <i class="fa-regular fa-calendar md-title"></i>\n        </md-button>\n        <md-button ng-click="stageControl.exportVideo($event)" ng-disabled="!stageControl.canExport" aria-label="{{ ::stageControl.msgs.export() }}" class="md-icon-button export-button hide-when-small">\n            <i class="fa fa-download md-title"></i>\n        </md-button>\n    </div>\n    <div ng-show="stageControl.selectionMode" class="layout-row layout-align-center-center motion-seek-container">\n        <md-button ng-click="stageControl.scaleLeft()" class="md-icon-button motion-seek-control">\n            <i class="fa fa-minus"></i>\n        </md-button>\n        <span class="md-body-1 scale-index">\n            {{ stageControl.scales[stageControl.scaleIndex] }}\n        </span>\n        <md-button ng-click="stageControl.scaleRight()" class="md-icon-button motion-seek-control">\n            <i class="fa fa-plus"></i>\n        </md-button>\n    </div>\n</div>\n'
        }
        ,
        59040: e => {
            e.exports = '<section layout="row" class="admin-section" flex>\n    <navigation display="left" ng-if="systemReport.isOrchid"></navigation>\n\n    <md-content class="admin-content centered">\n        <md-card class="system-reports-container admin-card">\n            <h1>{{ ::systemReport.msgs.timeSelection() }}</h1>\n            <div ng-class="{ \'has-error\': systemReport.from > systemReport.to }" class="system-report-to-from-selection" layout="row" layout-align="start start">\n                <div layout="column">\n                    <p class="ipc-date-time-label" sing-translated-msg="system.from"></p>\n                    <p class="ipc-date-time-label" sing-translated-msg="system.to"></p>\n                </div>\n                <div layout="column">\n                    <md-button class="md-raised md-primary" ng-click="systemReport.showDateTimePicker(false)">\n                        <i class="calendar-icon fa-regular fa-calendar-days"></i>\n                        {{ systemReport.from | date:systemReport.dateTimeFormat }}\n                    </md-button>\n                    <md-button class="md-raised md-primary" ng-click="systemReport.showDateTimePicker(true)">\n                        <i class="calendar-icon fa-regular fa-calendar-days"></i>\n                        {{ systemReport.to | date:systemReport.dateTimeFormat }}\n                    </md-button>\n                </div>\n            </div>\n            <div class="warn-text" ng-if="systemReport.from > systemReport.to">\n                {{ systemReport.msgs.timeRangeErrorSystemReport() }}\n            </div>\n\n            <div style="position: relative">\n                <h1>{{ ::systemReport.msgs.serverEvents() }}</h1>\n                <div ng-show="systemReport.fetching" class="spinner" ng-cloak>\n                    <md-progress-circular md-diameter="25" md-mode="indeterminate"></md-progress-circular>\n                    <div style="padding-left: 15px">{{ ::systemReport.msgs.loading() }}</div>\n                </div>\n                <div ng-show="!systemReport.fetching && systemReport.events.length < 1" class="error-text" ng-cloak>\n                    {{ ::systemReport.msgs.noEventsForTimeRange() }}\n                </div>\n                <events-chart class="events-chart" ng-class="{ \'hide-chart\': systemReport.fetching || systemReport.events.length < 1 }" events="systemReport.events" to="systemReport.to" from="systemReport.from" on-point-click="systemReport.pointClick(events)" on-point-dblclick="systemReport.pointDblClick()"></events-chart>\n            </div>\n\n            <md-card ng-show="systemReport.selectedEvents.length > 0">\n                <table md-table class="striped-table orchid-table">\n                    <thead md-head>\n                        <tr md-row>\n                            <th md-column class="what">{{ ::systemReport.msgs.what() }}</th>\n                            <th md-column class="where">{{ ::systemReport.msgs.where() }}</th>\n                            <th md-column class="when">{{ ::systemReport.msgs.when() }}</th>\n                        </tr>\n                    </thead>\n                    <tbody md-body>\n                        <tr md-row ng-repeat="event in systemReport.selectedEvents | orderBy:\'when\'">\n                            <td class="what" md-cell>{{ event.what }}</td>\n                            <td class="where camera-name" md-cell>{{ event.descriptiveWhere }}</td>\n                            <td class="when" md-cell>{{ event.when | date: systemReport.dateFormat }}</td>\n                        </tr>\n                    </tbody>\n                </table>\n            </md-card>\n\n            <h1>{{ ::systemReport.msgs.streamStats() }}</h1>\n            <md-card>\n                <table md-table class="striped-table orchid-table responsive-table-600">\n                    <thead md-head>\n                        <tr md-row>\n                            <th md-column>{{ ::systemReport.msgs.cameraStream() }}</th>\n                            <th md-column>{{ ::systemReport.msgs.mbRecorded() }}</th>\n                            <th md-column>{{ ::systemReport.msgs.videoRecorded() }}</th>\n                            <th md-column>{{ ::systemReport.msgs.motionRecorded() }}</th>\n                        </tr>\n                    </thead>\n                    <tbody md-body>\n                        <tr md-row ng-repeat="stream in systemReport.streams | orderBy:sortingCameraNames ">\n                            <td data-title="{{ ::systemReport.msgs.cameraStream() }}" class="camera-name" md-cell>\n                                {{ stream.cameraName }} / {{ stream.name }}\n                            </td>\n                            <td data-title="{{ ::systemReport.msgs.mbRecorded() }}" md-cell>\n                                {{ (stream.bytesRecorded / 1024 / 1024) | number:0 }}\n                            </td>\n                            <td data-title="{{ ::systemReport.msgs.videoRecorded() }}" md-cell>\n                                {{ stream.secondsRecorded * 1000 | timeDuration:true:2 }}\n                            </td>\n                            <td data-title="{{ ::systemReport.msgs.motionRecorded() }}" md-cell>\n                                {{ stream.secondsOfMotion * 1000 | timeDuration:true:2 }}\n                            </td>\n                        </tr>\n                        <tr md-row ng-if="systemReport.streams.length < 1">\n                            <td md-cell colspan="4">{{ ::systemReport.msgs.noDataFroTimeRange() }}</td>\n                        </tr>\n\n                        <tr></tr>\n                    </tbody>\n                </table>\n            </md-card>\n        </md-card>\n\n        <md-card class="form-card admin-card">\n            <app-log-export [orchid]="systemReport.orchid"></app-log-export>\n        </md-card>\n    </md-content>\n</section>\n'
        }
        ,
        93898: e => {
            e.exports = '<div class="disk-utes-bar" ng-class="{ loading: loading }" ng-cloak ng-if="(diskUtilization.orchid.permissions === undefined || hasSessionId(orchid.id)) && diskUtilization.error === \'\' && !diskUtilization.loadingUtesBar">\n    <uib-progress style="margin-top: 20px" animate="true" progressbar-threshold="diskUtilization.thresholdPercentage" class="progress-striped" ng-class="{ active: diskUtilization.active, \'progress-paused\': !diskUtilization.animate }">\n        <uib-bar value="diskUtilization.percentageUsedByOthers" type="dull"></uib-bar>\n        <uib-bar value="diskUtilization.percentageUsedByOrchid" type="{{diskUtilization.type}}"></uib-bar>\n    </uib-progress>\n    <div class="bar-legend-container" ng-visible="!diskUtilization.active">\n        <div class="legend-item">\n            <div class="legend-box progress-bar-dull"></div>\n            <div>{{ ::diskUtilization.msgs.system.ofUnusableSpace({ VALUE: diskUtilization.usedByOthers }) }}</div>\n        </div>\n        <div class="legend-item">\n            <div class="legend-box progress-bar-success"></div>\n            <div>{{ ::diskUtilization.msgs.system.ofVideoData({ VALUE: diskUtilization.usedByOrchid }) }}</div>\n        </div>\n        <div class="legend-item">\n            <div class="threshold-icon"></div>\n            <div>{{ ::diskUtilization.msgs.retentionPolicy.maxArchiveThreshold({ VALUE: diskUtilization.threshold }) }}\n            </div>\n        </div>\n        <div class="legend-item">\n            <div class="legend-box legend-container"></div>\n            <div>{{::freeOutOf(diskUtilization.free, diskUtilization.capacity)}}</div>\n        </div>\n    </div>\n</div>\n\n\x3c!-- Displayed if there is no session id and we are in Fusion (permissions property is not \n    present on the Orchid object when in Orchid) --\x3e\n<div class="bar-legend-container" ng-if="diskUtilization.orchid.permissions === undefined || !hasSessionId(orchid.id) || diskUtilization.error !== \'\'">\n    <p class="error-text error-text-container">{{ diskUtilization.error }}</p>\n</div>\n\n<div ng-if="loading || diskUtilization.loadingUtesBar" class="utes-loading">\n    <md-progress-circular md-diameter="30" md-mode="indeterminate"></md-progress-circular>\n</div>\n'
        }
        ,
        24476: e => {
            e.exports = '<form>\n    <md-toolbar class="orchid-toolbar">\n        <div class="md-toolbar-tools">\n            <h2 class="md-title ng-binding">\n                {{ ::orchidBulkActionConfirm.msgs.replicationStrategyFor({ VALUE:\n                orchidBulkActionConfirm.user.username}) }}\n            </h2>\n            <span flex></span>\n            <md-button class="md-icon-button" ng-disabled="orchidBulkActionConfirm.processing" ng-click="orchidBulkActionConfirm.cancel()">\n                <i class="fa fa-times fa-2x"></i>\n            </md-button>\n        </div>\n    </md-toolbar>\n    <md-dialog-content class="bulk-action-dialog">\n        <md-content class="md-padding">\n            <p>\n                {{ ::orchidBulkActionConfirm.msgs.replicationStrategyFor({ VALUE:\n                orchidBulkActionConfirm.user.username}) }}\n            </p>\n            <md-card>\n                <table md-table>\n                    <thead md-head md-order="query.order" md-on-reorder="onReorder">\n                        <tr md-row>\n                            <th md-column></th>\n                            <th class="server-name" md-column>{{ ::orchidBulkActionConfirm.msgs.server() }}</th>\n                            <th class="user-details" md-column colspan="2">\n                                {{ ::orchidBulkActionConfirm.msgs.existingUserDetails() }}\n                            </th>\n                            <th md-column>{{ ::orchidBulkActionConfirm.msgs.action() }}</th>\n                        </tr>\n                    </thead>\n                    <tbody md-body>\n                        <tr md-row ng-repeat="orchidUser in orchidBulkActionConfirm.siblingUpdates | orderBy: orchidBulkActionConfirm.sortOrder()" ng-class="orchidBulkActionConfirm.rowClass(orchidUser)">\n                            <td class="apply-to-user" md-cell>\n                                <md-checkbox ng-model="orchidUser.apply" class="apply-toggle"></md-checkbox>\n                            </td>\n                            <td class="server-name" md-cell>{{orchidUser.orchid.name}}</td>\n                            <td class="user-details" md-cell>{{orchidUser.user.username}}</td>\n                            <td class="user-details" md-cell>\n                                {{orchidBulkActionConfirm.roleTransHelper.translatedRole(orchidUser.user.role)}}\n                            </td>\n                            <td md-cell>{{orchidBulkActionConfirm.actionText(orchidUser)}}</td>\n                        </tr>\n                        <tr md-row ng-if="orchidBulkActionConfirm.ready === false">\n                            <td md-cell colspan="5">\n                                <md-progress-circular md-mode="indeterminate" md-diameter="30px"></md-progress-circular>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </md-card>\n        </md-content>\n    </md-dialog-content>\n    <md-dialog-actions>\n        <md-button ng-click="orchidBulkActionConfirm.cancel()" ng-disabled="orchidBulkActionConfirm.processing">\n            {{ ::orchidBulkActionConfirm.msgs.cancel() }}\n        </md-button>\n        <md-button class="md-raised md-primary" type="submit" ng-click="orchidBulkActionConfirm.accept()" ng-disabled="orchidBulkActionConfirm.ready === false || orchidBulkActionConfirm.processing">\n            <span ng-if="!orchidBulkActionConfirm.processing">{{ ::orchidBulkActionConfirm.msgs.replicateUser() }}</span>\n            <md-progress-circular md-mode="indeterminate" md-diameter="35px" ng-if="orchidBulkActionConfirm.processing" style="margin: auto"></md-progress-circular>\n        </md-button>\n    </md-dialog-actions>\n    <div class="md-dialog-focus-trap" tabindex="0"></div>\n</form>\n'
        }
        ,
        60298: e => {
            e.exports = '<form>\n    <md-toolbar class="orchid-toolbar">\n        <div class="md-toolbar-tools">\n            <h2 class="md-title ng-binding">\n                {{ ::orchidUserBulkDeleteConfirmDialog.msgs.removalStrategyFor({ VALUE:\n                orchidUserBulkDeleteConfirmDialog.user.username}) }}\n            </h2>\n            <span flex></span>\n            <md-button class="md-icon-button" ng-disabled="orchidUserBulkDeleteConfirmDialog.processing" ng-click="orchidUserBulkDeleteConfirmDialog.cancel()">\n                <i class="fa fa-times fa-2x"></i>\n            </md-button>\n        </div>\n    </md-toolbar>\n    <md-dialog-content class="bulk-action-dialog">\n        <md-content class="md-padding">\n            <p>{{ ::orchidUserBulkDeleteConfirmDialog.msgs.theFollowingUsersWillBeRemoved() }}</p>\n            <md-card>\n                <table md-table>\n                    <thead md-head md-order="query.order" md-on-reorder="onReorder">\n                        <tr md-row>\n                            <th class="apply-to-user" md-column></th>\n                            <th class="server-name" md-column>\n                                {{ ::orchidUserBulkDeleteConfirmDialog.msgs.server() }}\n                            </th>\n                            <th class="user-details" md-column colspan="2">\n                                {{ ::orchidUserBulkDeleteConfirmDialog.msgs.existingUserDetails() }}\n                            </th>\n                            <th md-column>{{ ::orchidUserBulkDeleteConfirmDialog.msgs.action() }}</th>\n                        </tr>\n                    </thead>\n                    <tbody md-body>\n                        <tr md-row ng-repeat="orchidUser in orchidUserBulkDeleteConfirmDialog.orchidUsers | orderBy:[\'-noUser\', \'-error\', \'orchid.name\']" ng-class="orchidUserBulkDeleteConfirmDialog.rowClass(orchidUser)">\n                            <td class="apply-to-user" md-cell>\n                                <md-checkbox ng-model="orchidUser.apply" class="apply-toggle"></md-checkbox>\n                            </td>\n                            <td class="server-name" md-cell>{{orchidUser.orchid.name}}</td>\n                            <td class="user-details" md-cell>{{orchidUser.user.username}}</td>\n                            <td class="user-details" md-cell>\n                                {{orchidUserBulkDeleteConfirmDialog.roleTransHelper.translatedRole(orchidUser.user.role)}}\n                            </td>\n                            <td md-cell>{{orchidUserBulkDeleteConfirmDialog.actionText(orchidUser)}}</td>\n                        </tr>\n                        <tr md-row ng-if="orchidUserBulkDeleteConfirmDialog.ready === false">\n                            <td md-cell colspan="5">\n                                <md-progress-circular md-mode="indeterminate" md-diameter="30px"></md-progress-circular>\n                            </td>\n                        </tr>\n                    </tbody>\n                </table>\n            </md-card>\n        </md-content>\n    </md-dialog-content>\n    <md-dialog-actions>\n        <md-button ng-disabled="orchidUserBulkDeleteConfirmDialog.processing" ng-click="orchidUserBulkDeleteConfirmDialog.cancel()">\n            {{ ::orchidUserBulkDeleteConfirmDialog.msgs.cancel() }}\n        </md-button>\n        <md-button class="md-raised md-warn" type="submit" ng-click="orchidUserBulkDeleteConfirmDialog.accept()" ng-disabled="orchidUserBulkDeleteConfirmDialog.ready === false || orchidUserBulkDeleteConfirmDialog.processing">\n            <span ng-if="!orchidUserBulkDeleteConfirmDialog.processing">{{ ::orchidUserBulkDeleteConfirmDialog.msgs.deleteUser() }}</span>\n            <md-progress-circular md-mode="indeterminate" md-diameter="35px" ng-if="orchidUserBulkDeleteConfirmDialog.processing" style="margin: auto"></md-progress-circular>\n        </md-button>\n    </md-dialog-actions>\n    <div class="md-dialog-focus-trap" tabindex="0"></div>\n</form>\n'
        }
        ,
        37996: e => {
            e.exports = '<md-dialog>\n    <md-dialog-content class="md-dialog-content" role="document" tabindex="-1">\n        <h2 class="md-title"></h2>\n        <div class="md-dialog-content-body">\n            <p>{{ ::orchidUserDeleteDialog.msgs.deleteWhichUser({ VALUE: orchidUserDeleteDialog.user.username }) }}</p>\n            <md-checkbox ng-if="orchidUserDeleteDialog.showBulkAction" ng-model="orchidUserDeleteDialog.bulkAction" aria-label="{{ ::orchidUserDeleteDialog.msgs.replicateThisChangeAcrossAllServers() }}" class="bulk-change-checkbox">\n                {{ ::orchidUserDeleteDialog.msgs.deleteUserOnAllServers() }}\n            </md-checkbox>\n        </div>\n        <div ng-if="orchidUserDeleteDialog.user.error">\n            <i class="fa fa-triangle-exclamation" style="margin-right:4px; color:red"></i>{{orchidUserDeleteDialog.user.error}}\n        </div>\n    </md-dialog-content>\n    <md-dialog-actions>\n        <md-button class="md-primary" ng-disabled="orchidUserDeleteDialog.user.processing" ng-click="orchidUserDeleteDialog.cancel()">\n            {{ ::orchidUserDeleteDialog.msgs.cancel() }}\n        </md-button>\n        <md-button class="md-primary" type="submit" ng-disabled="userForm.$invalid || orchidUserDeleteDialog.user.processing" ng-click="orchidUserDeleteDialog.confirm($event)">\n            <span ng-if="!orchidUserDeleteDialog.user.processing">{{ ::orchidUserDeleteDialog.msgs.deleteUser() }}</span>\n            <md-progress-circular md-mode="indeterminate" md-diameter="35px" ng-if="orchidUserDeleteDialog.user.processing" style="margin: auto"></md-progress-circular>\n        </md-button>\n    </md-dialog-actions>\n</md-dialog>\n'
        }
        ,
        15426: e => {
            e.exports = '<form name="userForm" autocomplete="off" class="user-dialog">\n    <div style="position: absolute; top: -1000px" tabindex="-1">\n        <input id="fake-user-name" name="fake_user[name]">\n        <input id="fake-user-password" name="fake_user[password]" type="password">\n    </div>\n\n    <md-toolbar class="orchid-toolbar">\n        <div class="md-toolbar-tools">\n            <h2>\n                <span class="hide-xs">{{::orchidUserDialog.title}}</span>\n                <span class="hide-gt-xs">{{::orchidUserDialog.titleShort}}</span>\n            </h2>\n            <span flex></span>\n            <md-button class="md-icon-button" ng-disabled="orchidUserDialog.user.processing" ng-click="orchidUserDialog.cancel()">\n                <i class="fa fa-times fa-2x"></i>\n            </md-button>\n        </div>\n    </md-toolbar>\n\n    <md-dialog-content>\n        <md-content class="md-padding" style="padding-bottom: 0; overflow-y: hidden" layout="row" layout-wrap>\n            \x3c!-- Self Edit Notice--\x3e\n            <div class="warning" ng-show="orchidUserDialog.isSelf">\n                {{ ::orchidUserDialog.msgs.noticeEditingOwnAccount() }}\n            </div>\n\n            \x3c!-- Username --\x3e\n            <md-input-container class="md-block md-icon-float" flex="65">\n                <label>{{ ::orchidUserDialog.formMsgs.labels.username() }}</label>\n                <input name="username" ng-model="orchidUserDialog.user.username" required ng-pattern="/^\\w+$/" md-autofocus ng-disabled="orchidUserDialog.user.isAdmin" autocorrect="off" autocapitalize="off" autocomplete="off">\n                <div ng-messages="userForm.username.$error" role="alert" multiple="multiple">\n                    <div ng-message="required" class="my-message">\n                        {{ ::orchidUserDialog.formMsgs.errors.username.usernameRequired() }}\n                    </div>\n                    <div ng-message="pattern" class="my-message">\n                        {{ ::orchidUserDialog.formMsgs.errors.username.invalidUsername() }}\n                    </div>\n                </div>\n            </md-input-container>\n\n            \x3c!-- Role --\x3e\n            <md-input-container class="role-container" flex="35">\n                <label>{{ ::orchidUserDialog.msgs.role() }}</label>\n                <md-select ng-disabled="orchidUserDialog.user.isAdmin" ng-model="orchidUserDialog.user.role">\n                    <md-option ng-repeat="role in orchidUserDialog.roleTransHelper.roles" value="{{role}}">\n                        {{orchidUserDialog.roleTransHelper.translatedRole(role)}}\n                    </md-option>\n                </md-select>\n            </md-input-container>\n\n            \x3c!-- Password --\x3e\n            <md-input-container class="md-block md-icon-float" flex="50">\n                <label>{{ ::orchidUserDialog.formMsgs.labels.password() }}</label>\n                <password-form-field-lite field-name="password" model-name="orchidUserDialog.user.password" minlength="4" placeholder="{{ ::orchidUserDialog.formMsgs.labels.password() }}" required="{{ (orchidUserDialog.newUser || (orchidUserDialog.bulkUpdate && orchidUserDialog.bulkCreate)) }}"></password-form-field-lite>\n                <div ng-messages="userForm.password.$error" role="alert">\n                    <div ng-message-exp="[\'minlength\', \'required\']">\n                        {{ ::orchidUserDialog.formMsgs.errors.password.passwordMustBeAtLeast4Characters() }}\n                    </div>\n                </div>\n            </md-input-container>\n\n            \x3c!-- Confirm Password --\x3e\n            <md-input-container class="md-block" flex="50">\n                <label>{{ ::orchidUserDialog.formMsgs.labels.confirmPassword() }}</label>\n                <password-form-field-lite field-name="confirmPassword" model-name="orchidUserDialog.user.confirmPassword" placeholder="{{ ::orchidUserDialog.formMsgs.labels.confirmPassword() }}" required="{{ (orchidUserDialog.newUser || (orchidUserDialog.bulkUpdate && orchidUserDialog.bulkCreate)) }}" minlength="4" equal="password"></password-form-field-lite>\n                <div ng-messages="userForm.confirmPassword.$error" role="alert">\n                    <div ng-message-exp="[\'minlength\', \'required\']">\n                        {{ ::orchidUserDialog.formMsgs.errors.password.passwordMustBeAtLeast4Characters() }}\n                    </div>\n                    <div ng-message="passwordMatch">\n                        {{ ::orchidUserDialog.formMsgs.errors.password.passwordDoNotMatch() }}\n                    </div>\n                </div>\n            </md-input-container>\n\n            \x3c!-- Create on all server --\x3e\n            <md-checkbox ng-model="orchidUserDialog.bulkCreate" aria-label="{{ ::orchidUserDialog.msgs.replicateThisChangeAcrossAll() }}" class="bulk-change-checkbox" ng-if="orchidUserDialog.newUser && !orchidUserDialog.isOrchid">\n                {{ ::orchidUserDialog.msgs.createOnAllServers() }}\n            </md-checkbox>\n\n            \x3c!-- Replicate changes on all servers --\x3e\n            <md-checkbox ng-model="orchidUserDialog.bulkUpdate" aria-label="{{ ::orchidUserDialog.msgs.replicateThisChangeAcrossAll() }}" class="bulk-change-checkbox" ng-if="!orchidUserDialog.newUser && !orchidUserDialog.isOrchid">\n                {{ ::orchidUserDialog.msgs.replicateChangesOnAllServers() }}\n            </md-checkbox>\n\n            \x3c!-- Also create new users--\x3e\n            <md-checkbox ng-model="orchidUserDialog.bulkCreate" aria-label="{{ ::orchidUserDialog.msgs.replicateThisChangeAcrossAll() }}" class="bulk-change-checkbox" ng-if="orchidUserDialog.bulkUpdate" ng-show="!orchidUserDialog.newUser && !orchidUserDialog.isOrchid">\n                {{ ::orchidUserDialog.msgs.alsoCreateNewUsers() }}\n            </md-checkbox>\n        </md-content>\n    </md-dialog-content>\n\n    \x3c!-- Error --\x3e\n    <dialog-errors target-object="orchidUserDialog"></dialog-errors>\n\n    \x3c!-- Action Buttons --\x3e\n    <md-dialog-actions layout="row">\n        <span flex></span>\n        <md-button ng-disabled="orchidUserDialog.user.processing" ng-click="orchidUserDialog.cancel()">\n            {{ ::orchidUserDialog.msgs.cancel() }}\n        </md-button>\n        <md-button class="md-raised md-primary" type="submit" ng-disabled="userForm.$invalid || orchidUserDialog.user.processing" ng-click="orchidUserDialog.addOrUpdateUser()">\n            <span ng-if="!orchidUserDialog.user.processing">{{::orchidUserDialog.buttonTitle}}</span>\n            <md-progress-circular md-mode="indeterminate" md-diameter="35px" ng-if="orchidUserDialog.user.processing" style="margin: auto"></md-progress-circular>\n        </md-button>\n    </md-dialog-actions>\n</form>\n'
        }
        ,
        87794: e => {
            e.exports = '<form name="userForm" autocomplete="off" class="user-dialog">\n    <div style="position: absolute; top: -1000px" tabindex="-1">\n        <input id="fake-user-name" name="fake_user[name]">\n        <input id="fake-user-password" name="fake_user[password]" type="password">\n    </div>\n\n    <md-toolbar>\n        <div class="md-toolbar-tools">\n            <h2>{{::singularityUserDialog.title}}</h2>\n            <span flex></span>\n            <md-button class="md-icon-button close-dialog-x" ng-click="singularityUserDialog.cancel()" ng-disabled="singularityUserDialog.processing">\n                <i class="fa fa-times fa-2x"></i>\n            </md-button>\n        </div>\n    </md-toolbar>\n\n    <md-content class="md-padding" id="dialog-scroll-region" style="padding-bottom: 0;" layout="row" layout-wrap>\n        \x3c!-- Username --\x3e\n        <md-input-container class="md-block md-icon-float" flex="50">\n            <label>{{ ::singularityUserDialog.formMsgs.labels.username() }}</label>\n            <input name="username" ng-disabled="singularityUserDialog.isCurrentUser === false && singularityUserDialog.user.superUser" ng-model="singularityUserDialog.user.username" required md-maxlength="30" ng-pattern="/^[a-zA-Z0-9_]+$/" md-autofocus autocorrect="off" autocapitalize="off" autocomplete="off">\n            <div ng-messages="userForm.username.$error" role="alert" multiple="multiple">\n                <div ng-message="required" class="my-message">{{ ::singularityUserDialog.formMsgs.errors.username.usernameRequired() }}</div>\n                <div ng-message="pattern" class="my-message">{{ ::singularityUserDialog.formMsgs.errors.username.invalidUsername() }}</div>\n            </div>\n        </md-input-container>\n\n        \x3c!-- Email Address --\x3e\n        <md-input-container flex="50">\n            <label>{{ ::singularityUserDialog.formMsgs.labels.emailAddress() }}</label>\n            <i class="fa fa-circle-question label-hint google-hint tooltip-icon" ng-if="singularityUserDialog.showGoogleAuthEmailInfoTip">\n                <md-tooltip md-direction="left">\n                    {{ ::singularityUserDialog.msgs.providingAnEmailAddressAssociatedToAGoogleAccountWillAllowThisUserToLoginUsingGoogleSignIn() }}\n                </md-tooltip>\n            </i>\n\n            <input ng-model="singularityUserDialog.user.emailAddress" name="emailAddress" ng-disabled="singularityUserDialog.isCurrentUser === false && singularityUserDialog.user.superUser" type="email" autocomplete="off">\n            <div ng-messages="userForm.emailAddress.$error" role="alert" multiple="multiple">\n                <div ng-message-exp="[\'email\']">\n                    {{ ::singularityUserDialog.formMsgs.errors.email.aValidEmailAddressRequired() }}\n                </div>\n            </div>\n        </md-input-container>\n\n        \x3c!-- Groups --\x3e\n        <div style="position: relative; width: 100%">\n            <md-input-container class="md-block" flex="100">\n                <label>{{ ::singularityUserDialog.msgs.groups() }}</label>\n                <autocomplete-chips items="singularityUserDialog.user.groups" master-list="singularityUserDialog.groups" name-field="name" placeholder="{{ ::singularityUserDialog.msgs.searchForAGroup() }}" ng-disabled="singularityUserDialog.isCurrentUser === false && singularityUserDialog.user.superUser">\n                </autocomplete-chips>\n            </md-input-container>\n        </div>\n\n        \x3c!-- Password --\x3e\n        <md-input-container class="md-block md-icon-float" flex="50">\n            <label>{{ ::singularityUserDialog.formMsgs.labels.password() }}</label>\n            <password-form-field-lite field-name="password" model-name="singularityUserDialog.user.password" minlength="4" placeholder="{{ ::singularityUserDialog.formMsgs.labels.password() }}" required="{{singularityUserDialog.newUser}}" disabled="{{singularityUserDialog.isCurrentUser === false && singularityUserDialog.user.superUser}}"></password-form-field-lite>\n            <div ng-messages="userForm.password.$error" role="alert">\n                <div ng-message-exp="[\'required\', \'minlength\']">\n                    {{ ::singularityUserDialog.formMsgs.errors.password.passwordMustBeAtLeast4Characters() }}\n                </div>\n            </div>\n        </md-input-container>\n\n        \x3c!-- Confirm Password --\x3e\n        <md-input-container class="md-block" flex="50">\n            <label>{{ ::singularityUserDialog.formMsgs.labels.confirmPassword() }}</label>\n            <password-form-field-lite field-name="confirmPassword" model-name="singularityUserDialog.user.confirmPassword" placeholder="{{ ::singularityUserDialog.formMsgs.labels.confirmPassword() }}" required="{{singularityUserDialog.newUser}}" disabled="{{singularityUserDialog.isCurrentUser === false && singularityUserDialog.user.superUser}}" minlength="4" equal="password"></password-form-field-lite>\n            <div ng-messages="userForm.confirmPassword.$error" role="alert">\n                <div ng-message-exp="[\'minlength\', \'required\']">\n                    {{ ::singularityUserDialog.formMsgs.errors.password.passwordMustBeAtLeast4Characters() }}\n                </div>\n                <div ng-message="passwordMatch">\n                    {{ ::singularityUserDialog.formMsgs.errors.password.passwordDoNotMatch() }}\n                </div>\n            </div>\n        </md-input-container>\n\n    </md-content>\n\n    \x3c!-- Error --\x3e\n    <dialog-errors target-object="singularityUserDialog"></dialog-errors>\n\n    \x3c!-- Action Buttons --\x3e\n    <md-dialog-actions layout="row">\n        <span flex></span>\n        <md-button ng-click="singularityUserDialog.cancel()" ng-disabled="singularityUserDialog.processing" class="close-dialog-button">{{ ::singularityUserDialog.msgs.cancel() }}</md-button>\n        <md-button class="md-raised md-primary" type="submit" ng-click="singularityUserDialog.addOrUpdateUser()" ng-disabled="singularityUserDialog.processing || (singularityUserDialog.isCurrentUser === false && singularityUserDialog.user.superUser) || userForm.$invalid" class="submit-user">\n            <span ng-if="!singularityUserDialog.processing">{{::singularityUserDialog.buttonTitle}}</span>\n            <md-progress-circular md-mode="indeterminate" md-diameter="35px" ng-if="singularityUserDialog.processing" style="margin:auto"></md-progress-circular>\n        </md-button>\n    </md-dialog-actions>\n</form>\n'
        }
        ,
        32243: e => {
            e.exports = '<div class="user-admin-header" ng-if="userManagerList.failedReason === \'\'">\n    <span class="spacer" flex></span>\n    <md-button class="md-raised md-primary action-button add-button" aria-label="{{ ::userManagerList.msgs.addUserTo({ VALUE: userManagerList.title }) }}" ng-click="userManagerList.addUser($event);" ng-class="{ \'add-fusion-user\': userManagerList.isFusion, \'add-orchid-user\': !userManagerList.isFusion }">\n        {{ ::userManagerList.msgs.addUser() }}\n    </md-button>\n</div>\n<div class="loading-container" ng-if="userManagerList.loading">\n    <page-loading progress="userManagerList.msgs.loadingUsers()"> </page-loading>\n</div>\n<div ng-if="!userManagerList.loading" class="user-manager-list-content">\n    <md-content class="generic-admin-content text-center pt-50 opacity-54" ng-if="userManagerList.failedReason !== \'\'">{{ userManagerList.failedReason }}</md-content>\n    <md-card class="layout-column layout-gt-xs-row layout-align-gt-xs-center-end" ng-if="filteredUsers.length > userManagerList.paging.paginatorLimit || userManagerList.filters.searchNames.length">\n        <md-card-content class="flex-100">\n            <md-input-container class="flex-100 user-manager-list-search-container">\n                <label>{{ ::userManagerList.msgs.username() }}</label>\n                <md-chips ng-model="userManagerList.filters.searchNames" md-add-on-blur="true" placeholder="{{ ::userManagerList.msgs.search() }}" secondary-placeholder="{{ ::userManagerList.msgs.search() }}" md-on-add="userManagerList.onFiltersChanged()" md-on-remove="userManagerList.onFiltersChanged()">\n                </md-chips>\n            </md-input-container>\n        </md-card-content>\n    </md-card>\n\n    <md-content ng-if="userManagerList.failedReason === \'\' && (userManagerList.users.length === 0 || filteredUsers.length === 0)">\n        <div class="md-no-sticky no-bananas no-matches-error-message" ng-switch="userManagerList.noUsersOrSearchDidNotMatchSwitchKey">\n            <span ng-switch-when="matches">{{ ::userManagerList.msgs.noUsersMatchSearch() }}</span>\n            <span ng-switch-default>{{ ::userManagerList.msgs.noUsersExist() }}</span>\n        </div>\n    </md-content>\n\n    <div ng-if="filteredUsers.length > 0 && userManagerList.pagingPages(filteredUsers.length) > 0" class="content-list-counter">\n        {{ userManagerList.msgs.usersRange({ RANGE: userManagerList.pageRange(filteredUsers), LENGTH:\n        filteredUsers.length}) }}\n    </div>\n    <md-card>\n        <table md-table md-progress="userManagerList.promise" class="user-manager-list striped-table interactive" ng-class="{\'fusion-list\': userManagerList.isFusion, \'single-list\': userManagerList.isSingle, \'orchid-list\': !userManagerList.isFusion}">\n            <tbody md-body>\n                <tr md-row ng-repeat="user in (filteredUsers = userManagerList.filteredUsers | orderBy: \'username\' |\n                        limitTo : userManagerList.displayedUsersPerPage : userManagerList.getStartFromIndex()) track by user.id" ng-class="{ singularityUser: userManagerList.isFusion, orchidUser: !userManagerList.isFusion, selected: user.selected }" ng-click="userManagerList.modifyUser($event, user)" id="{{::user.username}}-row">\n                    <td class="user-username" ng-class="{ \'user-admin\': user.admin }" md-cell>\n                        {{user.username}}\n                        <div class="admin-indicator hint-text" ng-if="user.admin && !user.superUser">\n                            {{ ::userManagerList.msgs.administrator().toLowerCase() }}\n                        </div>\n                        <div class="admin-indicator hint-text" ng-if="user.superUser">\n                            {{ ::userManagerList.msgs.superuser() }}\n                        </div>\n                    </td>\n                    <td class="user-role" md-cell>\n                        <div class="role-container">\n                            <div>{{userManagerList.roleTransHelper.roleToTrans[user.role]}}{{user.groupList}}</div>\n                        </div>\n                    </td>\n                    <td class="user-controls" md-cell>\n                        <md-button ng-click="userManagerList.modifyUser($event, user)" class="md-icon-button">\n                            <i class="fa-solid fa-sm fa-pencil"></i>\n                        </md-button>\n                        <md-button ng-disabled="(userManagerList.isFusion === false && user.username === \'admin\') || (userManagerList.isFusion && (user.superUser || userManagerList.isCurrentUser(user)))" ng-click="userManagerList.deleteUser($event, user)" class="{{::user.username}}-delete-user-button md-icon-button">\n                            <i class="fa-sm {{userManagerList.getDeleteIcon(user)}}">\n                                <md-tooltip md-autohide ng-if="userManagerList.isFusion === false && user.username === \'admin\'" md-direction="bottom" delay="500">{{ ::userManagerList.msgs.thisDefaultAccountHasAdmin() }}</md-tooltip>\n                                <md-tooltip md-autohide ng-if="userManagerList.isFusion === true && user.superUser" md-direction="bottom" delay="500">{{ ::userManagerList.msgs.thisSuperuserAccountHas() }}</md-tooltip>\n                            </i>\n                        </md-button>\n                    </td>\n                </tr>\n            </tbody>\n        </table>\n    </md-card>\n\n    <mat-paginator ng-if="filteredUsers.length > userManagerList.paging.paginatorLimit" show-first-last-buttons [length]="userManagerList.filteredUsers.length" [page-index]="userManagerList.paging.current" [page-size]="userManagerList.paging.perPage" [page-size-options]="userManagerList.paging.pageSizeOptions" (page)="userManagerList.onPageChange($event)">\n    </mat-paginator>\n</div>\n'
        }
        ,
        70671: e => {
            e.exports = '<md-dialog class="sing-yes-no-dialog" aria-label="{{ $ctrl.config.title }}" md-theme="{{$ctrl.theme}}">\n    <md-dialog-content class="md-dialog-content">\n        <h2 class="md-title" ng-if="$ctrl.config.title">{{ ::$ctrl.config.title }}</h2>\n        <div ng-if="!$ctrl.config.html">\n            <p>{{$ctrl.config.body}}</p>\n        </div>\n        <div ng-if="$ctrl.config.html" ng-bind-html="$ctrl.config.body"></div>\n    </md-dialog-content>\n\n    <md-dialog-actions layout="row" layout-align="end center">\n        <md-button class="md-primary" ng-click="$ctrl.clickedNoButton()" id="yes-no-dialog-no-button" ng-if="!$ctrl.config.hideNo">\n            {{ ::$ctrl.config.noButtonText }}\n        </md-button>\n        <md-button class="md-primary" ng-click="$ctrl.clickedYes()" id="yes-no-dialog-yes-button">\n            {{ ::$ctrl.config.yesButtonText }}\n        </md-button>\n    </md-dialog-actions>\n</md-dialog>\n'
        }
        ,
        91450: e => {
            var t = function(e, t) {
                var n = String(e).split(".")
                  , i = !n[1]
                  , a = Number(n[0]) == e
                  , r = a && n[0].slice(-1)
                  , s = a && n[0].slice(-2);
                return t ? 1 == r && 11 != s ? "one" : 2 == r && 12 != s ? "two" : 3 == r && 13 != s ? "few" : "other" : 1 == e && i ? "one" : "other"
            }
              , n = function(e, t, n, i, a) {
                if ({}.hasOwnProperty.call(i, e))
                    return i[e];
                t && (e -= t);
                var r = n(e, a);
                return r in i ? i[r] : i.other
            }
              , i = function(e, t) {
                return {}.hasOwnProperty.call(t, e) ? t[e] : t.other
            }
              , a = function(e, t, n) {
                var i = n && n.split(":") || []
                  , a = {
                    integer: {
                        maximumFractionDigits: 0
                    },
                    percent: {
                        style: "percent"
                    },
                    currency: {
                        style: "currency",
                        currency: i[1] && i[1].trim() || "USD",
                        minimumFractionDigits: 2,
                        maximumFractionDigits: 2
                    }
                };
                return new Intl.NumberFormat(t,a[i[0]] || {}).format(e)
            }
              , r = function(e) {
                return /^[aeiou]/i.test(e) ? `an ${e}` : `a ${e}`
            };
            e.exports = {
                bytes: function(e) {
                    return a(e.VALUE, "en")
                },
                bits: function(e) {
                    return a(e.VALUE, "en")
                },
                days: function(e) {
                    return e.VALUE + " days"
                },
                slashDay: function(e) {
                    return e.VALUE + " / day"
                },
                commaAnd: function(e) {
                    return ", and"
                },
                monday: function(e) {
                    return "Monday"
                },
                tuesday: function(e) {
                    return "Tuesday"
                },
                wednesday: function(e) {
                    return "Wednesday"
                },
                thursday: function(e) {
                    return "Thursday"
                },
                friday: function(e) {
                    return "Friday"
                },
                saturday: function(e) {
                    return "Saturday"
                },
                sunday: function(e) {
                    return "Sunday"
                },
                mondayInitial: function(e) {
                    return "M"
                },
                tuesdayInitial: function(e) {
                    return "T"
                },
                wednesdayInitial: function(e) {
                    return "W"
                },
                thursdayInitial: function(e) {
                    return "T"
                },
                fridayInitial: function(e) {
                    return "F"
                },
                saturdayInitial: function(e) {
                    return "S"
                },
                sundayInitial: function(e) {
                    return "S"
                },
                accessDenied: {
                    accessDenied: function(e) {
                        return "Access Denied"
                    },
                    youAreNotAuthorizedToAccessTheRequestedResource: function(e) {
                        return "You are not authorized to access the requested resource."
                    }
                },
                accountSettings: {
                    accountInformation: function(e) {
                        return "Account Information"
                    },
                    accountSettings: function(e) {
                        return "Account Settings"
                    },
                    changePassword: function(e) {
                        return "Change Password"
                    },
                    editPassword: {
                        cancel: function(e) {
                            return "Cancel"
                        },
                        changePassword: function(e) {
                            return "Change Password"
                        },
                        save: function(e) {
                            return "Save"
                        },
                        successfulPasswordChange: function(e) {
                            return "Your password was successfully updated."
                        }
                    },
                    generalSettings: {
                        cancel: function(e) {
                            return "Cancel"
                        },
                        save: function(e) {
                            return "Save"
                        },
                        yourInformationWasSuccessfullyUpdated: function(e) {
                            return "Your information was successfully updated."
                        }
                    },
                    loadingAccountInformation: function(e) {
                        return "Loading account information..."
                    },
                    preferences: {
                        preferences: function(e) {
                            return "Preferences"
                        }
                    },
                    security: function(e) {
                        return "Security"
                    },
                    youCantChangePasswordHere: function(e) {
                        return "You can't change your password here. Your organization doesn't allow you to change your password on this site."
                    },
                    yourGroups: function(e) {
                        return "Your Groups"
                    }
                },
                activation: {
                    activationCode: function(e) {
                        return "Activation Code"
                    },
                    addLicense: function(e) {
                        return "Add License"
                    },
                    archiveRetention: function(e) {
                        return "Archive Retention"
                    },
                    areYouSureYouWantToDetachThisCHILDFromPARENT: function(e) {
                        return "Are you sure you want to detach this Orchid Recorder from Orchid Hybrid VMS?"
                    },
                    camerasLicensed: function(e) {
                        return "Cameras Licensed"
                    },
                    childCurrentlyManagedBy: function(e) {
                        return "Orchid Recorder is currently managed by Orchid Hybrid VMS."
                    },
                    childActivated: function(e) {
                        return "Orchid Recorder has <b>been activated.</b>"
                    },
                    childNotActivated: function(e) {
                        return "Orchid Recorder has not yet <b>been activated.</b>"
                    },
                    childHas: function(e) {
                        return "Orchid Recorder has"
                    },
                    notYet: function(e) {
                        return "not yet"
                    },
                    beenActivated: function(e) {
                        return "been activated."
                    },
                    detachFromParent: function(e) {
                        return "Detach from Orchid Hybrid VMS"
                    },
                    edition: function(e) {
                        return "Edition"
                    },
                    failedToFetchCHILDNAMELicenseInfo: function(e) {
                        return "Failed to fetch Orchid Recorder license info"
                    },
                    headerActivation: function(e) {
                        return "Orchid Recorder Activation"
                    },
                    invalidServerLicense: function(e) {
                        return "The license of this server is invalid. Orchid Recorder has stopped all recording and cleaning processes until a valid license is configured."
                    },
                    licenseWillExpireIn: function(e) {
                        return "Your " + e.VALUE + " license will expire in"
                    },
                    loadingLicenseInfo: function(e) {
                        return "Loading license information..."
                    },
                    na: function(e) {
                        return "N/A"
                    },
                    parentStatus: function(e) {
                        return "Orchid Hybrid VMS Status"
                    },
                    removeChildFromParent: function(e) {
                        return "If you would like to remove this Orchid Recorder from Orchid Hybrid VMS, that should be done through Orchid Hybrid VMS.  If Orchid Hybrid VMS is inaccessible you may manually detach Orchid Recorder from Orchid Hybrid VMS by clicking the button below."
                    },
                    removeLicense: function(e) {
                        return "Remove License"
                    },
                    restartToUseNewLicense: function(e) {
                        return "Orchid Recorder needs to be restarted before your new license can take effect."
                    },
                    storageDeviceChanged: function(e) {
                        return "The storage device of this server has changed. In order to prevent data loss, Orchid Recorder has stopped all recording and cleaning processes until the original storage device is present again."
                    },
                    storagePathInvalid: function(e) {
                        return "The configured storage path is invalid. In order to prevent data loss, Orchid Recorder has stopped all recording and cleaning processes until a valid storage path is configured."
                    },
                    supportExpiration: function(e) {
                        return "Support Expiration"
                    },
                    systemDegradedState: function(e) {
                        return "Your system is in a degraded state:"
                    },
                    unlimited: function(e) {
                        return "Unlimited"
                    },
                    updateLicense: function(e) {
                        return "Update License"
                    }
                },
                ambulance: {
                    weAreHavingTroubleReaching: function(e) {
                        return "We are having trouble reaching " + e.VALUE
                    },
                    troubleReason: function(e) {
                        return "Reason: " + e.VALUE
                    }
                },
                app: {
                    appInLowBandwidth: function(e) {
                        return "Orchid Hybrid VMS is in low-bandwidth mode."
                    },
                    browserNotSupported: function(e) {
                        return "This browser is not supported."
                    },
                    timeDifferenceWarning: function(e) {
                        return "Time Difference Warning"
                    },
                    clientServerTimesOff: function(e) {
                        return "<p>The client time and server time are off by " + e.HUMAN + ".<br><br>You should seek to correct this using an NTP server, as it may cause playback issues.<br><br>Client: " + e.CLIENT + "<br>Server: " + e.SERVER + "<p>"
                    },
                    errors: {
                        license: {
                            title: function(e) {
                                return "License error detected"
                            },
                            ariaLabel: function(e) {
                                return "License error"
                            },
                            systemStateExplanation: function(e) {
                                return "The license of this server is invalid. In order to prevent data loss, Orchid Recorder has stopped all recording and cleaning processes until a valid license is configured."
                            }
                        },
                        storage: {
                            title: function(e) {
                                return "Storage error detected"
                            },
                            ariaLabel: function(e) {
                                return "Storage error"
                            },
                            systemStateExplanation: function(e) {
                                return "The storage device of this server has changed. In order to prevent data loss, Orchid Recorder has stopped all recording and cleaning processes until the original storage device is present again."
                            }
                        },
                        storagePath: {
                            title: function(e) {
                                return "Storage error detected"
                            },
                            ariaLabel: function(e) {
                                return "Storage error"
                            },
                            systemStateExplanation: function(e) {
                                return "The configured storage path is invalid. In order to prevent data loss, Orchid Recorder has stopped all recording and cleaning processes until a valid storage path is configured."
                            }
                        },
                        framerate: {
                            title: function(e) {
                                return "Performance Warning"
                            },
                            weveNoticedYourBrowserIsRunningSlowly: function(e) {
                                return "We've noticed your browser is running slowly. This could be due to the following:"
                            },
                            tooManyDewarpedCameras: function(e) {
                                return "Too many dewarped cameras on the stage"
                            },
                            tooManyHighResolutionCameras: function(e) {
                                return "Too many high resolution cameras on the stage"
                            },
                            tooManyWebRTCPlayers: function(e) {
                                return "Too many WebRTC players on the stage"
                            },
                            anOlderPCOrVideoCard: function(e) {
                                return "An older PC or video card"
                            },
                            hideFutureNotifications: function(e) {
                                return "Hide these notifications"
                            }
                        },
                        template: function(e) {
                            return "<p>Your system is in a degraded state: <strong>" + e.DESC + "</strong></p><p>" + e.WHY + "</p>"
                        }
                    },
                    leave: function(e) {
                        return "Leave"
                    },
                    signedInAs: function(e) {
                        return "Signed in as"
                    },
                    signedInAsToolTip: function(e) {
                        return "Signed in as " + e.VALUE
                    },
                    signOut: function(e) {
                        return "Sign Out"
                    }
                },
                applicationDeath: {
                    appUnresponsive: function(e) {
                        return "Orchid Hybrid VMS Service Unresponsive"
                    },
                    cannotUseWS: function(e) {
                        return " It seems that the Orchid Hybrid VMS can not use WebSockets at this time."
                    },
                    reload: function(e) {
                        return "Reload"
                    },
                    cannotReachServer: function(e) {
                        return "It seems that the Orchid Hybrid VMS server is offline or otherwise unreachable.  The server should restart itself."
                    }
                },
                auditLogs: {
                    actions: {
                        create: function(e) {
                            return "Create"
                        },
                        export: function(e) {
                            return "Export"
                        },
                        remove: function(e) {
                            return "Delete"
                        },
                        update: function(e) {
                            return "Update"
                        },
                        talk: function(e) {
                            return "Talk"
                        },
                        view: function(e) {
                            return "View"
                        }
                    },
                    auditLogs: function(e) {
                        return "Audit Logs"
                    },
                    backToTop: function(e) {
                        return "Back to top"
                    },
                    error: function(e) {
                        return "There was an error fetching audit logs. Please try again later."
                    },
                    exportLogs: function(e) {
                        return "Export logs"
                    },
                    fetchLogs: function(e) {
                        return "Fetch Audit Logs"
                    },
                    filters: {
                        advancedFilters: function(e) {
                            return "Advanced Filters"
                        },
                        authType: {
                            all: function(e) {
                                return "All"
                            },
                            basic: function(e) {
                                return "API (basic)"
                            },
                            jwt: function(e) {
                                return "API (token)"
                            },
                            remoteSession: function(e) {
                                return "Management Server"
                            },
                            userSession: function(e) {
                                return "Recorder"
                            }
                        },
                        fromDate: function(e) {
                            return "From date"
                        },
                        headline: function(e) {
                            return "Filters"
                        },
                        reset: function(e) {
                            return "Reset"
                        },
                        search: function(e) {
                            return "Search"
                        },
                        searchDateRange: function(e) {
                            return "Past 24 Hours"
                        },
                        selectAuthType: function(e) {
                            return "Authentication Type"
                        },
                        selectCamera: function(e) {
                            return "Filter by Camera"
                        },
                        selectUser: function(e) {
                            return "Filter by user"
                        },
                        toDate: function(e) {
                            return "To date"
                        }
                    },
                    loadingAuditLogs: function(e) {
                        return "Loading Audit Logs"
                    },
                    noResults: function(e) {
                        return "There are no audit logs to display."
                    },
                    refreshResults: function(e) {
                        return "Refresh results"
                    },
                    resources: {
                        archive: function(e) {
                            return "Archive"
                        },
                        camera: function(e) {
                            return "Camera"
                        },
                        event: function(e) {
                            return "Event"
                        },
                        eventSubscription: function(e) {
                            return "Event Subscription"
                        },
                        license: function(e) {
                            return "License"
                        },
                        log: function(e) {
                            return "Log"
                        },
                        properties: function(e) {
                            return "Properties"
                        },
                        server: function(e) {
                            return "Server"
                        },
                        session: function(e) {
                            return "Session"
                        },
                        smartSearch: function(e) {
                            return "Smart Search"
                        },
                        stream: function(e) {
                            return "Stream"
                        },
                        trustedIssuer: function(e) {
                            return "Trusted Issuer"
                        },
                        ui: function(e) {
                            return "UI"
                        },
                        user: function(e) {
                            return "User"
                        }
                    },
                    selectActions: function(e) {
                        return "Filter Actions"
                    },
                    selectResources: function(e) {
                        return "Filter Resources"
                    },
                    table: {
                        authType: {
                            basic: function(e) {
                                return "API (basic)"
                            },
                            jwt: function(e) {
                                return "API (token)"
                            },
                            remoteSession: function(e) {
                                return "Management Server"
                            },
                            userSession: function(e) {
                                return "Recorder"
                            }
                        },
                        date: function(e) {
                            return "Date/Time"
                        },
                        description: function(e) {
                            return "Description"
                        },
                        details: {
                            client: {
                                address: function(e) {
                                    return "Address"
                                },
                                authType: function(e) {
                                    return "Authentication Type"
                                },
                                forwardingAddresses: function(e) {
                                    return "Forwarding Addresses"
                                },
                                header: function(e) {
                                    return "Client"
                                },
                                originatingAddress: function(e) {
                                    return "Originating Address"
                                },
                                remoteAuthProvider: function(e) {
                                    return "Auth Provider"
                                },
                                user: function(e) {
                                    return "User"
                                },
                                userAgent: function(e) {
                                    return "User Agent"
                                }
                            },
                            currentlyViewing: function(e) {
                                return "Currently viewing"
                            },
                            date: function(e) {
                                return "Date/Time"
                            },
                            metrics: {
                                duration: {
                                    days: function(e) {
                                        return "days"
                                    },
                                    hours: function(e) {
                                        return "hours"
                                    },
                                    minutes: function(e) {
                                        return "minutes"
                                    },
                                    seconds: function(e) {
                                        return "seconds"
                                    }
                                },
                                earliestPlaybackTime: function(e) {
                                    return "Video Playback Start Time"
                                },
                                header: function(e) {
                                    return "Metrics"
                                },
                                latestPlaybackTime: function(e) {
                                    return "Video Playback End Time"
                                },
                                rateLimitGroupDuration: function(e) {
                                    return "Rate Limit Group Duration"
                                },
                                requestCount: function(e) {
                                    return "Request Count"
                                },
                                streamSessionDuration: function(e) {
                                    return "Stream Session Duration"
                                }
                            },
                            request: {
                                header: function(e) {
                                    return "Request"
                                },
                                changeDiff: function(e) {
                                    return "Change Differences"
                                },
                                original: function(e) {
                                    return "Original"
                                },
                                parentResourceName: function(e) {
                                    return "Parent Resource"
                                },
                                requestTime: function(e) {
                                    return "Time"
                                },
                                requestUri: function(e) {
                                    return "URI"
                                },
                                resourceName: function(e) {
                                    return "Resource"
                                },
                                responseStatus: function(e) {
                                    return "Response Status"
                                },
                                updated: function(e) {
                                    return "Updated"
                                }
                            }
                        },
                        remoteAuthProvider: {
                            activeDirectory: function(e) {
                                return "AD"
                            },
                            azureActiveDirectory: function(e) {
                                return "Azure"
                            },
                            fusion: function(e) {
                                return "Management Server"
                            },
                            freeipa: function(e) {
                                return "FreeIPA"
                            },
                            googleOAuth: function(e) {
                                return "Google OAuth"
                            },
                            googleSignIn: function(e) {
                                return "Google"
                            },
                            saml: function(e) {
                                return "SAML"
                            }
                        },
                        resource: function(e) {
                            return "Resource"
                        },
                        user: function(e) {
                            return "User"
                        },
                        userType: {
                            local: function(e) {
                                return "Recorder"
                            },
                            remote: function(e) {
                                return "Management Server"
                            }
                        }
                    }
                },
                bag: {
                    addCamera: function(e) {
                        return "Add a camera."
                    },
                    cameraGroup: {
                        noCamerasConfiguredInGroup: function(e) {
                            return "No cameras configured in this group."
                        }
                    },
                    clearStage: function(e) {
                        return "Clear Stage"
                    },
                    cycle: function(e) {
                        return "Cycle:"
                    },
                    cameras: function(e) {
                        return "cameras"
                    },
                    stages: function(e) {
                        return "stages"
                    },
                    disabled: function(e) {
                        return "Disabled"
                    },
                    groups: function(e) {
                        return "Groups"
                    },
                    home: function(e) {
                        return "Home"
                    },
                    maps: function(e) {
                        return "Maps"
                    },
                    noAccessibleServers: function(e) {
                        return "No accessible servers."
                    },
                    noCamsConfigured: function(e) {
                        return "No cameras configured."
                    },
                    noCamsConfiguredInServer: function(e) {
                        return "No cameras configured in this server."
                    },
                    noServersConfigured: function(e) {
                        return "No servers configured."
                    },
                    noSavedStages: function(e) {
                        return "No saved stages."
                    },
                    registerAServer: function(e) {
                        return "Register a Server"
                    },
                    remove: function(e) {
                        return "Remove"
                    },
                    rename: function(e) {
                        return "Rename"
                    },
                    saveStage: function(e) {
                        return "Save Stage"
                    },
                    saving: function(e) {
                        return "Saving"
                    },
                    search: function(e) {
                        return "Search"
                    },
                    searchDidNotMatchCams: function(e) {
                        return "Your search didn't match any cameras"
                    },
                    searchDidNotMatchGroupedCams: function(e) {
                        return "Your search didn't match any grouped cameras"
                    },
                    searchDidNotMatchMaps: function(e) {
                        return "Your search didn't match any maps"
                    },
                    servers: function(e) {
                        return "Servers"
                    },
                    share: function(e) {
                        return "Share"
                    },
                    stageControls: function(e) {
                        return "Stage Controls"
                    },
                    stageSharedWithYouByAdmin: function(e) {
                        return "This stage has been shared with you by an administrator."
                    },
                    thereAreNoAccessibleCameras: function(e) {
                        return "There are no accessible cameras based on your permissions."
                    },
                    thereAreNoAccessibleServers: function(e) {
                        return "There are no accessible servers based on your permissions."
                    },
                    thisStageVisibleToAllUsers: function(e) {
                        return "This stage is visible to all users who have access to at least one camera in this stage."
                    },
                    unShare: function(e) {
                        return "Un-share"
                    },
                    update: function(e) {
                        return "Update"
                    },
                    valueSeconds: function(e) {
                        return e.VALUE + " seconds"
                    }
                },
                cameras: {
                    cameraPicker: {
                        allServersAreSelected: function(e) {
                            return "All servers are selected"
                        },
                        cameras: function(e) {
                            return "Cameras"
                        },
                        cardView: function(e) {
                            return "Card view"
                        },
                        items: function(e) {
                            return "Items"
                        },
                        nextPageTotal: function(e) {
                            return "+ " + e.VALUE + " more"
                        },
                        noSelectedData: function(e) {
                            return "No servers or cameras have been selected."
                        },
                        noSelectedDataSearch: function(e) {
                            return "No selected servers or cameras match search."
                        },
                        noServersCamerasDiscovered: function(e) {
                            return "No servers or cameras have been discovered."
                        },
                        noServersDiscovered: function(e) {
                            return "No servers have been discovered."
                        },
                        noServersCamerasMatchSearch: function(e) {
                            return "No servers or cameras match search."
                        },
                        noServersMatchSearch: function(e) {
                            return "No servers match search."
                        },
                        searchAllServersAndCameras: function(e) {
                            return "Search - all servers and cameras"
                        },
                        searchCamerasOnly: function(e) {
                            return "Search - cameras only"
                        },
                        searchServersOnly: function(e) {
                            return "Search - servers only"
                        },
                        searchForCameras: function(e) {
                            return "Search for cameras"
                        },
                        searchForServers: function(e) {
                            return "Search for servers"
                        },
                        searchForServersAndCameras: function(e) {
                            return "Search for servers and cameras"
                        },
                        searchOptions: function(e) {
                            return "Search options"
                        },
                        selectAllCameras: function(e) {
                            return "Select all cameras"
                        },
                        selectAllServers: function(e) {
                            return "Select all servers"
                        },
                        selectedOnly: function(e) {
                            return "Selected only"
                        },
                        serverIsSelected: function(e) {
                            return "Server is selected"
                        },
                        servers: function(e) {
                            return "Servers"
                        },
                        showThumbnails: function(e) {
                            return "Show thumbnails"
                        },
                        tableView: function(e) {
                            return "Table view"
                        },
                        totalCameras: function(e) {
                            return "Cameras: " + e.CAMERAS
                        },
                        totalServers: function(e) {
                            return "Servers: " + e.SERVERS
                        },
                        viewSelectedOnly: function(e) {
                            return "View selected only"
                        }
                    },
                    recordingsStyles: {
                        group: {
                            continuous: function(e) {
                                return "Continuous recording options"
                            },
                            nonRecordingOptions: function(e) {
                                return "Non-recording options"
                            },
                            noncontinuous: function(e) {
                                return "Noncontinuous recording"
                            }
                        },
                        name: {
                            continuousAdaptiveMotion: function(e) {
                                return "Continuous recording with motion adaptive frame rate"
                            },
                            continuousMotion: function(e) {
                                return "Continuous recording with motion detection"
                            },
                            continuousNoMotion: function(e) {
                                return "Continuous recording without motion detection"
                            },
                            proxyOnlyNoVideo: function(e) {
                                return "Proxy only, no video will be recorded"
                            },
                            recordOnlyWhenMotionDetected: function(e) {
                                return "Recording only when motion detected"
                            }
                        }
                    },
                    motionStyles: {
                        camera: function(e) {
                            return "Camera"
                        },
                        server: function(e) {
                            return "Server"
                        },
                        none: function(e) {
                            return "None"
                        }
                    },
                    invalidStreamConfig: {
                        modeMismatch: function(e) {
                            return "Orchid Recorder is configured to use camera events for motion detection, but the stream is not configured to send any events."
                        },
                        topicFilterMismatch: function(e) {
                            return "Orchid Recorder is configured to use camera events for motion detection, but the stream is not configured to send related events."
                        },
                        invalidTopic: function(e) {
                            return "Orchid Recorder is configured to use camera events for motion detection, but the camera does not support the configured event Topic."
                        }
                    },
                    motionStyle: function(e) {
                        return "Motion Style"
                    },
                    cameraEvent: function(e) {
                        return "Camera Event"
                    },
                    attention: {
                        G726AudioNotSupportedWarning: function(e) {
                            return "Warning! Your chosen audio configuration is not supported!"
                        },
                        motionReductionFeatureOnlyWorksWith: function(e) {
                            return "Attention! The Motion Reduction feature requires an H264 encoded stream, so to take advantage of this feature, you'll need to configure your Encoder below to use H264."
                        },
                        motionReductionFeatureOnlyWorksWithNote: function(e) {
                            return "Please note that our Motion Reduction feature requires an H264 stream with a specific Frame Rate and GOV Length.\nSince you're using our Generic RTSP driver, we cannot control the encoder, frame rate, or GOV Length, so to take full advantage of Motion Reduction, you'll need to configure the source stream appropriately."
                        },
                        recordOnlyWhenMotionDetected: function(e) {
                            return "Attention! With this mode, motion detection accuracy may vary and result in video loss."
                        },
                        secondaryStreamsConfiguredWithAVALUEEncoderWillNotBeAvailableForViewingOnTheStage: function(e) {
                            return "Attention! Secondary streams configured with " + r(e.VALUE, "en") + " encoder will not be available for viewing on the stage."
                        },
                        smartSearchIsOnlyAvailableWhenUsingServerMotionDetection: function(e) {
                            return "Attention! Smart Search is only available when using Server motion detection."
                        },
                        transcodedAudioWarningForEncoderOnPRODUCT: function(e) {
                            return "Warning! Your chosen audio settings require transcoding and will increase load on your " + e.PRODUCT + " server."
                        },
                        whileInProxyMode: function(e) {
                            return 'Attention! While in "Proxy only" mode the following features are not available:'
                        },
                        whileMotionDetectionIsDisabled: function(e) {
                            return "Attention! While motion detection is disabled, live view will not be available in low bandwidth mode."
                        },
                        noCameraCapabilities: function(e) {
                            return "Attention! Orchid Recorder is configured to use events sent by this camera to flag motion, but the camera does not support sending events."
                        }
                    },
                    actions: function(e) {
                        return "Actions"
                    },
                    add: function(e) {
                        return "Add"
                    },
                    addCamera: function(e) {
                        return "Add Camera"
                    },
                    addStream: function(e) {
                        return "Add Stream"
                    },
                    advanced: function(e) {
                        return "Advanced"
                    },
                    areYouSureDeleteCameras: function(e) {
                        return "Are you sure you want to delete the selected cameras?"
                    },
                    ariaLabels: {
                        selectCameraPage: function(e) {
                            return "Select camera page"
                        }
                    },
                    aspectRatio: function(e) {
                        return "Aspect Ratio"
                    },
                    auto: function(e) {
                        return "auto"
                    },
                    bestMatch: function(e) {
                        return "Best Match"
                    },
                    brush: function(e) {
                        return "Brush"
                    },
                    camera: function(e) {
                        return "Camera"
                    },
                    cameraId: function(e) {
                        return "Camera Id"
                    },
                    cameraImageCouldNotBeRetrieved: function(e) {
                        return "An image for this camera could not be retrieved."
                    },
                    cameraInformation: function(e) {
                        return "Camera Information"
                    },
                    cameraMacAddress: function(e) {
                        return "Camera MAC Address"
                    },
                    cameraModel: function(e) {
                        return "Camera Model"
                    },
                    cameraModelOrIpAddress: function(e) {
                        return "Camera model or IP address"
                    },
                    cameraName: function(e) {
                        return "Camera Name"
                    },
                    cameraNameRequired: function(e) {
                        return "Camera name is required."
                    },
                    cameraPosition: function(e) {
                        return "Camera Position"
                    },
                    cameraReachedMaximumNumStreams: function(e) {
                        return "This camera has reached the maximum number of streams allowed.  Please delete or modify an existing stream."
                    },
                    cameraTags: function(e) {
                        return "Camera Tags"
                    },
                    recordingStatistics: function(e) {
                        return "Recording Statistics"
                    },
                    averageWindow: function(e) {
                        return "Average Window"
                    },
                    packetLoss: function(e) {
                        return "Packet Loss"
                    },
                    lastArchive: function(e) {
                        return "Last Video File Written"
                    },
                    statsTotal: function(e) {
                        return "Total"
                    },
                    statsVideo: function(e) {
                        return "Video"
                    },
                    perSecond: function(e) {
                        return "/s"
                    },
                    seconds: function(e) {
                        return "s"
                    },
                    minutes: function(e) {
                        return "m"
                    },
                    cameraManualAdd: {
                        cameraNameRequired: function(e) {
                            return "Camera name required."
                        },
                        driverRequired: function(e) {
                            return "Driver required."
                        },
                        onvifDiscoveryUrlRequired: function(e) {
                            return "ONVIF Discovery URL required."
                        },
                        rtspStreamUriRequired: function(e) {
                            return "RTSP Stream URI required."
                        }
                    },
                    camerasRegistered: function(e) {
                        return "Cameras Registered"
                    },
                    cameraRtspURL: function(e) {
                        return "Camera RTSP URL"
                    },
                    cameraSearch: function(e) {
                        return "Camera Search"
                    },
                    cameraStreamId: function(e) {
                        return "Camera " + e.CID + ", Stream " + e.SID
                    },
                    cameraStreamRTSPURL: function(e) {
                        return "Camera Stream RTSP URL"
                    },
                    cameraStreamProxyRTSPURL: function(e) {
                        return "Camera Stream Proxy RTSP URL"
                    },
                    cancel: function(e) {
                        return "Cancel"
                    },
                    ceiling: function(e) {
                        return "Ceiling"
                    },
                    clear: function(e) {
                        return "Clear"
                    },
                    clickToRefresh: function(e) {
                        return "click to refresh"
                    },
                    configurationProtocol: {
                        configurationProtocol: function(e) {
                            return "Configuration Protocol"
                        },
                        editCameraConfigurationProtocol: function(e) {
                            return "Edit Camera Configuration Protocol"
                        },
                        save: function(e) {
                            return "Save"
                        }
                    },
                    connectionPreference: {
                        connectionPreference: function(e) {
                            return "Connection Preference"
                        },
                        connectionSettings: function(e) {
                            return "Connection Settings"
                        },
                        useHttpIfHttpsIsUnavailable: function(e) {
                            return "Use HTTP if HTTPS is unavailable"
                        },
                        ignoreTlsCertificateValidation: function(e) {
                            return "Ignore TLS certificate validation"
                        }
                    },
                    connectionSettings: function(e) {
                        return "Connection Settings"
                    },
                    copy: function(e) {
                        return "Copy"
                    },
                    copyAllSettings: function(e) {
                        return "Copy all settings"
                    },
                    copyMacAddress: function(e) {
                        return "Copy MAC Address"
                    },
                    copyProxyURL: function(e) {
                        return "Copy Proxy URL"
                    },
                    copyURL: function(e) {
                        return "Copy URL"
                    },
                    copyWhatToCameras: function(e) {
                        return "Copy " + e.VALUE + " to Cameras"
                    },
                    credentials: function(e) {
                        return "Credentials"
                    },
                    decodeAllFrames: function(e) {
                        return "Decode all frames"
                    },
                    defaultPan: function(e) {
                        return "Default Pan"
                    },
                    defaultTilt: function(e) {
                        return "Default Tilt"
                    },
                    defaultZoom: function(e) {
                        return "Default Zoom"
                    },
                    delete: function(e) {
                        return "Delete"
                    },
                    deleteCamera: function(e) {
                        return "Delete Camera"
                    },
                    deleteFailed: function(e) {
                        return " delete failed"
                    },
                    deleteNamedCamera: function(e) {
                        return 'Delete camera "' + e.VALUE + '"?'
                    },
                    deleteNamedStream: function(e) {
                        return 'Delete stream "' + e.VALUE + '"?'
                    },
                    deleteSelected: function(e) {
                        return "Delete Selected"
                    },
                    deleteSelectedCameras: function(e) {
                        return "Delete Selected Cameras"
                    },
                    depth: function(e) {
                        return "Depth"
                    },
                    motion: function(e) {
                        return "Motion"
                    },
                    detection: function(e) {
                        return "Detection"
                    },
                    configuration: function(e) {
                        return "Configuration"
                    },
                    motionDetectionConfigurationTitle: function(e) {
                        return 'Motion <span class="hide-xs">Detection</span> Configuration'
                    },
                    dewarpConfiguration: function(e) {
                        return "Dewarp Configuration"
                    },
                    dewarpSettings: function(e) {
                        return "Dewarp Settings"
                    },
                    dewarping: function(e) {
                        return "Dewarping"
                    },
                    disabled: function(e) {
                        return "Disabled"
                    },
                    discoveryURL: function(e) {
                        return "Discovery URL"
                    },
                    done: function(e) {
                        return "Done"
                    },
                    driver: function(e) {
                        return "Driver"
                    },
                    edit: function(e) {
                        return "Edit"
                    },
                    editCameraName: function(e) {
                        return "Edit Camera Name"
                    },
                    editName: function(e) {
                        return "Edit Name"
                    },
                    enable: function(e) {
                        return "Enable"
                    },
                    enabled: function(e) {
                        return "Enabled"
                    },
                    error: function(e) {
                        return "Error"
                    },
                    errors: function(e) {
                        return "Errors:"
                    },
                    failedToInitializeDewarper: function(e) {
                        return "Failed to initialize dewarper"
                    },
                    failedToLoadPreview: function(e) {
                        return "Failed to load stream preview"
                    },
                    failedToRemoveNamedCamera: function(e) {
                        return "Failed to remove " + e.VALUE
                    },
                    failedToSaveDewarpConfig: function(e) {
                        return "Failed to save dewarp configuration"
                    },
                    fisheye: function(e) {
                        return "Fisheye"
                    },
                    fixedStreamNoDelete: function(e) {
                        return "Fixed stream; cannot delete"
                    },
                    floor: function(e) {
                        return "Floor"
                    },
                    frameRateDuringMotion: function(e) {
                        return "Frame Rate During Motion"
                    },
                    frameRateDuringNonMotion: function(e) {
                        return "Frame Rate During Non-Motion"
                    },
                    frontDoorCam: function(e) {
                        return "Front Door Cam"
                    },
                    genericRtsp: function(e) {
                        return "Generic RTSP"
                    },
                    hideFields: function(e) {
                        return "Hide fields"
                    },
                    liveViewLowBandwidthMode: function(e) {
                        return "Live view in low bandwidth mode"
                    },
                    loadingCameras: function(e) {
                        return "Loading Cameras..."
                    },
                    loadingStreamSettings: function(e) {
                        return "Loading Stream Settings"
                    },
                    lowBandwithSettings: function(e) {
                        return "Low-bandwidth Settings"
                    },
                    manual: function(e) {
                        return "Manual"
                    },
                    metadataStatistics: {
                        metadataStatsBlurb: function(e) {
                            return "The following statistics represent non-audio/video metadata received from the camera via the ONVIF protocol. The ONVIF Event data recorded here is updated independently of any Event Subscriptions with which the camera is associated."
                        },
                        metadata: function(e) {
                            return "Camera Metadata"
                        },
                        timestamp: function(e) {
                            return "Time Last Received"
                        },
                        analyticsTimestampMs: function(e) {
                            return "ONVIF Analytics"
                        },
                        eventsTimestampMs: function(e) {
                            return "ONVIF Event"
                        },
                        motionRegionsTimestampMs: function(e) {
                            return "ONVIF Analytics Motion Regions"
                        },
                        noData: function(e) {
                            return "No camera metadata was discovered."
                        }
                    },
                    mode: function(e) {
                        return "Mode"
                    },
                    model: function(e) {
                        return "Model"
                    },
                    motionDetection: function(e) {
                        return "Motion Detection"
                    },
                    motionDetectionConfiguration: function(e) {
                        return "Motion Detection Configuration"
                    },
                    motionMask: function(e) {
                        return "Motion Mask"
                    },
                    motionMaskBrushUsage: function(e) {
                        return "Use the brush to paint the areas of the image that should be ignored when determining if there is motion on this camera. No mask means all motion will be detected."
                    },
                    name: function(e) {
                        return "Name"
                    },
                    nameServerOrCamera: function(e) {
                        return "Name, Server or Camera"
                    },
                    noCamerasConfigured: function(e) {
                        return "No cameras have been configured."
                    },
                    noCamerasDiscovered: function(e) {
                        return "No cameras have been discovered."
                    },
                    noCamerasForCopy: function(e) {
                        return "No cameras for copy."
                    },
                    noCamerasMatchSearch: function(e) {
                        return "No cameras match search."
                    },
                    none: function(e) {
                        return "none"
                    },
                    noResponseFromOrchid: function(e) {
                        return "No response was returned from Orchid Recorder."
                    },
                    objectSize: function(e) {
                        return "Object Size"
                    },
                    objectSizeSliderUsage: function(e) {
                        return "Use the slider to change the size of the box. Objects larger than the area of the box will be detected as motion on this camera."
                    },
                    offline: function(e) {
                        return "Offline"
                    },
                    online: function(e) {
                        return "Online"
                    },
                    onvifDiscoveryURL: function(e) {
                        return "ONVIF Discovery URL"
                    },
                    overwritePrimaryStream: function(e) {
                        return "Overwrite primary stream"
                    },
                    panorama: function(e) {
                        return "Panorama"
                    },
                    password: function(e) {
                        return "Password"
                    },
                    pending: function(e) {
                        return "Pending"
                    },
                    perfect: function(e) {
                        return "Perfect"
                    },
                    perspective: function(e) {
                        return "Perspective"
                    },
                    preview: function(e) {
                        return "Preview"
                    },
                    primaryStreamProxyRtspURL: function(e) {
                        return "Primary Stream Proxy RTSP URL"
                    },
                    primaryStreamRtspURL: function(e) {
                        return "Primary Stream RTSP URL"
                    },
                    primaryStreamStatus: function(e) {
                        return "Primary Stream Status"
                    },
                    primary: function(e) {
                        return "Primary"
                    },
                    proxy: function(e) {
                        return "Proxy"
                    },
                    recording: function(e) {
                        return "Recording"
                    },
                    recordingAndPlayback: function(e) {
                        return "Recording and playback"
                    },
                    recordingStyle: function(e) {
                        return "Recording Style"
                    },
                    recoverCamera: function(e) {
                        return "Recover Camera"
                    },
                    refresh: function(e) {
                        return "refresh"
                    },
                    register: function(e) {
                        return "Register"
                    },
                    registerCamera: function(e) {
                        return "Register Camera"
                    },
                    registerCameras: function(e) {
                        return "Register Cameras"
                    },
                    registerSelectedCameras: function(e) {
                        return "Register Selected Cameras"
                    },
                    registrationError: function(e) {
                        return "Registration Error"
                    },
                    registrationStatus: function(e) {
                        return "Registration Status:"
                    },
                    restart: function(e) {
                        return "Restart"
                    },
                    restartStreamFailed: function(e) {
                        return "Stream failed to restart"
                    },
                    retryFailedCameras: function(e) {
                        return "Retry Failed Cameras"
                    },
                    rtspStreamUri: function(e) {
                        return "RTSP Stream URI"
                    },
                    save: function(e) {
                        return "Save"
                    },
                    searchCameras: function(e) {
                        return "Search cameras"
                    },
                    secondary: function(e) {
                        return "Secondary"
                    },
                    secondaryRecordingStyle: function(e) {
                        return "Secondary Recording Style"
                    },
                    setting: function(e) {
                        return "Setting"
                    },
                    settings: function(e) {
                        return "Settings"
                    },
                    shift: function(e) {
                        return "Shift"
                    },
                    showNHiddenFields: function(e) {
                        return "Show " + e.VALUE + " hidden " + n(e.VALUE, 0, t, {
                            one: "field",
                            other: "fields"
                        })
                    },
                    showOnlyPerfectCopies: function(e) {
                        return "Show only perfect copies"
                    },
                    size: function(e) {
                        return "Size"
                    },
                    status: function(e) {
                        return "Status"
                    },
                    stream: function(e) {
                        return "Stream"
                    },
                    streamId: function(e) {
                        return "Stream Id"
                    },
                    streamConfiguration: function(e) {
                        return "Stream Configuration"
                    },
                    streamError: function(e) {
                        return "Stream Error:"
                    },
                    streamNameIsRequired: function(e) {
                        return "Stream name is required."
                    },
                    streamSettings: function(e) {
                        return "Stream Settings"
                    },
                    streamSettingsWillBeAdapted: function(e) {
                        return "The stream settings will be adapted as shown to work with the chosen cameras."
                    },
                    streamStatus: function(e) {
                        return "Stream Status"
                    },
                    streamURI: function(e) {
                        return "Stream URI"
                    },
                    streams: function(e) {
                        return "Streams"
                    },
                    streamTransportProtocol: function(e) {
                        return "Stream Transport Protocol"
                    },
                    success: function(e) {
                        return "Success!"
                    },
                    tag: function(e) {
                        return "Tag"
                    },
                    theCameraDoesNotHavePrimaryStream: function(e) {
                        return "The camera does not have a primary stream."
                    },
                    theCameraInProxyOnlyMode: function(e) {
                        return "The camera is in proxy only mode."
                    },
                    theCameraNotInRunningState: function(e) {
                        return "The camera is not in a running state."
                    },
                    theCamerasIPHasChanged: function(e) {
                        return "The camera's IP address has changed"
                    },
                    theCamerasSettingsChangedOutsideOf: function(e) {
                        return "The camera's settings have been changed outside of Orchid Recorder"
                    },
                    theFollowingStatisticsAreBasedOnThePrimaryStream: function(e) {
                        return "The following statistics are based on the primary stream."
                    },
                    theseValuesCanBeManipulatedMotionReduce: function(e) {
                        return "These values can be manipulated above while Motion Reduction is selected."
                    },
                    thumbnailPreview: function(e) {
                        return "Thumbnail previews"
                    },
                    unableToDetermineRecordingStyle: function(e) {
                        return "Unable to determine recording style. Default recording style has been applied."
                    },
                    unableToDetermineMotionStyle: function(e) {
                        return "Unable to determine motion style. Default motion style has been applied."
                    },
                    unableToMarkStreamAsDisabled: function(e) {
                        return "Unable to mark stream as disabled."
                    },
                    unableToMarkStreamAsPrimary: function(e) {
                        return "Unable to mark stream as primary."
                    },
                    unableToMarkStreamAsSecondary: function(e) {
                        return "Unable to mark stream as secondary."
                    },
                    unableToRetrieve: function(e) {
                        return "unable to retrieve"
                    },
                    unknownGenericRTSP: function(e) {
                        return "Unknown, Generic RTSP"
                    },
                    unknownRecordingStyleChosen: function(e) {
                        return "Unknown recording style chosen: " + e.VALUE
                    },
                    unknownType: function(e) {
                        return "unknown type"
                    },
                    updateCamera: function(e) {
                        return "Update Camera"
                    },
                    updateStream: function(e) {
                        return "Update Stream"
                    },
                    useThisToRecoverAndSynchronize: function(e) {
                        return "Use this to recover and synchronize your camera when:"
                    },
                    username: function(e) {
                        return "Username"
                    },
                    value: function(e) {
                        return "Value"
                    },
                    wall: function(e) {
                        return "Wall"
                    },
                    wallFlipped: function(e) {
                        return "Wall (flipped)"
                    },
                    whichSettings: function(e) {
                        return e.VALUE + " Settings"
                    },
                    copyStream: {
                        translateFeatureId: function(e) {
                            return e.VALUE
                        }
                    },
                    daylightSavingsTime: function(e) {
                        return "Daylight Saving Time"
                    },
                    editCameraNTPSettings: function(e) {
                        return "Edit Camera NTP Settings"
                    },
                    editCameraTZSettings: function(e) {
                        return "Edit Camera Time Zone Settings"
                    },
                    editStreamTPSettings: function(e) {
                        return "Edit Stream Transport Protocol"
                    },
                    ntpServer: function(e) {
                        return "NTP Server"
                    },
                    ntpSettings: function(e) {
                        return "NTP Settings"
                    },
                    timeZone: function(e) {
                        return "Time Zone"
                    },
                    unknownTZ: function(e) {
                        return "Unknown Time Zone"
                    },
                    updateNTPSettings: function(e) {
                        return "Update NTP Settings"
                    },
                    updateTPSettings: function(e) {
                        return "Update Transport Protocol"
                    },
                    updateTZSettings: function(e) {
                        return "Update Time Zone Settings"
                    },
                    useNTPSettingsFromDHCPServer: function(e) {
                        return "Use NTP settings from DHCP server"
                    },
                    usesNTPSettingsFromDHCPServer: function(e) {
                        return "Uses NTP settings from DHCP server"
                    },
                    reactivateCamera: function(e) {
                        return "Reactivate Camera"
                    },
                    camerasEnabled: function(e) {
                        return "Cameras Enabled"
                    },
                    disableCamera: function(e) {
                        return "Disable Camera"
                    },
                    youveReachedTheMaximumNumberOfCamerasForYourCurrentLicense: function(e) {
                        return "You've reached the maximum number of cameras for your current license."
                    },
                    youAreAboutToDisableCamera: function(e) {
                        return "You are about to disable " + e.VALUE
                    },
                    youAreAboutToReactivateCamera: function(e) {
                        return "You are about to reactivate camera " + e.VALUE
                    },
                    onceDisabled: function(e) {
                        return "Once disabled, this camera will not be available for live feed and will not be recording further footage from this point onward."
                    },
                    deleteThisCamera: function(e) {
                        return "Delete this camera from the server when there is no more archived footage"
                    },
                    VALUECamerasDisabled: function(e) {
                        return e.VALUE + " " + n(e.VALUE, 0, t, {
                            one: "Camera",
                            other: "Cameras"
                        }) + " Disabled"
                    },
                    advancedSettings: {
                        fisheyeDewarping: function(e) {
                            return "Fisheye Dewarping"
                        },
                        configureDewarp: function(e) {
                            return "Configure dewarp options for this camera"
                        },
                        motionDetectionMask: function(e) {
                            return "Motion Detection Mask"
                        },
                        configureMaskedArea: function(e) {
                            return "Configure masked area for motion detection"
                        },
                        talkDown: function(e) {
                            return "Talk Down"
                        },
                        allowUsersToTalk: function(e) {
                            return "Allow users to talk to this camera"
                        },
                        edit: function(e) {
                            return "Edit"
                        },
                        on: function(e) {
                            return "ON"
                        }
                    }
                },
                cameraGroups: {
                    addCameraGroup: function(e) {
                        return "Add Camera Group"
                    },
                    addCameraGroupShort: function(e) {
                        return "Camera Group"
                    },
                    addCamerasToGroup: function(e) {
                        return "Add Cameras to Group"
                    },
                    addGroup: function(e) {
                        return "Add Group"
                    },
                    addMap: function(e) {
                        return "Add Map"
                    },
                    addSubGroup: function(e) {
                        return "Add Sub-Group"
                    },
                    addSubGroupShort: function(e) {
                        return "Sub-Group"
                    },
                    addToGroup: function(e) {
                        return "Add to Group"
                    },
                    addToGroupShort: function(e) {
                        return "Add"
                    },
                    anErrorOccurredWhileAttemptingToDeleteTheGroup: function(e) {
                        return "An error occurred while attempting to delete the group"
                    },
                    anUnexpectedErrorHasOccurred: function(e) {
                        return "An unexpected error has occurred."
                    },
                    cameraGroupSettings: function(e) {
                        return "Camera Group Settings"
                    },
                    cancel: function(e) {
                        return "Cancel"
                    },
                    deleteGroup: function(e) {
                        return "Delete Group"
                    },
                    deleteGroupAndAllOfItsChildren: function(e) {
                        return 'Delete group "' + e.VALUE + '" and all of its children?'
                    },
                    deleteGroupShort: function(e) {
                        return "Delete"
                    },
                    editCameraGroup: function(e) {
                        return "Edit Camera Group"
                    },
                    editGroup: function(e) {
                        return "Edit Group"
                    },
                    editGroupShort: function(e) {
                        return "Edit"
                    },
                    editMap: function(e) {
                        return "Edit Map"
                    },
                    failedToLoadCameraGroups: function(e) {
                        return "Failed to load Camera Groups"
                    },
                    groupContainsVALUEOrMoreCameras: function(e) {
                        return "This group contains more than " + e.VALUE + " cameras. Edit the group to view them."
                    },
                    groupName: function(e) {
                        return "Group Name"
                    },
                    groupSettings: function(e) {
                        return "Group Settings"
                    },
                    groupNameIsRequired: function(e) {
                        return "Group name is required."
                    },
                    hideCameras: function(e) {
                        return "Hide Cameras"
                    },
                    home: function(e) {
                        return "Home"
                    },
                    loadingCameraGroups: function(e) {
                        return "Loading Camera Groups..."
                    },
                    map: function(e) {
                        return "Map"
                    },
                    movedNamedGroup: function(e) {
                        return "Move " + e.VALUE
                    },
                    moveGroup: function(e) {
                        return "Move Group"
                    },
                    newCameraGroup: function(e) {
                        return "New Camera Group"
                    },
                    noCameraGroupsExist: function(e) {
                        return "No Camera Groups exist."
                    },
                    noCameras: function(e) {
                        return "No Cameras."
                    },
                    noneTopLevelGroup: function(e) {
                        return "None, top level group"
                    },
                    numUngroupedCameras: function(e) {
                        return e.VALUE + " " + n(e.VALUE, 0, t, {
                            one: "Ungrouped Camera",
                            other: "Ungrouped Cameras"
                        })
                    },
                    numUngroupedCamerasShort: function(e) {
                        return e.VALUE + " Ungrouped"
                    },
                    orchidContainsVALUEOrMoreCameras: function(e) {
                        return "This server contains more than " + e.VALUE + " cameras. Edit the group to view them."
                    },
                    parentGroup: function(e) {
                        return "Parent Group"
                    },
                    selectAGroup: function(e) {
                        return "Select a group"
                    },
                    selectedCameraPlural: function(e) {
                        return e.VALUE + " " + n(e.VALUE, 0, t, {
                            one: "camera",
                            other: "cameras"
                        })
                    },
                    serversAndCameras: function(e) {
                        return "Servers and Cameras"
                    },
                    settings: function(e) {
                        return "Settings"
                    },
                    showNCameras: function(e) {
                        return "Show " + e.VALUE + " Cameras"
                    },
                    showServersInBagLower: function(e) {
                        return "Show servers in bag"
                    },
                    showServersInBag: function(e) {
                        return "Show Servers in Bag"
                    },
                    thisGroupIsEmpty: function(e) {
                        return "This group is empty."
                    },
                    updateGroup: function(e) {
                        return "Update Group"
                    },
                    updateSettings: function(e) {
                        return "Update Settings"
                    },
                    cameraGroupsRange: function(e) {
                        return "Camera Groups " + e.RANGE + " of " + e.LENGTH
                    },
                    yourSearchDidNotMatchAnyGroups: function(e) {
                        return "Your search didn't match any Camera Groups"
                    }
                },
                cameraSelection: {
                    noCamerasAvailable: function(e) {
                        return "There are no cameras available"
                    }
                },
                capabilities: {
                    BitRate: function(e) {
                        return "Bit Rate"
                    },
                    FrameRate: function(e) {
                        return "Frame Rate"
                    },
                    Quality: function(e) {
                        return "Quality"
                    },
                    Encoder: function(e) {
                        return "Encoder"
                    },
                    SampleRate: function(e) {
                        return "Sample Rate"
                    },
                    Resolution: function(e) {
                        return "Resolution"
                    },
                    EncoderInterval: function(e) {
                        return "Encoder Interval"
                    },
                    Profile: function(e) {
                        return "Profile"
                    },
                    GOVLength: function(e) {
                        return "GOV Length"
                    }
                },
                capabilityEnums: {
                    Main: function(e) {
                        return "Main"
                    },
                    High: function(e) {
                        return "High"
                    },
                    none: function(e) {
                        return "none"
                    },
                    Baseline: function(e) {
                        return "Baseline"
                    }
                },
                chips: {
                    allCameras: function(e) {
                        return "All Cameras"
                    },
                    noOptionsToSelect: function(e) {
                        return "No options to select."
                    },
                    orchidAllCameras: function(e) {
                        return e.VALUE + " all cameras"
                    },
                    pleaseChooseAnOptionFromTheMenu: function(e) {
                        return "Please choose an option from the menu."
                    },
                    searchForType: function(e) {
                        return "Search for " + e.TYPE + " ..."
                    },
                    searchPlaceholder: function(e) {
                        return "Search"
                    },
                    yourSearchDidNotMatchAnyResults: function(e) {
                        return "Your search did not match any results."
                    }
                },
                common: {
                    all: function(e) {
                        return "All"
                    },
                    anUnexpectedErrorOccurred: function(e) {
                        return "An unexpected error occurred."
                    },
                    back: function(e) {
                        return "Back"
                    },
                    camera: function(e) {
                        return "Camera"
                    },
                    cancel: function(e) {
                        return "Cancel"
                    },
                    canceled: function(e) {
                        return "Canceled"
                    },
                    confirm: function(e) {
                        return "Confirm"
                    },
                    delete: function(e) {
                        return "Delete"
                    },
                    done: function(e) {
                        return "Done"
                    },
                    failed: function(e) {
                        return "Failed"
                    },
                    inProgress: function(e) {
                        return "In Progress"
                    },
                    loading: function(e) {
                        return "Loading"
                    },
                    next: function(e) {
                        return "Next"
                    },
                    none: function(e) {
                        return "None"
                    },
                    ok: function(e) {
                        return "Ok"
                    },
                    password: function(e) {
                        return "Password"
                    },
                    passwordIsRequired: function(e) {
                        return "Password is required"
                    },
                    pending: function(e) {
                        return "Pending"
                    },
                    plusMore: function(e) {
                        return "+ " + e.VALUE + " more"
                    },
                    remove: function(e) {
                        return "Remove"
                    },
                    removing: function(e) {
                        return "Removing"
                    },
                    reset: function(e) {
                        return "Reset"
                    },
                    save: function(e) {
                        return "Save"
                    },
                    search: function(e) {
                        return "Search"
                    },
                    stream: function(e) {
                        return "Stream"
                    },
                    streamStatus: function(e) {
                        return "Stream Status"
                    },
                    streams: function(e) {
                        return "Streams"
                    },
                    success: function(e) {
                        return "Success"
                    },
                    timedOut: function(e) {
                        return "Timed Out"
                    },
                    unsupported: function(e) {
                        return "Unsupported"
                    },
                    username: function(e) {
                        return "Username"
                    },
                    usernameIsRequired: function(e) {
                        return "Username is required"
                    }
                },
                credentialsForm: {
                    errors: {
                        email: {
                            aValidEmailAddressRequired: function(e) {
                                return "A valid email address is required."
                            },
                            emailAddressRequired: function(e) {
                                return "Email address required."
                            }
                        },
                        username: {
                            invalidUsername: function(e) {
                                return "Invalid user name (alphanumeric characters and underscores only)."
                            },
                            usernameRequired: function(e) {
                                return "Username required."
                            }
                        },
                        password: {
                            passwordComfirmationRequired: function(e) {
                                return "Password confirmation required."
                            },
                            passwordDoNotMatch: function(e) {
                                return "Password do not match."
                            },
                            passwordMustBeAtLeast4Characters: function(e) {
                                return "Password must be at least 4 characters."
                            },
                            passwordRequired: function(e) {
                                return "Password required."
                            }
                        }
                    },
                    labels: {
                        confirmPassword: function(e) {
                            return "Confirm Password"
                        },
                        currentPassword: function(e) {
                            return "Current Password"
                        },
                        emailAddress: function(e) {
                            return "Email Address"
                        },
                        newPassword: function(e) {
                            return "New Password"
                        },
                        password: function(e) {
                            return "Password"
                        },
                        username: function(e) {
                            return "Username"
                        }
                    }
                },
                custom: {
                    appProvidedBy: function(e) {
                        return "App provided by:"
                    },
                    contactSupport: function(e) {
                        return "Contact Support"
                    },
                    done: function(e) {
                        return "Done"
                    },
                    name: function(e) {
                        return "Name"
                    },
                    support: function(e) {
                        return "Support"
                    },
                    supportOptions: function(e) {
                        return "Support Options"
                    },
                    theExtensionIsNotAvailable: function(e) {
                        return "The " + e.VALUE + " app is not available."
                    },
                    thePluginCouldNotBeFound: function(e) {
                        return "The " + e.PLUGIN + "/" + e.EXTENSION + " app could not be found"
                    },
                    theTypeOfAppIsNotSupported: function(e) {
                        return "The type of app " + e.NAME + "/" + e.ENAME + ", " + e.TYPE + ", is not supported"
                    },
                    version: function(e) {
                        return "Version"
                    }
                },
                dashboard: {
                    aValidHttpOrHttpsUrlIsRequired: function(e) {
                        return "A valid HTTP or HTTPS URL is required"
                    },
                    activation: function(e) {
                        return "Activation"
                    },
                    addChildName: function(e) {
                        return "Add Orchid Recorder"
                    },
                    addOrchid: function(e) {
                        return "Add Orchid Recorder"
                    },
                    alertUnregisterFailed: function(e) {
                        return "An error was encountered while unregistering " + e.VALUE + ". It may be unreachable."
                    },
                    anUnexpectedErrorHasOccurred: function(e) {
                        return "An unexpected error has occurred."
                    },
                    auditLogs: function(e) {
                        return "Audit Logs"
                    },
                    cameras: function(e) {
                        return "Cameras"
                    },
                    camerasOnline: function(e) {
                        return e.VALUE + " cameras online"
                    },
                    cancel: function(e) {
                        return "Cancel"
                    },
                    confirmRequired: function(e) {
                        return "Confirm required"
                    },
                    currentVersion: function(e) {
                        return "Current Version"
                    },
                    deleteOrchid: function(e) {
                        return "Delete " + e.VALUE
                    },
                    deleteOrchidDialogContent: function(e) {
                        return 'Unregister Orchid Recorder server named "' + e.VALUE + '"?'
                    },
                    editOrchid: function(e) {
                        return "Edit " + e.VALUE
                    },
                    health: function(e) {
                        return "Health"
                    },
                    licenseExpiration: function(e) {
                        return "expiring"
                    },
                    loadingServers: function(e) {
                        return "Loading Servers..."
                    },
                    minimumVersion: function(e) {
                        return "Minimum Version"
                    },
                    name: function(e) {
                        return "Name"
                    },
                    noChildNameServersHaveBeenRegistered: function(e) {
                        return "No Orchid Recorder servers are available."
                    },
                    noServersFound: function(e) {
                        return "No servers found."
                    },
                    noServersMatchSearch: function(e) {
                        return "Your search didn't match any Servers"
                    },
                    noSessionExistsForVALUE: function(e) {
                        return "No session exists for " + e.VALUE
                    },
                    password: function(e) {
                        return "Password"
                    },
                    passwordIsRequired: function(e) {
                        return "Password is required."
                    },
                    recoverOrchid: function(e) {
                        return "Recover " + e.VALUE
                    },
                    recoverThisServer: function(e) {
                        return "Recover this Orchid Recorder server"
                    },
                    refreshCameras: function(e) {
                        return "Refresh Cameras"
                    },
                    register: function(e) {
                        return "Register"
                    },
                    registerAOrAnVALUEServer: function(e) {
                        return "Register " + r(e.VALUE, "en") + " Server"
                    },
                    retentionPolicy: function(e) {
                        return "Retention Policy"
                    },
                    search: function(e) {
                        return "Search"
                    },
                    serverIsAvailable: function(e) {
                        return "healthy"
                    },
                    serverIsDegraded: function(e) {
                        return "degraded"
                    },
                    serverIsUnavailable: function(e) {
                        return "offline"
                    },
                    serverIsUnsupported: function(e) {
                        return "unsupported"
                    },
                    serverName: function(e) {
                        return "Server Name"
                    },
                    serverNameIsRequired: function(e) {
                        return "Server name is required."
                    },
                    serverUrl: function(e) {
                        return "Server URL"
                    },
                    serversRange: function(e) {
                        return "Servers " + e.RANGE + " of " + e.LENGTH
                    },
                    sort: function(e) {
                        return "Sort"
                    },
                    systemReport: function(e) {
                        return "System Report"
                    },
                    systemStatus: function(e) {
                        return "System Status"
                    },
                    thisServerWillAlwaysBeProxiedBecause: function(e) {
                        return "This server will always be proxied because it is not configured for HTTPS"
                    },
                    unregister: function(e) {
                        return "Unregister"
                    },
                    unregisterChildApp: function(e) {
                        return "Unregister Orchid Recorder"
                    },
                    unregisteringFailed: function(e) {
                        return "Unregistering " + e.VALUE + " failed"
                    },
                    unregisteringFailedReason: function(e) {
                        return "Reason: " + e.VALUE + " <br><br> Would you like to remove the Orchid Recorder server anyway?"
                    },
                    unsupportedOrchid: function(e) {
                        return "Unsupported Orchid Recorder Version"
                    },
                    unsupportedOrchidDescription: function(e) {
                        return "This server is likely still recording properly. However, this version of Orchid Hybrid VMS requires Orchid Recorder to be version " + e.VALUE + " or greater. Please update Orchid Recorder to restore the connection to the server."
                    },
                    update: function(e) {
                        return "Update"
                    },
                    updateOrchidServerSettings: function(e) {
                        return "Update " + e.VALUE + " Server Settings"
                    },
                    username: function(e) {
                        return "Username"
                    },
                    usernameIsRequired: function(e) {
                        return "Username is required."
                    },
                    users: function(e) {
                        return "Users"
                    },
                    version: function(e) {
                        return "Version"
                    },
                    versionInformation: function(e) {
                        return "Version Information"
                    },
                    youExceededTheCharacterLimit: function(e) {
                        return "You exceeded the character limit."
                    }
                },
                dialogs: {
                    anUnexpectedErrorHasOccurred: function(e) {
                        return "An unexpected error has occurred."
                    },
                    areYouSure: function(e) {
                        return "Are you sure?"
                    },
                    cancel: function(e) {
                        return "Cancel"
                    },
                    close: function(e) {
                        return "Close"
                    },
                    delete: function(e) {
                        return "Delete"
                    },
                    detach: function(e) {
                        return "Detach"
                    },
                    done: function(e) {
                        return "Done"
                    },
                    go: function(e) {
                        return "GO"
                    },
                    ok: function(e) {
                        return "Okay"
                    },
                    update: function(e) {
                        return "Update"
                    },
                    no: function(e) {
                        return "No"
                    },
                    required: function(e) {
                        return "Required"
                    },
                    bagDialog: {
                        playerLimitExceeded: function(e) {
                            return "Player Limit Exceeded"
                        },
                        cannotViewMoreThanNPlayers: function(e) {
                            return "You cannot view more than " + e.VALUE + " players at a time.  Please remove a player first and try again."
                        }
                    },
                    bagStagesDialog: {
                        nameRequired: function(e) {
                            return "Stage name is required."
                        },
                        newStage: function(e) {
                            return "New Stage"
                        },
                        renameNamedStage: function(e) {
                            return "Rename " + e.VALUE
                        },
                        renameStage: function(e) {
                            return "Rename Stage"
                        },
                        saveStage: function(e) {
                            return "Save Stage"
                        },
                        stageName: function(e) {
                            return "Stage Name"
                        }
                    },
                    licenseDialog: {
                        activate: function(e) {
                            return "Activate"
                        },
                        activation: function(e) {
                            return "Activation"
                        },
                        activationCode: function(e) {
                            return "Activation Code"
                        },
                        activationInstructions: function(e) {
                            return "Activation Instructions"
                        },
                        activationOrUpgradeCode: function(e) {
                            return "Activation or Upgrade Code"
                        },
                        ariaLabel: function(e) {
                            return "Licensing"
                        },
                        connectingToActivationService: function(e) {
                            return "Connecting to Activation Service"
                        },
                        licenseKey: function(e) {
                            return "License Key"
                        },
                        location: function(e) {
                            return "Location"
                        },
                        locationInputPlaceHolder: function(e) {
                            return "Store #12345 or Beach house"
                        },
                        machineId: function(e) {
                            return "Machine Id"
                        },
                        offline: function(e) {
                            return "Offline"
                        },
                        offLineActivation: function(e) {
                            return "Offline Activation"
                        },
                        offlineCAPS: function(e) {
                            return "OFFLINE"
                        },
                        onlineCAPS: function(e) {
                            return "ONLINE"
                        },
                        or: function(e) {
                            return "or"
                        },
                        pleaseProvideActivation: function(e) {
                            return "Please provide your Activation Code and a location description."
                        },
                        pleaseProvideActivationIsActive: function(e) {
                            return "Please provide your Activation or Upgrade Code and a location description."
                        },
                        toActivateAppNameAccessTheLicensingPortal: function(e) {
                            return '<p> To activate Orchid Hybrid VMS, access <strong> <a class="singularity-link text-link" target="_blank" href="http://vmsactivation.com/activation?machine_id=' + e.ID + '&bid=hybrid">the licensing portal</a></strong>. You will need your Machine ID (shown below) to generate a license key. </p>'
                        }
                    },
                    removeLicenseDialog: {
                        ariaLabel: function(e) {
                            return "Remove License"
                        },
                        failedToRemoveLicense: function(e) {
                            return "Failed to remove license"
                        },
                        areYouSure: function(e) {
                            return "Are you sure you want to deactivate Orchid Recorder?"
                        },
                        removeLicense: function(e) {
                            return "Remove License"
                        }
                    },
                    updateClientDialog: {
                        updateUIPackage: function(e) {
                            return "Update UI Package"
                        },
                        noFileSpecified: function(e) {
                            return "No file specified"
                        }
                    },
                    greetingDialog: {
                        dismiss: function(e) {
                            return "Dismiss"
                        },
                        accept: function(e) {
                            return "Accept"
                        }
                    }
                },
                dinosaur: {
                    alternativelyYouCanContinueInCompatibilityMode: function(e) {
                        return "Alternatively you can continue in compatibility mode."
                    },
                    browserCheck: function(e) {
                        return "Browser Check"
                    },
                    browserNotSupported: function(e) {
                        return "Your browser is no longer supported.  Some features may not work or will appear broken."
                    },
                    continueAnyway: function(e) {
                        return "continue anyway"
                    },
                    forTheBestStreamingExperiencePleaseDownload: function(e) {
                        return "For the best streaming experience please download:"
                    },
                    latest: function(e) {
                        return "latest"
                    },
                    stuffMaybeBroken: function(e) {
                        return "Stuff may be broken,"
                    },
                    toCorrectThis: function(e) {
                        return "To correct this, please download:"
                    },
                    thisBrowserDoesNotSupportWebSockets: function(e) {
                        return "This browser does not support WebSockets and is incompatible with Orchid Hybrid VMS."
                    }
                },
                error: {
                    proceedToTheStage: function(e) {
                        return "Proceed to the Stage"
                    }
                },
                errorBanner: {
                    noResultFound: function(e) {
                        return "No result found"
                    },
                    pageNotFound: function(e) {
                        return "Page Not Found"
                    },
                    pleaseTryAgain: function(e) {
                        return "Please try again another time"
                    },
                    somethingWentWrong: function(e) {
                        return "Something went wrong"
                    },
                    theRequestedResource: function(e) {
                        return "The requested resource could not be found"
                    },
                    tryUsingDifferentKeyword: function(e) {
                        return "Try using a different keyword"
                    },
                    tryUsingDifferentKeywordOrFilterOption: function(e) {
                        return "Try using a different keyword or filter option"
                    }
                },
                errors: {
                    connectionRemotelyEnded: function(e) {
                        return "Connection remotely ended"
                    },
                    couldNotEstablishIceConnection: function(e) {
                        return "Could not establish connection (ICE connection failed)"
                    },
                    errorHelp: function(e) {
                        return 'If this error persists or you do not know how to proceed, please open a ticket on our <a class="text-link" target="_blank" href="' + e.VALUE + '">support portal</a>.'
                    },
                    errorRenderingImage: function(e) {
                        return "Error rendering image"
                    },
                    failedToCreateLowBandwidthStream: function(e) {
                        return "Failed to create low bandwidth stream (status " + e.VALUE + ")"
                    },
                    failedToGetLowBandwidthStream: function(e) {
                        return "Failed to GET low bandwidth stream (status " + e.VALUE + ")"
                    },
                    highPacketLossDetected: function(e) {
                        return "High packet loss detected"
                    },
                    iceConnectionFailed: function(e) {
                        return "ICE Connection Failed"
                    },
                    iceConnectionClosed: function(e) {
                        return "Could not establish connection (ICE connection closed)"
                    },
                    incognitoFix: function(e) {
                        return "You are either using an ancient browser, Private Browsing, or Incognito Mode.  Please switch to normal browsing to use Orchid Hybrid VMS."
                    },
                    invalidAnswerSessionDescription: function(e) {
                        return "Invalid Answer SessionDescription"
                    },
                    invalidIceCandidate: function(e) {
                        return "Invalid ICE Candidate"
                    },
                    invalidWebRtcOffer: function(e) {
                        return "Invalid WebRTC Offer"
                    },
                    lowBandwidthStreamFailedToStart: function(e) {
                        return "Low bandwidth stream failed to start"
                    },
                    noResponseReturnedFrom: function(e) {
                        return "No response was returned from " + e.VALUE
                    },
                    notFound: function(e) {
                        return "Not found"
                    },
                    peerConnectionClosed: function(e) {
                        return "Peer Connection Closed"
                    },
                    peerConnectionDisconnected: function(e) {
                        return "Peer Connection Disconnected"
                    },
                    playFailure: function(e) {
                        return "Play failure: " + e.VALUE
                    },
                    playRequestCancelled: function(e) {
                        return "Play request cancelled"
                    },
                    playRequestUpdatedError: function(e) {
                        return "Play request updated"
                    },
                    pleaseCheckTheAddressAndTryAgainOrGotoFrontPage: function(e) {
                        return 'Please check the address and try again or <a href="#!/stage">go to the front page</a>'
                    },
                    poorConnectionNoDataReceived: function(e) {
                        return "Poor connection (no packets received)"
                    },
                    poorConnectionPacketLoss: function(e) {
                        return "Poor connection (packet loss)"
                    },
                    poorConnectionUnableToDecode: function(e) {
                        return "Poor connection (unable to decode video)"
                    },
                    problemsDecodingVideoFrames: function(e) {
                        return "Problems decoding video frames"
                    },
                    requestStreamFunctionMustBeCalledBeforeAnswerSdp: function(e) {
                        return "requestStream function must be called before answerSDP."
                    },
                    requestStreamFunctionMustBeCalledBeforeSendIcecandidate: function(e) {
                        return "requestStream function must be called before sendICECandidate."
                    },
                    theBrowserDoesNotSupportThisMediaFormat: function(e) {
                        return "The browser does not support this media format"
                    },
                    theBrowserIsPreventingTheMediaFromAutoplaying: function(e) {
                        return "The browser is preventing the media from autoplaying"
                    },
                    thePeerConnectionAlreadyHasARemoteDescriptionSet: function(e) {
                        return "The peer connection already has a remote description set."
                    },
                    timedOutWaitingForIceConnection: function(e) {
                        return "Timed out waiting for ICE connection to complete"
                    },
                    timedOutWaitingForStreamToPlay: function(e) {
                        return "Timed out waiting for stream to play"
                    },
                    tryAgain: function(e) {
                        return "Try again"
                    },
                    unexpectedErrorOccurred: function(e) {
                        return "An unexpected error occurred."
                    },
                    unexpectedResponseFromAuthService: function(e) {
                        return "Unexpected response from auth service"
                    },
                    unknownErrorOccurred: function(e) {
                        return "Unknown error occurred."
                    },
                    websocketClosedUnexpectedly: function(e) {
                        return "Websocket closed unexpectedly"
                    },
                    websocketError: function(e) {
                        return "Websocket error"
                    },
                    websocketFailedSend: function(e) {
                        return "Failed to send frame request over WebSocket"
                    },
                    yourBrowserDoesNotSupportWebStorage: function(e) {
                        return "Your browser does not support Web Storage"
                    }
                },
                events: {
                    active: function(e) {
                        return "Active"
                    },
                    cameras: function(e) {
                        return "Cameras"
                    },
                    category: function(e) {
                        return "Category"
                    },
                    COUNTevents: function(e) {
                        return e.COUNT + " " + n(e.COUNT, 0, t, {
                            1: "Event",
                            other: "Events"
                        })
                    },
                    event: function(e) {
                        return "Event"
                    },
                    eventDetails: {
                        eventId: function(e) {
                            return "Event ID"
                        },
                        onvifTopic: function(e) {
                            return "ONVIF topic"
                        },
                        sourceCamera: function(e) {
                            return "Source camera"
                        },
                        subscriptionId: function(e) {
                            return "Subscription ID"
                        }
                    },
                    eventName: function(e) {
                        return "Event Name"
                    },
                    events: function(e) {
                        return "Events"
                    },
                    eventsFilters: {
                        active: function(e) {
                            return "Active"
                        },
                        all: function(e) {
                            return "All"
                        },
                        categories: function(e) {
                            return "Categories"
                        },
                        dateRangeDialog: {
                            cancel: function(e) {
                                return "Cancel"
                            },
                            from: function(e) {
                                return "From"
                            },
                            mustBeAValidDateRange: function(e) {
                                return "Must be a valid date range"
                            },
                            ok: function(e) {
                                return "OK"
                            },
                            selectDateRange: function(e) {
                                return "Select Date Range"
                            },
                            to: function(e) {
                                return "To"
                            }
                        },
                        filterByCameras: function(e) {
                            return "Filter by Cameras"
                        },
                        filterByCategories: function(e) {
                            return "Filter by Categories"
                        },
                        filterByDate: function(e) {
                            return "Filter by Date"
                        },
                        filterByEventNames: function(e) {
                            return "Filter by Event Names"
                        },
                        filterByState: function(e) {
                            return "Filter by State"
                        },
                        fromDate: function(e) {
                            return "From date"
                        },
                        inactive: function(e) {
                            return "Inactive"
                        },
                        last12Hours: function(e) {
                            return "Last 12 hours"
                        },
                        last24Hours: function(e) {
                            return "Last 24 hours"
                        },
                        lastHour: function(e) {
                            return "Last hour"
                        },
                        noState: function(e) {
                            return "No State"
                        },
                        reset: function(e) {
                            return "Reset"
                        },
                        search: function(e) {
                            return "Search"
                        },
                        toDate: function(e) {
                            return "To date"
                        }
                    },
                    eventsSubscriptions: {
                        addToSubscription: function(e) {
                            return "Add to subscription"
                        },
                        anUnexpectedErrorOccurred: function(e) {
                            return "An unexpected error occurred."
                        },
                        associatedCameras: function(e) {
                            return "Associated Cameras"
                        },
                        associatedCamerasInstructions: function(e) {
                            return "Select cameras to associate with this event. Only selected cameras will appear in the Event Viewer."
                        },
                        back: function(e) {
                            return "Back"
                        },
                        camera: function(e) {
                            return "Camera"
                        },
                        cameraIsRequired: function(e) {
                            return "Camera is required"
                        },
                        cameras: function(e) {
                            return "Cameras"
                        },
                        cancel: function(e) {
                            return "Cancel"
                        },
                        category: function(e) {
                            return "Category"
                        },
                        categoryIsRequired: function(e) {
                            return "Category is required"
                        },
                        close: function(e) {
                            return "Close"
                        },
                        copiedExclamation: function(e) {
                            return "Copied!"
                        },
                        copyFailed: function(e) {
                            return "Copy failed"
                        },
                        copyUrl: function(e) {
                            return "Copy URL"
                        },
                        delete: function(e) {
                            return "Delete"
                        },
                        deleteSubscriptionVALUE: function(e) {
                            return "Delete subscription " + e.VALUE + "?"
                        },
                        edit: function(e) {
                            return "Edit"
                        },
                        editSubscription: function(e) {
                            return "Edit Subscription"
                        },
                        enterSubscriptionName: function(e) {
                            return "Enter subscription name"
                        },
                        eventSubscriptions: function(e) {
                            return "Event Subscriptions"
                        },
                        eventSubscriptionTags: function(e) {
                            return "Event Subscription Tags"
                        },
                        eventType: function(e) {
                            return "Event Type"
                        },
                        external: function(e) {
                            return "External"
                        },
                        failedToLoadEventSubscriptions: function(e) {
                            return "Failed to load Event Subscriptions"
                        },
                        failedToLoadSubscriptionDataForVALUE: function(e) {
                            return "Failed to load subscription data for " + e.VALUE
                        },
                        id: function(e) {
                            return "ID"
                        },
                        information: function(e) {
                            return "Information"
                        },
                        loadingEventSubscriptions: function(e) {
                            return "Loading Event Subscriptions"
                        },
                        loadingSubscriptionData: function(e) {
                            return "Loading subscription data"
                        },
                        name: function(e) {
                            return "Name"
                        },
                        nameCategoryOrOnvifTopic: function(e) {
                            return "Name, Category or ONVIF Topic"
                        },
                        nameIsRequired: function(e) {
                            return "Name is required"
                        },
                        new: function(e) {
                            return "New"
                        },
                        newSubscription: function(e) {
                            return "New Subscription"
                        },
                        next: function(e) {
                            return "Next"
                        },
                        noAssociatedCamerasWereSelected: function(e) {
                            return "No associated cameras were selected"
                        },
                        noSubscriptionsHaveBeenConfigured: function(e) {
                            return "No subscriptions have been configured"
                        },
                        noneSelected: function(e) {
                            return "None selected"
                        },
                        onvif: function(e) {
                            return "ONVIF"
                        },
                        onvifTopic: function(e) {
                            return "ONVIF Topic"
                        },
                        onvifTopicIsRequired: function(e) {
                            return "ONVIF Topic is required"
                        },
                        review: function(e) {
                            return "Review"
                        },
                        saveSubscription: function(e) {
                            return "Save Subscription"
                        },
                        search: function(e) {
                            return "Search"
                        },
                        searchSubscriptions: function(e) {
                            return "Search subscriptions"
                        },
                        selectAnEventType: function(e) {
                            return "Select an event type"
                        },
                        sourceCamera: function(e) {
                            return "Source camera"
                        },
                        subscribeToAnExternalEvent: function(e) {
                            return "Subscribe to an event external to this Orchid Recorder"
                        },
                        subscribeToAnOnvifEvent: function(e) {
                            return "Subscribe to an ONVIF event emitted from a specific camera"
                        },
                        subscription: function(e) {
                            return "Subscription"
                        },
                        subscriptionID: function(e) {
                            return "Subscription " + e.ID
                        },
                        subscriptionName: function(e) {
                            return "Subscription name"
                        },
                        theSelectedCameraWillEmitAnOnvifEventWheneverTheOnvifTopicCriteriaIsMet: function(e) {
                            return "The selected camera will emit an ONVIF event whenever the criteria for the chosen ONVIF topic is met"
                        },
                        tag: function(e) {
                            return "Tag"
                        },
                        type: function(e) {
                            return "Type"
                        },
                        typeIsRequired: function(e) {
                            return "Type is required"
                        },
                        unknown: function(e) {
                            return "Unknown"
                        },
                        usageDirections: function(e) {
                            return "Usage Directions"
                        },
                        webhookApiUrl: function(e) {
                            return "Webhook API URL"
                        },
                        webhookInstructions: function(e) {
                            return "Webhook Instructions"
                        },
                        webhookUsageInstructions: function(e) {
                            return '<p>\n  This URL can be used by external systems to POST events to this Orchid Recorder. The minimum payload has the form:<br><br>\n  <code class="example-object">\n    &lbrace;<br>\n    <span>"eventTime": number,</span>\n    <span>"active": boolean,</span>\n    <span>"message": &lbrace; . . . &rbrace;</span>\n    &rbrace;<br>\n  </code>\n    <br>\n    <div><b>eventTime:</b> The time the event occurred.</div>\n    <div><b>active:</b> The state of the event (true, false or null).</div>\n    <div><b>message:</b> Any valid JSON object.</div>\n</p>\n'
                        },
                        selectAnAPPNAMEServerToConfigureItsEventSubscriptions: function(e) {
                            return "Select an Orchid Recorder server to configure its event subscriptions"
                        },
                        urlAvailableAfterSaving: function(e) {
                            return "This URL will be available after saving successfully."
                        }
                    },
                    eventsViewer: {
                        eventDetails: function(e) {
                            return "Event Details"
                        },
                        events: function(e) {
                            return "Events"
                        },
                        loadingEvents: function(e) {
                            return "Loading events..."
                        },
                        loadingServers: function(e) {
                            return "Loading servers..."
                        },
                        noAssociatedCameras: function(e) {
                            return "No associated cameras"
                        },
                        refreshIsNotAvailable: function(e) {
                            return "Refresh is not available with custom date range filter"
                        },
                        selectAServer: function(e) {
                            return "Select a server to see events"
                        },
                        somethingWentWrong: function(e) {
                            return "Something went wrong"
                        },
                        tryAgain: function(e) {
                            return "Try again?"
                        },
                        VALUENewEventsSinceLastRefresh: function(e) {
                            return e.VALUE + " new " + n(e.VALUE, 0, t, {
                                one: "event",
                                other: "events"
                            }) + " since last refresh"
                        }
                    },
                    failedToFetchEvents: function(e) {
                        return "Failed to fetch events"
                    },
                    fetchingEvents: function(e) {
                        return "Fetching events"
                    },
                    inactive: function(e) {
                        return "Inactive"
                    },
                    noEventsFound: function(e) {
                        return "No events found."
                    },
                    noEventSubscriptionsHaveBeenConfigured: function(e) {
                        return "No event subscriptions have been configured."
                    },
                    none: function(e) {
                        return "None"
                    },
                    orchidSelector: {
                        registerAServer: function(e) {
                            return "Register a Server"
                        },
                        noServersConfigured: function(e) {
                            return "No servers configured"
                        },
                        notAvailable: function(e) {
                            return "Not available for version " + e.VALUE
                        },
                        searchForServer: function(e) {
                            return "Search for server.."
                        },
                        server: function(e) {
                            return "Server"
                        },
                        serverUnavailable: function(e) {
                            return "Server is currently unavailable"
                        }
                    },
                    STARTdashCOUNTofmany: function(e) {
                        return e.START + " - " + e.COUNT + " of many"
                    },
                    state: function(e) {
                        return "State"
                    },
                    time: function(e) {
                        return "Time"
                    }
                },
                expired: {
                    expired: function(e) {
                        return "Expired"
                    },
                    theRequestedResourceHasExpired: function(e) {
                        return "The requested resource has expired."
                    }
                },
                externalProviders: {
                    activeDirectory: function(e) {
                        return "Active Directory"
                    },
                    azureActiveDirectory: function(e) {
                        return "Azure Active Directory"
                    },
                    freeIPA: function(e) {
                        return "FreeIPA"
                    },
                    googleOAuth: function(e) {
                        return "Google OAuth"
                    },
                    saml: function(e) {
                        return "SAML"
                    }
                },
                groups: {
                    abilities: function(e) {
                        return "Abilities:"
                    },
                    abilitiesTitle: function(e) {
                        return "Abilities"
                    },
                    add: function(e) {
                        return "Add"
                    },
                    addGroup: function(e) {
                        return "Add Group"
                    },
                    addPermissionGroup: function(e) {
                        return "Add Permission Group"
                    },
                    admin: function(e) {
                        return "Admin"
                    },
                    administratorGroup: function(e) {
                        return "Administrator Group"
                    },
                    adminPrivilege: function(e) {
                        return "Admin Privilege"
                    },
                    aGroupOfUsersForSpecifyingPermissions: function(e) {
                        return "A group of users for specifying permissions"
                    },
                    all: function(e) {
                        return "All"
                    },
                    allApps: function(e) {
                        return "All Apps"
                    },
                    allCameras: function(e) {
                        return "All Cameras"
                    },
                    allServersAndCameras: function(e) {
                        return "All servers and cameras"
                    },
                    andSlashOr: function(e) {
                        return "and/or"
                    },
                    anUnexpectedErrorOccurred: function(e) {
                        return "An unexpected error occurred."
                    },
                    app: function(e) {
                        return "App"
                    },
                    apps: function(e) {
                        return "Apps"
                    },
                    appsAccess: function(e) {
                        return "Apps Access"
                    },
                    areYouSureYouWantToDeleteThisGroup: function(e) {
                        return "Are you sure you want to delete this group?"
                    },
                    bothDomainAndGroupValuesAreRequired: function(e) {
                        return "Both domain and group values are required."
                    },
                    cancel: function(e) {
                        return "cancel"
                    },
                    delete: function(e) {
                        return "Delete"
                    },
                    domain: function(e) {
                        return "Domain"
                    },
                    done: function(e) {
                        return "Done"
                    },
                    editGroup: function(e) {
                        return "Edit Group"
                    },
                    editGroupShort: function(e) {
                        return "Edit"
                    },
                    editNamedGroup: function(e) {
                        return "Edit " + e.VALUE
                    },
                    extendedSaml: {
                        addAnAttributeSet: function(e) {
                            return "Add an attribute set"
                        },
                        addAnotherAttribute: function(e) {
                            return "Add another attribute"
                        },
                        attribute: function(e) {
                            return "Attribute"
                        },
                        attributeGroupMappings: function(e) {
                            return "Attribute Group Mappings"
                        },
                        attributeGroupMappingsTooltip: function(e) {
                            return "Users authenticating with one of these providers and meeting the conditions defined here will be a part of this group."
                        },
                        attributeSet: function(e) {
                            return "Attribute Set"
                        },
                        attributeSetHintText: function(e) {
                            return "All conditions of this attribute set must be met for a user to be included in this permission group."
                        },
                        attributeSetVALUE: function(e) {
                            return "Attribute Set " + e.VALUE
                        },
                        attributeValue: function(e) {
                            return "Attribute Value"
                        },
                        attributes: function(e) {
                            return "Attributes"
                        },
                        createADomainMapping: function(e) {
                            return "Create a domain mapping"
                        },
                        createAnAttributeSet: function(e) {
                            return "Create an attribute set"
                        },
                        domainGroupMappings: function(e) {
                            return "Domain Group Mappings"
                        },
                        domainMapping: function(e) {
                            return "Domain Mapping"
                        },
                        groupHasInactiveAttributesWarningMessage: function(e) {
                            return "This group contains one or more inactive attributes. Attribute sets containing inactive attributes cannot be fulfilled until the attribute is reactivated or the conditions associated with the inactive attribute are removed from the set."
                        },
                        inactiveAttribute: function(e) {
                            return "Inactive Attribute"
                        },
                        noAttributeSetsConfigured: function(e) {
                            return "No attribute sets configured."
                        },
                        noSupportedAttributesConfigured: function(e) {
                            return "No supported attributes configured."
                        },
                        thisProviderHasNoSupportedAttributes: function(e) {
                            return "This SAML provider does not have any attributes configured.\nPlease consult the provider's documentation for instruction on attribute configuration.\n"
                        },
                        noDomainMappings: function(e) {
                            return "No domain mappings."
                        },
                        or: function(e) {
                            return "OR"
                        },
                        remove: function(e) {
                            return "Remove"
                        },
                        thisGroupHasNoDomainMappings: function(e) {
                            return "There are no domain mappings configured for this permission group."
                        },
                        thisProviderHasNoAttributeSets: function(e) {
                            return "There are no configured attribute sets for this SAML provider."
                        },
                        values: function(e) {
                            return "Values"
                        }
                    },
                    externalGroupMappings: function(e) {
                        return "External Group Mappings"
                    },
                    externalPROVIDERSGroupsCanBeMappedToThisPermissionGroup: function(e) {
                        return "External " + e.PROVIDERS + " groups can be mapped to this permission group."
                    },
                    failedToLoadPermissionGroup: function(e) {
                        return "Failed to load Permission Group"
                    },
                    failedToLoadPermissionGroups: function(e) {
                        return "Failed to load Permission Groups"
                    },
                    grantAbilitiesAdmin: function(e) {
                        return "Grant abilities to create, edit, and delete data across " + e.APP
                    },
                    grantAbilitiesRecorderAdmin: function(e) {
                        return "Grant abilities to create, edit, and delete data for selected Recorders"
                    },
                    grantOrRevoke: function(e) {
                        return "Grant or Revoke specific abilities and scope"
                    },
                    grantThisGroupAccessToSpecificApps: function(e) {
                        return "Grant this group access to specific apps"
                    },
                    grantThisGroupAdmin: function(e) {
                        return "Grant this group administrative abilities"
                    },
                    grantAnotherPermission: function(e) {
                        return "Grant " + n(e.VALUE, 0, t, {
                            0: "Permission",
                            other: "Another Permission"
                        })
                    },
                    grantPermission: function(e) {
                        return "Grant Permission"
                    },
                    group: function(e) {
                        return "Group"
                    },
                    groupDescription: function(e) {
                        return "Group Description"
                    },
                    groupName: function(e) {
                        return "Group Name"
                    },
                    groupNameIsRequired: function(e) {
                        return "Group name is required."
                    },
                    includedMembers: function(e) {
                        return "Included Members:"
                    },
                    libraryAccess: function(e) {
                        return "Library Access"
                    },
                    libraryAccessTooltip: function(e) {
                        return "Users with library access can view and delete library items. Library items can be created from any camera where the user has permission to export."
                    },
                    loadingPermissionsGroups: function(e) {
                        return "Loading Permissions Groups..."
                    },
                    managePermissions: function(e) {
                        return "Manage Permissions"
                    },
                    memberGroups: function(e) {
                        return "Member Groups"
                    },
                    members: function(e) {
                        return "Members"
                    },
                    membersOfTheseGroupsAreAlsoAMemberOfThisGroup: function(e) {
                        return "Members of these groups are also a member of this group"
                    },
                    needToGrantAccessToCamerasOrFeatures: function(e) {
                        return "Need to grant access to cameras or features?"
                    },
                    needToRevokeAccessToCamerasOrFeatures: function(e) {
                        return "Need to revoke access to cameras or features?"
                    },
                    newPermissionGroup: function(e) {
                        return "New Permission Group"
                    },
                    noAbilitiesSelected: function(e) {
                        return "No abilities selected"
                    },
                    noGroupMatchesSearch: function(e) {
                        return "Your search didn't match any Permission Groups"
                    },
                    none: function(e) {
                        return "None"
                    },
                    noPermissionsGroupsExist: function(e) {
                        return "No Permissions Groups exist."
                    },
                    noServersOrCamerasSelected: function(e) {
                        return "No servers or cameras selected"
                    },
                    permissionsGranted: function(e) {
                        return "Permissions Granted"
                    },
                    permissionsRevoked: function(e) {
                        return "Permissions Revoked"
                    },
                    permissions: {
                        all: function(e) {
                            return "All"
                        },
                        export: function(e) {
                            return "Export"
                        },
                        live: function(e) {
                            return "Live"
                        },
                        playback: function(e) {
                            return "Playback"
                        },
                        ptz: function(e) {
                            return "PTZ"
                        },
                        talk: function(e) {
                            return "Talk"
                        }
                    },
                    recorderAdmin: {
                        all: function(e) {
                            return "All current and future Recorders"
                        },
                        allRecorders: function(e) {
                            return "All Recorders"
                        },
                        canRegister: function(e) {
                            return "Can register new Recorders"
                        },
                        grantThisGroup: function(e) {
                            return "Grant this group ability to administrate all of the currently registered Recorders and any future Recorders added to " + e.VMS
                        },
                        recorder: function(e) {
                            return "Recorder"
                        },
                        recorderAdminAbilities: function(e) {
                            return "Recorder Administration Abilities"
                        },
                        recorderAdminGroup: function(e) {
                            return "Recorder Administrator Group"
                        },
                        recordersThisGroup: function(e) {
                            return "Recorders this group can administrate"
                        },
                        selection: function(e) {
                            return "Selection"
                        },
                        selectSpecificRecorder: function(e) {
                            return "Select specific Recorders this group can administrate"
                        }
                    },
                    recorderAdministratorGroup: function(e) {
                        return "Recorder Administrator Group"
                    },
                    remove: function(e) {
                        return "Remove"
                    },
                    revoke: function(e) {
                        return "Revoke"
                    },
                    revokeAnotherPermission: function(e) {
                        return "Revoke " + n(e.VALUE, 0, t, {
                            0: "Permission",
                            other: "Another Permission"
                        })
                    },
                    revokePermission: function(e) {
                        return "Revoke Permission"
                    },
                    ruleConsiderAlsoIncluding: function(e) {
                        return e.RULE + ": consider also including " + e.INCLUDE
                    },
                    save: function(e) {
                        return "Save"
                    },
                    saveGroup: function(e) {
                        return "Save Group"
                    },
                    scope: function(e) {
                        return "Scope:"
                    },
                    scopeTitle: function(e) {
                        return "Scope"
                    },
                    searchForAGroup: function(e) {
                        return "Search for a Group"
                    },
                    showMembers: function(e) {
                        return "Show Members"
                    },
                    tabs: {
                        admin: function(e) {
                            return "Admin Settings"
                        },
                        general: function(e) {
                            return "General Settings"
                        },
                        other: function(e) {
                            return "Other Permissions"
                        },
                        permissions: function(e) {
                            return "Permissions"
                        }
                    },
                    usersInTheseExternalGroupsWillBeMembersOfThisPermissionGroup: function(e) {
                        return "Users in these external groups will be members of this permission group"
                    }
                },
                inactivityMonitor: {
                    continueSession: function(e) {
                        return "Continue Session"
                    },
                    sessionTimeout: function(e) {
                        return "Session Timeout"
                    },
                    yourSessionIsTimingOutDueToInactivityItWillExpireInCOUNTSeconds: function(e) {
                        return "Your session is timing out due to inactivity. It will expire in " + e.COUNT + " " + n(e.COUNT, 0, t, {
                            1: "second",
                            other: "seconds"
                        }) + "."
                    }
                },
                incognito: {
                    incognito: function(e) {
                        return "Incognito"
                    },
                    youAreEitherUsingAnAncientBrowserPrivateBrowsingOrIncognitoModePleaseSwitchToNormalBrowsingToUseSERVER: function(e) {
                        return "You are either using an ancient browser, Private Browsing, or Incognito Mode. Please switch to normal browsing to use " + e.SERVER + "."
                    }
                },
                indexTemplate: {
                    loading: function(e) {
                        return e.APP + " is loading..."
                    },
                    error: function(e) {
                        return "Error"
                    }
                },
                library: {
                    addLibraryItem: function(e) {
                        return "Add Library Item"
                    },
                    addLibraryItemMessage: function(e) {
                        return "Create Library Items to view and download later."
                    },
                    addLibraryItems: function(e) {
                        return "Add Library Items"
                    },
                    addToLibrary: function(e) {
                        return "Add to Library"
                    },
                    areYouSureYouWantToDeleteTheseCOUNTLibraryItems: function(e) {
                        return "Are you sure you want to delete " + n(e.COUNT, 0, t, {
                            1: "this Library Item",
                            other: "these " + e.COUNT + " Library Items"
                        }) + "? Items that cannot be deleted will be removed from the Orchid Hybrid VMS library and will no longer be managed by Orchid Hybrid VMS."
                    },
                    camera: function(e) {
                        return "Camera"
                    },
                    cancel: function(e) {
                        return "Cancel"
                    },
                    canceled: function(e) {
                        return "Canceled"
                    },
                    completed: function(e) {
                        return "Completed"
                    },
                    COUNTminutes: function(e) {
                        return e.COUNT + " " + n(e.COUNT, 0, t, {
                            1: "minute",
                            other: "minutes"
                        })
                    },
                    createdBy: function(e) {
                        return "Created By"
                    },
                    createdOn: function(e) {
                        return "Created On"
                    },
                    date: function(e) {
                        return "Date"
                    },
                    delete: function(e) {
                        return "Delete"
                    },
                    deleteSelected: function(e) {
                        return "Delete Selected"
                    },
                    download: function(e) {
                        return "Download"
                    },
                    open: function(e) {
                        return "Open"
                    },
                    duration: function(e) {
                        return "Duration"
                    },
                    egParkingLotIncident: function(e) {
                        return "e.g. Parking Lot Incident"
                    },
                    error: function(e) {
                        return "Error"
                    },
                    exportFileName: function(e) {
                        return e.LIBRARYITEMNAME + "_on_" + e.ORCHIDNAME + "_" + e.CAMERANAME + "_from_" + e.START + "_to_" + e.FINISH + "." + e.EXTENSION
                    },
                    failed: function(e) {
                        return "Failed"
                    },
                    failedToLoadLibraryItems: function(e) {
                        return "Failed to load Library Items"
                    },
                    format: function(e) {
                        return "Format"
                    },
                    from: function(e) {
                        return "From"
                    },
                    go: function(e) {
                        return "Go"
                    },
                    goToLibrary: function(e) {
                        return "Go to Library"
                    },
                    library: function(e) {
                        return "Library"
                    },
                    libraryError: function(e) {
                        return "Library Error:"
                    },
                    libraryItemName: function(e) {
                        return "Library Item Name"
                    },
                    loadingLibraryItems: function(e) {
                        return "Loading Library Items"
                    },
                    minutes: function(e) {
                        return "minutes"
                    },
                    name: function(e) {
                        return "Name"
                    },
                    nameServerOrCamera: function(e) {
                        return "Name, Server or Camera"
                    },
                    noCamerasWithExport: function(e) {
                        return "There are no cameras available for exporting on this server."
                    },
                    noItemsHaveBeenAddedToTheLibrary: function(e) {
                        return "No items have been added to the Library"
                    },
                    noLibraryItemsWereFoundThatMatchTheSearchCriteria: function(e) {
                        return "No Library Items were found that match the search criteria"
                    },
                    noServersWithCamerasToExport: function(e) {
                        return "There are no servers with cameras available for exporting."
                    },
                    COMPLETEDofTOTAL: function(e) {
                        return e.COMPLETED + " of " + e.TOTAL
                    },
                    ok: function(e) {
                        return "Ok"
                    },
                    oneOrMoreOfTheLibraryItemsFailedToBeCreated: function(e) {
                        return "One or more of the Library Items failed to be created."
                    },
                    paginatorFirstTooltip: function(e) {
                        return "First Page"
                    },
                    paginatorLastTooltip: function(e) {
                        return "Last Page"
                    },
                    paginatorRangeLabel: function(e) {
                        return "of"
                    },
                    pending: function(e) {
                        return "Pending"
                    },
                    preparingFileCOMPLETEDofTOTAL: function(e) {
                        return "Preparing file " + e.COMPLETED + " of " + e.TOTAL
                    },
                    rename: function(e) {
                        return "Rename"
                    },
                    renameLibraryItem: function(e) {
                        return "Rename Library Item"
                    },
                    retry: function(e) {
                        return "Retry"
                    },
                    retrievingPreview: function(e) {
                        return "Retrieving preview"
                    },
                    search: function(e) {
                        return "Search"
                    },
                    server: function(e) {
                        return "Server"
                    },
                    size: function(e) {
                        return "Size"
                    },
                    sort: function(e) {
                        return "Sort"
                    },
                    started: function(e) {
                        return "Started"
                    },
                    startTime: function(e) {
                        return "Start Time"
                    },
                    storeClipsToViewAndDownloadLater: function(e) {
                        return "Store clips to view and download later."
                    },
                    storing: function(e) {
                        return "Storing"
                    },
                    status: function(e) {
                        return "Status"
                    },
                    theCameraStreamWithTheHighestResolutionAvailableIsPreSelected: function(e) {
                        return "The camera stream with the highest resolution available is pre-selected"
                    },
                    thereAreNoCamerasAssociatedWithThisServer: function(e) {
                        return "There are no cameras associated with this server"
                    },
                    theSelectedVideosHaveBeenSentToTheLibrary: function(e) {
                        return "The selected videos have been sent to the Library."
                    },
                    to: function(e) {
                        return "To"
                    },
                    transferringCOMPLETEDofTOTAL: function(e) {
                        return "Transferring " + e.COMPLETED + " of " + e.TOTAL
                    },
                    tripleDot: function(e) {
                        return "..."
                    },
                    unknown: function(e) {
                        return "Unknown"
                    },
                    valueFps: function(e) {
                        return e.VALUE + "fps"
                    }
                },
                licensing: {
                    activationReportTimeExtension: function(e) {
                        return "activation_report_" + e.TIME + "." + e.EXTENSION
                    },
                    areYouSureThisWillCancelAnyPendingActivationsAndClearTheTable: function(e) {
                        return "Are you sure? This will cancel any pending activations and clear the table."
                    },
                    ariaLabels: {
                        selectPageOfActivationReport: function(e) {
                            return "Select page of activation report"
                        },
                        selectPageOfLicenseImports: function(e) {
                            return "Select page of license imports"
                        }
                    },
                    buttons: {
                        cancel: function(e) {
                            return "Cancel"
                        },
                        clear: function(e) {
                            return "Clear"
                        },
                        downloadReport: function(e) {
                            return "Download Report"
                        },
                        retry: function(e) {
                            return "Retry"
                        },
                        uploadBundle: function(e) {
                            return "Upload Bundle"
                        }
                    },
                    columnHeaders: {
                        activationCode: function(e) {
                            return "Activation Code"
                        },
                        archiveRetention: function(e) {
                            return "Archive Retention"
                        },
                        camerasLicensed: function(e) {
                            return "Cameras Licensed"
                        },
                        edition: function(e) {
                            return "Edition"
                        },
                        importStatus: function(e) {
                            return "Import Status"
                        },
                        lastUpdate: function(e) {
                            return "Last Update"
                        },
                        server: function(e) {
                            return "Server"
                        },
                        supportExpiration: function(e) {
                            return "Support Expiration"
                        }
                    },
                    countOfTotalComplete: function(e) {
                        return e.COUNT + " of " + e.TOTAL + " complete"
                    },
                    errors: {
                        errorCancellingActivationRequest: function(e) {
                            return "Error cancelling activation request."
                        },
                        errorClearingActivationHistory: function(e) {
                            return "Error clearing activation history."
                        },
                        errorFetchingActivationData: function(e) {
                            return "Error fetching activation data."
                        },
                        errorRetryingActivationRequest: function(e) {
                            return "Error retrying activation request."
                        },
                        errorTheFileWasModifiedAfterSelectionPleaseReselectTheFile: function(e) {
                            return "Error. The file " + e.FILE + " was modified after selection. Please reselect the file."
                        },
                        errorUploadingLicenseBundleFile: function(e) {
                            return "Error uploading license bundle file."
                        }
                    },
                    exportActivationReport: function(e) {
                        return "Export Activation Report"
                    },
                    importActivationBundle: function(e) {
                        return "Import Activation Bundle"
                    },
                    importStatus: {
                        cancelled: function(e) {
                            return "Cancelled"
                        },
                        failed: function(e) {
                            return "Failed"
                        },
                        pending: function(e) {
                            return "Pending"
                        },
                        success: function(e) {
                            return "Success"
                        }
                    },
                    loadingActivationBundleStatus: function(e) {
                        return "Loading Activation Bundle Status..."
                    },
                    loadingActivationReport: function(e) {
                        return "Loading Activation Report..."
                    },
                    noActivationDataToDisplay: function(e) {
                        return "No activation data to display."
                    },
                    noChildNameServersHaveBeenRegistered: function(e) {
                        return "No Orchid Recorder servers have been registered."
                    },
                    na: function(e) {
                        return "N/A"
                    },
                    paginator: {
                        countOfTotal: function(e) {
                            return e.COUNT + " of " + e.TOTAL
                        },
                        firstPage: function(e) {
                            return "First page"
                        },
                        itemsPerPage: function(e) {
                            return "Items per page:"
                        },
                        lastPage: function(e) {
                            return "Last page"
                        },
                        nextPage: function(e) {
                            return "Next page"
                        },
                        previousPage: function(e) {
                            return "Previous page"
                        },
                        perPage: function(e) {
                            return "per page:"
                        }
                    },
                    processState: {
                        automaticRetryInTime: function(e) {
                            return "Automatic retry in " + e.TIME + "..."
                        },
                        cancelled: function(e) {
                            return "Cancelled"
                        },
                        idle: function(e) {
                            return "Idle"
                        },
                        pending: function(e) {
                            return "Pending"
                        },
                        processing: function(e) {
                            return "Processing"
                        },
                        retryPending: function(e) {
                            return "Retry Pending"
                        },
                        successful: function(e) {
                            return "Successful"
                        }
                    },
                    status: function(e) {
                        return "Status"
                    },
                    unknown: function(e) {
                        return "Unknown"
                    },
                    unlimited: function(e) {
                        return "Unlimited"
                    },
                    uploadDialog: {
                        cancel: function(e) {
                            return "cancel"
                        },
                        pleaseSelectALicenseBundleFile: function(e) {
                            return "Please select a license bundle file."
                        },
                        theLicenseBundleFileIsACsvFileProvidedForBulkUpdatingChildLicenses: function(e) {
                            return "The license bundle file is a .csv file provided by IPConfigure Inc. for bulk updating Orchid Recorder licenses."
                        },
                        upload: function(e) {
                            return "upload"
                        },
                        uploadActivationBundle: function(e) {
                            return "Upload Activation Bundle"
                        }
                    }
                },
                maps: {
                    addToStage: function(e) {
                        return "Add To Stage"
                    },
                    cameras: function(e) {
                        return "Cameras"
                    },
                    close: function(e) {
                        return "Close"
                    },
                    dismiss: function(e) {
                        return "Dismiss"
                    },
                    done: function(e) {
                        return "Done"
                    },
                    loadingMaps: function(e) {
                        return "Loading Maps"
                    },
                    orchidName: function(e) {
                        return "Orchid Recorder - " + e.VALUE
                    },
                    retry: function(e) {
                        return "Retry"
                    },
                    theCameraDetailsCannotBeShownInACellThisSize: function(e) {
                        return "The camera details cannot be shown in a cell this size."
                    },
                    theMapCouldNotBeLoaded: function(e) {
                        return "The map could not be loaded"
                    },
                    thereAreNoMapsConfigured: function(e) {
                        return "There are no maps configured"
                    }
                },
                mapConfiguration: {
                    areYouSureYouWantToDeleteThisMapImageThisActionCannotBeUndone: function(e) {
                        return "Are you sure you want to delete this map image? This action cannot be undone."
                    },
                    areYouSureYouWantToRemoveTheSelectedCameraFromTheMap: function(e) {
                        return "Are you sure you want to remove the selected camera from the map?"
                    },
                    cancel: function(e) {
                        return "Cancel"
                    },
                    delete: function(e) {
                        return "Delete"
                    },
                    deleteMap: function(e) {
                        return "Delete Map"
                    },
                    dismiss: function(e) {
                        return "Dismiss"
                    },
                    editVALUEmap: function(e) {
                        return "Edit " + e.VALUE + " Map"
                    },
                    loseUnsavedChanges: function(e) {
                        return "Lose unsaved changes?"
                    },
                    remove: function(e) {
                        return "Remove"
                    },
                    saveMap: function(e) {
                        return "Save Map"
                    },
                    selectTheMapImage: function(e) {
                        return "Select the map image"
                    },
                    serversCanNotBeAddedToAMap: function(e) {
                        return "Servers can not be added to a map"
                    },
                    serversCanNotBePlacedOnAMap: function(e) {
                        return "Servers can not be placed on a map"
                    },
                    showCamerasInBag: function(e) {
                        return "Show Cameras in Bag"
                    },
                    theCameraPositionsCouldNotBeSaved: function(e) {
                        return "The camera positions could not be saved."
                    },
                    theMapCouldNotBeDeleted: function(e) {
                        return "The map could not be deleted."
                    },
                    theMapFileCouldNotBeUploaded: function(e) {
                        return "The map file could not be uploaded"
                    },
                    thereAreNoMoreCamerasAvailableToBeAddedToTheMap: function(e) {
                        return "There are no more cameras available to be added to the map."
                    },
                    thisWillReplaceTheExistingMapImageThisActionCannotBeUndone: function(e) {
                        return "This will replace the existing map image. This action cannot be undone."
                    },
                    upload: function(e) {
                        return "Upload"
                    },
                    uploadMap: function(e) {
                        return "Upload Map"
                    },
                    whenCheckedCamerasInThisGroupWillBeDisplayedInTheBagOnTheStage: function(e) {
                        return "When checked cameras in this group will be displayed in the Bag on the Stage."
                    }
                },
                motionAlerts: {
                    failedToLoadMotionAlerts: function(e) {
                        return "Failed to load Motion Alerts"
                    },
                    loadingMotionAlerts: function(e) {
                        return "Loading Motion Alerts"
                    },
                    schedulesCOUNT: function(e) {
                        return "Schedules (" + e.COUNT + ")"
                    }
                },
                motionAlertsList: {
                    addNotification: function(e) {
                        return "Add Notification"
                    },
                    addSchedule: function(e) {
                        return "Add Schedule"
                    },
                    all: function(e) {
                        return "All"
                    },
                    areYouSureYouWantToDeleteThisNotification: function(e) {
                        return "Are you sure you want to delete this Notification?"
                    },
                    cancel: function(e) {
                        return "Cancel"
                    },
                    configured: function(e) {
                        return "Configured"
                    },
                    CONFIGUREDslashTOTALconfigured: function(e) {
                        return e.CONFIGURED + "/" + e.TOTAL + " Servers Configured"
                    },
                    COUNTcamerasAdded: function(e) {
                        return e.COUNT + " " + n(e.COUNT, 0, t, {
                            one: "Camera",
                            other: "Cameras"
                        }) + " Added"
                    },
                    disabled: function(e) {
                        return "Disabled"
                    },
                    enabled: function(e) {
                        return "Enabled"
                    },
                    errorDeletingNotificationERRORCODEparenthesisERRORMSG: function(e) {
                        return "Error deleting notification: " + e.ERRORCODE + " (" + e.ERRORMSG + ")"
                    },
                    failedToDisableNotification: function(e) {
                        return "Failed to disable the notification"
                    },
                    failedToEnableNotification: function(e) {
                        return "Failed to enable the notification"
                    },
                    noScheduleIsConfiguredForThisNotification: function(e) {
                        return "No schedule is configured for this notification"
                    },
                    notConfigured: function(e) {
                        return "Not Configured"
                    },
                    notificationDeleted: function(e) {
                        return "Notification deleted"
                    },
                    notificationSpecifiesNoCameras: function(e) {
                        return "Notification specifies no cameras"
                    },
                    notificationSpecifiesNoRecipients: function(e) {
                        return "Notification specifies no recipients"
                    },
                    notificationSpecifiesNoSchedule: function(e) {
                        return "Notification specifies no schedule"
                    },
                    notificationSpecifiesNoSmtpServer: function(e) {
                        return "Notification specifies no SMTP server"
                    },
                    orchidOrNotification: function(e) {
                        return "Orchid Recorder or Notification"
                    },
                    scheduleAddedSuccessfully: function(e) {
                        return "Schedule added successfully"
                    },
                    schedulesVALUE: function(e) {
                        return "Schedules (" + e.VALUE + ")"
                    },
                    search: function(e) {
                        return "Search"
                    },
                    searchReturnedNoChildNameServers: function(e) {
                        return "No Orchid Recorder servers were found that match the search criteria"
                    },
                    selectPage: function(e) {
                        return "Select page"
                    },
                    status: function(e) {
                        return "Status"
                    }
                },
                navigation: {
                    accountSettings: function(e) {
                        return "Account Settings"
                    },
                    activation: function(e) {
                        return "Activation"
                    },
                    advancedSettings: function(e) {
                        return "Advanced Settings"
                    },
                    apps: function(e) {
                        return "Apps"
                    },
                    auditLogs: function(e) {
                        return "Audit Logs"
                    },
                    cameraConfiguration: function(e) {
                        return "Camera Configuration"
                    },
                    cameraGroups: function(e) {
                        return "Camera Groups"
                    },
                    customFeature: function(e) {
                        return "Custom Feature"
                    },
                    events: function(e) {
                        return "Events"
                    },
                    eventSubscriptions: function(e) {
                        return "Event Subscriptions"
                    },
                    leave: function(e) {
                        return "Leave"
                    },
                    library: function(e) {
                        return "Library"
                    },
                    licensing: function(e) {
                        return "Licensing"
                    },
                    maps: function(e) {
                        return "Maps"
                    },
                    menu: function(e) {
                        return "Menu"
                    },
                    motionAlerts: function(e) {
                        return "Motion Alerts"
                    },
                    notifications: function(e) {
                        return "Notifications"
                    },
                    permissionGroups: function(e) {
                        return "Permission Groups"
                    },
                    retentionPolicy: function(e) {
                        return "Retention Policy"
                    },
                    servers: function(e) {
                        return "Servers"
                    },
                    signOut: function(e) {
                        return "Sign Out"
                    },
                    smtpServers: function(e) {
                        return "SMTP Servers"
                    },
                    stage: function(e) {
                        return "Stage"
                    },
                    subscriptions: function(e) {
                        return "Subscriptions"
                    },
                    systemAlerts: function(e) {
                        return "System Alerts"
                    },
                    systemMenu: function(e) {
                        return "System Menu"
                    },
                    systemReport: function(e) {
                        return "System Report"
                    },
                    systemStatus: function(e) {
                        return "System Status"
                    },
                    users: function(e) {
                        return "Users"
                    },
                    versionInformation: function(e) {
                        return "Version Information"
                    },
                    viewer: function(e) {
                        return "Viewer"
                    }
                },
                notFound: {
                    notFound: function(e) {
                        return "Not Found"
                    },
                    theRequestedResourceCouldNotBeFound: function(e) {
                        return "The requested resource could not be found."
                    }
                },
                notifications: {
                    actions: function(e) {
                        return "Actions"
                    },
                    aDailyEmailContainingADigestOfAllTriggeredEventsWillBeSentAt: function(e) {
                        return "A daily email containing a digest of all triggered events will be sent at"
                    },
                    aDailyEmailContainingADigestOfAllTriggeredEventsWillBeSentTo: function(e) {
                        return "A daily email containing a digest of all triggered events will be sent to"
                    },
                    aDailyEmailContainingADigestOfAllTriggeredEventsWillBeSentToValueEmailAddressesProvided: function(e) {
                        return "A daily email containing a digest of all triggered events will be sent to " + e.VALUE + " email addresses provided."
                    },
                    add: function(e) {
                        return "Add"
                    },
                    addAction: function(e) {
                        return "Add Action"
                    },
                    addAnotherAction: function(e) {
                        return "Add Another Action"
                    },
                    addAnotherTrigger: function(e) {
                        return "Add Another Trigger"
                    },
                    addMotionAlertFor: function(e) {
                        return "Add Motion Alert for"
                    },
                    addNotification: function(e) {
                        return "Add Notification"
                    },
                    addSchedule: function(e) {
                        return "Add Schedule"
                    },
                    addSmtpServer: function(e) {
                        return "Add SMTP Server"
                    },
                    addSystemAlert: function(e) {
                        return "Add System Alert"
                    },
                    addToNotification: function(e) {
                        return "Add to notification"
                    },
                    addTrigger: function(e) {
                        return "Add Trigger"
                    },
                    advancedSettings: function(e) {
                        return "Advanced Settings"
                    },
                    allCameras: function(e) {
                        return "All Cameras"
                    },
                    another: function(e) {
                        return "Another"
                    },
                    advancedMessage: {
                        aMotionAlertWillBeSent: function(e) {
                            return "A motion alert will be sent when motion is longer than"
                        },
                        timeToWait: function(e) {
                            return "Time to wait before sending another motion alert for the same camera:"
                        },
                        maxExportClipDuration: function(e) {
                            return "Max export clip duration:"
                        }
                    },
                    aDailyEmailContainingADigestOfAllTriggeredEventsWillBeSentAtDateTimeToTheEmailAddressesProvided: function(e) {
                        return "A daily email containing a digest of all triggered events will be sent at " + e.DATE + " (" + e.TIME + ") to the email addresses provided."
                    },
                    aDailyEmailContainingADigestOfAllTriggeredEventsWillBeSentAtDateTimeToAppNameUsersPermissionGroupMembersAndAnyAdditionalEmailAddressesProvided: function(e) {
                        return "A daily email containing a digest of all triggered events will be sent at " + e.DATE + " (" + e.TIME + ") to Orchid Hybrid VMS Users, Permission Group members, and any additional email addresses provided."
                    },
                    emailsWillBeSentToTheEmailAddressesProvided: function(e) {
                        return "Emails will be sent to the email addresses provided."
                    },
                    emailsWillBeSentToAppNameUsersPermissionGroupMembersAndAnyAdditionalEmailAddressesProvided: function(e) {
                        return "Emails will be sent to the email addresses provided."
                    },
                    alertConfiguration: function(e) {
                        return "Alert Configuration"
                    },
                    aNotificationWillBeSentAsSoonAsPossibleWhen: function(e) {
                        return "A notification will be sent as soon as possible when"
                    },
                    aNotificationWillBeSentWhenA: function(e) {
                        return "A notification will be sent when a"
                    },
                    aNotificationWillBeSentWhenAServerRestartsEntersDegradedModeDueToAStorageErrorOrLicenseExpirationOrStopsWritingVideoFiles: function(e) {
                        return "A notification will be sent when a server restarts, enters degraded mode due to a storage error or license expiration, or stops writing video files."
                    },
                    aNotificationWillBeSentWhenVideoFilesCannotBeWrittenToDiskDueToInsufficientStorageThroughput: function(e) {
                        return "A notification will be sent when video files cannot be written to disk due to insufficient storage throughput."
                    },
                    anyValue: function(e) {
                        return "Any " + e.VALUE
                    },
                    appNameUsersPermissionGroupMembersAndAnyAdditional: function(e) {
                        return "Orchid Hybrid VMS Users, Permission Group members, and any additional"
                    },
                    areYouSureYouWantToDelete: function(e) {
                        return "Are you sure you want to delete " + e.VALUE + "?"
                    },
                    areYouSureYouWantToDeleteTheValueSchedule: function(e) {
                        return "Are you sure you want to delete the " + e.VALUE + " schedule?"
                    },
                    areYouSureYouWantToDeleteThisSmtpServer: function(e) {
                        return "Are you sure you want to delete this SMTP server?"
                    },
                    aServerRestartsEntersDegradedModeDueToAStorageErrorOrLicenseExpirationOrStopsWritingVideoFiles: function(e) {
                        return "a server restarts, enters degraded mode due to a storage error or license expiration, or stops writing video files"
                    },
                    aValidEmailAddressIsRequired: function(e) {
                        return "A valid email address is required."
                    },
                    aValidSmtpAddressIsRequired: function(e) {
                        return "A valid SMTP address is required."
                    },
                    becomesUnreachableFor: function(e) {
                        return "becomes unreachable for"
                    },
                    camera: function(e) {
                        return "Camera"
                    },
                    cameraNotConfiguredForMotion: function(e) {
                        return "This camera is not configured for motion detection and will not produce motion alerts"
                    },
                    cameraSelection: function(e) {
                        return "Camera Selection"
                    },
                    camerasThatBecomeUnreachableBecauseAServerBecomesUnreachableWillNotSendNotifications: function(e) {
                        return "Cameras that become unreachable because a server becomes unreachable will not send notifications."
                    },
                    cameraUnreachable: function(e) {
                        return "Camera Unreachable"
                    },
                    cancel: function(e) {
                        return "Cancel"
                    },
                    consolidateEmailsMessage: function(e) {
                        return "A single email will consolidate notifications for multiple events."
                    },
                    consolidateTriggersToOneEmail: function(e) {
                        return "Consolidate multiple trigger events into a single email"
                    },
                    createSchedule: function(e) {
                        return "Create Schedule"
                    },
                    SELECTEDslashTOTALselected: function(e) {
                        return e.SELECTED + " / " + e.TOTAL + " Selected"
                    },
                    customSettingsAdvanced: function(e) {
                        return "Custom Settings (Advanced)"
                    },
                    dailyEmailDigest: function(e) {
                        return "Daily Email Digest"
                    },
                    delete: function(e) {
                        return "Delete"
                    },
                    deleteNotification: function(e) {
                        return "Delete Notification"
                    },
                    deleteSystemAlert: function(e) {
                        return "Delete System Alert"
                    },
                    description: function(e) {
                        return "Description"
                    },
                    done: function(e) {
                        return "Done"
                    },
                    edit: function(e) {
                        return "Edit"
                    },
                    editMotionAlertFor: function(e) {
                        return "Edit Motion Alert for"
                    },
                    editNotification: function(e) {
                        return "Edit Notification"
                    },
                    editNamedThing: function(e) {
                        return "Edit " + e.VALUE
                    },
                    editSchedule: function(e) {
                        return "Edit Schedule"
                    },
                    editSystemAlert: function(e) {
                        return "Edit System Alert"
                    },
                    emailAddressesProvided: function(e) {
                        return "email addresses provided."
                    },
                    emails: function(e) {
                        return "Emails"
                    },
                    emailsColon: function(e) {
                        return "Emails:"
                    },
                    emailConfiguration: function(e) {
                        return "Email Configuration"
                    },
                    emailTriggersSeparately: function(e) {
                        return "For each trigger event, you will receive a separate email notification."
                    },
                    emailsWillBeSentToValueEmailAddressesProvided: function(e) {
                        return "Emails will be sent to " + e.VALUE + " email addresses provided."
                    },
                    emailsWillBeSentTo: function(e) {
                        return "Emails will be sent to"
                    },
                    emailsWillBeSentToAllUsersInSpecifiedPermissionGroups: function(e) {
                        return "Emails will be sent to all users in specified Permission Groups"
                    },
                    enableTls: function(e) {
                        return "Enable TLS"
                    },
                    excluding: function(e) {
                        return "Excluding"
                    },
                    enabled: function(e) {
                        return "Enabled"
                    },
                    errorCreatingNotification: function(e) {
                        return "Error Creating Notification"
                    },
                    errorEditingNotification: function(e) {
                        return "Error Editing Notification"
                    },
                    excludingLower: function(e) {
                        return "excluding"
                    },
                    failedToLoadSmtpServers: function(e) {
                        return "Failed to load SMTP Servers"
                    },
                    failedToLoadSystemAlerts: function(e) {
                        return "Failed to load System Alerts"
                    },
                    groups: function(e) {
                        return "Groups:"
                    },
                    groupsWithoutEmailAddresses: function(e) {
                        return "Groups without email addresses:"
                    },
                    hideUsers: function(e) {
                        return "hide users"
                    },
                    immediateEmail: function(e) {
                        return "Immediate Email"
                    },
                    includedMembers: function(e) {
                        return "Included Members:"
                    },
                    iOError: function(e) {
                        return "I/O Error"
                    },
                    key: function(e) {
                        return "Key"
                    },
                    loadingNotifications: function(e) {
                        return "Loading Notifications"
                    },
                    loadingSmtpServers: function(e) {
                        return "Loading SMTP Servers"
                    },
                    maxExportDurationLimitExceeded: function(e) {
                        return "Max export duration limit exceeded"
                    },
                    minutePlural: function(e) {
                        return e.VALUE + " " + n(e.VALUE, 0, t, {
                            one: "minute",
                            other: "minutes"
                        }) + "."
                    },
                    minutesBeforeAnotherNotificationWillBeSent: function(e) {
                        return "minutes before another notification will be sent."
                    },
                    minutesBetweenNotifications: function(e) {
                        return "minutes between notifications."
                    },
                    minutesPeriod: function(e) {
                        return "minutes."
                    },
                    motionAlertsCOUNT: function(e) {
                        return "Motion Alerts (" + e.COUNT + ")"
                    },
                    motionAlerts: function(e) {
                        return "Motion Alerts"
                    },
                    mustSelectAtLeastOneCamera: function(e) {
                        return "Must select at least one camera."
                    },
                    name: function(e) {
                        return "Name"
                    },
                    nameIsRequired: function(e) {
                        return "Name is required."
                    },
                    nameSubject: function(e) {
                        return "Name/Subject"
                    },
                    newNotification: function(e) {
                        return "New Notification"
                    },
                    newSmtpServer: function(e) {
                        return "New SMTP Server"
                    },
                    newSystemAlert: function(e) {
                        return "New System Alert"
                    },
                    noActionsHaveBeenConfigured: function(e) {
                        return "No actions have been configured."
                    },
                    noActionsHaveBeenConfiguredNoNotificationsWillBeSent: function(e) {
                        return "No actions have been configured; no notifications will be sent."
                    },
                    noActionsHaveBeenCreated: function(e) {
                        return "No actions have been created."
                    },
                    noActionSpecifiesAnSmtpServer: function(e) {
                        return "No action specifies an SMTP server."
                    },
                    noActionSpecifiesARecipientWithAnEmailAddress: function(e) {
                        return "No action specifies a recipient with an email address."
                    },
                    noActionSpecifiesBothAnSmtpServerAndARecipientWithAnEmailAddress: function(e) {
                        return "No action specifies both an SMTP server and a recipient with an email address."
                    },
                    noDeviceNotificationsAreConfiguredForTrigger: function(e) {
                        return "No " + e.VALUE + "s are configured. No notifications will be sent for this trigger."
                    },
                    noEmailsWillBeSentForThisActionUnlessAnSmtpServerIsSpecified: function(e) {
                        return "No emails will be sent for this action unless an SMTP server is specified."
                    },
                    noEmailsWillBeSentForThisSchedule: function(e) {
                        return "No emails will be sent for this action unless a Schedule is specified."
                    },
                    none: function(e) {
                        return "None"
                    },
                    noNotificationsWillBeSent: function(e) {
                        return "No notifications will be sent."
                    },
                    noRecipientsHaveBeenSpecifiedNoEmailsWillBeSentForThisAction: function(e) {
                        return "No recipients have been specified; no emails will be sent for this action."
                    },
                    noSchedulesCreatedYet: function(e) {
                        return "No schedules created yet"
                    },
                    noSmtpServerHasBeenSpecifiedNoEmailsWillBeSentForThisAction: function(e) {
                        return "No SMTP server has been specified; no emails will be sent for this action."
                    },
                    noSmtpServersAreConfigured: function(e) {
                        return "No SMTP servers are configured."
                    },
                    noSystemAlertsAreConfigured: function(e) {
                        return "No System Alerts are configured."
                    },
                    notification: function(e) {
                        return "Notification"
                    },
                    notificationIsConfiguredCorrectlyNotificationsWillBeSent: function(e) {
                        return "Notification is configured correctly. Notifications will be sent."
                    },
                    notificationIsDisabledNoNotificationsWillBeSent: function(e) {
                        return "Notification is disabled. No notifications will be sent."
                    },
                    notifications: function(e) {
                        return "Notifications"
                    },
                    noTriggersHaveBeenConfigured: function(e) {
                        return "No triggers have been configured."
                    },
                    noTriggersHaveBeenConfiguredNoNotificationsWillBeSent: function(e) {
                        return "No triggers have been configured; no notifications will be sent"
                    },
                    noTriggersHaveBeenCreated: function(e) {
                        return "No triggers have been created."
                    },
                    only: function(e) {
                        return "Only"
                    },
                    permissionGroups: function(e) {
                        return "Permission Groups"
                    },
                    recipientEmailAddress: function(e) {
                        return "Recipient Email Address"
                    },
                    recipients: function(e) {
                        return "Recipients:"
                    },
                    remove: function(e) {
                        return "Remove"
                    },
                    save: function(e) {
                        return "Save"
                    },
                    saveMotionAlert: function(e) {
                        return "Save Motion Alert"
                    },
                    saveNotification: function(e) {
                        return "Save Notification"
                    },
                    saveSmtpSettings: function(e) {
                        return "Save SMTP Settings"
                    },
                    saveSystemAlert: function(e) {
                        return "Save System Alert"
                    },
                    schedule: function(e) {
                        return "Schedule"
                    },
                    scheduleSelection: function(e) {
                        return "Schedule Selection"
                    },
                    searchForAGroup: function(e) {
                        return "Search for a Group"
                    },
                    searchForAUser: function(e) {
                        return "Search for a User"
                    },
                    send: function(e) {
                        return "Send"
                    },
                    sendDigestAt: function(e) {
                        return "Send Digest At (" + e.VALUE + ")"
                    },
                    sendTestEmail: function(e) {
                        return "Send Test Email"
                    },
                    server: function(e) {
                        return "Server"
                    },
                    serverError: function(e) {
                        return "Server Error"
                    },
                    serverUnreachable: function(e) {
                        return "Server Unreachable"
                    },
                    showUsers: function(e) {
                        return "show users"
                    },
                    smtpAddress: function(e) {
                        return "Address"
                    },
                    "smtpDialog.smtpServer.name": function(e) {
                        return "Edit " + e.VALUE
                    },
                    smtpFromAddress: function(e) {
                        return "SMTP From-Address"
                    },
                    smtpName: function(e) {
                        return "Name"
                    },
                    smtpPassword: function(e) {
                        return "SMTP Password"
                    },
                    smtpPasswordIsRequired: function(e) {
                        return "SMTP Password is required."
                    },
                    smtpServer: function(e) {
                        return "SMTP Server"
                    },
                    smtpServerAddress: function(e) {
                        return "SMTP Server Address"
                    },
                    smtpServerName: function(e) {
                        return "SMTP Server Name"
                    },
                    smtpServerNameIsRequired: function(e) {
                        return "SMTP Server Name is required"
                    },
                    smtpServers: function(e) {
                        return "SMTP Servers"
                    },
                    smtpUsername: function(e) {
                        return "SMTP Username"
                    },
                    smtpUsernameIsRequired: function(e) {
                        return "SMTP Username is required"
                    },
                    start: function(e) {
                        return "Start"
                    },
                    stop: function(e) {
                        return "Stop"
                    },
                    systemAlerts: function(e) {
                        return "System Alerts"
                    },
                    systemAlertsCOUNT: function(e) {
                        return "System Alerts (" + e.COUNT + ")"
                    },
                    test: function(e) {
                        return "Test"
                    },
                    testRequiresUsernameAndPassword: function(e) {
                        return "Test requires a username and password"
                    },
                    the: function(e) {
                        return "the"
                    },
                    thereWillBeAtLeastVALUEMinutesOfDelayBetweenNotifications: function(e) {
                        return "There will be at least " + e.VALUE + " " + n(e.VALUE, 0, t, {
                            1: "minute",
                            other: "minutes"
                        }) + " of delay between notifications."
                    },
                    theValueMustBeOnlineFor: function(e) {
                        return "The " + e.VALUE + " must be online for"
                    },
                    timeMustBeAPositiveWholeNumber: function(e) {
                        return "Time must be a positive whole number"
                    },
                    to: function(e) {
                        return "to"
                    },
                    triggerAction: function(e) {
                        return "Trigger Action"
                    },
                    triggerEvent: function(e) {
                        return "Trigger Event"
                    },
                    triggers: function(e) {
                        return "Triggers"
                    },
                    triggersSpecifyNoValidTargets: function(e) {
                        return "Triggers specify no valid targets."
                    },
                    typeAnEmail: function(e) {
                        return "Type an email"
                    },
                    tzWarning: function(e) {
                        return "Schedules will be adjusted to the Orchid's local timezone"
                    },
                    users: function(e) {
                        return "Users: "
                    },
                    usersWithoutEmailAddresses: function(e) {
                        return "Users without email addresses:"
                    },
                    value: function(e) {
                        return "Value"
                    },
                    valueMustBeOnlineForRefractoryMinuteBeforeAnotherNotificationWllBeSent: function(e) {
                        return "The " + e.VALUE + " must be online for " + e.MINUTES + " " + n(e.MINUTES, 0, t, {
                            one: "minute",
                            other: "minutes"
                        }) + " before another notification will be sent."
                    },
                    verbTheseCamerasOrServers: function(e) {
                        return e.VERB + " These " + i(e.DEVICE, {
                            camera_state: "Cameras",
                            other: "Servers"
                        })
                    },
                    videoFilesCannotBeWrittenToDiskDueToInsufficientStorageThroughput: function(e) {
                        return "video files cannot be written to disk due to insufficient storage throughput"
                    },
                    withAtLeast: function(e) {
                        return "with at least"
                    },
                    notificationTriggerIOError: function(e) {
                        return "A notification will be sent as soon as possible when video files cannot be written to disk due to insufficient storage throughput. Notifications will be sent no more than once every"
                    },
                    notificationTriggerViewIOError: function(e) {
                        return "A notification will be sent as soon as possible when video files cannot be written to disk due to insufficient storage throughput. Notifications will be sent no more than once every " + e.MINUTES + " minutes."
                    },
                    notificationTriggerServerError: function(e) {
                        return "A notification will be sent as soon as possible when a server restarts, enters degraded mode due to a storage error or license expiration, or stops writing video files. Notifications will be sent no more than once every"
                    },
                    notificationTriggerViewServerError: function(e) {
                        return "A notification will be sent as soon as possible when a server restarts, enters degraded mode due to a storage error or license expiration, or stops writing video files.  Notifications will be sent no more than once every " + e.MINUTES + " minutes."
                    },
                    notificationTriggerCameraServerState: function(e) {
                        return "Before another notification will be sent, the " + e.VALUE + " must be online for at least"
                    },
                    notificationTriggerViewCameraServerState: function(e) {
                        return "Before another notification will be sent, the " + e.VALUE + " must be online for at least " + e.MINUTES + " minutes."
                    },
                    aNotificationWillBeSentWhenACameraOrServerBecomesUnreachableFor: function(e) {
                        return "A notification will be sent when a " + e.VALUE + " becomes unreachable for"
                    },
                    aNotificationWillBeSentWhenACameraOrServerBecomesUnreachableForNMinutes: function(e) {
                        return "A notification will be sent when a " + e.VALUE + " becomes unreachable for " + e.MINUTES + " " + n(e.MINUTES, 0, t, {
                            one: "minute",
                            other: "minutes"
                        }) + "."
                    }
                },
                onvifBulkRegistration: {
                    VALUEUnsupported: function(e) {
                        return e.VALUE + " Unsupported"
                    }
                },
                orchidDataService: {
                    isNotAvailable: function(e) {
                        return "Orchid Recorder is not available"
                    }
                },
                player: {
                    alertSlowNetwork: function(e) {
                        return "Alert: Slow network or viewing device."
                    },
                    bandwidthIssuesForCam: function(e) {
                        return "We're currently experiencing issues receiving and displaying video for this camera. This could be due to the following:"
                    },
                    bandwidthMode: function(e) {
                        return i(e.VALUE, {
                            webrtc: "Low",
                            other: "Full"
                        }) + "-bandwidth mode"
                    },
                    bidirectionalAudio: {
                        APPNAMERequiresMicrophoneAccess: function(e) {
                            return "Orchid Hybrid VMS requires access to your microphone before the two-way audio feature can be used."
                        },
                        microphoneInaccessible: function(e) {
                            return "Microphone Inaccessible"
                        },
                        microphonePermissionRequired: function(e) {
                            return "Microphone permission required"
                        },
                        noDeviceFound: function(e) {
                            return "No device found"
                        },
                        oneOrMoreMicrophonesAreRequiredToGrantPermissions: function(e) {
                            return "At least one available microphone is required to grant microphone permissions."
                        },
                        permissionRequired: function(e) {
                            return "Permission required"
                        },
                        secureContextNotice: function(e) {
                            return "Two-way audio is only available over a secure HTTPS connection. Contact your system administrator to access this functionality."
                        },
                        selectMicrophone: function(e) {
                            return "Select microphone"
                        },
                        unknownDevice: function(e) {
                            return "Unknown device"
                        },
                        verifyMicrophoneIsPluggedIn: function(e) {
                            return "Plug a microphone in if none are plugged in, otherwise verify it is recognized by the system and browser. You may need to restart your browser after plugging a device in."
                        },
                        youMayConfigureTheMicrophonePermission: function(e) {
                            return "You may configure the microphone permission within your browser's settings"
                        }
                    },
                    cancel: function(e) {
                        return "Cancel"
                    },
                    cannotPlayProxyOnlyStreamInLB: function(e) {
                        return "Cannot play Proxy Only stream in low-bandwidth mode."
                    },
                    cannotPlayLBStreamsWithoutMotionDetection: function(e) {
                        return "Cannot play low-bandwidth streams without motion detection."
                    },
                    clientTimezone: function(e) {
                        return "Client Timezone"
                    },
                    closePlayer: function(e) {
                        return "Close Player"
                    },
                    deletePreset: function(e) {
                        return "Delete preset"
                    },
                    dewarpFisheyeCamera: function(e) {
                        return "Dewarp Fisheye Camera"
                    },
                    dewarpIncompatibleError: function(e) {
                        return "The browser is currently unable to perform image dewarping."
                    },
                    dewarpLimit: function(e) {
                        return "The limit of dewarp players has been reached (" + e.VALUE + ")."
                    },
                    doNotHavePermissionThisStream: {
                        liveStream: function(e) {
                            return "You do not have permission to live stream this stream."
                        },
                        playback: function(e) {
                            return "You do not have permission to playback this stream."
                        }
                    },
                    error: function(e) {
                        return "Error"
                    },
                    errorCreatingPreset: function(e) {
                        return "Error creating preset: " + e.VALUE
                    },
                    expectedArchiveIsNotPlayable: function(e) {
                        return "Expected archive is not playable"
                    },
                    failedToDownloadImageFromPlayer: function(e) {
                        return "Failed to download the image from the player"
                    },
                    fullscreen: function(e) {
                        return "Fullscreen"
                    },
                    hide: function(e) {
                        return "Hide"
                    },
                    hideTheseError: function(e) {
                        return "Hide these errors"
                    },
                    clientServerTimeDiffSpaced: function(e) {
                        return e.SIGN + e.DIFF + " " + n(e.DIFF, 0, t, {
                            one: "hr",
                            other: "hrs"
                        })
                    },
                    ifAllEleseFailsLowB: function(e) {
                        return "If all else fails, try low-bandwidth mode."
                    },
                    insufficientDownloadSpeed: function(e) {
                        return "Insufficient download speed from your Orchid Recorder client."
                    },
                    insufficientProcessingSpeed: function(e) {
                        return "Insufficient processing power on your Orchid Recorder client."
                    },
                    insufficientUploadSpeed: function(e) {
                        return "Insufficient upload speed from your Orchid Recorder server."
                    },
                    invalidUserName: function(e) {
                        return "Invalid user name (alphanumeric characters only)."
                    },
                    learnMore: function(e) {
                        return "Learn more"
                    },
                    lowBandwidth: function(e) {
                        return "Low Bandwidth"
                    },
                    motionRegionsHide: function(e) {
                        return "Hide Motion Regions"
                    },
                    motionRegionsShow: function(e) {
                        return "Show Motion Regions"
                    },
                    newPreset: function(e) {
                        return "New Preset"
                    },
                    noFrameToDisplay: function(e) {
                        return "No frame to display."
                    },
                    noSavedPresets: function(e) {
                        return "No saved presets"
                    },
                    noSessionExistsFor: function(e) {
                        return "No session exists for " + e.VALUE
                    },
                    noStreamsConfigured: function(e) {
                        return "No streams configured."
                    },
                    noVideoToDisplay: function(e) {
                        return "No video to display."
                    },
                    off: function(e) {
                        return "Off"
                    },
                    ok: function(e) {
                        return "Ok"
                    },
                    panTiltZoom: function(e) {
                        return "Pan, Tilt, Zoom"
                    },
                    panorama: function(e) {
                        return "Panorama"
                    },
                    perspective: function(e) {
                        return "Perspective"
                    },
                    cameraCAMERANAMEfromTIMESTAMPdotEXTENSION: function(e) {
                        return "Camera_" + e.CAMERANAME + "_from_" + e.TIMESTAMP + "." + e.EXTENSION
                    },
                    preset: function(e) {
                        return "Preset"
                    },
                    presetName: function(e) {
                        return "Preset Name"
                    },
                    presetNameIsRequired: function(e) {
                        return "Preset name is required."
                    },
                    presetNameMustBe: function(e) {
                        return "Preset name must be 32 characters or fewer."
                    },
                    primary: function(e) {
                        return "Primary"
                    },
                    problemsStreamingVideo: function(e) {
                        return "Problems Streaming Video"
                    },
                    ptzPresets: function(e) {
                        return "PTZ Presets"
                    },
                    reload: function(e) {
                        return "Reload"
                    },
                    reloadPageInLowBandwidthMode: function(e) {
                        return "Reload Page in Low-bandwidth Mode"
                    },
                    reloadPlayerInLowBandwidthMode: function(e) {
                        return "Reload player in low-bandwidth mode"
                    },
                    save: function(e) {
                        return "Save"
                    },
                    savePreset: function(e) {
                        return "Save Preset"
                    },
                    secondaryStreamsOfThisMediaTypeCanNotBePlayed: function(e) {
                        return "Secondary streams of this media type (" + e.MEDIA_TYPE + ") can not be played."
                    },
                    serverTimezone: function(e) {
                        return "Server Timezone"
                    },
                    videoStartsIn: function(e) {
                        return 'Video<br>starts in<br><span class="time-text">' + e.TIME + "</span>"
                    },
                    statistics: function(e) {
                        return "Statistics"
                    },
                    stream: function(e) {
                        return "Stream:"
                    },
                    diagnostics: function(e) {
                        return "Diagnostics:"
                    },
                    troubleshootingSteps: function(e) {
                        return "Troubleshooting steps:"
                    },
                    tryDecreasingBitrate: function(e) {
                        return "Try decreasing the bitrate and resolution for this stream."
                    },
                    tryLowBandwidthMode: function(e) {
                        return "Try Low-bandwidth Mode"
                    },
                    unsupportedLowBandwidthMode: function(e) {
                        return "Cannot play video because Low Bandwidth Mode is unavailable"
                    },
                    unsupportedOrchid: function(e) {
                        return "Unsupported version of Orchid Recorder"
                    },
                    valueFps: function(e) {
                        return e.VALUE + " fps"
                    },
                    volume: function(e) {
                        return "Volume"
                    }
                },
                recipients: {
                    emailSelection: function(e) {
                        return "Email selection"
                    },
                    groupSelection: function(e) {
                        return "Group Selection"
                    },
                    noGroupsMatchSearch: function(e) {
                        return "No groups match search"
                    },
                    noUsersMatchSearch: function(e) {
                        return "No users match search"
                    },
                    userSelection: function(e) {
                        return "User selection"
                    }
                },
                recorderPicker: {
                    enterRecordersNameorIP: function(e) {
                        return "Enter Recorder's name or IP address"
                    },
                    recorders: function(e) {
                        return "Recorders"
                    },
                    search: function(e) {
                        return "Search"
                    },
                    selectAll: function(e) {
                        return "Select all " + e.NUMBER
                    }
                },
                resourceTagging: {
                    add: function(e) {
                        return "Add"
                    },
                    addCameraTag: function(e) {
                        return "Add Camera Tag"
                    },
                    addServerTag: function(e) {
                        return "Add Server Tag"
                    },
                    addTag: function(e) {
                        return "Add Tag"
                    },
                    affectedCameras: function(e) {
                        return "Affected Cameras"
                    },
                    affectedServers: function(e) {
                        return "Affected Servers"
                    },
                    backToServers: function(e) {
                        return "Back to Servers"
                    },
                    cameraTag: function(e) {
                        return "Camera Tag"
                    },
                    cameras: function(e) {
                        return "Cameras"
                    },
                    createCameraTag: function(e) {
                        return "Create camera tag"
                    },
                    createServerTag: function(e) {
                        return "Create server tag"
                    },
                    currentlyTagged: function(e) {
                        return "Currently Tagged"
                    },
                    deleteCameraTag: function(e) {
                        return "Delete Camera Tag"
                    },
                    deleteServerTag: function(e) {
                        return "Delete Server Tag"
                    },
                    deleteTag: function(e) {
                        return "Delete tag"
                    },
                    deletingThisTagWillAlsoRemoveTheTagFromTheFollowingServers: function(e) {
                        return "Deleting this tag will also remove the tag from the following servers"
                    },
                    deletingThisTagWillRemoveItFromTheFollowingCameras: function(e) {
                        return "Deleting this tag will also remove it from the following cameras"
                    },
                    editCameraTag: function(e) {
                        return "Edit Camera Tag"
                    },
                    editCameraTags: function(e) {
                        return "Edit Camera Tags"
                    },
                    editServerTag: function(e) {
                        return "Edit Server Tag"
                    },
                    editServerTags: function(e) {
                        return "Edit Server Tags"
                    },
                    enterTagName: function(e) {
                        return "Enter tag name"
                    },
                    enterTagValue: function(e) {
                        return "Enter tag value"
                    },
                    errors: {
                        alphanumericCharactersOnly: function(e) {
                            return "Only letters, numbers, and underscores allowed"
                        },
                        noDuplicateTagNames: function(e) {
                            return "Duplicate tag names are not allowed"
                        },
                        tagNameRequired: function(e) {
                            return "Tag name is required"
                        },
                        tagNameTooLong: function(e) {
                            return "Tag name is too long"
                        },
                        tagValueTooLong: function(e) {
                            return "Tag value is too long"
                        }
                    },
                    failedToFetchCameraTags: function(e) {
                        return "Failed to fetch camera tags"
                    },
                    failedToFetchResourceDetails: function(e) {
                        return "Failed to fetch resource details"
                    },
                    failedToFetchServerTags: function(e) {
                        return "Failed to fetch server tags"
                    },
                    failedToFetchServerTagDetails: function(e) {
                        return "Failed to fetch server tag details"
                    },
                    label: function(e) {
                        return "Label"
                    },
                    loadingCameraTags: function(e) {
                        return "Loading camera tags"
                    },
                    loadingServerTags: function(e) {
                        return "Loading server tags"
                    },
                    manageTags: function(e) {
                        return "Manage Tags"
                    },
                    newTag: function(e) {
                        return "(New tag)"
                    },
                    noCameraTagsHaveBeenCreated: function(e) {
                        return "No camera tags have been created"
                    },
                    noServerTagsHaveBeenCreated: function(e) {
                        return "No server tags have been created"
                    },
                    operationInProgress: {
                        areYouSure: function(e) {
                            return "Are you sure you would like to cancel all tagging operation?"
                        },
                        cancel: function(e) {
                            return "Cancel"
                        },
                        cancelAll: function(e) {
                            return "Cancel All"
                        },
                        cancelOperation: function(e) {
                            return "Cancel Operation"
                        },
                        nevermind: function(e) {
                            return "Nevermind"
                        },
                        theServerIsCurrentlyBusy: function(e) {
                            return "The server is currently busy with a bulk operation"
                        },
                        tryAgain: function(e) {
                            return "Try again"
                        },
                        unableToCancelOperation: function(e) {
                            return "Unable to cancel operation at this time"
                        },
                        yesCancelAllRequests: function(e) {
                            return "Yes, cancel all requests"
                        }
                    },
                    operationStatusUncertainDescription: function(e) {
                        return "Operation status uncertain. It may have completed successfully.<br><br>Please verify or try again."
                    },
                    oneOrMoreTagsCouldNotBeDeleted: function(e) {
                        return "One or more tags could not be deleted."
                    },
                    oneOrMoreTagsCouldNotBeProcessed: function(e) {
                        return "One or more tags could not be processed."
                    },
                    plusVALUEMore: function(e) {
                        return "+ " + e.VALUE + " more"
                    },
                    remove: function(e) {
                        return "Remove"
                    },
                    requestTimedOut: function(e) {
                        return "Request Timed Out"
                    },
                    searchCameraTags: function(e) {
                        return "Search camera tags"
                    },
                    searchServerTags: function(e) {
                        return "Search server tags"
                    },
                    selectCameras: function(e) {
                        return "Select cameras to apply this tag to"
                    },
                    selectServers: function(e) {
                        return "Select servers to apply this tag to"
                    },
                    servers: function(e) {
                        return "Servers"
                    },
                    serverSettingsSubtext: function(e) {
                        return "General settings specific to this server"
                    },
                    serverTag: function(e) {
                        return "Server Tag"
                    },
                    tagConfiguration: function(e) {
                        return "Tag Configuration"
                    },
                    tagEditor: {
                        cameraTagName: function(e) {
                            return "Camera Tag Name"
                        },
                        cameraTags: function(e) {
                            return "Camera Tags"
                        },
                        cameraTagValue: function(e) {
                            return "Camera Tag Value"
                        },
                        eventSubscriptionTagName: function(e) {
                            return "Event Subscription Tag Name"
                        },
                        eventSubscriptionTags: function(e) {
                            return "Event Subscription Tags"
                        },
                        eventSubscriptionTagValue: function(e) {
                            return "Event Subscription Tag Value"
                        },
                        newCameraTags: function(e) {
                            return "New Camera Tags"
                        },
                        newEventSubscriptionTags: function(e) {
                            return "New Event Subscription Tags"
                        },
                        newServerTags: function(e) {
                            return "New Server Tags"
                        },
                        serverTagName: function(e) {
                            return "Server Tag Name"
                        },
                        serverTags: function(e) {
                            return "Server Tags"
                        },
                        serverTagValue: function(e) {
                            return "Server Tag Value"
                        }
                    },
                    tag: function(e) {
                        return "Tag"
                    },
                    tagNamesAreCaseInsensitive: function(e) {
                        return "Tag names will be converted to lowercase"
                    },
                    tagNamesAndValuesAreCaseInsensitive: function(e) {
                        return "Tag names and values will be converted to lowercase"
                    },
                    tagOperationCanceled: function(e) {
                        return "Tag Operation Canceled"
                    },
                    tags: function(e) {
                        return "Tags"
                    },
                    theTagYouSelectedAlreadyExisted: function(e) {
                        return "<p>The tag you've selected already exists. If you proceed, it may override the existing tag or be added to other " + e.RESOURCES + ".</p> <p>To avoid unintended changes, we recommend closing this dialog and selecting the tag from the table.</p>"
                    },
                    theTagCannotBeDeletedCompletelyBecauseOneOrMoreOfTheserversItIsAssociatedWithAreRunningAVersionOlderThanVERSION: function(e) {
                        return "The tag cannot be fully deleted because one or more associated servers are running a version earlier than " + e.VERSION + "."
                    },
                    thisTagWillBePermanentlyRemoved: function(e) {
                        return "This tag will be permanently removed"
                    },
                    newUpdateWillBeAppliedToServers: function(e) {
                        return "New update to this tag will be applied to the following servers"
                    },
                    newUpdateWillBeAppliedToCameras: function(e) {
                        return "New update to this tag will be applied to the following cameras"
                    },
                    value: function(e) {
                        return "Value"
                    },
                    AMOUNTtags: function(e) {
                        return e.AMOUNT + " " + n(e.AMOUNT, 0, t, {
                            one: "tag",
                            other: "tags"
                        })
                    }
                },
                serverShutdown: {
                    shutdownAlertTooltip: function(e) {
                        return "Service restarting due to unconfirmed advanced setting changes"
                    }
                },
                propertyEditor: {
                    checkingIfPropertiesNeedConfirming: function(e) {
                        return "Checking if properties need confirming"
                    },
                    yes: function(e) {
                        return "Yes"
                    },
                    no: function(e) {
                        return "No"
                    },
                    saveProperty: function(e) {
                        return "Save Properties"
                    },
                    areYouSureYouWantToSaveThesePropertiesSavingThesePropertiesWillRequireAServerRestart: function(e) {
                        return "Are you sure you want to save these properties? Saving these properties will require a server restart and subsequent confirmation of property changes."
                    },
                    errorSavingProperties: function(e) {
                        return "Error Saving Properties"
                    },
                    confirm: function(e) {
                        return "Confirm"
                    },
                    confirmProperties: function(e) {
                        return "Confirm Properties"
                    },
                    newProperty: function(e) {
                        return "New Property"
                    },
                    property: function(e) {
                        return "Property"
                    },
                    saveProperties: function(e) {
                        return "Save Properties"
                    },
                    save: function(e) {
                        return "Save"
                    },
                    serverSettings: function(e) {
                        return "Server Settings"
                    },
                    filterProperties: function(e) {
                        return "Filter properties"
                    },
                    propertyFileEditor: function(e) {
                        return "Property File Editor"
                    },
                    propertyName: function(e) {
                        return "Property Name"
                    },
                    propertyValue: function(e) {
                        return "Property Value"
                    },
                    searchForProperty: function(e) {
                        return "Search for property"
                    },
                    thisPropertyIsLockedAndCannotBeChangedViaThisInterface: function(e) {
                        return "This property is locked and cannot be changed via this interface"
                    },
                    unckeckingThisBoxWillDeleteTheProperty: function(e) {
                        return "Unckecking this box will delete the property"
                    },
                    unfinishedProperties: function(e) {
                        return "Unfinished properties"
                    },
                    thereAreSomeEditedPropertiesThatDoNotHaveValuesAreYouSureYouWantToContinue: function(e) {
                        return "There are some edited properties that do not have values. Are you sure you want to continue?"
                    },
                    yesIAmSure: function(e) {
                        return "Yes I am sure"
                    },
                    noIAmNotSure: function(e) {
                        return "No I am not sure"
                    },
                    anUnexpectedErrorOccurredWhileFetchingProperties: function(e) {
                        return "An unexpected error occurred when retrieving the properties"
                    },
                    loadingProperties: function(e) {
                        return "Loading Properties..."
                    },
                    savingPropertiesShutdownReason: function(e) {
                        return "The Orchid Recorder service is restarting in order to save your configuration changes.  Once the service starts back up, you will need to confirm the new settings within 5 minutes or the service will restart once more and the previous configuration will be restored."
                    },
                    noPropertiesExist: function(e) {
                        return "No properties exist"
                    },
                    noPropertiesMatchTheSearch: function(e) {
                        return "No properties match the search"
                    },
                    propertiesChipsInputAriaLabel: function(e) {
                        return "Search for a property by name"
                    },
                    failedToLoadPropertyFileData: function(e) {
                        return "Failed To Load Property File Data"
                    },
                    theFollowingErrorOccurred: function(e) {
                        return "The following error occurred:"
                    },
                    aPropertyWithThisNameAlreadyExists: function(e) {
                        return "A property with this name already exists."
                    },
                    thisPropertyIsMarkedAsActiveButHasNoName: function(e) {
                        return "This property is marked as active but has no name"
                    },
                    thisPropertyIsMarkedAsActiveButHasNoValue: function(e) {
                        return "This property is marked as active but has no value"
                    },
                    thisPropertyHasInvalidPrefix: function(e) {
                        return "This property has a reserved prefix"
                    },
                    unCheckingWillDisableTheProperty: function(e) {
                        return "Un-checking will disable the property."
                    },
                    checkingWillEnableTheProperty: function(e) {
                        return "Checking will enable the property."
                    },
                    removeCustomProperty: function(e) {
                        return "Remove unsaved custom property"
                    },
                    dialogs: {
                        saving: {
                            title: function(e) {
                                return "Saving Properties"
                            }
                        },
                        confirming: {
                            title: function(e) {
                                return "Confirming Properties"
                            }
                        },
                        save: {
                            title: function(e) {
                                return "Save Properties"
                            },
                            body: function(e) {
                                return "The Orchid Recorder service must restart in order to save the configuration. The new configuration must be confirmed within 5 minutes of the service restarting or the original configuration will be restored."
                            },
                            yes: function(e) {
                                return "Save and Restart"
                            },
                            no: function(e) {
                                return "Cancel"
                            }
                        },
                        confirm: {
                            title: function(e) {
                                return "Conform Properties"
                            },
                            body: function(e) {
                                return "Would you like to keep the advanced settings changes? If you do not confirm, the Orchid Recorder service will automatically restart within the next five minutes and the previous configuration will be restored."
                            },
                            yes: function(e) {
                                return "Keep Changes"
                            },
                            no: function(e) {
                                return "Cancel"
                            }
                        },
                        unsavedProps: {
                            title: function(e) {
                                return "Unsaved Property Changes"
                            },
                            body: function(e) {
                                return "Are you sure you want leave without saving your changes?"
                            },
                            yes: function(e) {
                                return "Leave"
                            },
                            no: function(e) {
                                return "Stay"
                            }
                        }
                    },
                    badCharsPropertyInput: {
                        name: function(e) {
                            return "Invalid property name (invalid character)"
                        },
                        value: function(e) {
                            return "Invalid property value (invalid character)"
                        }
                    },
                    serverTags: function(e) {
                        return "Server Tags"
                    }
                },
                recorderRecovery: {
                    dialogs: {
                        VALUEUnmapped: function(e) {
                            return e.VALUE + " unmapped"
                        },
                        cameraMapping: function(e) {
                            return "Camera Mapping"
                        },
                        cameraMappingNoticeMessage: function(e) {
                            return "A different Recorder exists at the specified URL. Cameras from the old Recorder can optionally be mapped to cameras on the new Recorder."
                        },
                        mappedVALUECameras: function(e) {
                            return "Mapped " + e.VALUE + " " + n(e.VALUE, 0, t, {
                                one: "camera",
                                other: "cameras"
                            })
                        },
                        newRecorderHasNoCamerasWarning: function(e) {
                            return "The new Recorder has no registered cameras. All cameras from the old Recorder will be removed from Orchid Hybrid VMS if you proceed."
                        },
                        recorderUrl: function(e) {
                            return "Recorder URL"
                        },
                        recoverVALUE: function(e) {
                            return "Recover " + e.VALUE
                        },
                        thereAreVALUEUnmappedOldCamerasThatWillBeRemoved: function(e) {
                            return "There " + n(e.VALUE, 0, t, {
                                one: "is",
                                other: "are"
                            }) + " " + e.VALUE + " old " + n(e.VALUE, 0, t, {
                                one: "camera",
                                other: "cameras"
                            }) + " still unmapped. Any unmapped old cameras will be removed permanently once this Recorder is recovered."
                        },
                        warning: function(e) {
                            return "Warning!"
                        },
                        cameraMappingSummary: {
                            add: function(e) {
                                return "Add"
                            },
                            migrate: function(e) {
                                return "Migrate"
                            },
                            remove: function(e) {
                                return "Remove"
                            }
                        },
                        cameraMappingTable: {
                            actions: function(e) {
                                return "Actions"
                            },
                            clearAll: function(e) {
                                return "Clear all"
                            },
                            mapByIp: function(e) {
                                return "Map by IP"
                            },
                            mapByName: function(e) {
                                return "Map by name"
                            },
                            newCameras: function(e) {
                                return "New Cameras"
                            },
                            noCameraSelected: function(e) {
                                return "No camera selected"
                            },
                            noCamerasMatchTheSearch: function(e) {
                                return "No cameras matched the search."
                            },
                            noNewCamerasToMap: function(e) {
                                return "No new cameras to map"
                            },
                            oldCameras: function(e) {
                                return "Old Cameras"
                            },
                            searchOldCameras: function(e) {
                                return "Search old cameras"
                            }
                        },
                        recoverySummary: {
                            VALUEToAdd: function(e) {
                                return e.VALUE + " to add"
                            },
                            VALUEToMigrate: function(e) {
                                return e.VALUE + " to migrate"
                            },
                            VALUEToRemove: function(e) {
                                return e.VALUE + " to remove"
                            },
                            confirmation: function(e) {
                                return "Confirmation"
                            },
                            newRecorder: function(e) {
                                return "New Recorder"
                            },
                            oldRecorder: function(e) {
                                return "Old Recorder"
                            },
                            overview: function(e) {
                                return "Overview"
                            },
                            serverName: function(e) {
                                return "Server Name"
                            },
                            serverUrl: function(e) {
                                return "Server URL"
                            },
                            summaryOfTheCurrentRecorderAndIncomingRecorder: function(e) {
                                return "Summary of the currently registered Recorder and incoming Recorder"
                            },
                            totalCamerasVALUE: function(e) {
                                return "Total Cameras: " + e.VALUE
                            }
                        },
                        refreshNotification: {
                            recorderVALUEHasBeenRecovered: function(e) {
                                return "Recorder " + e.VALUE + " has been recovered"
                            },
                            dataForThisRecorderMayBeOutOfDateOnThisPage: function(e) {
                                return "Data for this recorder may be out of date on this page."
                            },
                            toFixThisSaveAnyChangesAnd: function(e) {
                                return "To fix this save any changes and"
                            },
                            refreshThePage: function(e) {
                                return "refresh the page"
                            }
                        }
                    }
                },
                recorderPermGroups: {
                    headline: function(e) {
                        return "Recorder Administrator Groups"
                    },
                    error: function(e) {
                        return "At least one group must be selected."
                    },
                    inputLabel: function(e) {
                        return "Permission Groups"
                    },
                    placeholderChip: function(e) {
                        return "Add a permission group"
                    },
                    subheader: function(e) {
                        return "Users in these permission groups have access to administer this recorder."
                    },
                    empty: function(e) {
                        return "No groups have been granted access to this recorder"
                    }
                },
                redirectTemplate: {
                    redirectingTo: function(e) {
                        return "Redirecting to " + e.DESTINATION + "..."
                    }
                },
                retentionPolicy: {
                    actualRetention: function(e) {
                        return "Actual Retention"
                    },
                    actualRetentionTotal: function(e) {
                        return "(" + e.VALUE + ") total"
                    },
                    applyDesiredRetentionAllCameras: function(e) {
                        return "Apply Desired Retention (All Cameras)"
                    },
                    areYouSureYouWantToProceed: function(e) {
                        return "Are you sure you want to proceed?"
                    },
                    automatic: function(e) {
                        return "Automatic"
                    },
                    camera: function(e) {
                        return "Camera"
                    },
                    cancelChanges: function(e) {
                        return "Cancel Changes"
                    },
                    currentConfigNotPossible: function(e) {
                        return "Your current configuration is not possible given your maximum archive threshold. You can save these changes, but you must proceed at your own risk."
                    },
                    currentDiskUsage: function(e) {
                        return "Current Disk Utilization"
                    },
                    customAmount: function(e) {
                        return "Custom Amount"
                    },
                    days: function(e) {
                        return e.VALUE + " " + n(e.VALUE, 0, t, {
                            one: "day",
                            other: "days"
                        })
                    },
                    desiredRetention: function(e) {
                        return "Desired Retention"
                    },
                    deletedCameras: function(e) {
                        return "Deleted Cameras"
                    },
                    estimatedRetention: function(e) {
                        return "Estimated Retention"
                    },
                    expandThreshPleaseActivate: function(e) {
                        return "To expand your maximum archive threshold, please activate a <a href=/#!/activation>Orchid Recorder</a>."
                    },
                    failedPolicyData: function(e) {
                        return "Failed To Load Retention Policy Data"
                    },
                    failedTheError: function(e) {
                        return "The following error occurred:"
                    },
                    footageToDelete: function(e) {
                        return "Footage to Delete"
                    },
                    freeSpace: function(e) {
                        return e.VALUE + " of free space"
                    },
                    header: function(e) {
                        return "Estimated Retention"
                    },
                    loading: function(e) {
                        return "Loading Retention Policy Information..."
                    },
                    maxArchiveThreshold: function(e) {
                        return "Max archive threshold at " + e.VALUE
                    },
                    minMax: function(e) {
                        return "min=0; max=10k"
                    },
                    newRetention: function(e) {
                        return "New Retention"
                    },
                    noCamerasConfigured: function(e) {
                        return "No Cameras Configured"
                    },
                    noCamerasFix: function(e) {
                        return "You will need to have cameras registered prior to using this interface."
                    },
                    noStreamsAreRecording: function(e) {
                        return "No streams are recording"
                    },
                    notEnoughRetentionHistory: function(e) {
                        return "Not enough retention history"
                    },
                    oldRetention: function(e) {
                        return "Old Retention"
                    },
                    retentionEstimatesAreBasedOnLast24Hours: function(e) {
                        return "Retention estimates are based on each camera's average bitrate over the past 24 hours."
                    },
                    retentionEstimatesAssumeConstantMotionForStreamsConfiguredToRecordMotionOnly: function(e) {
                        return "Retention estimates assume constant motion for streams configured to record motion-only."
                    },
                    retentionSpan: function(e) {
                        return "Retention Span"
                    },
                    saveConfig: function(e) {
                        return "Save Configuration"
                    },
                    spans: function(e) {
                        return "spans"
                    },
                    unavailableSpace: function(e) {
                        return e.VALUE + " of unavailable space"
                    },
                    unavailableSpaceTitle: function(e) {
                        return "Unavailable space"
                    },
                    unusableSpace: function(e) {
                        return "Unusable Space"
                    },
                    unexpectedErrorWhenSavingRetention: function(e) {
                        return "An unexpected error occurred when saving retention"
                    },
                    usedByDeletedCams: function(e) {
                        return e.VALUE + " used by deleted cameras"
                    },
                    update: function(e) {
                        return "Update"
                    },
                    yourNewDesiredRetentionDurationWillResultIn: function(e) {
                        return "Your new Desired Retention duration will result in immediate deletion of older footage in your storage. The following cameras' archived footage will be affected:"
                    }
                },
                signIn: {
                    accessAgreement: function(e) {
                        return "access agreement."
                    },
                    agreementMessage: function(e) {
                        return "I have read and accepted the terms of the"
                    },
                    differentServer: function(e) {
                        return "Looking for a different Orchid server?"
                    },
                    domainLoginRequired: function(e) {
                        return "Domain login required: username@domain"
                    },
                    errorMissingFields: function(e) {
                        return "Username and Password are both required."
                    },
                    failDialogTitle: function(e) {
                        return "Sign in failed"
                    },
                    googleSignInUnsupported: function(e) {
                        return "Browser does not support Google Sign In."
                    },
                    lowBandwidthMode: function(e) {
                        return "Low-bandwidth mode"
                    },
                    offlineError: function(e) {
                        return "The server is offline or otherwise unreachable."
                    },
                    okay: function(e) {
                        return "Okay"
                    },
                    or: function(e) {
                        return "or"
                    },
                    password: function(e) {
                        return "Password"
                    },
                    signIn: function(e) {
                        return "sign in"
                    },
                    signInWithVALUE: function(e) {
                        return "Sign In with " + e.VALUE
                    },
                    staySignedIn: function(e) {
                        return "Stay signed in"
                    },
                    tryAnother: function(e) {
                        return "Try another"
                    },
                    unexpectedError: function(e) {
                        return "An unexpected error occurred"
                    },
                    unspecifiedError: function(e) {
                        return "An unspecified error occurred. Please try again later."
                    },
                    username: function(e) {
                        return "Username"
                    }
                },
                singlePlayer: {
                    noAccessToOrchid: function(e) {
                        return "No access to Orchid Recorder " + e.VALUE
                    },
                    authenticationFailed: function(e) {
                        return "Authentication failed"
                    },
                    cannotFetchCameraAndServerInformation: function(e) {
                        return "Cannot fetch camera and server information"
                    },
                    cannotOpenStream: function(e) {
                        return "Cannot open stream " + e.VALUE
                    },
                    timedOutWaitingForAuthorizationToken: function(e) {
                        return "Timed out waiting for authorization token"
                    }
                },
                smartSearch: {
                    drawRegionsToFilterForMotionInTheSpecifiedAreas: function(e) {
                        return "Draw regions to filter for motion in the specified areas."
                    }
                },
                thumbnailSearch: {
                    overlay: {
                        chooseADate: function(e) {
                            return "Choose a Date"
                        },
                        filteringByRegion: function(e) {
                            return "Filtering by region"
                        },
                        noPreviewsAvailable: function(e) {
                            return "No Previews Available"
                        },
                        hourViews: function(e) {
                            return "Hour Views"
                        },
                        minuteViews: function(e) {
                            return "Minute Views"
                        },
                        hourlyOverview: function(e) {
                            return "Hourly Overview"
                        },
                        selectAnHourToViewItsEvents: function(e) {
                            return "Select an hour to view its events"
                        },
                        selectAnEventToStartPlayback: function(e) {
                            return "Select an event to start playback"
                        }
                    }
                },
                stage: {
                    availableStreams: function(e) {
                        return "Available Streams"
                    },
                    dateSearch: function(e) {
                        return "Date Search"
                    },
                    dateTimeNavigation: function(e) {
                        return "Date/Time Navigation"
                    },
                    dewarp: function(e) {
                        return "dewarp"
                    },
                    dewarpPlayerFormat: function(e) {
                        return "Dewarp Player Format"
                    },
                    directlyDownloadExportedClips: function(e) {
                        return "Directly download exported clips."
                    },
                    download: function(e) {
                        return "Download"
                    },
                    end: function(e) {
                        return "End"
                    },
                    errorOccurredWhileExportingVideo: function(e) {
                        return "An error has occurred while attempting to export video"
                    },
                    export: function(e) {
                        return "Export"
                    },
                    exportEnd: function(e) {
                        return "Export End"
                    },
                    exportFileKind: function(e) {
                        return "Export " + e.VALUE + " file"
                    },
                    exportStart: function(e) {
                        return "Export Start"
                    },
                    exportingVideoFrom: function(e) {
                        return "Exporting video from"
                    },
                    forBestViewingExperienceFF: function(e) {
                        return "For the best possible viewing experience try using"
                    },
                    format: function(e) {
                        return "Format"
                    },
                    from: function(e) {
                        return "From"
                    },
                    learnMoreAboutFormats: function(e) {
                        return "Learn more about these formats."
                    },
                    live: function(e) {
                        return "LIVE"
                    },
                    locateStreamYouWantToExport: function(e) {
                        return "Locate the stream you want to export below and click on the button corresponding to the file format you'd like to export."
                    },
                    maximumExportDuration: function(e) {
                        return "Maximum export duration: " + e.VALUE + " " + n(e.VALUE, 0, t, {
                            one: "hour",
                            other: "hours"
                        }) + " of video."
                    },
                    matroskaMultimediaContainer: function(e) {
                        return "Matroska Multimedia Container"
                    },
                    name: function(e) {
                        return "Name"
                    },
                    nextMotionEvent: function(e) {
                        return "Next Motion Event"
                    },
                    pause: function(e) {
                        return "Pause"
                    },
                    play: function(e) {
                        return "Play"
                    },
                    playPause: function(e) {
                        return "Play/Pause"
                    },
                    previousMotionEvent: function(e) {
                        return "Previous Motion Event"
                    },
                    quickTimeFileFormat: function(e) {
                        return "QuickTime File Format"
                    },
                    recommendedPlayers: function(e) {
                        return "Recommended Players"
                    },
                    save: function(e) {
                        return "Save"
                    },
                    saveVideo: function(e) {
                        return "Save Video"
                    },
                    scales: {
                        "1day": function(e) {
                            return "1 day"
                        },
                        "12hr": function(e) {
                            return "12 hr"
                        },
                        "6hr": function(e) {
                            return "6 hr"
                        },
                        "3hr": function(e) {
                            return "3 hr"
                        },
                        "1hr": function(e) {
                            return "1 hr"
                        },
                        "30min": function(e) {
                            return "30 min"
                        },
                        "15min": function(e) {
                            return "15 min"
                        },
                        "5min": function(e) {
                            return "5 min"
                        },
                        "1min": function(e) {
                            return "1 min"
                        }
                    },
                    selectVideoFrom: function(e) {
                        return "Select video from"
                    },
                    setH264ProfileFF: function(e) {
                        return 'Set the h.264 profile for this stream to "Baseline."'
                    },
                    start: function(e) {
                        return "Start"
                    },
                    thereAreNoArchivesInRegion: function(e) {
                        return "There are no archives in the specified region."
                    },
                    timeRangeError: function(e) {
                        return "Invalid time selection.  Start time must be at least 10 seconds less than end time and end time cannot be in the future."
                    },
                    to: function(e) {
                        return "To"
                    },
                    toggleSelectionMode: function(e) {
                        return "Toggle Selection Mode"
                    },
                    unfortunatelyThereAreNoLinkedCamerasOnTheStageThatYouHavePermissionToSave: function(e) {
                        return "Unfortunately, there are no linked cameras on the stage that you have permission to save."
                    },
                    webRtcTroubleshooting: function(e) {
                        return "WebRTC Troubleshooting"
                    }
                },
                statisticKeys: {
                    player: {
                        general: function(e) {
                            return "General"
                        },
                        playerId: function(e) {
                            return "Player Id"
                        },
                        mode: function(e) {
                            return "Mode"
                        },
                        streamId: function(e) {
                            return "Stream Id"
                        },
                        cameraDriver: function(e) {
                            return "Camera Driver"
                        },
                        cameraMacAddress: function(e) {
                            return "Camera MAC Address"
                        },
                        cameraMake: function(e) {
                            return "Camera Make"
                        },
                        cameraModel: function(e) {
                            return "Camera Model"
                        },
                        upTime: function(e) {
                            return "Up time"
                        },
                        timeToPlay: function(e) {
                            return "Time To First Frame (ms)"
                        },
                        playbackTime: function(e) {
                            return "Play Back Time (ms)"
                        },
                        unknown: function(e) {
                            return "Unknown"
                        }
                    },
                    webrtc: {
                        TIMESTAMP: function(e) {
                            return "Timestamp"
                        },
                        RESOLUTION: function(e) {
                            return "Resolution"
                        },
                        FRAMERATE: function(e) {
                            return "Framerate"
                        },
                        BITRATE: function(e) {
                            return "Bitrate"
                        },
                        ICE_CONNECTION_STATE: function(e) {
                            return "ICE Connection State"
                        },
                        CONNECTION_STATE: function(e) {
                            return "Connection State"
                        },
                        PACKETS_RECEIVED: function(e) {
                            return "Packets Received"
                        },
                        PACKETS_LOST: function(e) {
                            return "Packets Lost"
                        },
                        FRACTION_PACKET_LOSS: function(e) {
                            return "Fraction Packet Loss"
                        },
                        HIDDEN: function(e) {
                            return "hidden"
                        },
                        REMOTE_CANDIDATES: function(e) {
                            return "Remote Candidates"
                        },
                        LOCAL_CANDIDATES: function(e) {
                            return "Local Candidates"
                        },
                        ADVANCED: function(e) {
                            return "Advanced"
                        },
                        FRAMES_RECEIVED: function(e) {
                            return "Frames Received"
                        },
                        BYTES_RECEIVED: function(e) {
                            return "Bytes Received"
                        },
                        FRAMES_DROPPED: function(e) {
                            return "Frames Dropped"
                        },
                        FRAMES_DECODED: function(e) {
                            return "Frames Decoded"
                        },
                        DTLS_STATE: function(e) {
                            return "DTLS State"
                        },
                        NACK_COUNT: function(e) {
                            return "NACK Count"
                        },
                        CONNECTION: function(e) {
                            return "Connection"
                        },
                        SAMPLES_RECEIVED: function(e) {
                            return "Samples Received"
                        },
                        SAMPLE_RATE: function(e) {
                            return "Sample Rate"
                        },
                        ENCODER: function(e) {
                            return "Encoder"
                        },
                        AUDIO: function(e) {
                            return "Audio"
                        },
                        VIDEO: function(e) {
                            return "Video"
                        },
                        PERFORMANCE: function(e) {
                            return "Performance"
                        },
                        TIME_TO_WS: function(e) {
                            return "Web Socket Connection Time (ms)"
                        },
                        TIME_TO_CHOSEN_PAIR: function(e) {
                            return "Chosen Pair Selection Time (ms)"
                        }
                    },
                    websocket: {
                        requestedSize: function(e) {
                            return "Requested Size"
                        },
                        resolution: function(e) {
                            return "Resolution"
                        },
                        framerate: function(e) {
                            return "Framerate"
                        },
                        bitrate: function(e) {
                            return "Bitrate"
                        },
                        bytesReceived: function(e) {
                            return "Bytes Received"
                        },
                        framesReceived: function(e) {
                            return "Frames Received"
                        },
                        framesRendered: function(e) {
                            return "Frames Rendered"
                        },
                        timeToWebSocket: function(e) {
                            return "Web Socket Connection Time (ms)"
                        }
                    }
                },
                statuses: {
                    disabled: function(e) {
                        return "disabled"
                    },
                    idle: function(e) {
                        return "idle"
                    },
                    starting: function(e) {
                        return "starting"
                    },
                    stopping: function(e) {
                        return "stopping"
                    },
                    restarting: function(e) {
                        return "restarting"
                    },
                    running: function(e) {
                        return "running"
                    },
                    unknown: function(e) {
                        return "unknown"
                    },
                    unableToRetrieve: function(e) {
                        return "unable to retrieve"
                    }
                },
                storageUnits: {
                    bytes: function(e) {
                        return "bytes"
                    },
                    kb: function(e) {
                        return "KB"
                    },
                    mb: function(e) {
                        return "MB"
                    },
                    gb: function(e) {
                        return "GB"
                    },
                    tb: function(e) {
                        return "TB"
                    },
                    pb: function(e) {
                        return "PB"
                    },
                    eb: function(e) {
                        return "EB"
                    },
                    zb: function(e) {
                        return "ZB"
                    },
                    yb: function(e) {
                        return "YB"
                    }
                },
                bitrateUnits: {
                    bits: function(e) {
                        return "bits"
                    },
                    kb: function(e) {
                        return "Kb"
                    },
                    mb: function(e) {
                        return "Mb"
                    },
                    gb: function(e) {
                        return "Gb"
                    },
                    tb: function(e) {
                        return "Tb"
                    }
                },
                system: {
                    actions: function(e) {
                        return "Actions"
                    },
                    allStreamsDisabled: function(e) {
                        return "All streams are disabled because your system is in a degraded state."
                    },
                    averageVideoBitrateOverPast15Minutes: function(e) {
                        return "Average video bitrate received by Orchid Recorder over the last 15 minutes"
                    },
                    badExportFromValue: function(e) {
                        return "from cannot be > to"
                    },
                    cameraStream: function(e) {
                        return "Camera / Stream"
                    },
                    cameraVerificationFailedERROR: function(e) {
                        return "Camera verification failed: " + e.ERROR
                    },
                    cannotZoomInFurther: function(e) {
                        return "Cannot zoom in any further."
                    },
                    diskUtilization: function(e) {
                        return "Disk Utilization"
                    },
                    errorOccurred: function(e) {
                        return "The following error occurred:"
                    },
                    exportFrom: function(e) {
                        return "Export From"
                    },
                    exportLogs: function(e) {
                        return "Export Logs"
                    },
                    exportTo: function(e) {
                        return "Export To"
                    },
                    failedToLoadDiskUtilization: function(e) {
                        return "Failed to load disk utilization"
                    },
                    failedToLoadStreams: function(e) {
                        return "Failed to load streams"
                    },
                    failedToLoadSystemStatus: function(e) {
                        return "Failed To Load System Status"
                    },
                    failedToVerifyVALUE: function(e) {
                        return "Failed to verify camera " + e.VALUE
                    },
                    format: function(e) {
                        return "Format:"
                    },
                    freeOutOf: function(e) {
                        return e.FREE + " free out of " + e.CAPACITY
                    },
                    from: function(e) {
                        return "From:"
                    },
                    go: function(e) {
                        return "Go"
                    },
                    gzip: function(e) {
                        return "gzip"
                    },
                    lastArchive: function(e) {
                        return "Last Archive"
                    },
                    lessThan60Seconds: function(e) {
                        return "< 60 seconds"
                    },
                    loading: function(e) {
                        return "Loading..."
                    },
                    loadingSystemStatus: function(e) {
                        return "Loading System Status"
                    },
                    logExport: function(e) {
                        return "Log Export"
                    },
                    mbRecorded: function(e) {
                        return "MB Recorded"
                    },
                    motionRecorded: function(e) {
                        return "Motion Recorded"
                    },
                    na: function(e) {
                        return "N/A"
                    },
                    never: function(e) {
                        return "never"
                    },
                    noActiveStreams: function(e) {
                        return "No active streams"
                    },
                    noDataFroTimeRange: function(e) {
                        return "There is no stream data for the selected time range."
                    },
                    noEventsForTimeRange: function(e) {
                        return "There are no events in the selected time range."
                    },
                    ofUnusableSpace: function(e) {
                        return e.VALUE + " of unusable space"
                    },
                    ofVideoData: function(e) {
                        return e.VALUE + " of video data"
                    },
                    preview: function(e) {
                        return "Preview"
                    },
                    primaryStream: function(e) {
                        return "Primary Stream"
                    },
                    primaryStreamStatus: function(e) {
                        return "Primary Stream Status"
                    },
                    reportFrom: function(e) {
                        return "Report From"
                    },
                    reportTo: function(e) {
                        return "Report To"
                    },
                    restart: function(e) {
                        return "Restart"
                    },
                    serverEvents: function(e) {
                        return "Server Events"
                    },
                    specifyRange: function(e) {
                        return "Specify Range"
                    },
                    status: function(e) {
                        return "Status"
                    },
                    streamStats: function(e) {
                        return "Stream Statistics"
                    },
                    text: function(e) {
                        return "text"
                    },
                    timeRangeErrorSystemReport: function(e) {
                        return 'Invalid time selection.  "From" time must be before "To" time.'
                    },
                    timeSelection: function(e) {
                        return "Time Selection"
                    },
                    to: function(e) {
                        return "To:"
                    },
                    unknownCameraStream: function(e) {
                        return "unknown camera/stream"
                    },
                    verifiedCameraWasReached: function(e) {
                        return "Verified: the camera was reached successfully"
                    },
                    verify: function(e) {
                        return "Verify"
                    },
                    verifyCameraVALUE: function(e) {
                        return "Verify " + e.VALUE
                    },
                    verifyingCameraVALUE: function(e) {
                        return "Verifying " + e.VALUE + " . . ."
                    },
                    videoBitrate: function(e) {
                        return "Video Bitrate"
                    },
                    videoRecorded: function(e) {
                        return "Video Recorded"
                    },
                    what: function(e) {
                        return "What"
                    },
                    when: function(e) {
                        return "When"
                    },
                    where: function(e) {
                        return "Where"
                    }
                },
                timeUnitsPlural: {
                    day: function(e) {
                        return n(e.VALUE, 0, t, {
                            1: "day",
                            other: "days"
                        })
                    },
                    hour: function(e) {
                        return n(e.VALUE, 0, t, {
                            1: "hour",
                            other: "hours"
                        })
                    },
                    minute: function(e) {
                        return n(e.VALUE, 0, t, {
                            1: "minute",
                            other: "minutes"
                        })
                    },
                    second: function(e) {
                        return n(e.VALUE, 0, t, {
                            1: "second",
                            other: "seconds"
                        })
                    }
                },
                userManager: {
                    aLiveViewerCan: function(e) {
                        return "A <em>Live Viewer</em> can only stream live video."
                    },
                    aViewerCan: function(e) {
                        return "A <em>Viewer</em> can stream live video and review archived video."
                    },
                    aManagerCan: function(e) {
                        return "A <em>Manager</em> can do everything a Viewer can do. They can also view system reports, export archive footage, control PTZ cameras, and talk down."
                    },
                    anAdministratorCan: function(e) {
                        return "An <em>Administrator</em> can do everything a Manager can do. They can also configure cameras, manage user accounts, and manage Orchid Hybrid VMS licensing."
                    },
                    action: function(e) {
                        return "Action"
                    },
                    addUser: function(e) {
                        return "Add User"
                    },
                    addUserTo: function(e) {
                        return "Add user to " + e.VALUE
                    },
                    administrator: function(e) {
                        return "Administrator"
                    },
                    administratorCan: function(e) {
                        return "can do everything a Manager can do. They can also configure cameras, manage user accounts, and manage Orchid Hybrid VMS licensing."
                    },
                    alsoCreateNewUsers: function(e) {
                        return "Also create new users"
                    },
                    anErrorOccurredWhileDeleteUser: function(e) {
                        return "An error occurred while attempting to delete the user"
                    },
                    anErrorOccurredWhileProcessingBulkDelete: function(e) {
                        return "An error occurred while processing bulk delete."
                    },
                    cancel: function(e) {
                        return "Cancel"
                    },
                    connectionAborted: function(e) {
                        return "Connection aborted."
                    },
                    createOnAllServers: function(e) {
                        return "Create on all Orchid Recorder servers"
                    },
                    deleteUser: function(e) {
                        return "Delete User"
                    },
                    deleteUserOnAllServers: function(e) {
                        return "Delete user on all Orchid Recorder servers"
                    },
                    deleteWhichUser: function(e) {
                        return 'Delete user "' + e.VALUE + '"?'
                    },
                    existingUserDetails: function(e) {
                        return "Existing User Details"
                    },
                    failedToDeleteUser: function(e) {
                        return 'Failed to delete user "' + e.VALUE + '"'
                    },
                    failedToLoadUsers: function(e) {
                        return "Failed to load users"
                    },
                    failedToUpdateUserThisUserNoLongerExists: function(e) {
                        return "Failed to update user: This user no longer exists"
                    },
                    liveViewer: function(e) {
                        return "Live Viewer"
                    },
                    loadingUsers: function(e) {
                        return "Loading Users..."
                    },
                    lookingForUsers: function(e) {
                        return "Looking for Orchid Recorder Users?"
                    },
                    manager: function(e) {
                        return "Manager"
                    },
                    newUserFor: function(e) {
                        return "New User for " + e.VALUE
                    },
                    newUserForShort: function(e) {
                        return "New User"
                    },
                    noActionCannotQueryServer: function(e) {
                        return "No action: Cannot query server"
                    },
                    noActionUserDoesNotExist: function(e) {
                        return "No action: User does not exist"
                    },
                    noticeEditingOwnAccount: function(e) {
                        return "Notice: You are editing your own account and will be logged out automatically on update."
                    },
                    password: function(e) {
                        return "Password"
                    },
                    theFollowingChangesApplied: function(e) {
                        return "The following changes will be applied:"
                    },
                    providingAnEmailAddressAssociatedToAGoogleAccountWillAllowThisUserToLoginUsingGoogleSignIn: function(e) {
                        return "Providing an email address associated to a Google account will allow this user to login using Google Sign-In"
                    },
                    removalStrategyFor: function(e) {
                        return "Removal Strategy for " + e.VALUE
                    },
                    replicationStrategyFor: function(e) {
                        return "Replication Strategy for " + e.VALUE
                    },
                    replicateChangesOnAllServers: function(e) {
                        return "Replicate changes across all Orchid Recorder servers"
                    },
                    replicateThisChangeAcrossAllServers: function(e) {
                        return "Replicate this change across all Orchid Recorder servers"
                    },
                    replicateUser: function(e) {
                        return "Replicate User"
                    },
                    role: function(e) {
                        return "Role"
                    },
                    server: function(e) {
                        return "Server"
                    },
                    servers: function(e) {
                        return "Servers"
                    },
                    superuser: function(e) {
                        return "superuser"
                    },
                    theFollowingUsersWillBeRemoved: function(e) {
                        return "The following users will be removed:"
                    },
                    thisDefaultAccountHasAdmin: function(e) {
                        return "This default account has all administrator privileges and cannot be downgraded, deleted, or renamed."
                    },
                    thisSuperuserAccountHas: function(e) {
                        return "This default account has all administrator privileges and cannot be downgraded, deleted, or renamed."
                    },
                    unableToConnedToServer: function(e) {
                        return "Unable to connect to " + e.SERVER
                    },
                    updateUser: function(e) {
                        return "Update User"
                    },
                    userRoles: function(e) {
                        return "Orchid Recorder Roles"
                    },
                    userWithSameNameExists: function(e) {
                        return "A user already exists with name"
                    },
                    userWillBeRemoved: function(e) {
                        return "User will be removed"
                    },
                    userWillBeUpdated: function(e) {
                        return "User will be updated"
                    },
                    userWillBeAdded: function(e) {
                        return "User will be added"
                    },
                    usernameFrom: function(e) {
                        return e.USERNAME + " from " + e.FROM
                    },
                    usersHaveMovedToTabOn: function(e) {
                        return "Orchid Recorder users have been moved to a tab on"
                    },
                    viewer: function(e) {
                        return "Viewer"
                    },
                    viewerCan: function(e) {
                        return "can stream live video and review archived video."
                    },
                    whatisRequired: function(e) {
                        return e.VALUE + " is required"
                    },
                    add: function(e) {
                        return "Add"
                    },
                    anUnexpectedErrorHasOccurred: function(e) {
                        return "An unexpected error has occurred."
                    },
                    groups: function(e) {
                        return "Groups"
                    },
                    newUserForApp: function(e) {
                        return "New User for Orchid Hybrid VMS"
                    },
                    searchForAGroup: function(e) {
                        return "Search for a Group"
                    },
                    update: function(e) {
                        return "Update"
                    },
                    user: function(e) {
                        return "User"
                    },
                    userNameFromApp: function(e) {
                        return e.VALUE + " from Orchid Hybrid VMS"
                    },
                    usersRange: function(e) {
                        return "Users " + e.RANGE + " of " + e.LENGTH
                    },
                    noUsersExist: function(e) {
                        return "No Users exist."
                    },
                    noUsersMatchSearch: function(e) {
                        return "Your search didn't match any Users"
                    }
                },
                utilityService: {
                    noStreamsConfigures: function(e) {
                        return "No streams configured"
                    },
                    audio: function(e) {
                        return "Audio"
                    },
                    genericRtsp: function(e) {
                        return "Generic RTSP"
                    },
                    fps: function(e) {
                        return "fps"
                    },
                    ptz: function(e) {
                        return "PTZ"
                    }
                },
                versionInfo: {
                    apiManual: function(e) {
                        return "API Manual"
                    },
                    buildInfo: function(e) {
                        return "Build Information"
                    },
                    changeLog: function(e) {
                        return "ChangeLog"
                    },
                    client: function(e) {
                        return "Client"
                    },
                    devDocs: function(e) {
                        return "Developer Documentation"
                    },
                    eula: function(e) {
                        return "End-User License Agreement"
                    },
                    failedToLoadVersionInfo: function(e) {
                        return "Failed to load Version Information"
                    },
                    knowledgeBase: function(e) {
                        return "Knowledge Base"
                    },
                    loadingVersionInformation: function(e) {
                        return "Loading Version Information"
                    },
                    openSourceAcks: function(e) {
                        return "Open Source Acknowledgements"
                    },
                    resources: function(e) {
                        return "Resources"
                    },
                    targetArch: function(e) {
                        return "Target Architecture"
                    },
                    unableToLoadChangeLog: function(e) {
                        return "Unable to load change log."
                    },
                    updateClient: function(e) {
                        return "Update Client"
                    },
                    userManuals: function(e) {
                        return "User Manuals"
                    },
                    userTraining: function(e) {
                        return "User Training"
                    },
                    version: function(e) {
                        return "Version"
                    },
                    versionInfo: function(e) {
                        return "Version Information"
                    }
                }
            }
        }
        ,
        77171: (e, t, n) => {
            var i = {
                "./de": 59740,
                "./de.js": 59740,
                "./es": 55655,
                "./es.js": 55655,
                "./fr": 94470,
                "./fr.js": 94470,
                "./it": 90626,
                "./it.js": 90626,
                "./nl": 93901,
                "./nl.js": 93901,
                "./pt": 89520,
                "./pt.js": 89520
            };
            function a(e) {
                var t = r(e);
                return n(t)
            }
            function r(e) {
                if (!n.o(i, e)) {
                    var t = new Error("Cannot find module '" + e + "'");
                    throw t.code = "MODULE_NOT_FOUND",
                    t
                }
                return i[e]
            }
            a.keys = function() {
                return Object.keys(i)
            }
            ,
            a.resolve = r,
            e.exports = a,
            a.id = 77171
        }
        ,
        84715: (e, t, n) => {
            "use strict";
            n(6037),
            n(28660);
            var i = n(13822)
              , a = n(83868)
              , r = n(32508)
              , s = n(66695)
              , o = n.n(s)
              , c = n(70655)
              , l = n(53533)
              , d = n(36867)
              , u = n(50194)
              , m = n(39443)
              , h = n(57776)
              , p = n(91902)
              , g = n(67445)
              , f = (n(87828),
            n(23234),
            n(89672),
            n(84590),
            n(58953),
            n(75520),
            n(63558),
            n(48963),
            n(56536),
            n(96336),
            n(67131),
            n(74096),
            n(65736),
            n(15078))
              , v = n(22539)
              , y = n.n(v);
            angular.module("ipconfigure.orchid.singularity", ["md.data.table", "ngMaterial", "ngMessages", "ngPassword", "ngStorage", "ngSanitize", "PubSub", "scDateTime", "rzModule", "ui.bootstrap", "angular-uuid"]).config(["$mdGestureProvider", "$mdAriaProvider", "$animateProvider", "$compileProvider", "$httpProvider", function(e, t, n, i, a) {
                e.skipClickHijack(),
                i.preAssignBindingsEnabled(!0),
                t.disableWarnings(),
                n.classNameFilter(/^((?!(fa-spinner)).)*$/),
                a.interceptors.push("HttpResponseErrorHandler"),
                a.interceptors.push("PreflightService"),
                a.useApplyAsync(!0)
            }
            ]).run(["$rootScope", "$interval", "$timeout", "DataService", "AuthenticationService", "FusionConfigService", function(e, t, n, i, a, r) {
                var s = Object.getPrototypeOf(e);
                s.$smartInterval = function(e, n, i) {
                    var a = t(e, n, 0, i);
                    return this.$on("$destroy", (function() {
                        t.cancel(a)
                    }
                    )),
                    a
                }
                ,
                s.$smartTimeout = function(e, t, i) {
                    var a = n(e, t, i);
                    return this.$on("$destroy", (function() {
                        n.cancel(a)
                    }
                    )),
                    a
                }
                ,
                s.$smartAddEventListener = function(e, t, n, i) {
                    i = i || {},
                    e.addEventListener(t, n, i.add),
                    this.$on("$destroy", (function() {
                        e.removeEventListener(t, n, i.remove)
                    }
                    ))
                }
                ,
                s.$smartOn = function(e, t, n) {
                    var i = e.on(t, n);
                    return this.$on("$destroy", (function() {
                        e.off(i, n)
                    }
                    )),
                    i
                }
                ,
                angular.element(document).ready((function() {
                    e.$digest()
                }
                ))
            }
            ]);
            var b = n(43144)
              , S = n(15671);
            const C = {
                isOrchid: (!0,
                !1),
                fusionDestroyed: !1,
                brand: "hybrid".toUpperCase(),
                isPWA: (e => {
                    let t;
                    try {
                        t = new URL(e)
                    } catch (e) {
                        return !1
                    }
                    return "https:" === t.protocol
                }
                )(window.localStorage["api.url"]),
                license: "hybrid",
                get baseUrl() {
                    return this.isPWA ? window.localStorage["api.url"] : `${window.location.protocol}//${window.location.hostname}${window.location.port ? ":" + window.location.port : ""}`
                },
                get secondsPlaybackFromLive() {
                    return 5
                },
                get singlePlayerMode() {
                    const e = new URLSearchParams(window.location.hash)
                      , t = new URLSearchParams(window.location.search);
                    return e.has("single-player") || t.has("single-player")
                },
                get isCustomLicense() {
                    return "orchid" !== this.license && "fusion" !== this.license && "hybrid" !== this.license && "alto" !== this.license
                }
            }
              , w = C;
            let I = (0,
            b.Z)((function e(t) {
                if ((0,
                S.Z)(this, e),
                t.has("$authProvider")) {
                    let e = t.get("$authProvider");
                    e.httpInterceptor = function() {
                        return !1
                    }
                    ,
                    e.tokenName = "token",
                    e.tokenPrefix = "fusion",
                    e.oauth2({
                        name: "azure",
                        optionalUrlParams: ["prompt"],
                        clientId: "uninitialized",
                        url: w.baseUrl + "/service/sessions/login/azure",
                        authorizationEndpoint: "uninitialized",
                        redirectUri: window.location.origin + "/redirect.html",
                        requiredUrlParams: ["scope"],
                        scope: ["user.read"],
                        scopeDelimiter: " ",
                        prompt: "select_account"
                    }),
                    e.google({
                        name: "google.oauth",
                        optionalUrlParams: ["prompt"],
                        clientId: "uninitialized",
                        url: w.baseUrl + "/service/sessions/login/google/oauth",
                        authorizationEndpoint: "https://accounts.google.com/o/oauth2/auth",
                        redirectUri: window.location.origin + "/redirect.html",
                        requiredUrlParams: ["scope"],
                        scope: ["profile", "email"],
                        scopePrefix: "openid",
                        scopeDelimiter: " ",
                        prompt: "select_account",
                        oauthType: "2.0"
                    })
                }
            }
            ));
            I.$inject = ["$injector"],
            angular.module("ipconfigure.orchid.singularity").config(["$injector", function(e) {
                return new I(e)
            }
            ]);
            var T = n(11752)
              , E = n(61120)
              , _ = n(79340)
              , x = n(14876);
            n(22966);
            let D = y();
            try {
                y()("dummy")
            } catch (e) {
                D = function(e) {
                    return function(t, n) {
                        const i = `${e}: ${n}`
                          , a = console[t];
                        if (a)
                            return a.call(console, i)
                    }
                }
            }
            const O = D;
            n(74916),
            n(15306);
            var A = n(80008)
              , R = n.n(A)
              , P = n(86515)
              , k = n(60544);
            const M = O("Localization.service");
            const L = new class {
                constructor() {
                    this._locale = new P.X("en"),
                    this.locale$ = this._locale.asObservable(),
                    this._messages = new P.X(k.messages),
                    this.messages$ = this._messages.asObservable(),
                    this._formats = new P.X(k.formats),
                    this.formats$ = this._formats.asObservable()
                }
                get messages() {
                    return this._messages.getValue()
                }
                get formats() {
                    return this._formats.getValue()
                }
                get locale() {
                    return this._locale.getValue()
                }
                setLocale(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        return M.info(`Setting locale to ${e}`),
                        yield n(44582)(`./${e}/${e}.module`).then((t => {
                            M.info(`Received module for ${e}`),
                            this._locale.next(e),
                            this._messages.next(t.messages),
                            this._formats.next(t.formats)
                        }
                        )).catch((t => {
                            M.error(`An error occurred while fetching locale: ${e}`, t)
                        }
                        ))
                    }
                    ))
                }
            }
            ;
            function N(e) {
                var t, n, i, a;
                return null !== (n = null === (t = e.features) || void 0 === t ? void 0 : t.ptz) && void 0 !== n ? n : null === (a = null === (i = e.capabilities) || void 0 === i ? void 0 : i.camera) || void 0 === a ? void 0 : a.PTZ
            }
            function F(e) {
                const t = N(e);
                return !!t && ("true" === t.pan || "true" === t.tilt || "true" === t.zoom)
            }
            var U, $, j, V, G, B, z, H, W, q, Y, X, K, Z, J, Q;
            function ee(e) {
                let t = "";
                if (e.driver === Q.ONVIF) {
                    if (se(e.primaryStream))
                        return L.messages.utilityService.noStreamsConfigures();
                    e.primaryStream.configuration && (t = e.primaryStream.configuration.Video.Resolution + ", " + e.primaryStream.configuration.Video.FrameRate + L.messages.utilityService.fps() + ", " + e.primaryStream.configuration.Video.Encoder,
                    "none" !== e.primaryStream.configuration.Audio.Encoder && (t += ", " + e.primaryStream.configuration.Audio.Encoder + " " + L.messages.utilityService.audio())),
                    F(e) && (t += ", " + L.messages.utilityService.ptz())
                } else
                    t = L.messages.utilityService.genericRtsp();
                return t
            }
            function te(e) {
                var t = {};
                if ("object" != typeof e || null === e)
                    return null;
                if (!ae(e.defaultMode, ["perspective", "panorama", "warped"]))
                    return null;
                if (t.defaultMode = e.defaultMode,
                "object" != typeof e.defaultPerspectiveView || null === e.defaultPerspectiveView)
                    return null;
                var n = {
                    pan: parseFloat(e.defaultPerspectiveView.pan),
                    tilt: parseFloat(e.defaultPerspectiveView.tilt),
                    zoom: parseFloat(e.defaultPerspectiveView.zoom)
                };
                return isNaN(n.pan) || isNaN(n.tilt) || isNaN(n.zoom) ? null : (t.defaultPerspectiveView = n,
                t.enable = ie(e.enable),
                null === t.enable ? null : ae(e.orientation, ["ceiling", "floor", "wall", "wall-flipped"]) ? (t.orientation = e.orientation,
                t.panoramaAspectRatio = parseFloat(e.panoramaAspectRatio),
                isNaN(t.panoramaAspectRatio) ? null : (t.panoramaShift = parseFloat(e.panoramaShift),
                isNaN(t.panoramaShift) ? null : (t.perspectiveDepth = parseFloat(e.perspectiveDepth),
                isNaN(t.perspectiveDepth) ? null : t))) : null)
            }
            function ne(e) {
                return re(e) || "" === e
            }
            function ie(e) {
                return "boolean" == typeof e ? e : "string" == typeof e ? "true" === e : null
            }
            function ae(e, t) {
                return !("string" != typeof e || !Array.isArray(t) || -1 === t.indexOf(e))
            }
            function re(e) {
                return null == e
            }
            function se(e) {
                return re(e) || 0 === Object.keys(e).length
            }
            function oe() {
                let e, t;
                return {
                    promise: new Promise((function(n, i) {
                        e = n,
                        t = i
                    }
                    )),
                    resolve: e,
                    reject: t
                }
            }
            function ce(e) {
                return "string" == typeof e || e instanceof String
            }
            function le(e) {
                if (re(e) || "object" != typeof e || "number" != typeof e.major || "number" != typeof e.minor || "string" != typeof e.patch || "boolean" != typeof e.parsed)
                    throw new Error("Invalid SemverInfo object")
            }
            function de() {}
            !function(e) {
                e.STATIC = "static",
                e.TILE = "tile"
            }(U || (U = {})),
            function(e) {
                e.OSM = "OSM",
                e.BING = "BING",
                e.XYZ = "XYZ"
            }($ || ($ = {})),
            function(e) {
                e.CHIP = "chip",
                e.SMALL = "small",
                e.LARGE = "large"
            }(j || (j = {})),
            function(e) {
                e.NORMAL = "normal",
                e.DEGRADED = "degraded",
                e.PENDING_CHANGE = "pending_change"
            }(V || (V = {})),
            function(e) {
                e.JSON = "application/json",
                e.CSV = "text/csv"
            }(G || (G = {})),
            function(e) {
                e.SUCCESS = "SUCCESS",
                e.PENDING = "PENDING",
                e.CANCELED = "CANCELED",
                e.FAILED = "FAILED"
            }(B || (B = {})),
            function(e) {
                e.IDLE = "IDLE",
                e.PROCESSING = "PROCESSING",
                e.PENDING_CANCEL = "PENDING_CANCEL",
                e.PENDING_RETRY = "PENDING_RETRY",
                e.SUCCESS = "SUCCESS"
            }(z || (z = {})),
            function(e) {
                e.EMAIL_ACTION = "email",
                e.EMAIL_DIGEST_ACTION = "email_digest",
                e.MOTION_ALERT_EMAIL_ACTION = "motion_alert_email"
            }(H || (H = {})),
            function(e) {
                e.CAMERA_STATE_CONDITION = "camera_state",
                e.DEVICE_STATE_CONDITION = "device_state",
                e.IO_ERROR_CONDITION = "io_error",
                e.SERVER_ERROR_CONDITION = "server_error",
                e.MOTION_ALERT_CONDITION = "motion_event"
            }(W || (W = {})),
            function(e) {
                e.IPC_UNKNOWN = "IPC_UNKNOWN",
                e.IPC_FAILOVER_FAIL = "IPC_FAILOVER_FAIL",
                e.IPC_MOTION_EVENT = "IPC_MOTION_EVENT",
                e.IPC_STREAM_IDLE = "IPC_STREAM_IDLE",
                e.IPC_STREAM_STARTING = "IPC_STREAM_STARTING",
                e.IPC_STREAM_STOPPING = "IPC_STREAM_STOPPING",
                e.IPC_STREAM_RUNNING = "IPC_STREAM_RUNNING",
                e.IPC_STREAM_ERROR = "IPC_STREAM_ERROR"
            }(q || (q = {})),
            function(e) {
                e.REMOVE = "remove",
                e.CREATE = "create",
                e.UPDATE = "update",
                e.EXPORT = "export",
                e.VIEW = "view",
                e.TALK = "talk"
            }(Y || (Y = {})),
            function(e) {
                e.ARCHIVE = "archive",
                e.CAMERA = "camera",
                e.STREAM = "stream",
                e.USER = "user",
                e.SMART_SEARCH = "smart-search",
                e.EVENT = "metadata-event",
                e.EVENT_SUBSCRIPTION = "metadata-event-subscription",
                e.LICENSE = "license",
                e.PROPERTIES = "properties",
                e.SERVER = "server",
                e.SESSION = "session",
                e.TRUSTED_ISSUER = "trusted-issuer",
                e.LOG = "log",
                e.UI = "ui"
            }(X || (X = {})),
            function(e) {
                e.USER_SESSION = "user-session",
                e.REMOTE_SESSION = "remote-session",
                e.BASIC = "basic",
                e.JWT = "jwt"
            }(K || (K = {})),
            function(e) {
                e.REMOTE = "remote",
                e.LOCAL = "local"
            }(Z || (Z = {})),
            function(e) {
                e.FUSION = "fusion",
                e.GOOGLE_SIGN_IN = "google.sign.in",
                e.GOOGLE_OAUTH = "google.oauth",
                e.ACTIVE_DIRECTORY = "active.directory",
                e.FREEIPA = "freeipa",
                e.AZURE_ACTIVE_DIRECTORY = "azure.active.directory",
                e.SAML = "saml"
            }(J || (J = {})),
            function(e) {
                e.ONVIF = "ONVIF",
                e.RTSP = "Generic RTSP"
            }(Q || (Q = {}));
            let ue = function() {
                function e() {
                    (0,
                    S.Z)(this, e)
                }
                return (0,
                b.Z)(e, null, [{
                    key: "isSet",
                    value: function(e, t) {
                        if (re(e))
                            throw new Error(`Required variable "${t}" is undefined or null`)
                    }
                }, {
                    key: "isValidEnum",
                    value: function(e, t) {
                        if (!ae(e, t))
                            throw new Error(`The enumeration [${t.join(",")}] does not contain "${e}"`)
                    }
                }, {
                    key: "isTrue",
                    value: function(e, t) {
                        if (!1 === e)
                            throw new Error(t)
                    }
                }]),
                e
            }();
            n(33948),
            n(41637),
            n(17727);
            const me = "oauth"
              , he = "form"
              , pe = "token"
              , ge = "jwt"
              , fe = "sid"
              , ve = "fsid";
            class ye {
                constructor(e, t) {
                    this.type = e,
                    this.data = t,
                    e === pe && ue.isValidEnum(t.tokenType, [ge, fe, ve])
                }
            }
            const be = O("TokenListener");
            let Se = function() {
                function e() {
                    (0,
                    S.Z)(this, e),
                    this._handleMessage = this._handleMessage.bind(this)
                }
                return (0,
                b.Z)(e, [{
                    key: "listen",
                    value: function() {
                        var e = this;
                        let t = new Promise((function(t, n) {
                            e.authenticationResolve = t,
                            e._authenticationReject = n
                        }
                        ));
                        return window.addEventListener("message", this._handleMessage),
                        this.timeout = setTimeout((function() {
                            clearTimeout(e.timeout),
                            e._authenticationReject({
                                reason: "no-authorization-received"
                            })
                        }
                        ), 3e4),
                        be("info", "App: awaiting an authorization token for singlePlayer mode"),
                        window.parent.postMessage({
                            event: {
                                component: "app",
                                type: "awaiting-auth"
                            },
                            origin: window.location.href
                        }, "*"),
                        t
                    }
                }, {
                    key: "_handleMessage",
                    value: function(e) {
                        if (void 0 !== e && void 0 !== e.data) {
                            if (void 0 !== e.data.jwt)
                                this.authenticationResolve(new ye(pe,{
                                    tokenType: ge,
                                    token: e.data.jwt
                                }));
                            else if (void 0 !== e.data.sid) {
                                const t = w.isOrchid ? fe : ve;
                                this.authenticationResolve(new ye(pe,{
                                    tokenType: t,
                                    token: e.data.sid
                                }))
                            }
                            clearTimeout(this.timeout)
                        }
                    }
                }]),
                e
            }();
            const Ce = O("Authenticator")
              , we = "persistent"
              , Ie = "session"
              , Te = "popup_closed_by_user"
              , Ee = 2592e3;
            let _e = (0,
            b.Z)((function e(t, n, i, a) {
                (0,
                S.Z)(this, e),
                this.username = t,
                this.password = n,
                this.cookie = i,
                this.expiresIn = a
            }
            ))
              , xe = function() {
                function e() {
                    (0,
                    S.Z)(this, e),
                    this._authenticationData = void 0,
                    this._authenticationProviders = [],
                    !1 === re(new URLSearchParams(window.location.search).get("single-player")) && (this._isAuthenticatedPromise = (new Se).listen().then(this.authenticate.bind(this)))
                }
                return (0,
                b.Z)(e, [{
                    key: "authenticate",
                    value: function(e) {
                        throw new Error("NOT IMPLEMENTED!!!")
                    }
                }, {
                    key: "deauthenticate",
                    value: function() {
                        return delete this._authenticationData,
                        Promise.resolve()
                    }
                }, {
                    key: "getAuthenticationData",
                    value: function() {
                        if (void 0 === this._authenticationData)
                            throw new Error("AuthenticationData is missing");
                        return this._authenticationData
                    }
                }, {
                    key: "getAuthenticationProviders",
                    value: function() {
                        return this._authenticationProviders
                    }
                }, {
                    key: "init",
                    value: function(e) {
                        throw new Error("NOT IMPLEMENTED!!!")
                    }
                }, {
                    key: "isAuthenticated",
                    value: function() {
                        return void 0 !== this._authenticationData
                    }
                }, {
                    key: "getAuthenticationDataPromise",
                    value: function() {
                        var e = this;
                        let t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        return this._authenticationData && !1 === t ? Promise.resolve(this._authenticationData) : this._isAuthenticatedPromise ? this._isAuthenticatedPromise.then((function() {
                            return e.getAuthenticationData()
                        }
                        )) : this._checkAuthentication().then((function() {
                            return e.getAuthenticationData()
                        }
                        ))
                    }
                }, {
                    key: "_checkAuthentication",
                    value: function() {
                        var e = this;
                        return void 0 === this._checkAuthPromise && (this._checkAuthPromise = this._api.me().then(this._successfulLogin.bind(this)).finally((function() {
                            delete e._checkAuthPromise
                        }
                        ))),
                        this._checkAuthPromise
                    }
                }, {
                    key: "_failedLogin",
                    value: function(e) {
                        throw Ce("error", "Failed login", e),
                        void 0 !== e.error ? {
                            reason: e.error
                        } : void 0 !== e.message ? {
                            reason: e.message
                        } : e.data
                    }
                }]),
                e
            }();
            var De, Oe, Ae, Re, Pe, ke, Me, Le;
            n(26699);
            !function(e) {
                e.AZURE = "azure.active.directory",
                e.FUSION = "fusion",
                e.FREEIPA = "freeipa",
                e.ACTIVE_DIRECTORY = "active.directory",
                e.GOOGLE_OAUTH = "google.oauth",
                e.SAML = "saml"
            }(De || (De = {})),
            function(e) {
                e.ADMINISTRATOR = "administrator",
                e.MANAGER = "manager",
                e.VIEWER = "viewer",
                e.LIVE_VIEWER = "live viewer"
            }(Oe || (Oe = {})),
            function(e) {
                e.ADMINISTRATOR = "administrator",
                e.VIEWER = "viewer",
                e.LIVE_VIEWER = "live viewer"
            }(Ae || (Ae = {})),
            function(e) {
                e.REGISTER_ORCHID = "REGISTER_ORCHID",
                e.MANAGE_ORCHID = "MANAGE_ORCHID"
            }(Re || (Re = {})),
            function(e) {
                e.ALL = "all",
                e.SELECTION = "selection"
            }(Pe || (Pe = {})),
            function(e) {
                e.NONE = "none",
                e.ADMIN = "admin",
                e.RECORDER_ADMIN = "subadmin"
            }(ke || (ke = {})),
            function(e) {
                e.GRANTED = "granted",
                e.REVOKED = "revoked",
                e.READONLY = "readOnly",
                e.EDITING = "editing",
                e.COMPLETED = "completed"
            }(Me || (Me = {})),
            function(e) {
                e.CANCEL = "cancel",
                e.NEW = "new",
                e.EDIT = "edit",
                e.DELETE = "delete"
            }(Le || (Le = {}));
            let Ne = function() {
                function e(t, n, i, a, r) {
                    (0,
                    S.Z)(this, e),
                    this.sessionId = t,
                    this.token = a,
                    this.tokenType = r,
                    this.userId = n,
                    this.username = i
                }
                return (0,
                b.Z)(e, [{
                    key: "isAdministrator",
                    value: function() {
                        throw new Error("NOT IMPLEMENTED!!!")
                    }
                }, {
                    key: "getRole",
                    value: function() {
                        throw new Error("NOT IMPLEMENTED!!!")
                    }
                }]),
                e
            }()
              , Fe = function(e) {
                (0,
                _.Z)(n, e);
                var t = (0,
                x.Z)(n);
                function n(e) {
                    var i;
                    return (0,
                    S.Z)(this, n),
                    (i = t.call(this, e.sessionId, e.id, e.username, e.token, e.tokenType))._abilities = e.abilities,
                    i._admin = e.admin,
                    i.email = e.emailAddress,
                    i.source = e.identity.authProvider,
                    i._libraryAccess = e.libraryAccess || e.admin,
                    i._canManageAllRecorders = e.manageAllOrchids,
                    i
                }
                return (0,
                b.Z)(n, [{
                    key: "isAdministrator",
                    value: function() {
                        return this._admin
                    }
                }, {
                    key: "hasUserAbility",
                    value: function(e) {
                        return !!this._abilities && this._abilities.includes(e)
                    }
                }, {
                    key: "isRecorderAdministrator",
                    value: function() {
                        return !this._admin && this.hasUserAbility(Re.MANAGE_ORCHID)
                    }
                }, {
                    key: "isRecorderRegistrar",
                    value: function() {
                        return !this._admin && this.hasUserAbility(Re.REGISTER_ORCHID)
                    }
                }, {
                    key: "canManageAllRecorders",
                    value: function() {
                        return this._canManageAllRecorders
                    }
                }, {
                    key: "getRole",
                    value: function() {
                        return ""
                    }
                }, {
                    key: "hasLibraryAccess",
                    value: function() {
                        return this._libraryAccess
                    }
                }, {
                    key: "canChangePassword",
                    value: function() {
                        return this.source === De.FUSION || this.source === De.GOOGLE_OAUTH
                    }
                }]),
                n
            }(Ne);
            const Ue = O("FusionAuthenticator");
            let $e = function(e) {
                (0,
                _.Z)(n, e);
                var t = (0,
                x.Z)(n);
                function n(e, i, a, r) {
                    var s;
                    return (0,
                    S.Z)(this, n),
                    (s = t.call(this))._api = a,
                    s._SatellizerConfig = i,
                    s._$auth = e,
                    s._sessionIdService = r,
                    s
                }
                return (0,
                b.Z)(n, [{
                    key: "authenticate",
                    value: function(e) {
                        switch (e.type) {
                        case he:
                            return this._authenticateFusion(e);
                        case me:
                            return this._authenticateOAuth(e);
                        case pe:
                            return this._authenticateToken(e);
                        default:
                            throw new Error(`The specified type of credentials ${e.constructor.name} is not supported`)
                        }
                    }
                }, {
                    key: "init",
                    value: function(e) {
                        var t = this;
                        this._authenticationProviders = [],
                        void 0 !== e && 0 !== e.length ? e.forEach((function(e) {
                            let n = e.configuration;
                            switch (e.type.toLowerCase()) {
                            case De.FUSION:
                            case De.ACTIVE_DIRECTORY:
                            case De.FREEIPA:
                            case De.SAML:
                                t._authenticationProviders.push(e);
                                break;
                            case De.GOOGLE_OAUTH:
                                t._SatellizerConfig.providers.google.clientId = n.clientId,
                                t._authenticationProviders.push(e);
                                break;
                            case De.AZURE:
                                t._SatellizerConfig.providers.azure.clientId = n.clientId,
                                t._SatellizerConfig.providers.azure.authorizationEndpoint = n.endpoint,
                                t._authenticationProviders.push(e)
                            }
                        }
                        )) : Ue("debug", "No authentication providers available")
                    }
                }, {
                    key: "_authenticateFusion",
                    value: function(e) {
                        Ue("debug", "authenticating");
                        let t = Ee
                          , n = e.data.rememberMe ? we : Ie;
                        w.isPWA && (t = 31536e3,
                        n = we);
                        let i = new _e(e.data.username,e.data.password,n,t);
                        return this._api.login(i).then(this._successfulLogin.bind(this)).catch(this._failedLogin.bind(this))
                    }
                }, {
                    key: "_authenticateOAuth",
                    value: function(e) {
                        return this._$auth.authenticate(e.data.provider, e.data.data).then((function(e) {
                            return e.data
                        }
                        )).then(this._successfulLogin.bind(this)).catch((function(e) {
                            throw "The popup window was closed" === e.message ? {
                                reason: Te
                            } : void 0 !== e.message ? {
                                reason: e.message
                            } : e
                        }
                        ))
                    }
                }, {
                    key: "_authenticateToken",
                    value: function(e) {
                        var t = this;
                        return ue.isTrue(ae(e.data.tokenType, [ge, ve]), `The specified type of token "${e.data.tokenType} is not supported`),
                        this._api.me(e.data.tokenType, e.data.token).then(this._successfulLogin.bind(this)).catch((function(e) {
                            return t._failedLogin(e)
                        }
                        ))
                    }
                }, {
                    key: "deauthenticate",
                    value: function() {
                        var e = this;
                        return (0,
                        T.Z)((0,
                        E.Z)(n.prototype), "deauthenticate", this).call(this).then((function() {
                            return e._api.logout()
                        }
                        ))
                    }
                }, {
                    key: "_successfulLogin",
                    value: function(e) {
                        ue.isSet(e, "authenticationData");
                        const t = new Fe(e);
                        return re(this._authenticationData) ? this._authenticationData = t : Object.assign(this._authenticationData, t),
                        this._sessionIdService.storeLocalSessionId(e.sessionId),
                        this._authenticationData
                    }
                }]),
                n
            }(xe);
            $e.$inject = ["$auth", "SatellizerConfig", "AuthenticationApi", "SessionIdService"];
            let je = function() {
                function e(t, n) {
                    (0,
                    S.Z)(this, e),
                    this._fusionBaseUrl = w.baseUrl + "/service",
                    this._$http = t,
                    this._sessionIdService = n,
                    this._sessionIdService.generateSessionIdKey(this._fusionBaseUrl, "fsid")
                }
                return (0,
                b.Z)(e, [{
                    key: "me",
                    value: function(e, t) {
                        var n = this;
                        if (e && t)
                            return ue.isValidEnum(e, [ge, ve]),
                            this._$http.get(this._fusionBaseUrl + `/sessions/me?${e}=${t}`).then((function(e) {
                                return e.data
                            }
                            ));
                        const i = {
                            withCredentials: !0
                        }
                          , a = this._sessionIdService.getLocalSessionId();
                        return void 0 !== a && (i.headers = {
                            Authorization: `Bearer ${a}`
                        }),
                        this._$http.get(this._fusionBaseUrl + "/sessions/me", i).catch((function() {
                            return n._sessionIdService.clearLocalSessionId()
                        }
                        )).then((function(e) {
                            return e.data
                        }
                        ))
                    }
                }, {
                    key: "login",
                    value: function(e) {
                        return this._$http.post(this._fusionBaseUrl + "/sessions/login", e, {
                            withCredentials: !0
                        }).then((function(e) {
                            return e.data
                        }
                        ))
                    }
                }, {
                    key: "logout",
                    value: function() {
                        return this._sessionIdService.clearLocalSessionId(),
                        this._$http.delete(this._fusionBaseUrl + "/sessions/me", {
                            withCredentials: !0
                        })
                    }
                }]),
                e
            }();
            function Ve(e, t) {
                function n() {
                    var t, n, i = e.navigator.userAgent || e.navigator.vendor || e.opera, a = "Unknown";
                    return -1 !== e.navigator.appVersion.indexOf("Win") ? a = "Windows" : -1 !== e.navigator.appVersion.indexOf("Mac") ? a = "MacOS" : -1 !== e.navigator.appVersion.indexOf("Android") ? a = "Android" : -1 !== e.navigator.appVersion.indexOf("Linux") && (a = "Linux"),
                    {
                        mobile: t = /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(i) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(i.substr(0, 4)),
                        tablet: n = /android|ipad|playbook|silk/i.test(i),
                        desktop: !t && !n,
                        operatingSystem: a
                    }
                }
                return {
                    getDevice: function() {
                        return n()
                    },
                    getBrowser: function() {
                        var t, i = e.navigator.userAgent, a = i.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [], r = n(), s = {
                            name: "",
                            version: "",
                            platform: navigator.platform,
                            isDesktop: r.desktop,
                            isMobile: r.mobile,
                            isTablet: r.tablet,
                            operatingSystem: r.operatingSystem
                        };
                        return /trident/i.test(a[0]) ? (t = /\brv[ :]+(\d+)/g.exec(i) || [],
                        s.name = "MSIE",
                        s.version = parseInt(t[1], 10) || 0) : "Chrome" === a[1] ? null !== (t = i.match(/\bOPR\/(\d+)/)) ? (s.name = "Opera",
                        s.version = parseInt(t[1], 10)) : (s.name = a[1],
                        s.version = parseInt(a[2], 10)) : (0 === a.length && "iPad" === navigator.platform && "Netscape" === navigator.appName && (a = ["Safari/7.0", "Safari", 7]),
                        a = a[2] ? [a[1], a[2]] : [navigator.appName, navigator.appVersion, "-?"],
                        null !== (t = i.match(/version\/(\d+)/i)) && a.splice(1, 1, t[1]),
                        s.name = a[0],
                        s.version = parseInt(a[1], 10)),
                        s
                    },
                    verifyBrowser: function(e) {
                        switch (e.name) {
                        case "Chrome":
                            return e.version >= 34 ? "" : "unsupported";
                        case "Firefox":
                            return e.version >= 33 ? "" : "unsupported";
                        case "MSIE":
                            return e.version >= 11 ? "" : "unsupported";
                        case "Opera":
                            return e.version >= 25 ? "" : "unsupported";
                        case "Safari":
                            return e.version >= 8 ? "" : "unsupported"
                        }
                        return "unknown"
                    },
                    browserSupportsWebSockets: function() {
                        return !(!angular.isDefined(e.WebSocket) || 2 !== e.WebSocket.CLOSING)
                    },
                    browserSupportsWebRTC: function(t) {
                        if ("enabled" === e.localStorage.webRTCSupportOverride)
                            return !0;
                        if (-1 !== e.navigator.userAgent.toLowerCase().indexOf("Edge"))
                            return !1;
                        return void 0 !== [{
                            name: "Chrome",
                            version: 66,
                            isDesktop: !0,
                            isMobile: !1
                        }, {
                            name: "Chrome",
                            version: 83,
                            isMobile: !0,
                            isDesktop: !1,
                            isTablet: !0
                        }, {
                            name: "Safari",
                            version: 13,
                            isMobile: !0,
                            isDesktop: !0,
                            isTablet: !0
                        }, {
                            name: "Firefox",
                            version: 80,
                            isDesktop: !0,
                            isMobile: !1
                        }].find((function(e) {
                            return e.name === t.name && e.version <= t.version && (e.isMobile && t.isMobile || e.isDesktop && t.isDesktop || e.isTablet && t.isTablet)
                        }
                        ))
                    },
                    cameraSupportsWebRTC: function(e) {
                        return !!e.primaryStream && (e.primaryStream && e.primaryStream.configuration && e.primaryStream.configuration.Video ? "H264" === e.primaryStream.configuration.Video.Encoder : void 0)
                    },
                    supportsLocalStorage() {
                        try {
                            window.localStorage.setItem("test", "value"),
                            window.localStorage.removeItem("test")
                        } catch (e) {
                            return !1
                        }
                        return !0
                    },
                    compareVersions: function(e, t) {
                        return function(e, t) {
                            if (void 0 === e)
                                return !1;
                            for (var n = e.split("."), i = t.split("."), a = 0; a < n.length; ++a)
                                if (n[a] < i[a])
                                    return !1;
                            return !0
                        }(e, t)
                    }
                }
            }
            function Ge(e, t) {
                const n = {
                    initialChecksPassed: !0,
                    evaluationFailed: !1,
                    value: null
                };
                if (re(t))
                    return n.initialChecksPassed = !1,
                    n;
                const i = t.trim();
                if (!i)
                    return n.initialChecksPassed = !1,
                    n;
                try {
                    return n.value = e.$eval(i),
                    n
                } catch (e) {
                    return n.evaluationFailed = !0,
                    n
                }
            }
            je.$inject = ["$http", "SessionIdService"],
            angular.module("ipconfigure.orchid.singularity").requires.push("satellizer"),
            angular.module("ipconfigure.orchid.singularity").service("AuthenticationService", ["$auth", "SatellizerConfig", "$http", "SessionIdService", function(e, t, n, i) {
                return new $e(e,t,new je(n,i),i)
            }
            ]),
            angular.module("ipconfigure.orchid.singularity").factory("PrerequisitesService", Ve),
            Ve.$inject = ["$window", "UtilityService"],
            angular.module("ipconfigure.orchid.singularity").directive("singAddTranslatedText", (function() {
                return {
                    restrict: "A",
                    scope: !1,
                    link(e, t, n) {
                        const i = Ge(e, n.singAddTranslatedText);
                        if (i.initialChecksPassed && !i.evaluationFailed && i.value)
                            t.html(i.value);
                        else {
                            let i, a = e.$watch(n.singAddTranslatedText, (function(e) {
                                e && (t.html(e),
                                a(),
                                a = null,
                                i && i(),
                                i = null)
                            }
                            ));
                            i = e.$on("$destroy", (function() {
                                i = null,
                                a && a(),
                                a = null
                            }
                            ))
                        }
                    }
                }
            }
            )).directive("singTranslatedMsg", (function() {
                return {
                    restrict: "A",
                    scope: !1,
                    compile(e, t) {
                        const n = t.singTranslatedMsg.split(".");
                        let i, a = L.messages;
                        for (let e = 0; e < n.length && !re(a); e++)
                            a = a[n[e]];
                        return "function" == typeof a && (i = a()),
                        function(e, t) {
                            re(i) || t.html(i)
                        }
                    }
                }
            }
            )).directive("singWatchTranslatedText", (function() {
                return {
                    restrict: "A",
                    scope: !1,
                    link(e, t, n) {
                        let i = e.$watch(n.singWatchTranslatedText, (function(e) {
                            e && t.html(e)
                        }
                        ))
                          , a = e.$on("$destroy", (function() {
                            i(),
                            i = null,
                            a(),
                            a = null
                        }
                        ))
                    }
                }
            }
            )).directive("singButton", (function() {
                return {
                    scope: !1,
                    template(e, t) {
                        const n = e.html().trim()
                          , i = !re(t.withSpinner);
                        let a = ""
                          , r = ""
                          , s = `${t.buttonClass || ""} sing-button`;
                        if (i) {
                            let e = "";
                            re(t.showSpinner) ? s = `${s} sing-button-showing-spinner` : (e = `ng-if="${t.showSpinner}"`,
                            r = `ng-class="{'sing-button-showing-spinner': ${t.showSpinner}}"`);
                            a = `<md-progress-circular ${e} ${`class="sing-button-spinner ${t.spinnerClass || ""}"`} ${`md-mode="indeterminate" md-diameter="${t.spinnerDiameter || "25px"}"`}></md-progress-circular>`
                        }
                        const o = re(t.buttonDisabled) ? "" : `ng-disabled="${t.buttonDisabled}"`;
                        return `<md-button class="action-button md-raised md-primary ${s}" ${r} ${`ng-click="${t.onClick}"`} ${o}>${n}${a}</md-button>`
                    }
                }
            }
            )).directive("singActionError", (function() {
                return {
                    scope: !1,
                    template(e, t) {
                        const n = !re(t.withIcon)
                          , i = re(t.clearError) ? "" : `ng-click="${t.clearError}"`;
                        return `<div ${`class="sing-action-error${n ? "-with-icon" : ""}"`} ${n ? "" : i}>${n ? `<i class="fa fa-times" ${i}>` : ""}${`<span class="text-danger sing-action-error-text">{{${t.actionError}}}</span>`}</div>`
                    }
                }
            }
            ));
            n(60285);
            var Be = n(19917)
              , ze = n(32817)
              , He = n(29127);
            const We = O("FeatureFlag.service");
            var qe;
            !function(e) {
                e.fetchOrchidsOmittingCapabilities = "fetch.orchids.omitting.capabilities",
                e.fetchOrchidsPaging1000 = "fetch.orchids.paging.1000"
            }(qe || (qe = {}));
            let Ye = class {
                constructor() {
                    this._features = new Map
                }
                setFeatures(e) {
                    We.info("Setting features", e),
                    e.forEach((e => {
                        const t = e.key
                          , n = {
                            isConfigured: !0,
                            key: e.key,
                            value: e.value
                        };
                        this._features.set(t, n)
                    }
                    ))
                }
                _getSproutFlag(e, t) {
                    var n;
                    return null === (n = t.discoverableOrchid.sprouts) || void 0 === n ? void 0 : n.find((t => t.key === e))
                }
                getFeatureConfiguration(e, t) {
                    var n;
                    if (We.info(`Checking for ${e} feature flag`),
                    t) {
                        const n = this._getSproutFlag(e, t);
                        return n ? {
                            isConfigured: !0,
                            key: n.key,
                            value: n.value
                        } : {
                            isConfigured: !1,
                            key: e,
                            value: void 0
                        }
                    }
                    return null !== (n = this._features.get(e)) && void 0 !== n ? n : {
                        isConfigured: !1,
                        key: e,
                        value: void 0
                    }
                }
                isFeatureEnabled(e, t) {
                    var n, i, a;
                    if (We.info(`Checking for ${e} feature flag`),
                    t) {
                        const i = this._getSproutFlag(e, t);
                        return "true" === (null === (n = null == i ? void 0 : i.value) || void 0 === n ? void 0 : n.trim().toLowerCase())
                    }
                    return "true" === (null === (a = null === (i = this._features.get(e)) || void 0 === i ? void 0 : i.value) || void 0 === a ? void 0 : a.trim().toLowerCase())
                }
            }
            ;
            function Xe(e, t, n, i) {
                return (0,
                c.mG)(this, void 0, void 0, (function*() {
                    const a = O("users")
                      , r = n;
                    let s = 0
                      , o = n
                      , c = 0
                      , l = [];
                    try {
                        for (; o >= r; ) {
                            s = c++ * r;
                            const n = `${t}/service/orchids?exclude=camera.streams,camera.capabilities&generateMissingSessionIds=false&limit=${r}&offset=${s}`
                              , a = `${t}/service/orchids?include=camera.capabilities&generateMissingSessionIds=false&limit=${r}&offset=${s}`
                              , [d,u] = yield Promise.all([e.get(n, {
                                withCredentials: !0
                            }).then((e => e.data)), i ? e.get(a, {
                                withCredentials: !0
                            }).then((e => e.data)) : Promise.resolve([])]);
                            for (const e of d) {
                                if (l.findIndex((t => t.id === e.id)) >= 0)
                                    continue;
                                const t = u.find((t => t.id === e.id));
                                if (void 0 !== t)
                                    for (const n of e.cameras) {
                                        const e = t.cameras.find((e => e.id === n.id));
                                        void 0 !== e && (n.capabilities = e.capabilities)
                                    }
                            }
                            l = l.concat(d),
                            o = d.length
                        }
                    } catch (e) {
                        a.error("Could not load Orchids", e)
                    }
                    return l
                }
                ))
            }
            function Ke(e) {
                return null != e
            }
            Ye = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            })], Ye);
            const Ze = L.messages;
            angular.module("ipconfigure.orchid.singularity").factory("FusionDataService", Qe);
            const Je = O("FusionDataService");
            function Qe(e, t, n, i, a) {
                return {
                    updateServerConfig: function(e) {
                        return t.patch(w.baseUrl + "/service/about/config", e, {
                            withCredentials: !0
                        })
                    },
                    fetchPrivate: function() {
                        return t.get(w.baseUrl + "/service/about", {
                            withCredentials: !0
                        })
                    },
                    fetchPlugins: function() {
                        return t.get(w.baseUrl + "/service/apps", {
                            withCredentials: !0
                        })
                    },
                    testPlugin: function(e) {
                        return t({
                            method: "HEAD",
                            url: w.baseUrl + "/service/app-proxy/" + e.rootpath + "/" + e.extension.source
                        })
                    },
                    fetchGreeting: function() {
                        return t.get(w.baseUrl + "/service/about/greeting", {
                            withCredentials: !0
                        })
                    },
                    fetchOrchids: function() {
                        return a.isFeatureEnabled(qe.fetchOrchidsPaging1000) ? (Je.debug(`Feature flag ${qe.fetchOrchidsPaging1000} is set`),
                        a.isFeatureEnabled(qe.fetchOrchidsOmittingCapabilities) ? (Je.debug(`Feature flag ${qe.fetchOrchidsOmittingCapabilities} is set`),
                        Xe(t, w.baseUrl, 1e3, !1)) : Xe(t, w.baseUrl, 1e3, !0)) : a.isFeatureEnabled(qe.fetchOrchidsOmittingCapabilities) ? (Je.debug(`Feature flag ${qe.fetchOrchidsOmittingCapabilities} is set`),
                        function(e, t) {
                            return (0,
                            c.mG)(this, void 0, void 0, (function*() {
                                const n = `${t}/service/orchids?exclude=camera.streams,camera.capabilities&generateMissingSessionIds=false`;
                                return e.get(n, {
                                    withCredentials: !0
                                }).then((e => e.data))
                            }
                            ))
                        }(t, w.baseUrl)) : function(e, t) {
                            return (0,
                            c.mG)(this, void 0, void 0, (function*() {
                                const n = `${t}/service/orchids?exclude=camera.streams,camera.capabilities&generateMissingSessionIds=false`
                                  , i = `${t}/service/orchids?include=camera.capabilities&generateMissingSessionIds=false`
                                  , a = e.get(n, {
                                    withCredentials: !0
                                })
                                  , r = e.get(i, {
                                    withCredentials: !0
                                });
                                return Promise.all([a, r]).then(( ([e,t]) => {
                                    for (const n of e.data) {
                                        const e = t.data.find((e => e.id === n.id));
                                        if (void 0 !== e)
                                            for (const t of n.cameras) {
                                                const n = e.cameras.find((e => e.id === t.id));
                                                void 0 !== n && (t.capabilities = n.capabilities)
                                            }
                                    }
                                    return e.data
                                }
                                ))
                            }
                            ))
                        }(t, w.baseUrl)
                    },
                    fetchManagedRecorders$: function() {
                        return i.getAuthenticationData().hasUserAbility(Re.MANAGE_ORCHID) ? (0,
                        Be.P)((function() {
                            return t.get(w.baseUrl + "/service/orchids?include=name&generateMissingSessionIds=false&manager=true", {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        ))) : (0,
                        ze.of)([])
                    },
                    fetchUserManagementGroups$: function() {
                        return i.getAuthenticationData().hasUserAbility(Re.MANAGE_ORCHID) ? (0,
                        Be.P)((function() {
                            return t.get(w.baseUrl + "/service/permissions/management-groups", {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        ))) : (0,
                        ze.of)([])
                    },
                    fetchRecorderManagementGroups$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.get(`${w.baseUrl}/service/orchids/${e}/management-groups`, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    fetchOrchid: function(e) {
                        return t.get(`${w.baseUrl}/service/orchids/${e}`, {
                            withCredentials: !0
                        }).then((function(e) {
                            return e.data
                        }
                        ))
                    },
                    getOrchidSessionId: function(e) {
                        return t.get(w.baseUrl + "/service/orchids/" + e.id + "/session", {
                            withCredentials: !0
                        })
                    },
                    fetchOrchidTimes: function() {
                        return t.get(w.baseUrl + "/service/orchids/time", {
                            withCredentials: !0
                        })
                    },
                    addOrchid: function(e) {
                        return t.post(w.baseUrl + "/service/orchids", e, {
                            withCredentials: !0
                        })
                    },
                    updateOrchid: function(e) {
                        return t.patch(w.baseUrl + "/service/orchids/" + e.id, e, {
                            withCredentials: !0
                        })
                    },
                    deleteOrchid: function(e, n) {
                        return t.delete(w.baseUrl + "/service/orchids/" + e.id + "?force=" + n, {
                            withCredentials: !0
                        })
                    },
                    purgeOrchid: function(e) {
                        return t.post(w.baseUrl + "/service/orchids/" + e.id + "/cache", {
                            withCredentials: !0
                        })
                    },
                    refreshDiscoverable: function(e) {
                        return n.resolve({})
                    },
                    fetchUser: function(e) {
                        return n((function(n, i) {
                            t.get(w.baseUrl + "/service/users/" + e).then((function(e) {
                                n(e.data)
                            }
                            ), (function(e) {
                                i(e.data)
                            }
                            ))
                        }
                        ))
                    },
                    fetchUsers: function() {
                        return n((function(e, n) {
                            t.get(w.baseUrl + "/service/users").then((function(t) {
                                e(t.data)
                            }
                            ), (function() {
                                n([])
                            }
                            ))
                        }
                        ))
                    },
                    ping: function() {
                        return t.get(w.baseUrl + "/service/ping?time=" + Date.now())
                    },
                    addUser: function(e) {
                        return t.post(w.baseUrl + "/service/users", e, {
                            withCredentials: !0
                        })
                    },
                    updateUser: function(e) {
                        return n((function(n, i) {
                            t.patch(w.baseUrl + "/service/users/" + e.id, e, {
                                withCredentials: !0
                            }).then((function(e) {
                                204 === e.status ? i({
                                    reason: Ze.dialogs.anUnexpectedErrorHasOccurred()
                                }) : n(e.data)
                            }
                            )).catch((function(e) {
                                return i(e.data)
                            }
                            ))
                        }
                        ))
                    },
                    deleteUser: function(e) {
                        return t.delete(w.baseUrl + "/service/users/" + e.id, {
                            withCredentials: !0
                        })
                    },
                    fetchVersionInfo: function() {
                        return t.get(w.baseUrl + "/service/version", {
                            withCredentials: !0
                        })
                    },
                    fetchAllCameras: function() {
                        return t.get(w.baseUrl + "/service/cameras", {
                            withCredentials: !0
                        })
                    },
                    fetchCameras: function(e) {
                        return t.get(w.baseUrl + "/service/orchids/" + e.id + "/cameras", {
                            withCredentials: !0
                        })
                    },
                    fetchCamera: function(e, n) {
                        return t.get(w.baseUrl + "/service/orchids/" + e.id + "/cameras/" + n, {
                            withCredentials: !0
                        }).then((function(e) {
                            return e.data
                        }
                        ))
                    },
                    fetchStages: function() {
                        return t.get(w.baseUrl + "/service/layouts", {
                            withCredentials: !0
                        })
                    },
                    fetchStage: function(e) {
                        return t.get(w.baseUrl + `/service/layouts/${e}`, {
                            withCredentials: !0
                        }).then((function(e) {
                            return e.data
                        }
                        ))
                    },
                    addStage: function(e) {
                        return t.post(w.baseUrl + "/service/layouts", e, {
                            withCredentials: !0
                        })
                    },
                    updateStage: function(e) {
                        return t.patch(w.baseUrl + "/service/layouts/" + e.id, e, {
                            withCredentials: !0
                        })
                    },
                    deleteStage: function(e) {
                        return t.delete(w.baseUrl + "/service/layouts/" + e.id, {
                            withCredentials: !0
                        })
                    },
                    fetchCameraGroups: function(e) {
                        return t.get(w.baseUrl + "/service/groups" + (!0 === e ? "/flat" : ""), {
                            withCredentials: !0
                        })
                    },
                    saveCameraGroups: function(e) {
                        return t.put(w.baseUrl + "/service/groups", e, {
                            withCredentials: !0
                        })
                    },
                    fetchCameraGroupById: function(e) {
                        return t.get(w.baseUrl + "/service/groups/" + e, {
                            withCredentials: !0
                        }).then((function(e) {
                            return e.data
                        }
                        ))
                    },
                    addCameraGroup: function(e) {
                        return t.post(w.baseUrl + "/service/groups", e, {
                            withCredentials: !0
                        })
                    },
                    updateCameraGroup: function(e) {
                        return t.patch(w.baseUrl + "/service/groups/" + e.id, e, {
                            withCredentials: !0
                        })
                    },
                    deleteCameraGroup: function(e) {
                        return t.delete(w.baseUrl + "/service/groups/" + e, {
                            withCredentials: !0
                        })
                    },
                    putGroupMapImageById: function(e, n) {
                        const i = {
                            method: "PUT",
                            data: n,
                            transformRequest: angular.identity,
                            headers: {
                                "Content-Type": n.type
                            },
                            url: w.baseUrl + `/service/groups/${e}/map-image`
                        };
                        return t(i).then((function(e) {
                            return e.data
                        }
                        ))
                    },
                    deleteGroupMapImageById: function(e) {
                        return t.delete(`${w.baseUrl}/service/groups/${e}/map-image`, {
                            withCredentials: !0
                        })
                    },
                    fetchGroup: function(e) {
                        return t.get(w.baseUrl + "/service/permissions/" + e, {
                            withCredentials: !0
                        })
                    },
                    fetchGroups: function() {
                        return t.get(w.baseUrl + "/service/permissions", {
                            withCredentials: !0
                        })
                    },
                    fetchGroupSummaries: function(e, n) {
                        return t.get(w.baseUrl + "/service/permissions/summaries?count=" + e + "&offset=" + n, {
                            withCredentials: !0
                        })
                    },
                    fetchGroupNames: function() {
                        return t.get(w.baseUrl + "/service/permissions/names", {
                            withCredentials: !0
                        })
                    },
                    newGroup: function(e) {
                        return t.post(w.baseUrl + "/service/permissions", e, {
                            withCredentials: !0
                        })
                    },
                    updateGroup: function(e) {
                        return t.patch(w.baseUrl + "/service/permissions/" + e.id, e, {
                            withCredentials: !0
                        })
                    },
                    deleteGroup: function(e) {
                        return t.delete(w.baseUrl + "/service/permissions/" + e.id, {
                            withCredentials: !0
                        })
                    },
                    fetchSmtpServers: function() {
                        return t.get(w.baseUrl + "/service/smtp-servers", {
                            withCredentials: !0
                        })
                    },
                    newSmtpServer: function(e) {
                        return t.post(w.baseUrl + "/service/smtp-servers", e, {
                            withCredentials: !0
                        })
                    },
                    updateSmtpServer: function(e) {
                        return t.patch(w.baseUrl + "/service/smtp-servers/" + e.id, e, {
                            withCredentials: !0
                        })
                    },
                    deleteSmtpServer: function(e) {
                        return t.delete(w.baseUrl + "/service/smtp-servers/" + e.id, {
                            withCredentials: !0
                        })
                    },
                    testSmtpServer: function(e) {
                        return t.post(w.baseUrl + "/service/smtp-servers/test", e, {
                            withCredentials: !0
                        })
                    },
                    fetchNotifications: function() {
                        return t.get(w.baseUrl + "/service/notifications", {
                            withCredentials: !0
                        })
                    },
                    newNotification: function(e) {
                        return t.post(w.baseUrl + "/service/notifications", e, {
                            withCredentials: !0
                        })
                    },
                    updateNotification: function(e) {
                        return t.patch(w.baseUrl + "/service/notifications/" + e.id, e, {
                            withCredentials: !0
                        })
                    },
                    deleteNotification: function(e) {
                        return t.delete(w.baseUrl + "/service/notifications/" + e.id, {
                            withCredentials: !0
                        })
                    },
                    fetchSmtpServers$: function() {
                        return (0,
                        Be.P)((function() {
                            return t.get(w.baseUrl + "/service/smtp-servers", {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    fetchSmtpServer$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.get(w.baseUrl + "/service/smtp-server/" + e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    newSmtpServer$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.post(w.baseUrl + "/service/smtp-servers", e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    updateSmtpServer$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.patch(w.baseUrl + "/service/smtp-servers/" + e.id, e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    deleteSmtpServer$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.delete(w.baseUrl + "/service/smtp-servers/" + e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    fetchNotifications$: function() {
                        return (0,
                        Be.P)((function() {
                            return t.get(w.baseUrl + "/service/notifications", {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    fetchNotification$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.get(w.baseUrl + "/service/notification/" + e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    newNotification$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.post(w.baseUrl + "/service/notifications", e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    updateNotification$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.patch(w.baseUrl + "/service/notifications/" + e.id, e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    deleteNotification$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.delete(w.baseUrl + "/service/notifications/" + e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    fetchSchedules$: function() {
                        return (0,
                        Be.P)((function() {
                            return t.get(w.baseUrl + "/service/schedules", {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    fetchSchedule$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.get(w.baseUrl + "/service/schedules/" + e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    newSchedule$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.post(w.baseUrl + "/service/schedules", e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    updateSchedule$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.put(w.baseUrl + "/service/schedules/" + e.id, e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    deleteSchedule$: function(e) {
                        return (0,
                        Be.P)((function() {
                            return t.delete(w.baseUrl + "/service/schedules/" + e, {
                                withCredentials: !0
                            })
                        }
                        )).pipe((0,
                        He.U)((function(e) {
                            return e.data
                        }
                        )))
                    },
                    cameraPreviewUrl: function(e, t, n, a, r) {
                        if (n !== j.CHIP && n !== j.SMALL && n !== j.LARGE)
                            throw new Error("cameraPreviewUrl size must be 'chip', 'small', or 'large'!");
                        {
                            let s;
                            const o = i.getAuthenticationData();
                            if (n === j.CHIP ? (s = new URL(`${w.baseUrl}/service/orchids/${e}/cameras/${t}/preview`),
                            s.searchParams.set("width", 72),
                            s.searchParams.set("height", 72),
                            s.searchParams.set("crop", "true")) : s = new URL(`${w.baseUrl}/service/orchids/${e}/cameras/${t}/preview/${n}`),
                            !0 !== w.singlePlayerMode && !0 !== w.isPWA && !0 !== a || s.searchParams.set("fsid", o.sessionId),
                            !0 !== r) {
                                const e = 12e4
                                  , t = new Date
                                  , n = new Date(Math.round(t.getTime() / e) * e).getTime();
                                s.searchParams.set("cache-bust", n)
                            }
                            return s.href
                        }
                    },
                    fetchPreviewPromiseAndCanceller(e) {
                        const i = n.defer();
                        return {
                            promise: t.get(e, {
                                timeout: i.promise,
                                responseType: "blob"
                            }).then((function(e) {
                                return e.data
                            }
                            )),
                            cancel: function(e) {
                                i.resolve(e)
                            }
                        }
                    },
                    fetchUpdatedOrchidInfo(e) {
                        const n = ce(e) ? e : e.id;
                        return t.post(`${w.baseUrl}/service/orchids/${n}/cache`, {}, {
                            withCredentials: !0
                        })
                    },
                    newLibraryExport: e => t.post(`${w.baseUrl}/service/library/exports`, e, {
                        withCredentials: !0
                    }).then((function(e) {
                        return e.data
                    }
                    )),
                    fetchLibraryExports: () => t.get(`${w.baseUrl}/service/library/exports`, {
                        withCredentials: !0
                    }).then((function(e) {
                        return e.data
                    }
                    )),
                    fetchLibraryExport: e => t.get(`${w.baseUrl}/service/library/exports/${e}`, {
                        withCredentials: !0
                    }).then((function(e) {
                        return e.data
                    }
                    )),
                    fetchLibraryItemExternalLink: (e, n) => t.get(`${w.baseUrl}/service/library/exports/${e}/files/${n}/external-link`, {
                        withCredentials: !0
                    }).then((function(e) {
                        return e.data.externalUrl
                    }
                    )),
                    patchLibraryExport: (e, n) => t.patch(`${w.baseUrl}/service/library/exports/${e}`, n, {
                        withCredentials: !0
                    }).then((function(e) {
                        return e.data
                    }
                    )),
                    retryLibraryExport: e => t.put(`${w.baseUrl}/service/library/exports/${e}/retry`, {
                        withCredentials: !0
                    }).then((function(e) {
                        return e.data
                    }
                    )),
                    cancelLibraryExport: e => t.put(`${w.baseUrl}/service/library/exports/${e}/cancel`, {
                        withCredentials: !0
                    }).then((function(e) {
                        return e.data
                    }
                    )),
                    deleteLibraryExport: e => t.delete(`${w.baseUrl}/service/library/exports/${e}?force=true`, {
                        withCredentials: !0
                    }),
                    fetchLicenses(e) {
                        let n = {
                            headers: {
                                Accept: e
                            },
                            withCredentials: !0
                        };
                        return t.get(`${w.baseUrl}/service/orchids/license`, n).then((function(e) {
                            return e.data
                        }
                        ))
                    },
                    licensesUrl() {
                        return this.authorizeUrl(`${w.baseUrl}/service/orchids/license`)
                    },
                    uploadLicenses: e => new Promise((function(t, n) {
                        const i = new FileReader;
                        i.onload = function() {
                            t(i.result)
                        }
                        ,
                        i.onerror = function(e) {
                            return n(i.error)
                        }
                        ,
                        i.readAsText(e)
                    }
                    )).then((function(e) {
                        return t.post(`${w.baseUrl}/service/orchids/license/import`, e, {
                            headers: {
                                "Content-Type": "text/csv"
                            },
                            withCredentials: !0
                        }).then((function(e) {
                            return e.data
                        }
                        ))
                    }
                    )),
                    fetchLicenseImportStatus: () => t.get(`${w.baseUrl}/service/orchids/license/import`, {
                        withCredentials: !0
                    }).then((function(e) {
                        return e.data
                    }
                    )),
                    putLicenseImportRetry: () => t.put(`${w.baseUrl}/service/orchids/license/import/retry`, {
                        withCredentials: !0
                    }),
                    putLicenseImportCancel: () => t.put(`${w.baseUrl}/service/orchids/license/import/cancel`, {
                        withCredentials: !0
                    }),
                    clearLicenseImports: () => t.delete(`${w.baseUrl}/service/orchids/license/import`, {
                        withCredentials: !0
                    }),
                    authorizeUrl(e) {
                        if (e.includes("fsid"))
                            return;
                        const t = i.getAuthenticationData();
                        let n = e.includes("?") ? "&fsid=" : "?fsid=";
                        return e + n + t.sessionId
                    }
                }
            }
            function et(e, t, n, i, a) {
                var r, s = this;
                function o(e, t) {
                    var n;
                    return delete (n = Object.assign(t, e)).extensions,
                    n
                }
                return s.plugins = [],
                {
                    getPlugins: function() {
                        return s.plugins
                    },
                    getNavigationExtensions: function() {
                        var e = [];
                        return angular.forEach(s.plugins, (function(t) {
                            angular.forEach(t.extensions, (function(n) {
                                if ("nav-menu" === n.point) {
                                    var i = o(t, n);
                                    e.push({
                                        name: i.name,
                                        appIcon: i.extension.iconSource,
                                        state: "/plugin/" + i.rootpath + "/" + i.extension.route
                                    })
                                }
                            }
                            ))
                        }
                        )),
                        e
                    },
                    findPlugin: function(e, t) {
                        for (var n, i, a = 0; a < s.plugins.length; ++a)
                            if ((n = s.plugins[a]).rootpath === e)
                                for (var r = 0; r < n.extensions.length; ++r) {
                                    if ((i = n.extensions[r]).extension.route === t)
                                        return o(n, i)
                                }
                    },
                    getPluginsPromise: function() {
                        return angular.isUndefined(r) && (r = e.isOrchid ? i((function(e, t) {
                            e(s.plugins)
                        }
                        )) : a.fetchPlugins().then((function(e) {
                            s.plugins = e.data
                        }
                        ), (function(e) {
                            t.error("Failed to fetch plugins", e)
                        }
                        ))),
                        r
                    },
                    clear: function() {
                        r = void 0,
                        s.plugins = []
                    }
                }
            }
            function tt(e, t) {
                var n = !0 === w.isOrchid ? e : t;
                return {
                    cameraPreviewUrl: n.cameraPreviewUrl,
                    fetchCamera: n.fetchCamera,
                    fetchCameras: n.fetchCameras,
                    fetchCamera: n.fetchCamera,
                    fetchAllCameras: n.fetchAllCameras,
                    fetchPreviewPromiseAndCanceller: n.fetchPreviewPromiseAndCanceller,
                    addOrchid: n.addOrchid,
                    fetchOrchids: n.fetchOrchids,
                    fetchOrchid: n.fetchOrchid,
                    getOrchidSessionId: n.getOrchidSessionId,
                    deleteOrchid: n.deleteOrchid,
                    purgeOrchid: n.purgeOrchid,
                    updateOrchid: n.updateOrchid,
                    fetchGroups: n.fetchGroups,
                    addUser: n.addUser,
                    deleteUser: n.deleteUser,
                    fetchUser: n.fetchUser,
                    fetchUsers: n.fetchUsers,
                    updateUser: n.updateUser,
                    fetchGreeting: n.fetchGreeting,
                    fetchPrivate: n.fetchPrivate,
                    fetchVersionInfo: n.fetchVersionInfo,
                    ping: n.ping,
                    refreshDiscoverable: n.refreshDiscoverable,
                    fetchCameraGroups: t.fetchCameraGroups,
                    getPropertyInfo: e.getPropertyInfo,
                    getProperties: e.getProperties,
                    getPropertiesAndInfo: e.getPropertiesAndInfo,
                    updateProperties: e.updateProperties,
                    doPropertiesNeedToBeConfirmed: e.doPropertiesNeedToBeConfirmed,
                    confirmProperties: e.confirmProperties,
                    fetchUpdatedOrchidInfo: t.fetchUpdatedOrchidInfo
                }
            }
            Qe.$inject = ["$rootScope", "$http", "$q", "AuthenticationService", "FeatureFlagService"],
            angular.module("ipconfigure.orchid.singularity").factory("PluginService", et),
            et.$inject = ["$rootScope", "$log", "$http", "$q", "FusionDataService"],
            angular.module("ipconfigure.orchid.singularity").factory("DataService", ["OrchidDataService", "FusionDataService", tt]);
            n(85827);
            const nt = (it = navigator.userAgent || navigator.vendor || window.opera,
            /(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(it) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(it.substr(0, 4)));
            var it;
            const at = /android|ipad|playbook|silk/i.test(navigator.userAgent);
            function rt() {
                function e() {
                    var e, t = navigator.userAgent, n = t.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [], i = {
                        name: "",
                        version: "",
                        platform: navigator.platform
                    };
                    return /trident/i.test(n[0]) ? (e = /\brv[ :]+(\d+)/g.exec(t) || [],
                    i.name = "MSIE",
                    i.version = parseInt(e[1], 10) || 0) : "Chrome" === n[1] ? null !== (e = t.match(/\bOPR\/(\d+)/)) ? (i.name = "Opera",
                    i.version = parseInt(e[1], 10)) : (i.name = n[1],
                    i.version = parseInt(n[2], 10)) : (0 === n.length && "iPad" === navigator.platform && "Netscape" === navigator.appName && (n = ["Safari/7.0", "Safari", 7]),
                    n = n[2] ? [n[1], n[2]] : [navigator.appName, navigator.appVersion, "-?"],
                    null !== (e = t.match(/version\/(\d+)/i)) && n.splice(1, 1, e[1]),
                    i.name = n[0],
                    i.version = parseInt(n[1], 10)),
                    i
                }
                function t() {
                    navigator.userAgent || navigator.vendor || window.opera;
                    var e = "Unknown";
                    return -1 !== navigator.appVersion.indexOf("Win") ? e = "Windows" : -1 !== navigator.appVersion.indexOf("Mac") ? e = "MacOS" : -1 !== navigator.appVersion.indexOf("Android") ? e = "Android" : -1 !== navigator.appVersion.indexOf("Linux") && (e = "Linux"),
                    {
                        isMobile: nt,
                        isTablet: at,
                        isDesktop: !nt && !at,
                        operatingSystem: e
                    }
                }
                return {
                    isChromeWebSocketCompatible: function() {
                        var e = navigator.userAgent.match(/Chrom(e|ium)\/([0-9]+)\./);
                        return !e || parseInt(e[2], 10) > 49
                    },
                    isEdge: function() {
                        return navigator.userAgent.indexOf("Edge/") > 0
                    },
                    isIE11: function() {
                        return !!window.MSInputMethodContext && !!document.documentMode
                    },
                    isMobileSafari: function() {
                        var n = t();
                        return (n.isMobile || n.isTablet) && "Safari" === e().name
                    },
                    getBrowserInfo: e,
                    getDeviceInfo: t,
                    isMobile: t().isMobile
                }
            }
            function st(e) {
                return {
                    isProxyForced: function(e) {
                        return w.isPWA || w.baseUrl.toLowerCase().indexOf("https://") > -1 && e.toLowerCase().indexOf("http://") > -1
                    },
                    isLive: function(e) {
                        return e >= Date.now() - 1e3 * w.secondsPlaybackFromLive
                    },
                    find: function(e, t) {
                        for (var n, i = 0; i < e.length; ++i)
                            if (t(e[i])) {
                                n = e[i];
                                break
                            }
                        return n
                    },
                    findAncestor: function(e, t) {
                        for (; e.parentNode; ) {
                            if (t(e))
                                return e;
                            e = e.parentNode
                        }
                    },
                    fillRectangle: function(e, t, n, i, a, r) {
                        var s = {
                            left: 0,
                            top: 0,
                            width: 0,
                            height: 0
                        };
                        return n / i > a / r ? (s.width = a * i / r,
                        s.height = i,
                        s.top = t,
                        s.left = e + (n - s.width) / 2) : (s.width = n,
                        s.height = r * n / a,
                        s.top = t + (i - s.height) / 2,
                        s.left = e),
                        s
                    },
                    parseUri: function(e) {
                        for (var t = {
                            strictMode: !1,
                            key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
                            q: {
                                name: "queryKey",
                                parser: /(?:^|&)([^&=]*)=?([^&]*)/g
                            },
                            parser: {
                                strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
                                loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
                            }
                        }, n = t.parser[t.strictMode ? "strict" : "loose"].exec(e), i = {}, a = 14; a--; )
                            i[t.key[a]] = n[a] || "";
                        return i[t.q.name] = {},
                        i[t.key[12]].replace(t.q.parser, (function(e, n, a) {
                            n && (i[t.q.name][n] = a)
                        }
                        )),
                        i
                    },
                    getCamerasFromMatrix: function(e) {
                        var t, n = [], i = [].concat.apply([], e), a = {};
                        return angular.forEach(i, (function(e) {
                            if ((t = e.camera) && angular.isDefined(t.id) && angular.isDefined(t.orchidId)) {
                                var i = t.id + "-" + t.orchidId;
                                angular.isUndefined(a[i]) && (a[i] = 1,
                                n.push(t))
                            }
                        }
                        )),
                        n
                    },
                    postMessage: function(t) {
                        e !== e.parent && e.parent.postMessage({
                            event: t,
                            origin: e.location.href
                        }, "*")
                    },
                    postMessageAPIPlayer: function(t) {
                        document.getElementById("player").contentWindow.postMessage({
                            event: t,
                            origin: e.location.href
                        }, "*")
                    }
                }
            }
            angular.module("ipconfigure.orchid.singularity").factory("BrowserInfoService", [rt]),
            angular.module("ipconfigure.orchid.singularity").factory("UtilityService", ["$window", st]).directive("input", ["BrowserInfoService", function(e) {
                return e.isEdge() ? {
                    link: function(e, t) {
                        "number" === t[0].type && t.on("keydown", (function(n) {
                            switch (n.which) {
                            case 38:
                            case 40:
                                e.$evalAsync((function() {
                                    t.triggerHandler("change")
                                }
                                ))
                            }
                        }
                        ))
                    }
                } : {}
            }
            ]);
            var ot, ct, lt = n(55645), dt = n(1718), ut = n(25211);
            !function(e) {
                e[e.PROXIED = 0] = "PROXIED",
                e[e.UNPROXIED = 1] = "UNPROXIED",
                e[e.UNKNOWN = 2] = "UNKNOWN"
            }(ct || (ct = {}));
            let mt = class {
                constructor(e) {
                    this._http = e,
                    this._recorderProxyMap = {},
                    this._timeDifferenceCache = {},
                    this._orchidProxyTestCache = {}
                }
                applyProxy(e, t, n) {
                    if (n || (n = {}),
                    !1 !== w.isOrchid || t.includes("service/orchid-proxy"))
                        return t;
                    {
                        const i = new URL(t);
                        return this.orchidUri(e, {
                            favorProxy: n.favorProxy
                        }) + "/" + i.pathname.replace(/^\//, "") + i.search + i.hash
                    }
                }
                checkProxy(e, t) {
                    return this._isProxyForced(e.uri) || this._orchidProxyTestCache[e.id] || (this._orchidProxyTestCache[e.id] = this._fetchTimeDifferenceFromClient(e, 2e3),
                    this._orchidProxyTestCache[e.id].then(( () => {}
                    ))),
                    t.url = this.applyProxy(e, t.url),
                    t
                }
                getProxyState(e, t) {
                    return t || (t = {}),
                    w.isOrchid ? ct.UNPROXIED : (void 0 === this._recorderProxyMap[e.id] && (this._recorderProxyMap[e.id] = ct.UNKNOWN),
                    this._isProxyForced(e.uri) || t.favorProxy && this._recorderProxyMap[e.id] === ct.UNKNOWN ? ct.PROXIED : this._recorderProxyMap[e.id])
                }
                getProxyStateById(e) {
                    return w.isOrchid ? ct.UNPROXIED : (void 0 === this._recorderProxyMap[e] && (this._recorderProxyMap[e] = ct.UNKNOWN),
                    this._recorderProxyMap[e])
                }
                orchidUri(e, t) {
                    return t || (t = {}),
                    !1 !== w.isOrchid || !0 === t.disableProxy || !t.forceProxy && this.getProxyState(e, {
                        favorProxy: t.favorProxy
                    }) === ct.UNPROXIED ? e.uri : w.baseUrl + "/service/orchid-proxy/" + e.id
                }
                orchidWsUri(e, t) {
                    if (this.getProxyState(e, {
                        favorProxy: !0
                    }) === ct.PROXIED) {
                        const n = new URL("/service/orchid-proxy-ws/" + e.id + t,w.baseUrl);
                        return n.protocol = "https:" === n.protocol ? "wss:" : "ws:",
                        n
                    }
                    {
                        const n = new URL(this.orchidUri(e));
                        return n.protocol = "https:" === n.protocol ? "wss:" : "ws:",
                        n.pathname = t,
                        n
                    }
                }
                setProxyState(e, t) {
                    this._recorderProxyMap[e] = t
                }
                _fetchTimeDifferenceFromClient(e, t) {
                    return new Promise((n => {
                        if (void 0 !== this._timeDifferenceCache[e.id] && !t)
                            return n(this._timeDifferenceCache[e.id]);
                        {
                            let i = !0;
                            t || (t = 5e3,
                            i = !1);
                            const a = this.orchidUri(e, {
                                disableProxy: i
                            }) + "/service/time?cache-bust=" + Date.now();
                            (0,
                            dt.z)(this._http.get(a, {
                                observe: "response"
                            }).pipe((0,
                            ut.V)(t))).then((t => {
                                var i;
                                if (null !== t.body) {
                                    let a = t.body;
                                    "string" == typeof a && (a = parseInt(a, 10));
                                    const r = Date.now() - a;
                                    !1 !== w.isOrchid || (null === (i = t.url) || void 0 === i ? void 0 : i.includes("orchid-proxy")) || this.setProxyState(e.id, ct.UNPROXIED),
                                    this._timeDifferenceCache[e.id] = r,
                                    n(this._timeDifferenceCache[e.id])
                                }
                            }
                            )).catch((t => {
                                this.getProxyState(e) === ct.UNKNOWN && this.setProxyState(e.id, ct.PROXIED),
                                t.url ? t.url.includes("service/orchid-proxy") || this.setProxyState(e.id, ct.PROXIED) : "404" === t.status && this.setProxyState(e.id, ct.PROXIED),
                                n(0)
                            }
                            ))
                        }
                    }
                    ))
                }
                _isProxyForced(e) {
                    return !!w.isPWA || ("enabled" === localStorage.forceOrchidProxy || w.baseUrl.toLowerCase().includes("https://") && e.toLowerCase().includes("http://"))
                }
            }
            ;
            mt = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.fM)(0, (0,
            i.Inject)(lt.eN)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (ot = void 0 !== lt.eN && lt.eN) ? ot : Object])], mt);
            const ht = L.messages;
            function pt(e, t, n, i, a, r, s, o, c) {
                let l;
                function d(e) {
                    w.isOrchid && (e.permissions = r.getAuthenticationData().getPermissions()),
                    e.orchidId = 1;
                    const t = e.streams.find((function(t) {
                        return t.id === e.primaryStream.id
                    }
                    ));
                    t && (e.primaryStream = {
                        ...e.primaryStream,
                        ...t
                    })
                }
                function u(e, i, a) {
                    if (angular.isUndefined(a) && (a = {}),
                    function(e, t, n) {
                        angular.isUndefined(e.headers) && (e.headers = {});
                        !0 === w.isOrchid ? e.withCredentials = !0 : (e.headers = function() {
                            return Array.prototype.slice.call(arguments).reduce((function(e, t) {
                                return Object.keys(t).forEach((function(n) {
                                    e[n] = t[n]
                                }
                                )),
                                e
                            }
                            ), {})
                        }(e.headers, function(e) {
                            return !0 === w.isOrchid ? {} : {
                                Authorization: "Bearer " + m(e),
                                OrchidId: e.id
                            }
                        }(t)),
                        !0 === n && (e.headers.ProxyTest = !0))
                    }(e, i, a.testProxy),
                    w.isOrchid || !0 === i.isAvailable)
                        return w.isOrchid || (e = o.checkProxy({
                            id: i.id,
                            uri: i.uri
                        }, e, a)),
                        e = function(e) {
                            return e.url.indexOf("service/orchid-proxy") > -1 && (void 0 === e.headers && (e.headers = {}),
                            e.headers.Authorization = "Bearer " + r.getAuthenticationData().sessionId),
                            e
                        }(e),
                        t(e);
                    var s = n.defer()
                      , c = ht.orchidDataService.isNotAvailable();
                    return s.reject({
                        data: {
                            message: c
                        },
                        status: 404,
                        headers: e.headers,
                        config: e.config,
                        statusText: c,
                        xhrStatus: "error"
                    }),
                    s.promise
                }
                function m(e) {
                    if (angular.isDefined(e))
                        return c.getSessionId(e.id)
                }
                function h(e, t) {
                    var n = o.orchidWsUri({
                        id: e.id,
                        uri: e.uri
                    }, t);
                    return n.href.includes("orchid-proxy") ? f(n).toString() : v(n, e).toString()
                }
                function p(e) {
                    return o.getProxyState({
                        id: e.id,
                        uri: e.uri
                    }) === ct.PROXIED ? a.getConfigPostAuth().rtspProtocol : e.discoverableOrchid.rtspProtocol
                }
                function g(e) {
                    return o.getProxyState({
                        id: e.id,
                        uri: e.uri
                    }) === ct.PROXIED ? a.getConfigPostAuth().rtspPort : e.discoverableOrchid.rtspPort
                }
                function f(e) {
                    return e.searchParams.set("fsid", r.getAuthenticationData().sessionId),
                    e
                }
                function v(e, t) {
                    var n = r.getAuthenticationData();
                    return void 0 !== n.tokenType && !0 === w.singlePlayerMode && !0 === w.isOrchid ? n.token && e.searchParams.set(n.tokenType, n.token) : e.searchParams.set("sid", function(e) {
                        var t = "";
                        t = w.isOrchid ? r.getAuthenticationData().sessionId : m(e);
                        return t
                    }(t)),
                    e
                }
                function y(e, t, n, i, a) {
                    let r = new URL(o.applyProxy({
                        id: e.id,
                        uri: e.uri
                    }, t + "/frame"));
                    return r = r.pathname.includes("orchid-proxy") ? f(r) : v(r, e),
                    r.searchParams.set("time", n),
                    r.searchParams.set("fallback", a),
                    r.searchParams.set("width", i.width),
                    r.searchParams.set("height", i.height),
                    r.searchParams.set("cb", Date.now()),
                    r.toString()
                }
                return {
                    fetchOrchids: function() {
                        return n((function(e, n) {
                            t.get(w.baseUrl + "/service/discoverable/orchids/1", {
                                withCredentials: !0
                            }).then((function(t) {
                                e([{
                                    maxPlayerCount: t.data.maxPlayerCount,
                                    camerasAvailable: 12,
                                    camerasOnline: 8,
                                    environment: "FULL",
                                    failureReason: "",
                                    id: 1,
                                    isAvailable: !0,
                                    lastAvailable: Date.now(),
                                    lastChecked: Date.now(),
                                    name: "Orchid",
                                    rtspPort: t.data.rtspPort,
                                    rtspProtocol: t.data.rtspProtocol,
                                    uri: w.baseUrl,
                                    discoverableOrchid: t.data,
                                    maxExportHours: t.data.maxExportHours
                                }])
                            }
                            ), (function(e) {
                                n([])
                            }
                            ))
                        }
                        ))
                    },
                    fetchOrchid: function(e) {
                        return this.fetchOrchids().then((function(e) {
                            return e[0]
                        }
                        ))
                    },
                    performRequest: u,
                    purgeOrchid: function(e) {},
                    refreshDiscoverable: function(e) {
                        return t.get(w.baseUrl + "/service/discoverable/orchids/1", {
                            withCredentials: !0
                        }).then((function(t) {
                            return e.iceServers = t.data.iceServers,
                            e.rtspPort = t.data.rtspPort,
                            e.rtspProtocol = t.data.rtspProtocol,
                            e.uri = w.baseUrl,
                            e.discoverableOrchid = t.data,
                            e
                        }
                        ))
                    },
                    ping: function() {
                        return t.get(w.baseUrl + "/ping?time=" + Date.now())
                    },
                    fetchCameras: function(e) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/cameras"
                        }, e).then((function(e) {
                            return null === e.data.cameras && (e.data.cameras = []),
                            e.data.cameras.forEach((function(e) {
                                return d(e)
                            }
                            )),
                            e
                        }
                        ))
                    },
                    fetchCamera: function(e, t) {
                        return u({
                            method: "GET",
                            url: e.uri + `/service/cameras/${t}`
                        }, e).then((function(e) {
                            return d(e.data),
                            e.data
                        }
                        ))
                    },
                    fetchCameraStreams: function(e, t) {
                        return u({
                            method: "GET",
                            url: `${e.uri}/service/cameras/${t}/streams`
                        }, e).then((function(e) {
                            return e.data.streams
                        }
                        ))
                    },
                    pingOrchid: function(e) {
                        return t.get(e.uri + "/ping?time=" + Date.now())
                    },
                    fetchUser: function(e, t) {
                        return u({
                            method: "GET",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/users/" + t
                        })
                    },
                    fetchUsers: function(e, t) {
                        return function(e, t) {
                            return n((function(n, i) {
                                angular.isUndefined(e.uri) || !0 !== e.isAvailable ? i(!1) : u({
                                    method: "GET",
                                    url: o.orchidUri({
                                        id: e.id,
                                        uri: e.uri
                                    }) + "/service/users"
                                }, e, {
                                    favorProxy: !angular.isDefined(t) || t
                                }).then((function(e) {
                                    n(e.data.users)
                                }
                                ), (function(e) {
                                    i(!1)
                                }
                                ))
                            }
                            ))
                        }(e, t)
                    },
                    addUser: function(e, t) {
                        return u({
                            method: "POST",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/users",
                            data: t
                        }, e)
                    },
                    updateUser: function(e, t) {
                        return u({
                            method: "PATCH",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/users/" + t.id,
                            data: t
                        }, e)
                    },
                    deleteUser: function(e, t) {
                        return u({
                            method: "DELETE",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/users/" + t.id
                        }, e)
                    },
                    fetchTimeExtended: function(e) {
                        return u({
                            method: "GET",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/time-extended"
                        }, e)
                    },
                    fetchArchiveAt: function(e, t, n, i) {
                        return u({
                            method: "GET",
                            url: o.orchidUri({
                                id: n.id,
                                uri: n.uri
                            }) + "/service/archives?take=" + i + "&streamId=" + t + "&start=" + e
                        }, n)
                    },
                    fetchArchiveCount: function(e, t) {
                        return u({
                            method: "GET",
                            url: o.orchidUri({
                                id: t.id,
                                uri: t.uri
                            }) + "/service/archives/per-day?ids=" + e
                        }, t)
                    },
                    testExport: function(e, t, n, i) {
                        return u({
                            method: "HEAD",
                            url: o.orchidUri({
                                id: i.id,
                                uri: i.uri
                            }) + "/service/streams/" + n + "/export?start=" + e + "&stop=" + t
                        }, i)
                    },
                    ptz: function(e, t, n) {
                        return u({
                            method: "POST",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/cameras/" + t.id + "/position",
                            data: n
                        }, e)
                    },
                    ptzPreset: function(e, t, n) {
                        var i = {
                            name: n.name,
                            token: n.token,
                            type: "preset"
                        };
                        return u({
                            method: "POST",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/cameras/" + t.id + "/position",
                            data: i
                        }, e)
                    },
                    addPtzPreset: function(e, t, n) {
                        return u({
                            method: "POST",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/cameras/" + t.id + "/position/presets",
                            data: n
                        }, e)
                    },
                    renamePtzPreset: function(e, t, n) {
                        return u({
                            method: "PATCH",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/cameras/" + t.id + "/position/presets/" + n.token,
                            data: n
                        }, e)
                    },
                    updatePtzPreset: function(e, t, n) {
                        return u({
                            method: "PATCH",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/cameras/" + t.id + "/position/presets/" + n.token,
                            data: n
                        }, e)
                    },
                    removePtzPreset: function(e, t, n) {
                        return u({
                            method: "DELETE",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/cameras/" + t.id + "/position/presets/" + n.token,
                            data: n
                        }, e)
                    },
                    getLowBandwidthStreams: function(e) {
                        return u({
                            method: "GET",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/low-bandwidth/streams"
                        }, e)
                    },
                    getLowBandwidthStream: function(e, t) {
                        return u({
                            method: "GET",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/low-bandwidth/streams/" + t
                        }, e)
                    },
                    createLowBandwidthStream: function(e, t) {
                        return u({
                            method: "POST",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/low-bandwidth/streams",
                            data: t
                        }, e)
                    },
                    deleteLowBandwidthStream: function(e, t) {
                        return u({
                            method: "DELETE",
                            url: o.orchidUri({
                                id: e.id,
                                uri: e.uri
                            }) + "/service/low-bandwidth/streams/" + t
                        }, e)
                    },
                    createLicense: function(e, t) {
                        return u({
                            method: "POST",
                            url: e.uri + "/service/license-session",
                            data: t
                        }, e)
                    },
                    deleteLicense: function(e) {
                        return u({
                            method: "DELETE",
                            url: e.uri + "/service/license-session"
                        }, e)
                    },
                    getTrustedIssuer: function(e) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/trusted/issuer"
                        }, e)
                    },
                    deleteTrustedIssuer: function(e) {
                        return u({
                            method: "DELETE",
                            url: e.uri + "/service/trusted/issuer"
                        }, e)
                    },
                    getDiscoverableOrchid: function(e) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/discoverable/orchids/1"
                        }, e)
                    },
                    getDiscoverableOrchids: function(e) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/discoverable/orchids"
                        }, e)
                    },
                    getDiscoverableCameras: function(e) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/discoverable/cameras"
                        }, e).then((function(e) {
                            return e.data
                        }
                        ))
                    },
                    registerCamera: function(e, t) {
                        return u({
                            method: "POST",
                            url: e.uri + "/service/cameras",
                            data: t
                        }, e).then((function(e) {
                            return d(e.data),
                            e
                        }
                        ))
                    },
                    updateCamera: function(e, t, n) {
                        return u({
                            method: "PATCH",
                            url: e.uri + "/service/cameras/" + t.id,
                            data: angular.isDefined(n) ? n : t
                        }, e).then((function(e) {
                            return d(e.data.camera),
                            e
                        }
                        ))
                    },
                    disableCamera: function(e, t) {
                        return u({
                            method: "PATCH",
                            url: e.uri + "/service/cameras/" + t,
                            data: {
                                active: !1
                            }
                        }, e)
                    },
                    activateCamera: function(e, t) {
                        return u({
                            method: "PATCH",
                            url: e.uri + "/service/cameras/" + t,
                            data: {
                                active: !0
                            }
                        }, e)
                    },
                    deleteCamera: function(e, t) {
                        return u({
                            method: "DELETE",
                            url: e.uri + "/service/cameras/" + t.id
                        }, e)
                    },
                    verifyCamera: function(e, t) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/cameras/" + t.id + "/verify"
                        }, e).then((function(e) {
                            return e.data
                        }
                        ))
                    },
                    getStream: function(e, t) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/streams/" + t
                        }, e)
                    },
                    getStreams: function(e) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/streams?live"
                        }, e)
                    },
                    addStream: function(e, t, n) {
                        return u({
                            method: "POST",
                            url: e.uri + "/service/cameras/" + t.id + "/streams",
                            data: n
                        }, e)
                    },
                    updateStream: function(e, t, n) {
                        return u({
                            method: "PUT",
                            url: e.uri + "/service/cameras/" + t.id + "/streams/" + n.id,
                            data: n
                        }, e)
                    },
                    restartStream: function(e, t, n) {
                        return u({
                            method: "PATCH",
                            url: e.uri + "/service/cameras/" + t.id + "/streams/" + n.id + "/restart"
                        }, e)
                    },
                    patchStream: function(e, t, n) {
                        return u({
                            method: "PATCH",
                            url: e.uri + "/service/cameras/" + t.id + "/streams/" + n.id,
                            data: n
                        }, e)
                    },
                    deleteStream: function(e, t, n) {
                        return u({
                            method: "DELETE",
                            url: e.uri + "/service/cameras/" + t.id + "/streams/" + n.id
                        }, e)
                    },
                    getStreamStatus: function(e, t) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/streams/" + t + "/status"
                        }, e)
                    },
                    getStreamStati: function(e) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/streams/status?live"
                        }, e)
                    },
                    getDiskUtilization: function(e) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/server/utilization/disk"
                        }, e)
                    },
                    getRetention: function(e, t, n) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/cameras/disk-usage?start=" + t + "&stop=" + n
                        }, e)
                    },
                    doRetentionUpdateDryRun: function(e, t) {
                        return u({
                            method: "POST",
                            url: `${e.uri}/service/cameras/dry-run`,
                            data: t
                        }, e).then((function(e) {
                            return e.data
                        }
                        ))
                    },
                    generateReport: function(e, t, n) {
                        return u({
                            method: "GET",
                            url: e.uri + "/service/server/report?start=" + t + "&stop=" + n
                        }, e)
                    },
                    deleteMotionMask: function(e, t) {
                        return u({
                            method: "DELETE",
                            url: e.uri + "/service/cameras/" + t.id + "/streams/" + t.primaryStream.id + "/motion/mask"
                        }, e)
                    },
                    saveMotionMask: function(e, t, n) {
                        return u({
                            method: "PUT",
                            url: e.uri + "/service/cameras/" + t.id + "/streams/" + t.primaryStream.id + "/motion/mask",
                            data: n
                        }, e)
                    },
                    fetchVersionInfo: function(e) {
                        var t = !0 === e ? "?all=true" : "";
                        return u({
                            method: "GET",
                            url: w.baseUrl + "/service/version" + t
                        })
                    },
                    updateUserInterface: function(e) {
                        return u({
                            method: "POST",
                            data: e,
                            transformRequest: angular.identity,
                            headers: {
                                "Content-Type": e.type
                            },
                            url: w.baseUrl + "/service/ui"
                        })
                    },
                    retry: function(e, n) {
                        return n.timeout = null,
                        n.url = o.applyProxy({
                            id: e.id,
                            uri: e.uri
                        }, n.url),
                        t(n)
                    },
                    rtspUrl: function(e, t, n, i) {
                        var a = document.createElement("a")
                          , r = "";
                        return a.href = o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        }),
                        r = (r = a.hostname + ":" + g(e) + "/" + a.pathname + (n ? "/orchid/playback?id=" + t + "&start=" + n + "&rate=" + i + "&waitThres=" + 2e3 * i + "&token=" + Math.floor(1e5 * Math.random() + 1) : "/orchid/live?id=" + t)).replace(/\/\/+/g, "/"),
                        p(e) + "://" + r
                    },
                    logExportUrl: function(e, t, n, i, a) {
                        const r = new URL(o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        }) + "/service/log");
                        return r.searchParams.set("format", t),
                        r.pathname.includes("orchid-proxy") ? f(r) : v(r, e),
                        a && (r.searchParams.set("from", n),
                        r.searchParams.set("to", i)),
                        r.href
                    },
                    exportUrl(e, t, n, i, a) {
                        const r = new URL(o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        }) + `/service/streams/${t}/export?start=${n}&stop=${i}&format=${a}`);
                        return r.pathname.includes("orchid-proxy") ? f(r) : v(r, e),
                        r.href
                    },
                    rtspPort: g,
                    rtspProtocol: p,
                    webrtcSocketUrl: function(e) {
                        return h(e, "/service/streams/webrtc")
                    },
                    generateOrchidWebSocketUrl: h,
                    lowbandwidthSocketUrl: function(e, t) {
                        return h(e, "/service/low-bandwidth/streams/" + t + "/ws")
                    },
                    motionMaskUrl: function(e, t) {
                        let n = new URL(o.applyProxy({
                            id: e.id,
                            uri: e.uri
                        }, t) + "?" + (new Date).getTime());
                        return n = n.pathname.includes("orchid-proxy") ? f(n) : v(n, e),
                        n
                    },
                    addOrchidAuthQueryParam: v,
                    cameraPreviewUrl: function(t, n, i, a) {
                        let s = 0
                          , o = 0;
                        switch (i) {
                        case j.CHIP:
                            s = o = 72;
                            break;
                        case j.SMALL:
                            s = o = 330;
                            break;
                        case j.LARGE:
                            s = o = 500;
                            break;
                        default:
                            throw new Error("cameraPreviewUrl size must be 'chip', 'small', or 'large'!")
                        }
                        const c = (angular.isUndefined(l) && (l = e.get("RenewableService")),
                        l).findCamera(t, n);
                        if (void 0 === c.primaryStream)
                            return;
                        const d = c.primaryStream.href
                          , u = new URL(`${d}/frame`);
                        return u.searchParams.set("width", s),
                        u.searchParams.set("height", o),
                        !0 === w.singlePlayerMode && u.searchParams.set("jwt", r.getAuthenticationData().token),
                        u.href
                    },
                    fetchPreviewPromiseAndCanceller(e) {
                        const i = n.defer();
                        return {
                            promise: t.get(e, {
                                timeout: i.promise,
                                responseType: "blob"
                            }).then((function(e) {
                                return e.data
                            }
                            )),
                            cancel: function(e) {
                                i.resolve(e)
                            }
                        }
                    },
                    frameUrl: function(e, t, n, i, a) {
                        return y(e, t.href, n, i, a)
                    },
                    cameraFrameUrl: function(e, t, n, i, a) {
                        return y(e, t.primaryStream.href, n, i, a)
                    },
                    getPropertyInfo: e => u({
                        method: "GET",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/server/properties/info`,
                        withCredentials: !0
                    }, e).then((function(e) {
                        return {
                            wasError: !1,
                            data: e.data.propertiesInfo,
                            error: null
                        }
                    }
                    )).catch((function(e) {
                        return {
                            wasError: !0,
                            data: null,
                            error: e
                        }
                    }
                    )),
                    getProperties: e => u({
                        method: "GET",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/server/properties`,
                        withCredentials: !0
                    }, e).then((function(e) {
                        return {
                            wasError: !1,
                            data: e.data.properties,
                            error: null
                        }
                    }
                    )).catch((function(e) {
                        return {
                            wasError: !0,
                            data: null,
                            error: e
                        }
                    }
                    )),
                    getPropertiesAndInfo(e) {
                        return n.all([this.getProperties(e), this.getPropertyInfo(e)]).then((function(e) {
                            let[t,n] = e;
                            return {
                                properties: t,
                                propertiesInfo: n
                            }
                        }
                        ))
                    },
                    updateProperties: (e, t) => u({
                        method: "PUT",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/server/properties`,
                        data: {
                            properties: t
                        },
                        withCredentials: !0
                    }, e).then((function(e) {
                        return {
                            wasError: !1,
                            data: e.data,
                            error: null
                        }
                    }
                    )).catch((function(e) {
                        return {
                            wasError: !0,
                            data: null,
                            error: e
                        }
                    }
                    )),
                    doPropertiesNeedToBeConfirmed: e => u({
                        method: "GET",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/server/properties/confirmed`,
                        withCredentials: !0
                    }, e).then((function(e) {
                        return {
                            wasError: !1,
                            data: e.data,
                            error: null
                        }
                    }
                    )).catch((function(e) {
                        return {
                            wasError: !0,
                            data: null,
                            error: e
                        }
                    }
                    )),
                    confirmProperties: e => u({
                        method: "POST",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/server/properties/confirmed`,
                        withCredentials: !0
                    }, e).then((function(e) {
                        return {
                            wasError: !1,
                            data: e.data,
                            error: null
                        }
                    }
                    )).catch((function(e) {
                        return {
                            wasError: !0,
                            data: null,
                            error: e
                        }
                    }
                    )),
                    fetchCamerasTZList: e => u({
                        method: "GET",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/cameras/tz-list`,
                        withCredentials: !0
                    }, e).then((function(e) {
                        return e.data.tzMappings ? e.data.tzMappings : Promise.reject(e.data)
                    }
                    )),
                    fetchEvents(e, t, n, i, a, r, s, c) {
                        if (null == n && null == i)
                            throw new Error("Either stop or count must be specified.");
                        const l = new URL(`${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/events/metadata`);
                        return void 0 !== t && l.searchParams.set("start", t),
                        void 0 !== n && l.searchParams.set("stop", n),
                        void 0 !== i && l.searchParams.set("count", i),
                        void 0 !== a && l.searchParams.set("offset", a),
                        void 0 !== c && c.length > 0 && (l.href += "&subscriptionIds=" + c.join(",")),
                        void 0 !== r && r.length > 0 && (l.href += "&categoryIds=" + r.join(",")),
                        void 0 !== s && s.length > 0 && (l.href += "&active=" + s.join(",")),
                        u({
                            method: "GET",
                            url: l.toString(),
                            withCredentials: !0
                        }, e).then((function(e) {
                            return e.data.events ? e.data.events : Promise.reject(e.data)
                        }
                        ))
                    },
                    postEvent: (e, t) => u({
                        method: "POST",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/events/metadata/external`,
                        withCredentials: !0,
                        data: t
                    }, e).then((function(e) {
                        return e.data
                    }
                    )),
                    deleteEventSubscription: (e, t) => u({
                        method: "DELETE",
                        url: o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        }) + "/service/events/metadata/subscriptions/" + t,
                        withCredentials: !0
                    }, e),
                    fetchEventSubscription: (e, t) => u({
                        method: "GET",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/events/metadata/subscriptions/${t}`,
                        withCredentials: !0
                    }, e).then((function(e) {
                        return e.data.subscription ? e.data.subscription : Promise.reject(e.data)
                    }
                    )),
                    fetchEventSubscriptions: e => u({
                        method: "GET",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/events/metadata/subscriptions`,
                        withCredentials: !0
                    }, e).then((function(e) {
                        return e.data.subscriptions ? e.data.subscriptions : Promise.reject(e.data)
                    }
                    )),
                    postEventSubscription: (e, t) => u({
                        method: "POST",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/events/metadata/subscriptions`,
                        withCredentials: !0,
                        data: t
                    }, e).then((function(e) {
                        return e.data
                    }
                    )),
                    postEventSubscriptions: (e, t) => u({
                        method: "POST",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/events/metadata/subscriptions/bulk`,
                        withCredentials: !0,
                        data: {
                            subscriptions: t
                        }
                    }, e).then((function(e) {
                        return e.data
                    }
                    )),
                    putEventSubscription: (e, t, n) => u({
                        method: "PUT",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/events/metadata/subscriptions/${t}`,
                        withCredentials: !0,
                        data: n
                    }, e).then((function(e) {
                        return e.data
                    }
                    )),
                    fetchOnvifCameraTopics: e => u({
                        method: "GET",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/events/metadata/onvif-topics`,
                        withCredentials: !0
                    }, e).then((function(e) {
                        return e.data
                    }
                    )),
                    fetchEventCategories: e => u({
                        method: "GET",
                        url: `${o.orchidUri({
                            id: e.id,
                            uri: e.uri
                        })}/service/events/metadata/categories`,
                        withCredentials: !0
                    }, e).then((function(e) {
                        return e.data.categories ? e.data.categories : Promise.reject(e.data)
                    }
                    )).catch((function(e) {
                        return Promise.reject(e)
                    }
                    )),
                    updateCameraTags: (e, t, n) => u({
                        method: "PATCH",
                        url: e.uri + "/service/cameras/" + t,
                        data: n
                    }, {
                        ...e,
                        isAvailable: !0
                    }).then((function(e) {
                        return d(e.data.camera),
                        e.data
                    }
                    )).catch((function(e) {
                        throw {
                            ...e,
                            statusText: e.data.reason
                        }
                    }
                    )),
                    updateServerTags: (e, t, n) => u({
                        method: "PATCH",
                        url: e.uri + "/service/servers/" + t,
                        data: n
                    }, {
                        ...e,
                        isAvailable: !0
                    }).then((function(e) {
                        return e.data
                    }
                    )).catch((function(e) {
                        throw {
                            ...e,
                            statusText: e.data.reason
                        }
                    }
                    ))
                }
            }
            function gt(e, t, n) {
                const i = this
                  , a = {
                    ping: "ping",
                    ws: "ws",
                    unknown: "unknown"
                };
                let r;
                return i.reason = a.unknown,
                {
                    reasons: a,
                    die: function(s) {
                        i.reason = s || a.unknown,
                        w.fusionDestroyed = !0,
                        re(r) && (r = t.get("ControlledShutdownService"));
                        let o = t.get("InactivityMonitorService");
                        !1 === re(o) && o.stop(),
                        r.shouldHandleApplicationDeathNormally && n((function() {
                            t.get("$mdDialog").cancel();
                            const n = t.get("MatDialog");
                            !1 === re(n) && n.closeAll();
                            var i = document.getElementsByTagName("navigation")[0];
                            void 0 !== i && i.parentNode.removeChild(i),
                            e.appDestroyed = !0
                        }
                        ), 3e3)
                    },
                    reason: () => i.reason
                }
            }
            angular.module("ipconfigure.orchid.singularity").factory("OrchidDataService", pt),
            pt.$inject = ["$injector", "$http", "$q", "$rootScope", "FusionConfigService", "AuthenticationService", "UtilityService", "OrchidProxyService", "SessionIdService"],
            gt.$inject = ["$rootScope", "$injector", "$timeout"],
            angular.module("ipconfigure.orchid.singularity").factory("DeathService", gt);
            var ft, vt, yt, bt, St = n(16716);
            function Ct(e) {
                return e.type === vt.Group
            }
            function wt(e) {
                return e.type === vt.Server
            }
            function It(e) {
                return e.type === vt.Group || e.type === vt.Server
            }
            function Tt(e) {
                if (/^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/.test(e)) {
                    return e.split(".").map((e => ("000" + e).slice(-3))).join(".")
                }
                return e.toLowerCase()
            }
            function Et(e, t) {
                return e + Tt(t.replace(e, ""))
            }
            function _t(e, t, n) {
                return (null == n ? void 0 : n.ignoreCase) ? e.toLowerCase() > t.toLowerCase() ? 1 : e.toLowerCase() < t.toLowerCase() ? -1 : 0 : e > t ? 1 : e < t ? -1 : 0
            }
            function xt(e) {
                return JSON.parse(JSON.stringify(e))
            }
            function Dt(e, t) {
                if (!(e instanceof Object))
                    return e;
                const n = [];
                for (const i in e)
                    (!0 === Object.prototype.hasOwnProperty.call(e, i) && !t || t && "object" == typeof e[i]) && n.push({
                        key: i,
                        value: e[i]
                    });
                return n
            }
            function Ot(e) {
                return "[object Array]" === toString.apply(e)
            }
            function At(e) {
                return "[object Date]" === toString.apply(e)
            }
            function Rt(e) {
                return "[object RegExp]" === toString.apply(e)
            }
            function Pt(e) {
                return e && e.document && e.location && e.alert && e.setInterval
            }
            function kt(e, t) {
                if (e === t)
                    return !0;
                if (null === e || null === t)
                    return !1;
                if (e != e && t != t)
                    return !0;
                const n = typeof e;
                let i, a, r;
                if (n === typeof t && "object" === n) {
                    if (!Ot(e)) {
                        if (At(e))
                            return At(t) && e.getTime() === t.getTime();
                        if (Rt(e) && Rt(t))
                            return e.toString() === t.toString();
                        if (Pt(e) || Pt(t) || Ot(t))
                            return !1;
                        if (Object.keys(e).length !== Object.keys(t).length)
                            return !1;
                        for (a in r = {},
                        e)
                            if ("function" != typeof e[a]) {
                                if (!kt(e[a], t[a]))
                                    return !1;
                                r[a] = !0
                            }
                        return !0
                    }
                    if (!Ot(t))
                        return !1;
                    if ((i = e.length) === t.length) {
                        for (a = 0; a < i; a++)
                            if (!kt(e[a], t[a]))
                                return !1;
                        return !0
                    }
                }
                return !1
            }
            function Mt(e, t, n, i, a) {
                let r = function(e, t) {
                    const n = {
                        renderItems: [],
                        runlengthEncoding: []
                    };
                    void 0 !== t && (void 0 !== e && n.renderItems.push({
                        type: vt.Label,
                        name: L.messages.bag.groups(),
                        nesting: 0,
                        msgType: yt.Header
                    }),
                    null === t || 0 === t.groups.length ? n.renderItems.push({
                        type: vt.Label,
                        name: L.messages.bag.searchDidNotMatchGroupedCams(),
                        nesting: 0,
                        msgType: yt.FilterMismatch
                    }) : (t.groups.sort(( (e, t) => jt(e.name, t.name))),
                    t.groups.forEach((e => {
                        var t, i;
                        const a = !!e.mapConfiguration
                          , r = !a || (!e.hideCamerasInBag || 0 !== e.groups.length);
                        n.renderItems.push({
                            type: vt.Group,
                            name: e.name,
                            nesting: 0,
                            isExpanded: !1,
                            groupId: e.id,
                            isMap: a,
                            hideCamerasInBag: e.hideCamerasInBag,
                            canExpand: r,
                            mapImageUrl: null === (i = null === (t = e.mapConfiguration) || void 0 === t ? void 0 : t.configuration) || void 0 === i ? void 0 : i.mapImage
                        })
                    }
                    ))));
                    void 0 !== e && (void 0 !== t && n.renderItems.push({
                        type: vt.Label,
                        name: L.messages.bag.servers(),
                        nesting: 0,
                        msgType: yt.Header
                    }),
                    null === e || 0 === e.length ? n.renderItems.push({
                        type: vt.Label,
                        name: L.messages.bag.searchDidNotMatchCams(),
                        nesting: 0,
                        msgType: yt.FilterMismatch
                    }) : (e.sort(( (e, t) => jt(e.name, t.name))),
                    e.forEach((e => {
                        n.renderItems.push({
                            type: vt.Server,
                            name: e.name,
                            nesting: 0,
                            isExpanded: !1,
                            canExpand: !0,
                            orchidId: e.id,
                            serverError: !e.isAvailable
                        })
                    }
                    ))));
                    return n
                }(e, t);
                if (void 0 === n)
                    return r.runlengthEncoding = Ut(r.renderItems),
                    r;
                const s = n.renderItems.filter((e => It(e) && e.isExpanded));
                let o = 0
                  , c = s.filter((e => e.nesting === o));
                for (; c.length > 0; )
                    c.forEach((n => {
                        if (null != t && Ct(n)) {
                            const e = r.renderItems.findIndex((e => Ct(e) && e.groupId === n.groupId));
                            -1 !== e && (r = Lt(r, e, t, i, a))
                        } else if (null != e && wt(n)) {
                            const t = r.renderItems.findIndex((e => wt(e) && e.orchidId === n.orchidId));
                            if (-1 !== t) {
                                const s = e.find((e => e.id === n.orchidId));
                                void 0 !== s && (r = Nt(r, t, s, i, a))
                            }
                        }
                    }
                    )),
                    o++,
                    c = s.filter((e => e.nesting === o));
                return r.runlengthEncoding = Ut(r.renderItems),
                r
            }
            function Lt(e, t, n, i, a) {
                const r = function(e, t) {
                    if (e < 0 || e >= t.length)
                        throw new Error("Invalid render item index");
                    const n = t[e];
                    if (!Ct(n))
                        throw new Error("Invalid render item. Expected a Group item.");
                    const i = [n.groupId];
                    let a = n.nesting;
                    if (a > 0)
                        for (let n = e; n >= 0; n--) {
                            const e = t[n];
                            if (Ct(e) && e.nesting < a && (a--,
                            i.push(e.groupId),
                            0 === a))
                                break
                        }
                    if (0 !== a)
                        throw new Error("Error determining nesting group info!");
                    return i
                }(t, e.renderItems)
                  , s = function(e, t) {
                    let n = t;
                    for (; e.length > 0; ) {
                        const t = e.pop();
                        if (n = n.groups.find((e => e.id === t)),
                        void 0 === n)
                            throw new Error("Error retrieving group from main structure")
                    }
                    return n
                }(r, n);
                s.mapConfiguration && s.hideCamerasInBag && (s.cameras = []);
                const o = function(e, t, n) {
                    const i = [];
                    e.cameras.forEach((e => {
                        const n = t(e.orchidId, e.id);
                        null !== n && i.push(n)
                    }
                    ));
                    const a = $t(i, n);
                    e.groups.sort(( (e, t) => jt(e.name, t.name))),
                    e.groups.forEach((e => {
                        var t, n;
                        const i = !!!e.mapConfiguration || (!e.hideCamerasInBag || 0 !== e.groups.length);
                        a.push({
                            type: vt.Group,
                            name: e.name,
                            nesting: 0,
                            isExpanded: !1,
                            groupId: e.id,
                            isMap: !!e.mapConfiguration,
                            hideCamerasInBag: e.hideCamerasInBag,
                            canExpand: i,
                            mapImageUrl: null === (n = null === (t = e.mapConfiguration) || void 0 === t ? void 0 : t.configuration) || void 0 === n ? void 0 : n.mapImage
                        })
                    }
                    )),
                    0 === a.length && a.push({
                        type: vt.Label,
                        name: L.messages.bag.cameraGroup.noCamerasConfiguredInGroup(),
                        nesting: 0,
                        msgType: yt.Empty
                    });
                    return a
                }(s, i, a);
                return Ft(e, t, o)
            }
            function Nt(e, t, n, i, a) {
                const r = [];
                n.cameras.forEach((e => {
                    const t = i(n.id, e.id);
                    null !== t && r.push(t)
                }
                ));
                const s = $t(r, a);
                return n.isAvailable ? 0 === s.length && s.push({
                    type: vt.Label,
                    name: L.messages.bag.noCamsConfiguredInServer(),
                    nesting: 0,
                    msgType: yt.Empty
                }) : s.unshift({
                    type: vt.Label,
                    name: n.failureReason,
                    nesting: 0,
                    msgType: yt.Error
                }),
                Ft(e, t, s)
            }
            function Ft(e, t, n) {
                if (t >= e.renderItems.length)
                    throw new Error("renderItemIndex is not within the renderItems range!");
                const i = e.renderItems[t]
                  , a = i.nesting;
                if (!It(i))
                    throw new Error("Target render item is not an expandable item!");
                if (i.isExpanded)
                    throw new Error("Target render item is already expanded");
                n.forEach((e => {
                    e.nesting += a + 1
                }
                ));
                const r = {
                    renderItems: [...e.renderItems],
                    runlengthEncoding: []
                };
                r.renderItems.splice(t + 1, 0, ...n);
                return r.renderItems[t].isExpanded = !0,
                r.runlengthEncoding = Ut(r.renderItems),
                r
            }
            function Ut(e) {
                let t = null
                  , n = 0;
                const i = [];
                return e.forEach((e => {
                    const a = e.type === vt.Preview || e.type === vt.GridRow ? bt.Big : bt.Small;
                    t === a ? n++ : (n > 0 && null !== t && i.push({
                        runlength: n,
                        category: t
                    }),
                    n = 1,
                    t = a)
                }
                )),
                n > 0 && null !== t && i.push({
                    runlength: n,
                    category: t
                }),
                i
            }
            function $t(e, t) {
                const n = [];
                if (0 === e.length)
                    return n;
                if (e.sort(( (e, t) => jt(Tt(e.name), Tt(t.name)))),
                t === ft.Grid) {
                    const t = 3;
                    let i = [];
                    e.forEach((e => {
                        i.push(e),
                        i.length >= t && (n.push({
                            type: vt.GridRow,
                            name: "",
                            nesting: 0,
                            previews: i
                        }),
                        i = [])
                    }
                    )),
                    0 !== i.length && n.push({
                        type: vt.GridRow,
                        name: "",
                        nesting: 0,
                        previews: i
                    })
                } else
                    e.forEach((e => {
                        n.push({
                            type: vt.Preview,
                            name: e.name,
                            nesting: 0,
                            detail: e.detail,
                            orchidId: e.orchidId,
                            cameraId: e.cameraId,
                            orchidName: e.orchidName,
                            active: e.active
                        })
                    }
                    ));
                return n
            }
            function jt(e, t) {
                const n = e.toUpperCase()
                  , i = t.toUpperCase();
                return n < i ? -1 : n > i ? 1 : 0
            }
            function Vt(e, t) {
                var n, i;
                const a = xt(e);
                for (const e of a)
                    e.orchids = null === (n = e.orchids) || void 0 === n ? void 0 : n.map((e => e === t.oldOrchidId ? t.newOrchidId : e)),
                    e.cameras = null === (i = e.cameras) || void 0 === i ? void 0 : i.map((e => {
                        var n, i;
                        return e.orchidId === t.oldOrchidId && (e.orchidId = t.newOrchidId,
                        e.id = null !== (i = null === (n = t.mappedCameras.find((t => t.oldCameraId === e.id))) || void 0 === n ? void 0 : n.newCameraId) && void 0 !== i ? i : e.id),
                        e
                    }
                    )),
                    e.groups = Vt(e.groups, t);
                return a
            }
            function Gt(e, t, n, i, a, r, s, c, l, d, u, m, h) {
                let p = this
                  , g = {}
                  , f = e.defer();
                t.orcDict = {};
                const v = new St.x;
                function y(e) {
                    switch (n.debug("Message received", e),
                    e.eventType) {
                    case "USER_LOGGED_OUT":
                        t.$broadcast("logout");
                        break;
                    case "USER_MODIFIED":
                        s.getAuthenticationDataPromise(!0).catch((function() {
                            return t.$broadcast("logout")
                        }
                        ));
                        break;
                    case "ORCHID_SESSION_ID":
                        i = e.orchidId,
                        a = e.sessionId,
                        p.orchidsPromise.then((function() {
                            let e = S(i);
                            o().isDefined(e) && (u.setSessionId(i, a),
                            t.$broadcast("sessionId", {
                                orchid: i,
                                sessionId: a
                            }))
                        }
                        ));
                        break;
                    case "PERMISSIONS_CHANGED":
                        !0 === w.singlePlayerMode || location.reload();
                        break;
                    case "CAMERA_ADDED":
                        x(e.cameraResponse);
                        break;
                    case "CAMERA_MODIFIED":
                        D(e.cameraResponse);
                        break;
                    case "CAMERA_REMOVED":
                        !function(e) {
                            let t = S(e.orchidId)
                              , n = C(e.orchidId, e.id);
                            o().isDefined(n) && (t.cameras.splice(g[e.orchidId].cameras[e.id], 1),
                            g[e.orchidId].cameras[e.id] = void 0,
                            e.defunct = !0,
                            _(e))
                        }(e.cameraResponse);
                        break;
                    case "ORCHID_ADDED":
                        T(e.orchidResponse);
                        break;
                    case "ORCHID_MODIFIED":
                        !function(e) {
                            let i = S(e.id);
                            o().isDefined(i) ? (!function(e, t) {
                                const n = !re(e.version)
                                  , i = !re(t.version);
                                if (n && i && !re(e.version.version) && !re(t.version.version))
                                    return e.version.version === t.version.version && t.version.parsed ? (e.version.major = t.version.major,
                                    e.version.minor = t.version.minor,
                                    e.version.patch = t.version.patch,
                                    void (e.version.parsed = t.version.parsed)) : O(e);
                                if (i)
                                    return void (e.version = t.version);
                                O(e)
                            }(e, i),
                            e.cameras = i.cameras,
                            t.orchids[g[e.id].index] = e,
                            E(e),
                            i.uri !== e.uri && (n.debug("Clearing proxy information for " + e.name),
                            d.setProxyState(e.id, ct.UNKNOWN))) : T(e)
                        }(e.orchidResponse);
                        break;
                    case "ORCHID_REMOVED":
                        !function(e) {
                            let n = S(e.id);
                            o().isDefined(n) && (t.orchids.splice(g[e.id].index, 1),
                            delete g[e.id],
                            e.defunct = !0,
                            E(e),
                            d.setProxyState(e.id, ct.UNKNOWN))
                        }(e.orchidResponse);
                        break;
                    case "ORCHID_ADVANCED_RECOVER":
                        !function(e) {
                            let n = S(e.oldOrchidId);
                            if (!n)
                                return;
                            const i = function(e, t) {
                                if (e.id !== t.oldOrchidId)
                                    throw Error(`The Orchid ${e.id} does not match the OrchidAdvancedRecover Orchid id ${t.oldOrchidId}. Unrecoverable.`);
                                const n = Object.assign(Object.assign({}, e), {
                                    id: t.newOrchidId,
                                    cameras: new Array
                                })
                                  , i = e.cameras;
                                return t.mappedCameras.forEach((e => {
                                    const t = i.find((t => t.id === e.oldCameraId));
                                    t && n.cameras.push(Object.assign(Object.assign({}, t), {
                                        id: e.newCameraId
                                    }))
                                }
                                )),
                                n
                            }(n, e);
                            t.orchids[g[n.id].index] = i,
                            d.setProxyState(n.id, ct.UNKNOWN),
                            h.clear(),
                            t.$broadcast("advancedRecover", e),
                            m.isRecoveryRefreshNeeded() && m.alert({
                                reason: "recovery",
                                recoveredOrchid: n
                            });
                            r.fetchCameraGroups(!0).then((function(n) {
                                const i = Vt(n.data.groups, e);
                                t.$broadcast("advancedRecoverGroups", i)
                            }
                            ))
                        }(e);
                        break;
                    case "LAYOUT_ADDED":
                        t.$broadcast("stageAdded", e.layoutResponse);
                        break;
                    case "LAYOUT_MODIFIED":
                        t.$broadcast("stageModified", e.layoutResponse);
                        break;
                    case "LAYOUT_REMOVED":
                        t.$broadcast("stageRemoved", e.layoutResponse);
                        break;
                    case "CAMERA_GROUPS_MODIFIED":
                        t.$broadcast("cameraGroupsModified", e.groups);
                        break;
                    case "ABOUT_CONFIG_MODIFIED":
                        c.updateConfigPostAuth(e.configResponse);
                        break;
                    case "SMTP_SERVER_ADDED":
                        t.$broadcast("smtpServerAdded", e.smtpServer);
                        break;
                    case "SMTP_SERVER_MODIFIED":
                        t.$broadcast("smtpServerModified", e.smtpServer);
                        break;
                    case "SMTP_SERVER_REMOVED":
                        t.$broadcast("smtpServerRemoved", e.smtpServer);
                        break;
                    case "NOTIFICATION_ADDED":
                        t.$broadcast("notificationAdded", e.notification);
                        break;
                    case "NOTIFICATION_MODIFIED":
                        t.$broadcast("notificationModified", e.notification);
                        break;
                    case "NOTIFICATION_REMOVED":
                        t.$broadcast("notificationRemoved", e.notification)
                    }
                    var i, a;
                    v.next(e)
                }
                function b() {
                    p.eventSubscription = l.open({
                        url: l.constructEventsUrl(),
                        openObserver: {
                            next: function() {
                                return n.debug("Events web socket opened"),
                                void f.resolve()
                            }
                        }
                    }).subscribe((function(e) {
                        return y(e)
                    }
                    ), (function(e) {
                        return function(e) {
                            n.error("Failed to open web socket", e),
                            f.reject(e)
                        }(e)
                    }
                    ))
                }
                function S(e) {
                    let n;
                    if (t.orchids) {
                        if (o().isUndefined(g[e]) && (g[e] = {
                            cameras: {},
                            index: 0
                        }),
                        o().isUndefined(t.orchids[g[e].index]) || t.orchids[g[e].index].id !== e) {
                            for (let i = 0; i < t.orchids.length; ++i)
                                if (n = t.orchids[i],
                                n.id === e)
                                    return g[e].index = i,
                                    n;
                            return
                        }
                        return t.orchids[g[e].index]
                    }
                }
                function C(e, t) {
                    let n, i = S(e);
                    if (o().isUndefined(g[e].cameras) && (g[e].cameras = {}),
                    o().isDefined(i)) {
                        if (o().isUndefined(g[e].cameras[t]) || o().isUndefined(i.cameras[g[e]]) || o().isUndefined(i.cameras[g[e].cameras[t]]) || i.cameras[g[e].cameras[t]].id !== t) {
                            for (let a = 0; a < i.cameras.length; ++a)
                                if (n = i.cameras[a],
                                n.id === t)
                                    return g[e].cameras[t] = a,
                                    n;
                            return
                        }
                        return i.cameras[g[e].cameras[t]]
                    }
                }
                function I(e) {
                    return t.isOrchid ? (e.camerasPromise = r.fetchCameras(e).then((function(n) {
                        e.cameras = !0 === t.isOrchid ? n.data.cameras : n.data,
                        R([e])
                    }
                    ), (function(e) {
                        n.error("Failed to refresh Cameras", e)
                    }
                    )),
                    e.camerasPromise) : r.purgeOrchid(e)
                }
                function T(e) {
                    let i = S(e.id);
                    o().isUndefined(i) ? (e.cameras = [],
                    O(e),
                    t.orchids.push(e),
                    g[e.id] = {
                        index: t.orchids.length - 1,
                        cameras: {}
                    },
                    t.$broadcast("orchidAdded", e)) : n.warn("Received event to add Orchid with ID " + e.id + ", but it already exists")
                }
                function E(e) {
                    t.$broadcast("orchidChanged", e)
                }
                function _(e) {
                    t.$broadcast("cameraChanged", e)
                }
                function x(e) {
                    let t = S(e.orchidId)
                      , i = C(e.orchidId, e.id);
                    o().isUndefined(t) ? n.warn(`The orchid ${e.orchidId} could not be found to add the camera ${e.name}`) : o().isUndefined(i) ? o().isDefined(t) ? (o().isUndefined(t.cameras) && (t.cameras = []),
                    t.cameras.push(e),
                    o().isUndefined(g[e.orchidId].cameras) && (g[e.orchidId].cameras = {}),
                    g[e.orchidId].cameras[e.id] = t.cameras.length - 1,
                    _(e)) : n.warn("Cannot add camera with ID " + e.id + ", its " + a.brand.CHILD_NAME + " server does not exist.") : (n.warn("Received event to add Camera with ID " + e.id + ", but it already exists"),
                    D(e))
                }
                function D(e) {
                    let t = S(e.orchidId);
                    if (o().isUndefined(t))
                        return void n.warn(`The orchid ${e.orchidId} could not be found to replace the camera ${e.name}`);
                    let i = C(e.orchidId, e.id);
                    o().isDefined(i) ? (t.cameras[g[e.orchidId].cameras[e.id]] = e,
                    _(e)) : x(e)
                }
                function O(e) {
                    re(e) || re(e.version) || re(e.version.version) || Object.assign(e.version, function(e) {
                        const t = {
                            major: Number.MIN_VALUE,
                            minor: Number.MIN_VALUE,
                            patch: "",
                            parsed: !1
                        };
                        if (ce(e)) {
                            const n = /(?:\s?v?)([0-9]\d*)\.([0-9]\d*)\.?(.*)?/gi.exec(e.trim());
                            re(n) || (t.parsed = !0,
                            t.major = parseInt(n[1], 10),
                            t.minor = parseInt(n[2], 10),
                            re(n[3]) || (t.patch = n[3]))
                        }
                        return t
                    }(e.version.version))
                }
                function A(e) {
                    p.jwt = e,
                    o().isDefined(p.jwt) && o().isDefined(t.orchids) && o().forEach(t.orchids, (function(e) {
                        e.permissions = {},
                        e.permissions.token = p.jwt
                    }
                    ))
                }
                function R(e) {
                    let n = {};
                    if (e) {
                        for (let t = 0; t < e.length; ++t) {
                            let i = e[t]
                              , a = {
                                index: t,
                                cameras: {}
                            };
                            for (let e = 0; e < i.cameras.length; ++e)
                                a.cameras[i.cameras[e].id] = e;
                            n[i.id] = a
                        }
                        t.orcDict = n
                    }
                }
                function P() {
                    s.getAuthenticationDataPromise().then((function() {
                        b()
                    }
                    )),
                    t.orchids = void 0,
                    p.orchidsPromise = e((function(e, a) {
                        f.promise.then((function() {
                            r.fetchOrchids().then((function(n) {
                                let a = n;
                                !0 === t.isOrchid ? o().forEach(a, (function(n) {
                                    p.maxPlayerCount = n.maxPlayerCount,
                                    O(n),
                                    I(n).then((function() {
                                        t.orchids = a,
                                        i((function() {
                                            e(a)
                                        }
                                        ))
                                    }
                                    ))
                                }
                                )) : (a.forEach((function(e) {
                                    return O(e)
                                }
                                )),
                                t.orchids = a,
                                i((function() {
                                    e(a)
                                }
                                )))
                            }
                            ), (function(e) {
                                n.error("Failed to fetch Orchids", e),
                                a({
                                    reason: "error",
                                    error: e
                                })
                            }
                            ))
                        }
                        ), (function(e) {
                            n.error("Authentication failed", e),
                            a({
                                reason: "authentication-failed"
                            })
                        }
                        ))
                    }
                    )),
                    p.orchidsPromise,
                    p.orchidWatch && p.orchidWatch(),
                    p.orchidsPromise.then((function() {
                        p.orchidWatch = t.$watchCollection((function() {
                            return t.orchids
                        }
                        ), (function(e, t) {
                            R(e)
                        }
                        ))
                    }
                    ))
                }
                return p.maxPlayerCount = void 0,
                {
                    get maxPlayerCount() {
                        return p.maxPlayerCount
                    },
                    sockOpen: function() {
                        return f
                    },
                    init: P,
                    closeEventSocket: function() {
                        p.eventSubscription && p.eventSubscription.unsubscribe(),
                        p.orchidsPromise = void 0,
                        l.close()
                    },
                    fetchCameras: function(a, s) {
                        let c = S(a.id);
                        return o().isDefined(c.camerasPromise) && o().isDefined(c.cameras) ? e((function(e, t) {
                            i((function() {
                                c.camerasPromise.then((function() {
                                    e(c.cameras)
                                }
                                ))
                            }
                            ))
                        }
                        )) : (c.cameras = [],
                        e((function(e, i) {
                            c.camerasPromise = r.fetchCameras(c).then((function(n) {
                                let i = !0 === t.isOrchid ? n.data.cameras : n.data;
                                c.cameras = i,
                                e(c.cameras)
                            }
                            ), (function(e) {
                                n.error("Failed to fetch Cameras", e),
                                i(e)
                            }
                            ))
                        }
                        )))
                    },
                    refreshCameras: I,
                    findOrchid: S,
                    findCamera: C,
                    replaceCamera: function(e) {
                        D(e)
                    },
                    messages$: v,
                    subscribe: function(e) {
                        return v.subscribe(e)
                    },
                    hasOrchids: function() {
                        return t.orchids && t.orcDict
                    },
                    orchidsPromise: function() {
                        return o().isUndefined(p.orchidsPromise) && P(),
                        p.orchidsPromise
                    },
                    setJwt: function(e) {
                        A(e)
                    }
                }
            }
            !function(e) {
                e.Large = "LARGE",
                e.Detail = "DETAIL",
                e.Grid = "GRID"
            }(ft || (ft = {})),
            function(e) {
                e.Preview = "PREVIEW",
                e.GridRow = "GRIDROW",
                e.Group = "GROUP",
                e.Server = "SERVER",
                e.Label = "LABEL"
            }(vt || (vt = {})),
            function(e) {
                e.Header = "HEADER",
                e.Empty = "EMPTY",
                e.Error = "ERROR",
                e.FilterMismatch = "FILTERMISMATCH"
            }(yt || (yt = {})),
            function(e) {
                e[e.Big = 0] = "Big",
                e[e.Small = 1] = "Small"
            }(bt || (bt = {})),
            o().module("ipconfigure.orchid.singularity").factory("RenewableService", Gt),
            Gt.$inject = ["$q", "$rootScope", "$log", "$timeout", "BrandService", "DataService", "AuthenticationService", "FusionConfigService", "WebSocketEventsService", "OrchidProxyService", "SessionIdService", "AppRefreshAlertService", "ManagedRecordersService"],
            angular.module("ipconfigure.orchid.singularity").factory("BrowserHacksService", ["$rootScope", "$timeout", function(e, t) {
                return {
                    correctDialogPosition: function() {
                        return e.$watch((function() {
                            return document.body.childNodes.length
                        }
                        ), (function() {
                            t((function() {
                                var e = document.getElementsByClassName("md-dialog-container");
                                angular.forEach(e, (function(e) {
                                    e.style.top = -1 * document.body.style.top.replace("px", "") + "px"
                                }
                                ))
                            }
                            ), 100)
                        }
                        ))
                    }
                }
            }
            ]);
            n.p;
            var Bt = n(84440);
            const zt = {
                info: "fa-solid fa-circle-info",
                info_light: "fa-regular fa-circle-info",
                hint: "fa-solid fa-circle-question",
                hint_light: "fa-regular fa-circle-question",
                success: "fa-solid fa-check",
                unavailable: "fa-regular fa-ban",
                error: "fa-solid fa-triangle-exclamation",
                error_light: "fa-regular fa-triangle-exclamation",
                search: "fa-regular fa-magnifying-glass",
                servers: {
                    server: "fa-regular fa-server",
                    add: "fa-kit fa-server-add",
                    settings: "fa-kit fa-server-edit",
                    search: "fa-kit fa-server-search",
                    error: "fa-kit fa-server-error"
                },
                camera: "fa-solid fa-video",
                smart_search: "fa-kit fa-smart-search",
                map: "fa-solid fa-location-dot",
                clock: "fa-regular fa-clock",
                date: "fa-regular fa-calendar",
                cloud: "fa-solid fa-cloud",
                email: "fa-solid fa-envelope",
                email_alert: "fa-regular fa-paper-plane",
                website: "fa-solid fa-globe",
                user: "fa-solid fa-user",
                users: "fa-solid fa-users",
                session: "fa-kit fa-session",
                ballot_check: "fa-regular fa-ballot-check",
                tag: "fa-regular fa-tag",
                wait: "fa-regular fa-hourglass-clock"
            }
              , Ht = {
                add: "fa-solid fa-plus",
                remove: "fa-solid fa-minus",
                close: "fa-solid fa-xmark",
                delete: "fa-regular fa-trash-can",
                edit: "fa-solid fa-pencil",
                copy: "fa-regular fa-copy",
                clipboard: "fa-solid fa-clipboard",
                save: "fa-solid fa-floppy-disk",
                more_actions: "fa-solid fa-ellipsis-v",
                refresh: "fa-solid fa-rotate",
                repeat: "fa-solid fa-repeat",
                user_add: "fa-solid fa-user-plus",
                lock: "fa-solid fa-lock"
            }
              , Wt = {
                stage: "fa-solid fa-eye",
                servers: "fa-regular fa-server",
                users: "fa-solid fa-user",
                camera_groups: "fa-kit fa-camera-group",
                camera_configuration: "fa-kit fa-video-camera",
                retention_policy: "fa-solid fa-database",
                permission_groups: "fa-solid fa-users",
                notifications: "fa-solid fa-bell",
                library: "fa-solid fa-bookmark",
                licensing: "fa-solid fa-id-card",
                events: {
                    viewer: "fa-kit fa-events",
                    settings: "fa-kit fa-events-subscriptions"
                },
                account_settings: "fa-solid fa-user-gear",
                version_info: "fa-solid fa-circle-info",
                plugin: "fa-solid fa-puzzle-piece",
                system_status: "fa-solid fa-medkit",
                system_report: "fa-regular fa-newspaper",
                audit_logs: "fa-kit fa-user-activity",
                system_alerts: "fa-solid fa-triangle-exclamation",
                motion_alerts: "fa-solid fa-bell",
                smtp_servers: "fa-solid fa-envelope",
                activation: "fa-solid fa-plug",
                advanced_settings: "fa-solid fa-cogs",
                sign_out: "fa-regular fa-power-off"
            }
              , qt = {
                camera: "fa-solid fa-video",
                camera_light: "fa-regular fa-video",
                camera_up: "fa-solid fa-circle-up",
                camera_down: "fa-solid fa-circle-down",
                camera_disabled: "fa-solid fa-video-slash",
                stream: "fa-kit fa-video-camera",
                stream_primary: "fa-kit fa-primary-stream",
                stream_up: "fa-solid fa-circle-up",
                stream_down: "fa-solid fa-circle-down",
                stream_unknown: "fa-solid fa-circle-question",
                stream_disabled: "fa-solid fa-minus",
                camera_dewarp: "fa-kit fa-dewarp",
                camera_dewarp_control: "fa-solid fa-globe",
                camera_motion: "fa-regular fa-radar",
                camera_ptz: "fa-kit fa-ptz",
                camera_ptz_control: "fa-regular fa-crosshairs",
                camera_mic_on: "fa-solid fa-microphone",
                camera_mic_off: "fa-solid fa-microphone-slash",
                camera_webrtc: "fa-kit fa-sitting-rabbit",
                camera_lbm: "fa-kit fa-turtle-land",
                camera_fullscreen: "fa-solid fa-maximize",
                camera_windowed: "fa-solid fa-minimize",
                camera_status: "fa-regular fa-chart-column",
                camera_link: "fa-kit fa-link",
                camera_unlink: "fa-kit fa-unlink",
                camera_search: "fa-regular fa-magnifying-glass",
                camera_thumbnail_search: "fa-solid fa-filter",
                camera_smart_search: "fa-regular fa-table-cells-large",
                camera_screenshot: "fa-regular fa-image"
            }
              , Yt = {
                windows: "fa-kit fa-windows",
                google: "fa-kit fa-google",
                other_providers: "fa-solid fa-right-to-bracket",
                chrome: "fa-kit fa-chrome"
            };
            function Xt(e, t, n, i) {
                var a = this;
                a.msgs = {
                    ...L.messages.navigation
                },
                a.brand = w.brand,
                a.router = i,
                a.state = a.router.url,
                a.authenticationData = t.getAuthenticationData(),
                a.isAdmin = a.authenticationData.isAdministrator(),
                a.isRecorderAdmin = a.authenticationData.isRecorderAdministrator(),
                a.isManager = a.authenticationData.isAdministrator() || "manager" === a.authenticationData.getRole(),
                a.isViewer = a.authenticationData.isAdministrator() || "manager" === a.authenticationData.getRole() || "viewer" === a.authenticationData.getRole(),
                a.noEventsAccess = "live viewer" === a.authenticationData.getRole(),
                a.isOrchid = e.isOrchid,
                a.hasLibraryAccess = a.authenticationData._libraryAccess,
                a.isPWA = w.isPWA,
                a._openSubmenu = null,
                a.$onInit = function() {
                    a.features = [{
                        name: a.msgs.stage(),
                        faIcon: Wt.stage,
                        show: "menu" === a.display,
                        state: "/stage",
                        subMenuItems: []
                    }, {
                        name: a.msgs.events(),
                        faIcon: Wt.events.viewer,
                        show: !1 === a.isOrchid || a.isViewer,
                        state: "/events-viewer",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.library(),
                        faIcon: Wt.library,
                        show: a.hasLibraryAccess && !a.isOrchid,
                        state: "/library",
                        subMenuItems: []
                    }],
                    a.menuItems = [{
                        name: a.msgs.servers(),
                        faIcon: Wt.servers,
                        show: (a.isAdmin || a.isRecorderAdmin) && !a.isOrchid,
                        state: "/orchids",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.cameraConfiguration(),
                        faIcon: Wt.camera_configuration,
                        show: a.isAdmin && a.isOrchid,
                        state: "/cameras",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.retentionPolicy(),
                        faIcon: Wt.retention_policy,
                        show: a.isAdmin && a.isOrchid,
                        state: "/retention",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.users(),
                        faIcon: Wt.users,
                        show: a.isAdmin,
                        state: "/users",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.cameraGroups(),
                        faIcon: Wt.camera_groups,
                        show: a.isAdmin && !a.isOrchid,
                        state: "/camera-groups",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.permissionGroups(),
                        faIcon: Wt.permission_groups,
                        show: a.isAdmin && !a.isOrchid,
                        state: "/permission-groups",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.eventSubscriptions(),
                        faIcon: Wt.events.settings,
                        show: a.isAdmin || a.isRecorderAdmin,
                        state: "/events-subscriptions",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.notifications(),
                        faIcon: Wt.notifications,
                        show: a.isAdmin && !a.isOrchid,
                        state: "/notifications",
                        subMenuItems: [{
                            name: L.messages.navigation.systemAlerts(),
                            faIcon: Wt.system_alerts,
                            show: a.isAdmin && !a.isOrchid,
                            state: "/system-alerts"
                        }, {
                            name: L.messages.navigation.motionAlerts(),
                            faIcon: Wt.motion_alerts,
                            show: a.isAdmin && !a.isOrchid,
                            state: "/motion-alerts"
                        }, {
                            name: L.messages.navigation.smtpServers(),
                            faIcon: Wt.smtp_servers,
                            show: a.isAdmin && !a.isOrchid,
                            state: "/smtp-servers"
                        }]
                    }, {
                        name: L.messages.navigation.licensing(),
                        faIcon: Wt.licensing,
                        show: a.isAdmin && !a.isOrchid && "ALTO" !== a.brand,
                        state: "/licensing",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.systemStatus(),
                        faIcon: Wt.system_status,
                        show: (a.isManager || a.isAdmin) && a.isOrchid,
                        state: "/system-status",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.systemReport(),
                        faIcon: Wt.system_report,
                        show: (a.isManager || a.isAdmin) && a.isOrchid,
                        state: "/system-report",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.auditLogs(),
                        faIcon: Wt.audit_logs,
                        show: a.isAdmin && a.isOrchid,
                        state: "/audit-logs",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.activation(),
                        faIcon: Wt.activation,
                        show: a.isAdmin && a.isOrchid,
                        state: "/activation",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.advancedSettings(),
                        faIcon: Wt.advanced_settings,
                        show: a.isAdmin && a.isOrchid,
                        state: "/advanced-settings",
                        subMenuItems: []
                    }],
                    a.accountManagementSettings = [{
                        name: L.messages.navigation.versionInformation(),
                        faIcon: Wt.version_info,
                        show: !0,
                        state: "/version",
                        subMenuItems: []
                    }, {
                        name: L.messages.navigation.accountSettings(),
                        faIcon: Wt.account_settings,
                        show: !a.isOrchid,
                        state: "/account-settings",
                        subMenuItems: []
                    }],
                    a.menuItemsVisible = function() {
                        return a.menuItems.filter((function(e) {
                            return e.show
                        }
                        )).length
                    }
                }
                ,
                a.signOut = function() {
                    a.onSignOut && a.onSignOut()
                }
                ,
                a.leave = function() {
                    a.router.navigateByUrl("/external-redirect?redirectTo=https://pwa.ipconfigure.com/select")
                }
                ,
                a.open = function(e, t) {
                    let n = arguments.length > 2 && void 0 !== arguments[2] && arguments[2];
                    !1 !== n ? (e !== a._openSubmenu && a._openSubmenu && a._openSubmenu.close(),
                    a._openSubmenu = e,
                    e.open(t)) : e.open(t)
                }
                ,
                n.getPluginsPromise().then((function() {
                    a.plugins = n.getNavigationExtensions()
                }
                )),
                a.toggleNav = function() {
                    a.navOpen = !a.navOpen
                }
                ;
                const r = a.router.events.subscribe((function(e) {
                    e instanceof Bt.m2 && (a.state = e.urlAfterRedirects)
                }
                ));
                a.$onDestroy = function() {
                    r.unsubscribe()
                }
            }
            Xt.$inject = ["$rootScope", "AuthenticationService", "PluginService", "Router"],
            angular.module("ipconfigure.orchid.singularity").directive("navigation", [function() {
                return {
                    restrict: "E",
                    template: n(2610),
                    bindToController: {
                        display: "@",
                        onSignOut: "<"
                    },
                    scope: {},
                    controller: Xt,
                    controllerAs: "navigation"
                }
            }
            ]);
            n(76166);
            let Kt = function() {
                function e() {
                    (0,
                    S.Z)(this, e)
                }
                return (0,
                b.Z)(e, null, [{
                    key: "addWebEventListener",
                    value: function(e, t, n, i) {
                        return e.addEventListener(t, n, i),
                        {
                            emitter: e,
                            eventName: t,
                            handler: n,
                            options: i
                        }
                    }
                }, {
                    key: "removeWebEventListener",
                    value: function(e) {
                        let {emitter: t, eventName: n, handler: i, options: a} = e;
                        t.removeEventListener(n, i, a)
                    }
                }, {
                    key: "removeWebEventListeners",
                    value: function(t) {
                        for (let n = 0; n < t.length; n++)
                            e.removeWebEventListener(t[n]);
                        t.length = 0
                    }
                }, {
                    key: "addEventListener",
                    value: function(e, t, n) {
                        return e.on(t, n),
                        {
                            emitter: e,
                            eventName: t,
                            handler: n
                        }
                    }
                }, {
                    key: "removeEventListener",
                    value: function(e) {
                        let {emitter: t, eventName: n, handler: i} = e;
                        t.off(n, i)
                    }
                }, {
                    key: "removeEventListeners",
                    value: function(t) {
                        for (let n = 0; n < t.length; n++)
                            e.removeEventListener(t[n]);
                        t.length = 0
                    }
                }, {
                    key: "addScopeListener",
                    value: function(e, t, n) {
                        return e.$on(t, n)
                    }
                }, {
                    key: "removeScopeListeners",
                    value: function(e) {
                        for (let t = 0; t < e.length; t++)
                            e[t]();
                        e.length = 0
                    }
                }]),
                e
            }();
            n.p;
            Jt.$inject = ["$mdDialog", "$rootScope", "$timeout", "$filter", "AuthenticationService", "FusionConfigService", "PluginService", "DataService", "OrchidDataService", "RenewableService", "BrowserInfoService", "BrowserHacksService", "PlayerModeService", "Router", "TimeService", "InactivityMonitorService", "UserSettingsService", "SessionIdService", "PerformanceTrackerService", "ManagedRecordersService"];
            const Zt = O("App");
            function Jt(e, t, n, i, a, r, s, o, c, l, d, u, m, h, p, g, f, v, y, b) {
                var S, C, I = this, T = this;
                let E;
                function _(e) {
                    T.orchidTimeOffset = null === e ? 0 : e.offset
                }
                T.router = h,
                t.isOrchid = w.isOrchid,
                t.signingOut = !1,
                R().locale("en"),
                T.orchidTimeOffset = 0,
                T.isUnsupported = d.isIE11() || !d.isChromeWebSocketCompatible(),
                T.isMobileSafari = d.isMobileSafari(),
                T.authenticationData = a.getAuthenticationData(),
                T.isPWA = w.isPWA,
                T.isOrchidAndAdministrator = w.isOrchid && T.authenticationData.isAdministrator(),
                T.resizeListeners = [],
                T.licenses = ["orchid", "fusion", "hybrid", "alto"],
                T.license = "orchid",
                T.licenseChange = function() {
                    w.license = I.license,
                    t.theme = f.getTheme()
                }
                ,
                T.leave = function() {
                    window.location = "https://pwa.ipconfigure.com/select"
                }
                ,
                T.signOut = function() {
                    let {skipDeactivationGuards: e=!1} = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {};
                    const n = {
                        skipAuth: !0,
                        skipDeactivationGuards: e
                    };
                    T.router.navigateByUrl("/sign-in", {
                        state: n
                    }).then((function(n) {
                        !1 !== n ? (t.signingOut = !0,
                        v.clearSessionIds(),
                        y.stop(),
                        p.stopRefreshInterval(),
                        g.stop(),
                        b.clear(),
                        T.orchidInstance && p.removeUpdateListener(T.orchidInstance.id, _),
                        T.routeChangeSub && T.routeChangeSub.unsubscribe(),
                        T.logOutListener && T.logOutListener(),
                        l.closeEventSocket(),
                        t.orchids = void 0,
                        a.deauthenticate().catch((function() {}
                        )),
                        w.isOrchid || r.clearPostAuthConfig(),
                        s.clear()) : e && Zt.error("Navigation failed")
                    }
                    ))
                }
                ,
                T.showTimeWarning = function() {
                    var t = i("timeDuration")(Math.abs(T.orchidTimeOffset), !0, 2);
                    e.show(e.alert().parent(angular.element(document.querySelector("#popupContainer"))).clickOutsideToClose(!0).title(T.msgs.timeDifferenceWarning()).ariaLabel(T.msgs.timeDifferenceWarning()).htmlContent(T.msgs.clientServerTimesOff({
                        HUMAN: t,
                        CLIENT: i("date")(Date.now(), "MMMM d, yyyy h:mm:ss a"),
                        SERVER: i("date")(Date.now() - T.orchidTimeOffset, "MMMM d, yyyy h:mm:ss a")
                    })).ok(T.msgs.dialogs.ok()))
                }
                ,
                T.showErrorDialog = function() {
                    e.show(e.alert().parent(angular.element(document.querySelector("#popupContainer"))).clickOutsideToClose(!0).title(T.errorTitle).htmlContent(T.errorDescriptionTemplate).ariaLabel(T.errorAriaLabel).ok(T.msgs.dialogs.ok()))
                }
                ,
                T.$onDestroy = function() {
                    T.resizeListeners && Kt.removeWebEventListeners(T.resizeListeners),
                    n.cancel(C),
                    S && n.cancel(S),
                    E && n.cancel(E),
                    T.unWatchBrowserHackCorrectDialogPos && T.unWatchBrowserHackCorrectDialogPos(),
                    p.stopRefreshInterval(),
                    y.stop()
                }
                ,
                function() {
                    function i() {
                        t.$broadcast("resize");
                        var e = document.getElementsByClassName("md-dialog-container");
                        angular.forEach(e, (function(e) {
                            e.style.height = ""
                        }
                        )),
                        S = null
                    }
                    function a() {
                        S && n.cancel(S),
                        E && (n.cancel(E),
                        E = null),
                        S = n(i, 150, !1)
                    }
                    T.msgs = {
                        ...L.messages.app,
                        dialogs: L.messages.dialogs
                    },
                    !0 === T.isMobileSafari && (T.unWatchBrowserHackCorrectDialogPos = u.correctDialogPosition());
                    function d() {
                        C = n(h, 1e4, !1)
                    }
                    function h() {
                        o.ping().then(d, d)
                    }
                    t.theme = f.getTheme(),
                    T.resizeListeners = [Kt.addWebEventListener(window, "resize", a, !0), Kt.addWebEventListener(window, "orientationchange", (function() {
                        S && n.cancel(S),
                        E && n.cancel(E),
                        E = n(a, 500, !1)
                    }
                    ), !0)],
                    h(),
                    l.orchidsPromise().then((function() {
                        if (p.startRefreshInterval(6e4),
                        T.routeChangeSub = T.router.events.subscribe((function(t) {
                            t instanceof Bt.sK && e.cancel(),
                            t instanceof Bt.jw && window.scrollTo(0, 0)
                        }
                        )),
                        T.logOutListener = t.$on("logout", (function() {
                            T.signOut({
                                skipDeactivationGuards: !0
                            })
                        }
                        )),
                        T.isLowBandwidthForced = function() {
                            let e = m.getAvailablePlayerModes();
                            return 1 === e.length && "lowbandwidth" === e[0]
                        }
                        ,
                        !0 === w.isOrchid)
                            c.getDiscoverableOrchids(t.orchids[0]).then((function(e) {
                                if (T.orchidInstance = e.data.orchids[0],
                                t.orchids[0].discoverableOrchid = T.orchidInstance,
                                c.discoverableOrchid = T.orchidInstance,
                                T.badLicense = "normal" !== T.orchidInstance.licenseSession.state.status,
                                _(p.getOrchidTimeInfo(T.orchidInstance.id)),
                                p.addUpdateListener(T.orchidInstance.id, _),
                                T.badLicense) {
                                    var n;
                                    switch (T.orchidInstance.licenseSession.state.reason) {
                                    case "storage":
                                        T.errorTitle = T.msgs.errors.storage.title(),
                                        T.errorAriaLabel = T.msgs.errors.storage.ariaLabel(),
                                        n = T.msgs.errors.storage.systemStateExplanation();
                                        break;
                                    case "storage_path":
                                        T.errorTitle = T.msgs.errors.storagePath.title(),
                                        T.errorAriaLabel = T.msgs.errors.storagePath.ariaLabel(),
                                        n = T.msgs.errors.storagePath.systemStateExplanation();
                                        break;
                                    default:
                                        T.errorTitle = T.msgs.errors.license.title(),
                                        T.errorAriaLabel = T.msgs.errors.license.ariaLabel(),
                                        n = T.msgs.errors.license.systemStateExplanation()
                                    }
                                    T.errorDescriptionTemplate = T.msgs.errors.template({
                                        DESC: T.orchidInstance.licenseSession.state.description,
                                        WHY: n
                                    }),
                                    T.showErrorDialog()
                                }
                            }
                            ));
                        else {
                            let e = parseFloat(r.getConfigPostAuth().config["inactivity.threshold.minutes"]);
                            isNaN(e) && (e = 0),
                            g.start(e, 60),
                            s.getPluginsPromise()
                        }
                    }
                    ))
                }()
            }
            angular.module("ipconfigure.orchid.singularity").directive("app", [function() {
                return {
                    restrict: "E",
                    template: n(52896),
                    controller: Jt,
                    controllerAs: "app"
                }
            }
            ]);
            n(38862);
            function Qt(e, t, n) {
                function i(e) {
                    return e + "_" + n.getAuthenticationData().userId.toString().replace(/-/g, "_")
                }
                return {
                    getSettings: function(e) {
                        var n = i(e)
                          , a = t.localStorage[n] || null;
                        return JSON.parse(a)
                    },
                    setSettings: function(e, n) {
                        var a = i(e);
                        t.localStorage[a] = JSON.stringify(n),
                        "isDark" === e && this.setTheme()
                    },
                    setTheme: function() {
                        e.theme = this.getTheme()
                    },
                    getTheme: function() {
                        let e = n.isAuthenticated();
                        var t = !1;
                        return !w.isCustomLicense && e && (t = this.getSettings("isDark")),
                        w.license + (t ? "-dark" : "")
                    }
                }
            }
            function en(e) {
                var t, n;
                return {
                    registerElement: function(e) {
                        t = e
                    },
                    getElement: function() {
                        return t
                    },
                    deregisterElement(e) {
                        e === t && (t = null)
                    },
                    registerScope: function(e) {
                        n = e
                    },
                    deregisterScope(e) {
                        e === n && (n = null)
                    },
                    dragClear: function() {
                        n.showLines(),
                        n.highlightCells([])
                    },
                    dragOver: function(e, i, a) {
                        var r, s, o, c = [];
                        n.showLines(),
                        r = n.findCellInMatrixByCoordinates(e, i),
                        !0 === a ? (o = t.getBoundingClientRect(),
                        c.push({
                            x: 0,
                            y: 0,
                            width: o.width,
                            height: o.height
                        })) : !1 !== r ? (o = r,
                        c.push({
                            x: o.left,
                            y: o.top,
                            width: o.width,
                            height: o.height
                        })) : !1 !== (s = n.findGridPositionByCoordinates(e, i)) && c.push(n.getDimensionsForGridPosition(s[0], s[1])),
                        n.highlightCells(c, "green")
                    },
                    drop: function() {
                        n.hideLines(),
                        n.highlightCells([])
                    },
                    claimCellByCoordinates: function(e, t, i) {
                        n.claimCellByCoordinates(e, t, i)
                    },
                    obtainContainer: function(e) {
                        n.obtainContainer(e)
                    },
                    releaseCell: function(e, t) {
                        n.releaseCell(e, t)
                    },
                    toggleFullScreen: function(e) {
                        for (var t = e.target, i = e.target; !1 === t.classList.contains("cell-matrix"); )
                            i = t,
                            t = t.parentElement;
                        const a = n.getCellByElement(i);
                        return n.toggleFullScreen(a),
                        a.fullScreen
                    },
                    buildSerializableMatrix: function() {
                        return n.buildSerializableMatrix()
                    },
                    persistStageConfiguration: function() {
                        n && n.persistStageConfiguration()
                    },
                    reloadStageConfiguration: function(e, t) {
                        n.reloadStageConfiguration(e, t)
                    },
                    cleanupCell(e, t) {
                        n && n.cleanupCell(e, t)
                    }
                }
            }
            angular.module("ipconfigure.orchid.singularity").factory("UserSettingsService", ["$rootScope", "$window", "AuthenticationService", Qt]),
            en.$inject = ["$rootScope"],
            angular.module("ipconfigure.orchid.singularity").factory("MatrixService", en);
            n.p;
            angular.module("ipconfigure.orchid.singularity").directive("matrix", ["$log", "$rootScope", "MatrixService", "UserSettingsService", "UtilityService", "$timeout", function(e, t, n, i, a, r) {
                return {
                    restrict: "E",
                    link: function(s, o, c) {
                        var l, d = d3.select(o[0]), u = d.append("svg").attr("class", "line-matrix").style("width", "100%").style("height", "100%"), m = d.append("div").attr("class", "cell-matrix"), h = d.append("svg").attr("class", "cell-highlighter"), p = 20, g = [16, 9], f = 200, v = {
                            container: m,
                            columnsInsertedSinceRender: 0,
                            rowsInsertedSinceRender: 0,
                            cellWidth: 0,
                            cellHeight: 0,
                            offsetLeft: 0,
                            offsetTop: 0,
                            cells: [[{
                                rowSpan: 1,
                                columnSpan: 1,
                                initialValues: {},
                                forceLbm: !1,
                                dewarpMode: void 0
                            }]]
                        }, y = {
                            container: u,
                            containerSize: {
                                width: 0,
                                height: 0
                            },
                            firstColumnIndex: 1e3,
                            firstRowIndex: 1e3,
                            previousValues: {
                                uninitialized: !0,
                                cellWidth: 0,
                                cellHeight: 0,
                                offsetLeft: 0,
                                offsetTop: 0
                            },
                            horizontal: {
                                group: u.append("g").attr("orientation", "horizontal"),
                                lines: []
                            },
                            vertical: {
                                group: u.append("g").attr("orientation", "vertical"),
                                lines: []
                            }
                        }, b = !1, S = !1, C = !1;
                        function w(e) {
                            var t;
                            e.element && e.element.on("click", (function() {
                                d3.event.preventDefault()
                            }
                            )).call(d3.behavior.drag().origin(Object).on("dragstart", (t = e,
                            function(e) {
                                U.call(this, e, t)
                            }
                            )).on("drag", function(e) {
                                return function(t) {
                                    $.call(this, t, e)
                                }
                            }(e)).on("dragend", function(e) {
                                return function(t) {
                                    j.call(this, t, e)
                                }
                            }(e)))
                        }
                        function I(e, t) {
                            var n = y.containerSize.width - 40 - 3 * (t - 1)
                              , i = y.containerSize.height - 40 - 3 * (e - 1)
                              , a = n / t
                              , r = i / e
                              , s = {
                                cellWidth: a,
                                cellHeight: r,
                                offsetLeft: 0,
                                offsetTop: 0
                            };
                            return a / g[0] > r / g[1] ? (s.cellWidth = r / g[1] * g[0],
                            s.offsetLeft = (n - s.cellWidth * t) / 2) : (s.cellHeight = a / g[0] * g[1],
                            s.offsetTop = (i - s.cellHeight * e) / 2),
                            s
                        }
                        function T() {
                            var e, t, n;
                            y.containerSize = {
                                width: d.node().clientWidth,
                                height: d.node().clientHeight
                            },
                            e = v.cells[0].length,
                            t = I(v.cells.length, e),
                            v.cellWidth = t.cellWidth,
                            v.cellHeight = t.cellHeight,
                            v.offsetLeft = t.offsetLeft,
                            v.offsetTop = t.offsetTop,
                            v.cells.forEach((function(e, t) {
                                e.forEach((function(e, n) {
                                    e.previousRow = e.row,
                                    e.previousColumn = e.column,
                                    e.row = t,
                                    e.column = n,
                                    e.left = n * v.cellWidth + 3 * n + p + v.offsetLeft,
                                    e.top = t * v.cellHeight + 3 * t + p + v.offsetTop,
                                    e.width = 0,
                                    e.height = 0,
                                    !0 !== e.spannedUpon && !0 === e.claimed && (e.width = e.columnSpan ? e.columnSpan * v.cellWidth + 3 * (e.columnSpan - 1) : v.cellWidth,
                                    e.height = e.rowSpan ? e.rowSpan * v.cellHeight + 3 * (e.rowSpan - 1) : v.cellHeight),
                                    E(e),
                                    !0 === e.claimed && e.initialValues && (!1 === angular.isUndefined(e.initialValues.left) && e.element.style("left", e.initialValues.left + "px"),
                                    !1 === angular.isUndefined(e.initialValues.top) && e.element.style("top", e.initialValues.top + "px"),
                                    !1 === angular.isUndefined(e.initialValues.width) && e.element.style("width", e.initialValues.width + "px"),
                                    !1 === angular.isUndefined(e.initialValues.height) && e.element.style("height", e.initialValues.height + "px"),
                                    delete e.initialValues),
                                    (!1 === b ? e.element.transition().duration(f) : e.element).style("width", (!0 === e.fullScreen ? e.element.node().parentNode.parentNode.offsetWidth : e.width) + "px").style("height", (!0 === e.fullScreen ? e.element.node().parentNode.parentNode.offsetHeight : e.height) + "px").style("left", (!0 === e.fullScreen ? 0 : e.left) + "px").style("top", (!0 === e.fullScreen ? 0 : e.top) + "px"),
                                    e.element.data([{
                                        x: e.left,
                                        y: e.top
                                    }])
                                }
                                ))
                            }
                            )),
                            !1 === b && V(),
                            !0 === y.previousValues.uninitialized && (delete y.previousValues.uninitialized,
                            y.previousValues = {
                                cellWidth: v.cellWidth,
                                cellHeight: v.cellHeight,
                                offsetLeft: v.offsetLeft,
                                offsetTop: v.offsetTop
                            }),
                            v.cellWidth > 0 && v.cellHeight > 0 && (function() {
                                var e, t, n, i, a, r = y.horizontal.lines;
                                for (y.horizontal.lines = [],
                                e = 0,
                                t = v.offsetTop + p - v.cellHeight - 3; t > 0; t -= v.cellHeight + 3)
                                    i = t - 1.5,
                                    n = y.firstRowIndex - 1 - e,
                                    a = 0 === r.length ? i : r[0].value + (n - r[0].index) * (y.previousValues.cellHeight + 3),
                                    y.horizontal.lines.splice(0, 0, {
                                        index: n,
                                        value: i,
                                        initialValue: a
                                    }),
                                    e += 1;
                                for (e = 0,
                                t = v.offsetTop + p; t < y.containerSize.height; t += v.cellHeight + 3)
                                    i = t - 1.5,
                                    n = y.firstRowIndex + e,
                                    0 === r.length ? a = i : (a = 0,
                                    a = y.previousValues.offsetTop + p - 1.5 + (n - y.firstRowIndex - v.rowsInsertedSinceRender) * (y.previousValues.cellHeight + 3)),
                                    y.horizontal.lines.push({
                                        index: n,
                                        value: i,
                                        initialValue: a
                                    }),
                                    e += 1
                            }(),
                            function() {
                                var e, t, n, i, a, r = y.vertical.lines;
                                for (y.vertical.lines = [],
                                e = 0,
                                t = v.offsetLeft + p - v.cellWidth - 3; t > 0; t -= v.cellWidth + 3)
                                    i = t - 1.5,
                                    n = y.firstColumnIndex - 1 - e,
                                    a = 0 === r.length ? i : r[0].value + (n - r[0].index) * (y.previousValues.cellWidth + 3),
                                    y.vertical.lines.splice(0, 0, {
                                        index: n,
                                        value: i,
                                        initialValue: a
                                    }),
                                    e += 1;
                                for (e = 0,
                                t = v.offsetLeft + p; t < y.containerSize.width; t += v.cellWidth + 3)
                                    i = t - 1.5,
                                    n = y.firstColumnIndex + e,
                                    0 === r.length ? a = i : (a = 0,
                                    a = y.previousValues.offsetLeft + p - 1.5 + (n - y.firstColumnIndex - v.columnsInsertedSinceRender) * (y.previousValues.cellWidth + 3)),
                                    y.vertical.lines.push({
                                        index: n,
                                        value: i,
                                        initialValue: a
                                    }),
                                    e += 1
                            }(),
                            _(n = y.horizontal.group.selectAll("line").data(y.horizontal.lines, (function(e) {
                                return e.index
                            }
                            )), "y", y.containerSize.width),
                            x(n, "y", y.containerSize.width),
                            D(n),
                            _(n = y.vertical.group.selectAll("line").data(y.vertical.lines, (function(e) {
                                return e.index
                            }
                            )), "x", y.containerSize.height),
                            x(n, "x", y.containerSize.height),
                            D(n)),
                            y.previousValues.cellWidth = v.cellWidth,
                            y.previousValues.cellHeight = v.cellHeight,
                            y.previousValues.offsetLeft = v.offsetLeft,
                            y.previousValues.offsetTop = v.offsetTop,
                            !1 === b && window.setTimeout((function() {
                                G(),
                                K()
                            }
                            ), 220),
                            v.columnsInsertedSinceRender = 0,
                            v.rowsInsertedSinceRender = 0
                        }
                        function E(e) {
                            e.element || (e.element = v.container.append("div").style("width", e.width + "px").style("height", e.height + "px"),
                            w(e))
                        }
                        function _(e, t, n) {
                            var i = "x" === t ? "y" : "x";
                            e.attr("index", (function(e) {
                                return e.index
                            }
                            )).transition().duration(b ? 0 : f).style("stroke-width", 3).attr(t + "1", (function(e) {
                                return e.value
                            }
                            )).attr(t + "2", (function(e) {
                                return e.value
                            }
                            )).attr(i + "1", 0).attr(i + "2", n)
                        }
                        function x(e, t, n) {
                            var i = "x" === t ? "y" : "x";
                            e.enter().append("line").attr("index-orig", (function(e) {
                                return e.index
                            }
                            )).attr("index", (function(e) {
                                return e.index
                            }
                            )).style("stroke-width", 3).attr(t + "1", (function(e) {
                                return e.initialValue
                            }
                            )).attr(t + "2", (function(e) {
                                return e.initialValue
                            }
                            )).transition().duration(b ? 0 : f).attr(t + "1", (function(e) {
                                return e.value
                            }
                            )).attr(t + "2", (function(e) {
                                return e.value
                            }
                            )).attr(i + "1", 0).attr(i + "2", n)
                        }
                        function D(e) {
                            e.exit().remove()
                        }
                        function O() {
                            var e, t, n, i;
                            for (y.firstRowIndex -= 1,
                            v.rowsInsertedSinceRender += 1,
                            e = -v.rowsInsertedSinceRender,
                            v.cells.splice(0, 0, []),
                            t = 0; t < v.cells[v.cells.length - 1].length; t += 1)
                                n = t - v.columnsInsertedSinceRender,
                                (i = {
                                    rowSpan: 1,
                                    columnSpan: 1,
                                    initialValues: {},
                                    forceLbm: !1,
                                    dewarpMode: void 0
                                }).initialValues.left = n * v.cellWidth + 3 * n + p + v.offsetLeft,
                                i.initialValues.top = e * v.cellHeight + 3 * e + p + v.offsetTop,
                                i.initialValues.width = v.cellWidth,
                                i.initialValues.height = v.cellHeight,
                                v.cells[0].push(i)
                        }
                        function A() {
                            var e, t, n, i;
                            for (y.firstColumnIndex -= 1,
                            v.columnsInsertedSinceRender += 1,
                            t = -v.columnsInsertedSinceRender,
                            e = 0; e < v.cells.length; e += 1)
                                n = e - v.rowsInsertedSinceRender,
                                (i = {
                                    rowSpan: 1,
                                    columnSpan: 1,
                                    initialValues: {},
                                    forceLbm: !1,
                                    dewarpMode: void 0
                                }).initialValues.left = t * v.cellWidth + 3 * t + p + v.offsetLeft,
                                i.initialValues.top = n * v.cellHeight + 3 * n + p + v.offsetTop,
                                i.initialValues.width = v.cellWidth,
                                i.initialValues.height = v.cellHeight,
                                v.cells[e].splice(0, 0, i)
                        }
                        function R() {
                            var e, t, n = v.cells.length;
                            for (v.cells.push([]),
                            e = 0; e < v.cells[0].length; e += 1)
                                (t = {
                                    rowSpan: 1,
                                    columnSpan: 1,
                                    initialValues: {},
                                    forceLbm: !1,
                                    dewarpMode: void 0
                                }).initialValues.left = e * v.cellWidth + 3 * e + p + v.offsetLeft,
                                t.initialValues.top = n * v.cellHeight + 3 * n + p + v.offsetTop,
                                t.initialValues.width = v.cellWidth,
                                t.initialValues.height = v.cellHeight,
                                v.cells[v.cells.length - 1].push(t)
                        }
                        function P() {
                            var e, t, n = v.cells[0].length;
                            for (e = 0; e < v.cells.length; e += 1)
                                (t = {
                                    rowSpan: 1,
                                    columnSpan: 1,
                                    initialValues: {},
                                    forceLbm: !1,
                                    dewarpMode: void 0
                                }).initialValues.left = n * v.cellWidth + 3 * n + p + v.offsetLeft,
                                t.initialValues.top = e * v.cellHeight + 3 * e + p + v.offsetTop,
                                t.initialValues.width = v.cellWidth,
                                t.initialValues.height = v.cellHeight,
                                v.cells[e].push(t)
                        }
                        function k() {
                            var e;
                            if (v.cells.length > 1) {
                                for (y.firstRowIndex += 1,
                                v.rowsInsertedSinceRender -= 1,
                                e = 0; e < v.cells[0].length; e += 1)
                                    v.cells[0][e].element && v.cells[0][e].element.remove();
                                v.cells.splice(0, 1)
                            }
                        }
                        function M() {
                            var e;
                            if (v.cells[0].length > 1)
                                for (v.columnsInsertedSinceRender -= 1,
                                y.firstColumnIndex += 1,
                                e = 0; e < v.cells.length; e += 1)
                                    v.cells[e][0].element && v.cells[e][0].element.remove(),
                                    v.cells[e].splice(0, 1)
                        }
                        function L() {
                            var e;
                            if (v.cells.length > 1) {
                                for (e = 0; e < v.cells[v.cells.length - 1].length; e += 1)
                                    v.cells[v.cells.length - 1][e].element && v.cells[v.cells.length - 1][e].element.remove();
                                v.cells.splice(v.cells.length - 1, 1)
                            }
                        }
                        function N() {
                            var e;
                            if (v.cells[0].length > 1)
                                for (e = 0; e < v.cells.length; e += 1)
                                    v.cells[e][v.cells[e].length - 1].element && v.cells[e][v.cells[e].length - 1].element.remove(),
                                    v.cells[e].splice(v.cells[e].length - 1, 1)
                        }
                        function F() {
                            for (var e = !1; v.cells.length > 1 && !0 === B(0); )
                                k(),
                                e = !0;
                            for (; v.cells.length > 1 && !0 === B(v.cells.length - 1); )
                                L(),
                                e = !0;
                            for (; v.cells[0].length > 1 && !0 === z(0); )
                                M(),
                                e = !0;
                            for (; v.cells[0].length > 1 && !0 === z(v.cells[0].length - 1); )
                                N(),
                                e = !0;
                            return e
                        }
                        function U(e, n) {
                            if (e.canDrag = angular.isUndefined(a.findAncestor(d3.event.sourceEvent.target, (function(e) {
                                return e.classList.contains("undraggable")
                            }
                            ))),
                            e.canDrag && !0 !== n.claimed)
                                return !1;
                            t.$broadcast("stageInteract")
                        }
                        function $(e, t) {
                            var n, i;
                            if (!0 !== t.claimed)
                                return !1;
                            angular.isUndefined(d3.event.sourceEvent.clientX) && window.TouchEvent && d3.event.sourceEvent instanceof window.TouchEvent && (d3.event.sourceEvent.clientX = d3.event.sourceEvent.changedTouches[0].clientX,
                            d3.event.sourceEvent.clientY = d3.event.sourceEvent.changedTouches[0].clientY),
                            !0 !== t.fullScreen && (angular.isUndefined(e.dragged) && (angular.isUndefined(e.initX) ? (e.initX = d3.event.sourceEvent.clientX,
                            e.initY = d3.event.sourceEvent.clientY) : e.canDrag && (Math.abs(e.initX - d3.event.sourceEvent.clientX) > 1 || Math.abs(e.initY - d3.event.sourceEvent.clientY) > 1) && (n = e.initX - t.left - d.node().offsetLeft,
                            i = e.initY - t.top - d.node().offsetTop,
                            n >= t.width - 21 && i >= t.height - 21 || d3.event.sourceEvent.target.classList.contains("resize-se") ? (e.resizeOffsetX = t.width - n,
                            e.resizeOffsetY = t.height - i,
                            e.action = "resize",
                            e.resizeDirection = "se") : n >= t.width - 21 && t.height / 2 - i > -16 && t.height / 2 - i < 16 || d3.event.sourceEvent.target.classList.contains("resize-e") ? (e.resizeOffsetX = t.width - n,
                            e.action = "resize",
                            e.resizeDirection = "e") : i >= t.height - 21 && t.width / 2 - n > -16 && t.width / 2 - n < 16 || d3.event.sourceEvent.target.classList.contains("resize-e") ? (e.resizeOffsetY = t.height - i,
                            e.action = "resize",
                            e.resizeDirection = "s") : d3.event.sourceEvent.touches && 1 !== d3.event.sourceEvent.touches.length || t.zoomValue && 100 !== t.zoomValue && !a.findAncestor(d3.event.sourceEvent.target, (function(e) {
                                return "HEADER" === e.tagName
                            }
                            )) || (t.rowSpan ? e.rowOffset = Math.max(1, Math.ceil(i / (v.cellHeight + 3))) - 1 : e.rowOffset = 0,
                            t.columnSpan ? e.columnOffset = Math.max(1, Math.ceil(n / (v.cellWidth + 3))) - 1 : e.columnOffset = 0,
                            e.action = "move"),
                            e.action && (t.element.style("opacity", .5),
                            V(),
                            e.dragged = !0))),
                            "resize" === e.action ? function(e, t) {
                                var n, i, a, r, c, l, u, m = [], h = "green";
                                if (t.dragResizing = !0,
                                e.dragged = !0,
                                e.w = t.width,
                                e.h = t.height,
                                e.resizeDirection.indexOf("e") > -1 && (e.w = d3.event.sourceEvent.clientX - t.left - o[0].offsetLeft + e.resizeOffsetX),
                                e.resizeDirection.indexOf("s") > -1 && (e.h = d3.event.sourceEvent.clientY - t.top - o[0].offsetTop + e.resizeOffsetY),
                                n = H(),
                                i = s.findGridPositionByCoordinates(t.left + 3 + d.node().offsetLeft, t.top + 3 + d.node().offsetTop),
                                a = s.findGridPositionByCoordinates(t.left + e.w + d.node().offsetLeft, t.top + e.h + d.node().offsetTop, !0),
                                (r = [a[0] - i[0] + 1, a[1] - i[1] + 1])[0] > 0 && r[1] > 0) {
                                    for (l = 0; l < r[1]; l += 1)
                                        for (c = 0; c < r[0]; c += 1)
                                            m.push(s.getDimensionsForGridPosition(c + i[0], l + i[1])),
                                            v.cells[l + i[1] - n[1]] && (u = v.cells[l + i[1] - n[1]][c + i[0] - n[0]]) && !0 === u.claimed && u !== t && u.spannedUponBy !== t && (h = "red");
                                    s.highlightCells(m, h),
                                    e.desiredSpan = "red" === h ? [t.columnSpan, t.rowSpan] : r
                                } else
                                    e.desiredSpan = [t.columnSpan, t.rowSpan];
                                t.element.classed("resizing", !0).style("z-index", 45).style("outline", "5px solid blue").style("width", e.w + "px").style("height", e.h + "px")
                            }(e, t) : "move" === e.action && function(e, t) {
                                var n, i, a, r, o, c, l = [], u = {}, m = {};
                                if (e.highlightColor = "green",
                                e.movePosition = void 0,
                                t.dragMoving = !0,
                                e.moveTarget = s.findCellInMatrixByCoordinates(d3.event.sourceEvent.clientX, d3.event.sourceEvent.clientY, t),
                                e.moveTarget)
                                    l.push({
                                        x: e.moveTarget.left,
                                        y: e.moveTarget.top,
                                        width: e.moveTarget.width,
                                        height: e.moveTarget.height
                                    });
                                else if (!1 !== (n = s.findGridPositionByCoordinates(d3.event.sourceEvent.clientX, d3.event.sourceEvent.clientY))) {
                                    for (a = {
                                        x: d.node().offsetLeft,
                                        y: d.node().offsetTop
                                    },
                                    r = {
                                        x: y.vertical.lines[0].value - v.cellWidth + a.x,
                                        y: y.horizontal.lines[0].value - v.cellHeight + a.y
                                    },
                                    t.rowSpan ? (u.from = n[1] - e.rowOffset,
                                    u.to = n[1] - e.rowOffset + t.rowSpan - 1) : (u.from = n[1],
                                    u.to = n[1]),
                                    t.columnSpan ? (m.from = n[0] - e.columnOffset,
                                    m.to = n[0] - e.columnOffset + t.columnSpan - 1) : (m.from = n[0],
                                    m.to = n[0]),
                                    i = H(),
                                    o = u.from; o <= u.to; o += 1)
                                        for (c = m.from; c <= m.to; c += 1)
                                            l.push(s.getDimensionsForGridPosition(c, o, a, r)),
                                            v.cells[o - i[1]] && v.cells[o - i[1]][c - i[0]] && !0 === v.cells[o - i[1]][c - i[0]].claimed && v.cells[o - i[1]][c - i[0]] !== t && v.cells[o - i[1]][c - i[0]].spannedUponBy !== t && (e.highlightColor = "red");
                                    e.movePosition = [n[0] - i[0] - e.columnOffset, n[1] - i[1] - e.rowOffset]
                                }
                                s.highlightCells(l, e.highlightColor),
                                e.dragged = !0,
                                e.x = d3.event.x,
                                e.y = d3.event.y,
                                t.element.classed("dragging", !0).style("z-index", 45).style("outline", "5px solid blue").style("top", e.y + "px").style("left", e.x + "px")
                            }(e, t))
                        }
                        function j(e, t) {
                            if (!0 !== t.claimed)
                                return !1;
                            !0 === e.dragged && (angular.isUndefined(d3.event.sourceEvent.clientX) && window.TouchEvent && d3.event.sourceEvent instanceof window.TouchEvent && (d3.event.sourceEvent.clientX = d3.event.sourceEvent.changedTouches[0].clientX,
                            d3.event.sourceEvent.clientY = d3.event.sourceEvent.changedTouches[0].clientY),
                            "resize" === e.action ? (function(e, t) {
                                e.desiredSpan[0] !== t.columnSpan || e.desiredSpan[1] !== t.rowSpan ? (q(t),
                                t.columnSpan = e.desiredSpan[0],
                                t.rowSpan = e.desiredSpan[1],
                                X([t.column, t.row], t.columnSpan, t.rowSpan),
                                Y(t),
                                F(),
                                T(),
                                window.setTimeout((function() {
                                    K()
                                }
                                ), f),
                                t.element.style("opacity", "").style("outline", 0).style("z-index", "")) : t.element.style("opacity", "").style("outline", 0).transition().ease("linear").duration(100).style("width", t.width + "px").style("height", t.height + "px").style("top", t.top + "px").style("left", t.left + "px").each("end", (function() {
                                    t.element.style("z-index", ""),
                                    K()
                                }
                                )),
                                window.setTimeout((function() {
                                    G(),
                                    t.element[0][0].classList.remove("resizing")
                                }
                                ), f)
                            }(e, t),
                            t.dragResizing = !1) : (function(e, t) {
                                var n, i = {};
                                "green" === e.highlightColor && !1 !== e.moveTarget ? ((t.rowSpan || t.columnSpan) && q(t),
                                (e.moveTarget.rowSpan || e.moveTarget.columnSpan) && q(e.moveTarget),
                                v.cells[e.moveTarget.row][e.moveTarget.column] = t,
                                v.cells[t.row][t.column] = e.moveTarget,
                                i.row = t.row,
                                i.column = t.column,
                                t.row = e.moveTarget.row,
                                t.column = e.moveTarget.column,
                                e.moveTarget.row = i.row,
                                e.moveTarget.column = i.column,
                                i.rowSpan = t.rowSpan,
                                i.columnSpan = t.columnSpan,
                                t.rowSpan = e.moveTarget.rowSpan,
                                t.columnSpan = e.moveTarget.columnSpan,
                                e.moveTarget.rowSpan = i.rowSpan,
                                e.moveTarget.columnSpan = i.columnSpan,
                                t.top = e.y,
                                t.left = e.x,
                                t.element.style("z-index", 47).style("opacity", 1),
                                e.moveTarget.element.style("z-index", 45),
                                (t.rowSpan || t.columnSpan) && Y(t),
                                (e.moveTarget.rowSpan || e.moveTarget.columnSpan) && Y(e.moveTarget),
                                F(),
                                T(),
                                i = e.moveTarget,
                                window.setTimeout((function() {
                                    t.element.style("outline", 0).style("z-index", ""),
                                    i.element.style("z-index", ""),
                                    K()
                                }
                                ), f)) : "green" !== e.highlightColor || !0 !== Array.isArray(e.movePosition) || t.column === e.movePosition[0] && t.row === e.movePosition[1] ? (t.element.style("opacity", "").transition().ease("linear").duration(100).style("width", t.width + "px").style("height", t.height + "px").style("top", t.top + "px").style("left", t.left + "px").each("end", (function() {
                                    t.element.style("z-index", ""),
                                    t.element.style("outline", 0),
                                    K()
                                }
                                )),
                                e.x = t.left,
                                e.y = t.top,
                                y.horizontal.group.style("opacity", 1).transition().duration(f).style("opacity", 0).each("end", (function() {
                                    G(),
                                    y.horizontal.group.style("opacity", 1)
                                }
                                )),
                                y.vertical.group.style("opacity", 1).transition().duration(f).style("opacity", 0).each("end", (function() {
                                    G(),
                                    y.vertical.group.style("opacity", 1)
                                }
                                ))) : (i = t,
                                v.cells[i.row][i.column] = {
                                    rowSpan: 1,
                                    columnSpan: 1,
                                    initialValues: {},
                                    forceLbm: !1,
                                    dewarpMode: void 0
                                },
                                v.cells[i.row][i.column].initialValues = {
                                    left: t.left,
                                    top: t.top,
                                    width: v.cellWidth,
                                    height: v.cellHeight
                                },
                                q(t),
                                n = X(e.movePosition, t.columnSpan, t.rowSpan),
                                i.column = e.movePosition[0] + n[0],
                                i.row = e.movePosition[1] + n[1],
                                angular.isDefined(v.cells[e.movePosition[1] + n[1]][e.movePosition[0] + n[0]].element) && v.cells[e.movePosition[1] + n[1]][e.movePosition[0] + n[0]].element.remove(),
                                v.cells[e.movePosition[1] + n[1]][e.movePosition[0] + n[0]] = i,
                                i.element.style("z-index", 47).style("opacity", 1),
                                Y(i),
                                F(),
                                T(),
                                i = t,
                                window.setTimeout((function() {
                                    t.element.style("outline", 0).style("z-index", ""),
                                    i.element.style("z-index", ""),
                                    K()
                                }
                                ), f)),
                                t.element[0][0].classList.remove("dragging")
                            }(e, t),
                            t.dragMoving = !1),
                            s.persistStageConfiguration(),
                            h.style("display", ""),
                            delete e.action,
                            delete e.dragged,
                            delete e.initX,
                            delete e.initY,
                            delete e.resizeOffsetX,
                            delete e.resizeOffsetY,
                            delete e.rowSpanAnchor,
                            delete e.columnSpanAnchor,
                            delete e.moveTarget,
                            delete e.rowOffset,
                            delete e.columnOffset,
                            delete e.highlightColor,
                            delete e.w,
                            delete e.h,
                            delete e.canDrag)
                        }
                        function V() {
                            "inline" !== y.horizontal.group.style("display") && y.horizontal.group.style("opacity", "0").style("display", "inline").transition().duration(f).style("opacity", "1").each("end", (function() {
                                y.horizontal.group.style("opacity", "")
                            }
                            )),
                            "inline" !== y.vertical.group.style("display") && y.vertical.group.style("opacity", "0").style("display", "inline").transition().duration(f).style("opacity", "1").each("end", (function() {
                                y.vertical.group.style("opacity", "")
                            }
                            ))
                        }
                        function G() {
                            "none" !== y.horizontal.group.style("display") && y.horizontal.group.style("opacity", "1").transition().duration(f).style("opacity", "0").each("end", (function() {
                                y.horizontal.group.style("display", "none"),
                                y.horizontal.group.style("opacity", "")
                            }
                            )),
                            "none" !== y.vertical.group.style("display") && y.vertical.group.style("opacity", "1").transition().duration(f).style("opacity", "0").each("end", (function() {
                                y.vertical.group.style("display", "none"),
                                y.vertical.group.style("opacity", "")
                            }
                            ))
                        }
                        function B(e) {
                            var t, n = v.cells[e].length;
                            for (t = 0; t < n; t += 1)
                                if (!0 === v.cells[e][t].claimed || !0 === v.cells[e][t].spannedUpon)
                                    return !1;
                            return !0
                        }
                        function z(e) {
                            var t, n = v.cells.length;
                            for (t = 0; t < n; t += 1)
                                if (!0 === v.cells[t][e].claimed || !0 === v.cells[t][e].spannedUpon)
                                    return !1;
                            return !0
                        }
                        function H() {
                            return s.findGridPositionByCoordinates(v.cells[0][0].left + d.node().offsetLeft + 3, v.cells[0][0].top + d.node().offsetTop + 3)
                        }
                        function W(e, t, n, i) {
                            return function(e, t, n, i, a) {
                                var r, s, o, c;
                                for (r = e,
                                o = e + n; r < o; r += 1)
                                    for (s = t,
                                    c = t + i; s < c; s += 1)
                                        if ((r !== e || s !== t) && v.cells[r] && v.cells[r][s] && !1 === a(v.cells[r][s]))
                                            return !1;
                                return !0
                            }(e.row, e.column, t, n, i)
                        }
                        function q(e) {
                            W(e, e.rowSpan, e.columnSpan, (function(e) {
                                delete e.claimed,
                                delete e.spannedUpon,
                                delete e.spannedUponBy,
                                e.width = v.cellWidth,
                                e.height = v.cellHeight,
                                e.initialValues = {
                                    width: v.cellWidth,
                                    height: v.cellHeight
                                }
                            }
                            ))
                        }
                        function Y(e) {
                            return W(e, e.rowSpan, e.columnSpan, (function(t) {
                                return t.claimed = !0,
                                t.spannedUpon = !0,
                                t.spannedUponBy = e,
                                t.width = 0,
                                t.height = 0,
                                t.initialValues = {
                                    width: 0,
                                    height: 0
                                },
                                !0
                            }
                            ))
                        }
                        function X(e, t, n) {
                            var i, a = [0, 0];
                            if (e[0] + t - 1 >= v.cells[0].length)
                                for (i = v.cells[0].length; i <= e[0] + t - 1; i += 1)
                                    P();
                            if (e[1] + n - 1 >= v.cells.length)
                                for (i = v.cells.length; i <= e[1] + n - 1; i += 1)
                                    R();
                            if (e[0] < 0)
                                for (i = 0; i > e[0]; i -= 1)
                                    A(),
                                    a[0] += 1;
                            if (e[1] < 0)
                                for (i = 0; i > e[1]; i -= 1)
                                    O(),
                                    a[1] += 1;
                            return a
                        }
                        function K(e) {
                            t.$broadcast("resize.stage")
                        }
                        s.highlightCells = function(e, t) {
                            var n = h.selectAll("rect").data(e);
                            n.attr("x", (function(e) {
                                return e.x + "px"
                            }
                            )).attr("y", (function(e) {
                                return e.y + "px"
                            }
                            )).attr("width", (function(e) {
                                return e.width + "px"
                            }
                            )).attr("height", (function(e) {
                                return e.height + "px"
                            }
                            )).style("fill", t),
                            n.exit().remove(),
                            n.enter().append("rect").attr("x", (function(e) {
                                return e.x + "px"
                            }
                            )).attr("y", (function(e) {
                                return e.y + "px"
                            }
                            )).attr("width", (function(e) {
                                return e.width + "px"
                            }
                            )).attr("height", (function(e) {
                                return e.height + "px"
                            }
                            )).style("fill", t).style("opacity", 0).transition().duration(f).style("opacity", .5),
                            h.style("display", 0 === e.length ? "" : "block")
                        }
                        ,
                        s.showLines = function() {
                            V()
                        }
                        ,
                        s.hideLines = function() {
                            G()
                        }
                        ,
                        s.findCellInMatrixByCoordinates = function(e, t, n) {
                            var i = e - d.node().offsetLeft
                              , a = t - d.node().offsetTop
                              , r = !1;
                            return v.cells.some((function(e) {
                                return e.some((function(e) {
                                    if (e !== n && e.left <= i && e.left + e.width >= i && e.top <= a && e.top + e.height >= a)
                                        return r = e,
                                        !0
                                }
                                ))
                            }
                            )),
                            r
                        }
                        ,
                        s.findGridPositionByCoordinates = function(e, t, n) {
                            var i, a, r, s = d.node().offsetLeft, o = d.node().offsetTop, c = y.vertical.lines[0].value - v.cellWidth + s - 1.5, l = y.horizontal.lines[0].value - v.cellHeight + o - 1.5, u = y.vertical.lines[y.vertical.lines.length - 1].value + s + 1.5, m = y.horizontal.lines[y.horizontal.lines.length - 1].value + o + 1.5, h = 0;
                            if (!0 === n || c > e || l > t || u < e || m < t)
                                return [Math.floor((e - c) / (v.cellWidth + 3)), Math.floor((t - l) / (v.cellHeight + 3))];
                            for (a = l; a <= d.node().clientHeight + v.cellHeight; a += v.cellHeight + 3) {
                                for (r = 0,
                                i = c; i <= d.node().clientWidth + v.cellWidth; i += v.cellWidth + 3) {
                                    if (i <= e && i + v.cellWidth >= e && a <= t && a + v.cellHeight >= t)
                                        return [r, h];
                                    r += 1
                                }
                                h += 1
                            }
                            return !1
                        }
                        ,
                        s.getDimensionsForGridPosition = function(e, t, n, i) {
                            return !0 === angular.isUndefined(n) && (n = {
                                x: d.node().offsetLeft,
                                y: d.node().offsetTop
                            }),
                            !0 === angular.isUndefined(i) && (i = {
                                x: y.vertical.lines[0].value - v.cellWidth + n.x,
                                y: y.horizontal.lines[0].value - v.cellHeight + n.y
                            }),
                            {
                                x: e * (v.cellWidth + 3) + i.x - n.x - 1.5,
                                y: t * (v.cellHeight + 3) + i.y - n.y - 1.5,
                                width: v.cellWidth,
                                height: v.cellHeight
                            }
                        }
                        ,
                        s.getCellByElement = function(e) {
                            var t;
                            return v.cells.some((function(n) {
                                return n.some((function(n) {
                                    if (n.element[0][0] === e)
                                        return t = n,
                                        !0
                                }
                                ))
                            }
                            )),
                            t
                        }
                        ,
                        s.getCellByCoordinates = function(e, t) {
                            return s.findCellInMatrixByCoordinates(e, t)
                        }
                        ,
                        s.claimCellByCoordinates = function(e, t, n) {
                            var i, a, r, o = s.findCellInMatrixByCoordinates(e, t);
                            !1 === o && !1 !== (i = s.findGridPositionByCoordinates(e, t)) && (a = H(),
                            r = X([i[0] - a[0], i[1] - a[1]], 1, 1),
                            (o = v.cells[i[1] - a[1] + r[1]][i[0] - a[0] + r[0]]).claimed = !0,
                            F()),
                            !1 === o ? n(!1) : (o.claimed = !0,
                            T(),
                            w(o),
                            n(o))
                        }
                        ,
                        s.releaseCell = function(e, t) {
                            !0 === e.fullScreen && (e.fullScreen = !1,
                            C = !1),
                            e.claimed = !1,
                            e.forceLbm = void 0,
                            e.dewarpMode = void 0,
                            q(e),
                            e.rowSpan = 1,
                            e.columnSpan = 1,
                            !0 !== t && (!0 === F() && v.cells.length > 1 && v.cells[0].length > 1 && V(),
                            T(),
                            window.setTimeout((function() {
                                G()
                            }
                            ), f))
                        }
                        ,
                        s.obtainContainer = function(e) {
                            var t, n, i, a, r, s = v.cells.length, o = v.cells[0].length;
                            if (!0 === S)
                                return !1;
                            for (t = 0; t <= s - 1; t += 1)
                                for (n = 0; n <= o - 1; n += 1)
                                    if (!0 !== (r = v.cells[t][n]).claimed && !0 !== r.spannedUpon)
                                        return r.claimed = !0,
                                        r.width = v.cellWidth,
                                        r.height = v.cellHeight,
                                        r.rowSpan = 1,
                                        r.columnSpan = 1,
                                        r.element.style("width", r.width + "px"),
                                        r.element.style("height", r.height + "px"),
                                        e(r),
                                        !0;
                            return S = !0,
                            i = I(s, o + 1),
                            a = I(s + 1, o),
                            i.cellWidth * i.cellHeight > a.cellWidth * a.cellHeight ? (P(),
                            (r = v.cells[0][v.cells[0].length - 1]).claimed = !0,
                            T(),
                            e(r),
                            window.setTimeout((function() {
                                S = !1
                            }
                            ), f),
                            !0) : (R(),
                            (r = v.cells[v.cells.length - 1][0]).claimed = !0,
                            T(),
                            e(r),
                            window.setTimeout((function() {
                                S = !1
                            }
                            ), f),
                            !0)
                        }
                        ,
                        s.toggleFullScreen = function(e) {
                            return !0 === C ? !0 === e.fullScreen && (C = !1,
                            e.fullScreen = !1,
                            function(e) {
                                e.element.transition().style("top", e.top + "px").style("left", e.left + "px").style("width", e.width + "px").style("height", e.height + "px").style("outline", "").each("end", (function() {
                                    e.element.style("z-index", ""),
                                    K()
                                }
                                ))
                            }(e),
                            !0) : (C = !0,
                            e.fullScreen = !0,
                            function(e) {
                                var t = e.element.node().parentNode.parentNode.offsetWidth
                                  , n = e.element.node().parentNode.parentNode.offsetHeight;
                                e.element.style("z-index", 50),
                                e.element.transition().style("top", "0px").style("left", "0px").style("height", n + "px").style("width", t + "px").each("end", (function() {
                                    K()
                                }
                                ))
                            }(e),
                            !0)
                        }
                        ,
                        s.buildSerializableMatrix = function() {
                            var e, t = [];
                            return v.cells.forEach((function(n) {
                                e = [],
                                n.forEach((function(t) {
                                    let n = {};
                                    t.claimed && (n.columnSpan = t.columnSpan,
                                    n.rowSpan = t.rowSpan,
                                    "map" === t.type ? (n.type = "map",
                                    n.map = t.map) : (n.type = "player",
                                    n.camera = t.camera,
                                    n.forceLbm = t.forceLbm,
                                    n.dewarpMode = t.dewarpMode)),
                                    e.push(n)
                                }
                                )),
                                t.push(e)
                            }
                            )),
                            t
                        }
                        ;
                        let Z = null;
                        function J() {
                            const e = s.buildSerializableMatrix();
                            i.setSettings("stage-matrix", e),
                            t.$broadcast("stageChanged"),
                            Z = null
                        }
                        s.persistStageConfiguration = function() {
                            Z && r.cancel(Z),
                            Z = r(J, 1e3)
                        }
                        ,
                        s.reloadStageConfiguration = function(t, n) {
                            v.cells.forEach((function(e) {
                                e.forEach((function(e) {
                                    e.element && e.element.remove()
                                }
                                ))
                            }
                            ));
                            try {
                                var a = i.getSettings("stage-matrix") || [[{}]];
                                v.cells = n || a,
                                v.cells || (v.cells = [[{
                                    rowSpan: 1,
                                    columnSpan: 1,
                                    initialValues: {},
                                    forceLbm: !1,
                                    dewarpMode: void 0
                                }]])
                            } catch (t) {
                                e.error((t.message,
                                t.message)),
                                v.cells = [[{
                                    rowSpan: 1,
                                    columnSpan: 1,
                                    initialValues: {},
                                    forceLbm: !1,
                                    dewarpMode: void 0
                                }]]
                            }
                            v.cells.forEach((function(e, t) {
                                e.forEach((function(e, n) {
                                    e.column = n,
                                    e.row = t
                                }
                                ))
                            }
                            )),
                            v.cells.forEach((function(e) {
                                e.forEach((function(e) {
                                    if ("map" === e.type)
                                        e.claimed = !0,
                                        E(e),
                                        (e.columnSpan > 1 || e.rowSpan > 1) && Y(e),
                                        t(e);
                                    else {
                                        var n = e.camera && e.camera.orchidId && e.camera.id;
                                        n && (e.claimed = !0,
                                        E(e)),
                                        e.span && (e.columnSpan = e.span,
                                        e.rowSpan = e.span,
                                        delete e.span),
                                        !0 === angular.isUndefined(e.columnSpan) && (e.columnSpan = 1),
                                        !0 === angular.isUndefined(e.rowSpan) && (e.rowSpan = 1),
                                        n && ((e.columnSpan > 1 || e.rowSpan > 1) && Y(e),
                                        t(e))
                                    }
                                }
                                ))
                            }
                            )),
                            F(),
                            b = !0,
                            T(),
                            b = !1
                        }
                        ,
                        s.cleanupCell = function(e, t) {
                            e && (e.element && (t && function(e) {
                                e.element && (e.element.on("click", null),
                                e.element.on(".drag", null))
                            }(e),
                            e.element.style("outline", 0),
                            e.element.style("z-index", "")),
                            e.dewarpMode = void 0,
                            e.forceLbm = !1,
                            delete e.camera)
                        }
                        ,
                        n.registerElement(o[0]),
                        n.registerScope(s),
                        s.$on("$destroy", (function() {
                            l(),
                            n.deregisterElement(o[0]),
                            n.deregisterScope(s)
                        }
                        )),
                        l = t.$on("resize", (function(e, t) {
                            "master-mode" !== t && (b = !0),
                            T(),
                            "master-mode" !== t && (K(),
                            b = !1)
                        }
                        )),
                        T()
                    }
                }
            }
            ]);
            n(17922);
            const tn = "lowbandwidth"
              , nn = "webrtc"
              , an = [tn, nn];
            let rn = (0,
            b.Z)((function e() {
                (0,
                S.Z)(this, e),
                this.showTimeline = !1,
                this.showControls = !1,
                this.showHeader = !1,
                this.showDewarp = !1,
                this.dewarpMode = 1,
                this.showPtz = !1,
                this.showPtzPresets = !1,
                this.canManagePtzPresets = !1,
                this.showStats = !1,
                this.showPlayerMode = !0,
                this.showClose = !1,
                this.showVolume = !0,
                this.showFullScreen = !1,
                this.availablePlayerModes = [],
                this.showTimezoneOffset = !0,
                this.ptzControlColor = "",
                this.showLBM = !0
            }
            ))
              , sn = function() {
                function e(t, n, i) {
                    (0,
                    S.Z)(this, e),
                    this._PlayerModeService = t,
                    this._PrerequisitesService = i,
                    this._themeService = n,
                    this._isOrchid = w.isOrchid
                }
                return (0,
                b.Z)(e, [{
                    key: "createStagePlayerOptions",
                    value: function(e) {
                        let t = new rn;
                        t.canManagePtzPresets = !0,
                        t.showClose = !0,
                        t.showControls = !0,
                        t.showDewarp = !0,
                        t.dewarpMode = 1,
                        t.showFullScreen = !0,
                        t.showHeader = !0,
                        t.showPtz = !0,
                        t.showPtzPresets = !0,
                        t.showStats = !0,
                        t.showTimeline = !0;
                        const n = e && e.forceLbm && this._PlayerModeService.isLbmAvailable() ? tn : void 0
                          , i = this._PlayerModeService.getAvailablePlayerModes(n);
                        return e && void 0 !== e.dewarpMode && e.dewarpMode <= 2 && e.dewarpMode >= 0 && (t.dewarpMode = e.dewarpMode),
                        t.availablePlayerModes = i,
                        t.ptzControlColor = this._themeService.getPrimaryColorHex(),
                        t
                    }
                }, {
                    key: "createPreviewPlayerOptions",
                    value: function() {
                        let e = new rn;
                        return e.availablePlayerModes = this._PlayerModeService.getAvailablePlayerModes(),
                        e.canManagePtzPresets = !0,
                        e.showClose = !0,
                        e.showControls = !0,
                        e.showDewarp = !0,
                        e.showFullScreen = !1,
                        e.showHeader = !0,
                        e.showPtz = !0,
                        e.showPtzPresets = !0,
                        e.showStats = !0,
                        e.showTimeline = !1,
                        e.ptzControlColor = this._themeService.getPrimaryColorHex(),
                        e
                    }
                }, {
                    key: "createApiPlayerOptions",
                    value: function(e) {
                        let t = new rn;
                        if (this._isOrchid || (t.showLBM = this._PlayerModeService.isLbmAvailable()),
                        this._isSet(e["disable-webrtc"]))
                            !1 === t.showLBM ? (t.availablePlayerModes = [],
                            t.showPlayerMode = !1) : (t.availablePlayerModes = [tn],
                            t.showPlayerMode = !1);
                        else {
                            let n;
                            if (e.forceWebrtc) {
                                const e = this._PrerequisitesService.getBrowser();
                                n = this._PrerequisitesService.browserSupportsWebRTC(e) ? nn : void 0
                            }
                            t.availablePlayerModes = this._PlayerModeService.getAvailablePlayerModes(n)
                        }
                        return t.showTimezoneOffset = !1,
                        t.showClose = !1,
                        t.showDewarp = this._isSet(e["show-dewarp"]),
                        t.showFullScreen = !1,
                        t.showPtz = this._isSet(e["single-player-ptz"]),
                        t.showPtzPresets = t.showPtz,
                        t.showPtz && (t.canManagePtzPresets = this._isSet(e["manage-ptz-presets"])),
                        t.showStats = !0,
                        t.showTimeline = !0,
                        t.showControls = t.showTimeline && !1 === this._isSet(e["hide-controls"]),
                        t.showHeader = this._isSet(e["show-header"]) || t.showPtz,
                        t.ptzControlColor = this._themeService.getPrimaryColorHex(),
                        t
                    }
                }, {
                    key: "_isSet",
                    value: function(e) {
                        return void 0 !== e && (!0 === e || "1" === e || "true" === e)
                    }
                }]),
                e
            }();
            angular.module("ipconfigure.orchid.singularity").factory("PlayerOptionsFactory", ["PlayerModeService", "ThemeService", "PrerequisitesService", function(e, t, n) {
                return new sn(e,t,n)
            }
            ]);
            const {v4: on} = n(21614);
            function cn(e, t, n, i, a, r, s) {
                var o;
                function c(e, n, i) {
                    e.element.node().innerHTML = "",
                    angular.element(e.element.node()).append(n);
                    var a = t(e.element.node().firstChild)(i);
                    o[i.id] = e,
                    i.$on("$destroy", (function() {
                        a.remove()
                    }
                    ))
                }
                function l(e) {
                    var t = angular.element(document.querySelector("#" + e));
                    return !!angular.isDefined(t.scope()) && (t.scope().$destroy(),
                    !0)
                }
                function d(e, t) {
                    i.cleanupCell(o[e], !t && u() > 1),
                    delete o[e]
                }
                function u() {
                    return Object.keys(o).length
                }
                return {
                    persist(e, t) {
                        if (!o)
                            return;
                        const n = o[e];
                        n && (Object.assign(n, t),
                        i.persistStageConfiguration())
                    },
                    persistPlayerLowBandwidthState(e, t) {
                        this.persist(e, {
                            forceLbm: t
                        })
                    },
                    persistPlayerStreamState(e, t) {
                        const n = o[e];
                        n && (n.camera.streamId = t,
                        this.persist(e, {
                            streamId: t
                        }))
                    },
                    persistDewarpModeState(e, t) {
                        if (!(t >= 0 && t <= 2))
                            throw new RangeError("dewarpMode must be 0, 1 or 2");
                        this.persist(e, {
                            dewarpMode: t
                        })
                    },
                    removeCellById: function(e, t) {
                        l(e) ? (!0 !== t && i.releaseCell(o[e]),
                        i.persistStageConfiguration()) : n.error("Unable to find cell: " + e),
                        d(e, t)
                    },
                    addMap: function(e, t) {
                        const n = "stage-" + on();
                        let a = angular.element(document.querySelector("stage")).scope().$new(!0);
                        a.id = n,
                        a.map = e,
                        t.type = "map",
                        t.map = {
                            id: e.id
                        };
                        c(t, '<map-cell [camera-group]="map" id="{{id}}"><map-cell/>', a),
                        i.persistStageConfiguration()
                    },
                    addPlayer: function(t, s, l) {
                        if (re(s) || re(t) || "object" != typeof s || 0 === Object.keys(s).length)
                            return n.error("Unable to add camera"),
                            void i.releaseCell(l);
                        if (!1 === re(a.maxPlayerCount) && Object.values(o).filter((function(e) {
                            return void 0 !== e.camera
                        }
                        )).length >= a.maxPlayerCount)
                            return n.error("Camera limit reached"),
                            void i.releaseCell(l);
                        const d = angular.element(document.querySelector("stage")).scope().$new(!0);
                        let u;
                        s.primaryStream && (u = s.primaryStream.id),
                        l.camera && !1 === re(l.camera.streamId) && !1 === isNaN(l.camera.streamId) && (u = l.camera.streamId),
                        d.id = "stage-" + on(),
                        d.title = e.isOrchid ? s.name : `${t.name}: ${s.name}`,
                        d.orchid = t,
                        d.camera = s,
                        d.streamId = u,
                        d.options = r.createStagePlayerOptions({
                            forceLbm: l.forceLbm,
                            dewarpMode: l.dewarpMode
                        }),
                        l.type = "player",
                        l.camera = {
                            id: s.id,
                            orchidId: s.orchidId,
                            streamId: u
                        },
                        c(l, '<player camera="camera" stream-id="streamId" id="{{id}}" options="options" orchid="orchid" camera-name="{{title}}"></player>', d),
                        i.persistStageConfiguration()
                    },
                    playerCount: u,
                    clearStage: function() {
                        var e = this;
                        angular.forEach(Object.keys(o), (function(t) {
                            e.removeCellById(t)
                        }
                        ))
                    },
                    cleanup() {
                        Object.keys(o).forEach((function(e) {
                            l(e),
                            d(e)
                        }
                        ))
                    },
                    init: function() {
                        o = {}
                    }
                }
            }
            function ln(e, t, n, i, a) {
                var r = {};
                function s(e) {
                    var t, r = this, s = {
                        paused: !1,
                        time: 0,
                        speed: 1
                    };
                    r.id = e,
                    r.linkedPlayerContainers = {},
                    r.getTime = function() {
                        return s.time
                    }
                    ,
                    r.getSpeed = function() {
                        return s.speed
                    }
                    ,
                    r.getPaused = function() {
                        return s.paused
                    }
                    ,
                    r.getTimeLengthFromPixels = function(e) {
                        return t.getTimeLengthFromPixels(e)
                    }
                    ,
                    r.subscribeEventSource = function(e) {
                        r._subscription = e.subscribe((function(e) {
                            null != t && t.setMotionEvents(e)
                        }
                        ))
                    }
                    ,
                    r.unsubscribeEventSource = function() {
                        r._subscription.unsubscribe()
                    }
                    ,
                    r.getCurrentState = function() {
                        var e = t.getFineTime();
                        return {
                            paused: s.paused,
                            time: s.time,
                            speed: s.speed,
                            fineTime: {
                                start: e[0],
                                stop: e[1]
                            }
                        }
                    }
                    ,
                    r.setTime = function(e, t) {
                        i.publish(r.id + "-set-time", e),
                        r.timeChanged(e, t)
                    }
                    ,
                    r.timeChanged = function(e, t) {
                        var a = this;
                        this._timeChangedDebouncer && n.cancel(this._timeChangedDebouncer),
                        this._timeChangedDebouncer = n((function() {
                            delete a._timeChangedDebouncer,
                            s.time = e,
                            !0 === t.publish && i.publish(r.id + "-time-changed", r.getCurrentState())
                        }
                        ), 50)
                    }
                    ,
                    r.setSpeed = function(e, t) {
                        s.speed !== e && (s.speed = e,
                        i.publish(r.id + "-set-speed", e),
                        t.publish && i.publish(r.id + "-speed-changed", e))
                    }
                    ,
                    r.setScale = function(e) {
                        i.publish(r.id + "-set-scale", e)
                    }
                    ,
                    r.setPaused = function(e, t) {
                        s.paused = e,
                        i.publish(r.id + "-pause-set", e),
                        !0 === t.publish && i.publish(r.id + "-pause-changed", e)
                    }
                    ,
                    r.scaleChanged = function(e) {
                        i.publish(r.id + "-scale-changed", e)
                    }
                    ,
                    r.storeTime = function(e) {
                        s.time = e
                    }
                    ,
                    r.storeTimeline = function(e) {
                        t = e
                    }
                    ,
                    r.getTimeline = function() {
                        return t
                    }
                    ,
                    r.rip = function(e) {
                        i.publish(r.id + "-rip", e)
                    }
                    ,
                    r.on = function(e, t) {
                        return i.subscribe(r.id + "-" + e, t)
                    }
                    ,
                    r.off = function(e) {
                        "string" == typeof e ? i.unsubscribe(r.id + "-" + e) : i.unsubscribe(e)
                    }
                    ,
                    r.getLinkedStreams = function(e) {
                        return Object.keys(r.linkedPlayerContainers).map((function(t) {
                            var n = r.linkedPlayerContainers[t].playerContainers.filter((function(t, n, i) {
                                var r = function(e, t) {
                                    for (var n = Object.keys(t), i = 0; i < n.length; ++i)
                                        if (t[n[i]] !== e.actions[n[i]])
                                            return !1;
                                    return !0
                                }(t.camera.permissions, e)
                                  , s = !0 !== a.isInFullscreenMode || t.isFullScreen;
                                return r && s
                            }
                            )).map((function(e) {
                                if (!se(e.camera.primaryStream))
                                    return e.camera.primaryStream.id
                            }
                            )).filter((function(e, t, n) {
                                return void 0 !== e && n.indexOf(e) === t
                            }
                            ));
                            return {
                                orchid: r.linkedPlayerContainers[t].orchid,
                                streamIds: n.join(",")
                            }
                        }
                        ))
                    }
                    ,
                    r.getLinkedCameras = function() {
                        return Object.keys(r.linkedPlayerContainers).map((function(e) {
                            var t = r.linkedPlayerContainers[e].playerContainers.filter((function(e, t, n) {
                                return !0 !== a.isInFullscreenMode || e.isFullScreen
                            }
                            )).map((function(e) {
                                return e.camera
                            }
                            )).filter((function(e, t, n) {
                                return n.indexOf(e) === t
                            }
                            ));
                            return {
                                orchid: r.linkedPlayerContainers[e].orchid,
                                cameras: t
                            }
                        }
                        ))
                    }
                    ,
                    r.linkPlayer = function(e, t) {
                        angular.isUndefined(r.linkedPlayerContainers[e.id]) && (r.linkedPlayerContainers[e.id] = {
                            orchid: e,
                            playerContainers: []
                        }),
                        r.linkedPlayerContainers[e.id].playerContainers.push(t)
                    }
                    ,
                    r.unlinkPlayer = function(e, t) {
                        angular.isDefined(r.linkedPlayerContainers[e]) && -1 !== r.linkedPlayerContainers[e].playerContainers.indexOf(t) && (r.linkedPlayerContainers[e].playerContainers.splice(r.linkedPlayerContainers[e].playerContainers.indexOf(t), 1),
                        0 === r.linkedPlayerContainers[e].playerContainers.length && delete r.linkedPlayerContainers[e])
                    }
                }
                return {
                    createContext: function(e) {
                        if (r[e])
                            throw "context already exists: " + e;
                        return r[e] = new s(e)
                    },
                    getContext: function(e) {
                        return r[e]
                    },
                    releaseContext: function(e) {
                        delete r[e]
                    }
                }
            }
            cn.$inject = ["$rootScope", "$compile", "$log", "MatrixService", "RenewableService", "PlayerOptionsFactory", "FusionDataService"],
            angular.module("ipconfigure.orchid.singularity").factory("StageService", cn),
            ln.$inject = ["$rootScope", "$log", "$timeout", "PubSub", "NGStageService"],
            angular.module("ipconfigure.orchid.singularity").factory("TimelineServiceFactory", ln);
            var dn, un, mn, hn = n(61418), pn = n(74727);
            const gn = O("ConfirmDialog");
            let fn = dn = class {
                constructor(e, t, n) {
                    this.options = e,
                    this.matDialogRef = t,
                    this.changeDetector = n,
                    this.isProcessing = !1,
                    this.msgs = L.messages.dialogs
                }
                cancel() {
                    this.matDialogRef.disableClose || this.matDialogRef.close()
                }
                confirm() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        try {
                            this.matDialogRef.disableClose = !0,
                            this.isProcessing = !0,
                            this.options.confirmCallback && this.options.confirmCallback(this.options.value),
                            this.options.confirmCallbackAsync && (yield this.options.confirmCallbackAsync(this.options.value)),
                            this.matDialogRef.close(this.options.value)
                        } catch (e) {
                            (null == e ? void 0 : e.message) ? this.error = e.message : (this.error = this.msgs.anUnexpectedErrorHasOccurred(),
                            gn.error(e))
                        } finally {
                            this.isProcessing = !1,
                            this.matDialogRef.disableClose = !1,
                            this.changeDetector.detectChanges()
                        }
                    }
                    ))
                }
                onEsc() {
                    this.cancel()
                }
                onEnter() {
                    this.options.value && this.confirm()
                }
                static show(e, t) {
                    return e.open(dn, t).afterClosed().pipe((0,
                    pn.q)(1))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.HostListener)("keydown.esc"), (0,
            c.w6)("design:type", Function), (0,
            c.w6)("design:paramtypes", []), (0,
            c.w6)("design:returntype", void 0)], fn.prototype, "onEsc", null),
            (0,
            c.gn)([(0,
            i.HostListener)("keydown.enter"), (0,
            c.w6)("design:type", Function), (0,
            c.w6)("design:paramtypes", []), (0,
            c.w6)("design:returntype", void 0)], fn.prototype, "onEnter", null),
            fn = dn = (0,
            c.gn)([(0,
            i.Component)({
                changeDetection: i.ChangeDetectionStrategy.OnPush,
                selector: "sing-prompt-dialog",
                template: n(14211)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(2, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (un = void 0 !== hn.so && hn.so) ? un : Object, "function" == typeof (mn = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? mn : Object])], fn),
            function() {
                function e(e) {
                    return function(t, n, i) {
                        var a, r, s, o, c, l, d, u = [], m = "";
                        if (angular.isDefined(i) && (m = i.map((function(e) {
                            return e.name
                        }
                        )).join(" > ")),
                        !e.hasOrchids() || angular.isUndefined(t) || t.length < 1)
                            return [];
                        if (angular.isUndefined(n) || n.length < 1)
                            return t.map((function(t) {
                                return e.findCamera(t.orchidId, t.id)
                            }
                            )).filter((function(e) {
                                return angular.isDefined(e)
                            }
                            ));
                        for (r = 0; r < t.length; ++r)
                            for (a = 0; a < n.length; ++a)
                                if (o = n[a].toLowerCase().split(" "),
                                c = !0,
                                t && t[r]) {
                                    for (l = t[r] ? e.findCamera(t[r].orchidId, t[r].id) : void 0,
                                    d = e.findOrchid(l.orchidId),
                                    s = 0; s < o.length; ++s)
                                        if (d.name.toLowerCase().indexOf(o[s]) < 0 && l.name.toLowerCase().indexOf(o[s]) < 0 && m.toLowerCase().indexOf(o[s]) < 0 && ee(l).toLowerCase().indexOf(o[s]) < 0) {
                                            c = !1;
                                            break
                                        }
                                    if (c) {
                                        u.push(l);
                                        break
                                    }
                                }
                        return u
                    }
                }
                e.$inject = ["RenewableService"],
                angular.module("ipconfigure.orchid.singularity").filter("bagSearch", e)
            }(),
            angular.module("ipconfigure.orchid.singularity").controller("CameraGroupController", (function() {
                var e = this;
                e.toggleExpand = function(t) {
                    e.expanded[t.id] = !e.expanded[t.id]
                }
                ,
                e.$onInit = function() {
                    e.msgs = Object.assign({}, L.messages.cameraGroups, L.messages.bag.cameraGroup),
                    e.childCameraCounts = {},
                    e.totalCameras = 0,
                    e.cameraCount = 0,
                    e.parentPath || (e.parentPath = []),
                    e.path = angular.copy(e.parentPath),
                    e.depth = e.parentDepth ? e.parentDepth + 1 : 1,
                    e.group && (e.path.push(e.group),
                    angular.forEach(e.group.groups, (function(t) {
                        e.expanded[t.id] = !1
                    }
                    )))
                }
            }
            )).directive("cameraGroup", (function() {
                return {
                    scope: {},
                    restrict: "E",
                    bindToController: {
                        group: "=",
                        cameraLayout: "=",
                        orchids: "=",
                        parentPath: "=?",
                        parentDepth: "=?",
                        parentId: "=?",
                        handleDoubleClick: "<",
                        enterGroup: "<",
                        expanded: "=?"
                    },
                    controller: "CameraGroupController",
                    controllerAs: "cameraGroup",
                    template: n(48507)
                }
            }
            ));
            n.p;
            function vn(e, t, n, i, a, r, s, c, l, d, u, m, h, p, g, f, v, y) {
                var b, S = this;
                function C(e, t) {
                    const n = g.findOrchid(e)
                      , i = g.findCamera(e, t);
                    return void 0 === n || void 0 === i ? null : {
                        name: i.name,
                        orchidName: n.name,
                        detail: ee(i),
                        orchidId: e,
                        cameraId: t,
                        active: i.active
                    }
                }
                function I(e) {
                    var t = -1;
                    if (e.isNew)
                        t = S.stages.length - 1;
                    else
                        for (var n = 0; n < S.stages.length; ++n)
                            if (e.id === S.stages[n].id) {
                                t = n;
                                break
                            }
                    return t
                }
                function T(e) {
                    const t = {
                        ...S.msgs.dialogs.bagStagesDialog,
                        cancel: S.msgs.dialogs.cancel
                    }
                      , n = {
                        panelClass: "stage-name-dialog",
                        data: {
                            value: e.name,
                            message: t.stageName(),
                            title: e.isNew ? t.newStage() : t.renameNamedStage({
                                VALUE: e.name
                            }),
                            confirmText: e.isNew ? t.saveStage() : t.renameStage(),
                            cancelText: t.cancel()
                        }
                    };
                    n.data.confirmCallbackAsync = async function(n) {
                        if (0 === n.trim().length)
                            throw new Error(t.nameRequired());
                        const i = e.isNew ? d.addStage : d.updateStage
                          , a = {
                            ...e,
                            name: n,
                            cameras: p.getCamerasFromMatrix(e.stageMatrix)
                        };
                        try {
                            await i(a)
                        } catch (e) {
                            throw re(e.data) || re(e.data.reason) ? e : new Error(e.data.reason)
                        }
                    }
                    ,
                    fn.show(c, n)
                }
                function E(e) {
                    var t = I(e);
                    h.clearStage(),
                    r((function() {
                        S.restoreStage(e),
                        r((function() {
                            S.stageCycle.currentStage = S.stages[t].id,
                            O()
                        }
                        ))
                    }
                    ))
                }
                function _() {
                    const e = window.location.href.match(/\/stage\/(.*)/);
                    return null !== e ? e[1] : null
                }
                function x(e) {
                    if (void 0 === e)
                        return h.clearStage(),
                        void S.restoreStage();
                    d.fetchStage(e).then((function(e) {
                        0 === e.cameras.length || e.cameras.every((function(e) {
                            return !1 === e.hasPermission
                        }
                        )) ? window.location.href = "/#!/access-denied" : e.expirationMs > 0 && e.expirationMs < Date.now() ? window.location.href = "/#!/expired" : (h.clearStage(),
                        S.restoreStage(e),
                        e.playbackStartTimeMs > 0 && y.getContext("master").setTime(e.playbackStartTimeMs, {
                            publish: !0
                        }))
                    }
                    )).catch((function(e) {
                        window.location.href = "/#!/not-found"
                    }
                    ))
                }
                S.isAdmin = l.getAuthenticationData().isAdministrator(),
                S.canRegister = !1,
                S.isOrchid = e.isOrchid,
                S.isOrchid || (S.canRegister = S.isAdmin || l.getAuthenticationData().isRecorderRegistrar()),
                S.expanded = !1,
                S.dragStartPoint = {
                    x: 0,
                    y: 0
                },
                S.layout = w.isOrchid ? "LARGE" : "GRID",
                S.oldLayout = S.layout,
                S.search = [],
                S.stages = [],
                S.stageCycle = m.getSettings("stage-cycle") || {
                    speed: 0,
                    currentStage: void 0,
                    excludeFromCycle: {}
                },
                w.isOrchid || (S.appSettings = v.getConfigPostAuth().config),
                S.icons = {
                    ...zt
                },
                S.groups = [],
                S.clearStage = function() {
                    h.clearStage(),
                    S.stageCycle.speed = 0,
                    O()
                }
                ,
                S.toggle = function() {
                    S.expanded = !S.expanded,
                    !0 === S.expanded && (S.expandedOnce = !0),
                    a.toggle()
                }
                ,
                S.handleRenderItemClick = function(e) {
                    if (e < 0 || e > S.bagRenderInfo.renderItems.length)
                        return;
                    const t = S.bagRenderInfo.renderItems[e];
                    It(t) && (t.isExpanded ? S.bagRenderInfo = function(e, t) {
                        if (t < 0 || t >= e.renderItems.length)
                            throw new Error("renderItemIndex is not within the renderItems range!");
                        const n = e.renderItems[t];
                        if (!It(n))
                            throw new Error("renderItem is not collapsable.");
                        if (!n.isExpanded)
                            throw new Error("Cannot collapse renderItem since it is not expanded.");
                        const i = {
                            renderItems: [...e.renderItems],
                            runlengthEncoding: []
                        }
                          , a = i.renderItems[t]
                          , r = t + 1;
                        let s = 0;
                        const o = a.nesting;
                        for (let e = r; e < i.renderItems.length && !(i.renderItems[e].nesting <= o); e++)
                            s++;
                        return s > 0 && i.renderItems.splice(r, s),
                        a.isExpanded = !1,
                        i.runlengthEncoding = Ut(i.renderItems),
                        i
                    }(S.bagRenderInfo, e) : Ct(t) ? function(e) {
                        S.bagRenderInfo = Lt(S.bagRenderInfo, e, S.filteredGroup, C, S.layout)
                    }(e) : wt(t) && function(e, t) {
                        const n = S.filteredOrchids.find((function(e) {
                            return e.id === t
                        }
                        ));
                        void 0 !== n && (S.bagRenderInfo = Nt(S.bagRenderInfo, e, n, C, S.layout))
                    }(e, t.orchidId),
                    S.bagRenderInfo = {
                        renderItems: [...S.bagRenderInfo.renderItems],
                        runlengthEncoding: [...S.bagRenderInfo.runlengthEncoding]
                    })
                }
                ,
                S.editStage = function(e) {
                    T(e)
                }
                ,
                S.newStage = function() {
                    T({
                        shared: !1,
                        isNew: !0,
                        name: "",
                        stageMatrix: u.buildSerializableMatrix()
                    })
                }
                ,
                S.shareStage = function(e) {
                    e.shadowShared = !0,
                    S.saveStage(e)
                }
                ,
                S.unshareStage = function(e) {
                    e.shadowShared = !1,
                    S.saveStage(e)
                }
                ,
                S.saveStage = function(e) {
                    var t = o().copy(e)
                      , n = e.isNew ? d.addStage : d.updateStage
                      , i = I(e);
                    o().isDefined(e.isNew) && (t.stageMatrix = u.buildSerializableMatrix(),
                    S.stages.splice(i, 1)),
                    o().isDefined(t.shadowName) && (t.name = t.shadowName),
                    o().isDefined(t.shadowShared) && (t.shared = t.shadowShared),
                    o().isDefined(t.updatedMatrix) && (t.stageMatrix = t.updatedMatrix),
                    t.cameras = p.getCamerasFromMatrix(t.stageMatrix),
                    n(t).then((function(e) {}
                    ), (function(e) {}
                    ))
                }
                ,
                S.selectStage = function(e) {
                    S.stageCycle.speed = 0,
                    O(),
                    E(e)
                }
                ,
                S.updateStage = function(e) {
                    e.updatedMatrix = u.buildSerializableMatrix(),
                    S.saveStage(e)
                }
                ,
                S.removeStage = function(e) {
                    var t = I(e);
                    S.stages.splice(t, 1),
                    d.deleteStage(e)
                }
                ,
                S.toggleCycleInclude = function(e) {
                    S.stageCycle.excludeFromCycle[e.id] = !S.stageCycle.excludeFromCycle[e.id],
                    O()
                }
                ,
                S.cycleStages = function() {
                    var e = S.stages.filter((function(e) {
                        return o().isUndefined(e.isNew) && !0 !== S.stageCycle.excludeFromCycle[e.id]
                    }
                    ));
                    if (e.length > 0) {
                        var t = e.map((function(e) {
                            return e.id
                        }
                        )).indexOf(S.stageCycle.currentStage);
                        E(e[t = (t + 1) % e.length])
                    }
                    b = a.$smartTimeout((function() {
                        S.cycleStages()
                    }
                    ), 1e3 * S.stageCycle.speed)
                }
                ,
                S.restoreStage = function(e) {
                    var t, n;
                    u.reloadStageConfiguration((async function(e) {
                        try {
                            if ("map" === e.type) {
                                if (re(e.map))
                                    throw new Error("Invalid map storage settings");
                                const t = await d.fetchCameraGroupById(e.map.id);
                                if (re(t) || re(t.mapConfiguration))
                                    throw new Error("Could not find map configuration");
                                await h.addMap(t, e)
                            } else
                                t = g.findOrchid(e.camera.orchidId),
                                n = g.findCamera(e.camera.orchidId, e.camera.id),
                                o().isDefined(t) && o().isDefined(n) ? h.addPlayer(t, n, e) : u.releaseCell(e, !0)
                        } catch (t) {
                            i.error(`Failed to load cell type: ${e.type} Error: (${t.message})`),
                            u.releaseCell(e, !1)
                        }
                    }
                    ), e ? o().copy(e.stageMatrix) : void 0)
                }
                ,
                S.loading = !0;
                const D = [g.orchidsPromise()];
                function O() {
                    m.setSettings("stage-cycle", S.stageCycle)
                }
                function A(t, n) {
                    S.listeners.push(e.$on(t, n))
                }
                function R(e, t) {
                    let i = o().copy(e)
                      , a = t.concat([e]);
                    return i.cameras = n("bagSearch")(e.cameras, S.search, a),
                    i.count = i.cameras.length,
                    i.groups = [],
                    o().forEach(e.groups, (function(e) {
                        let t = R(e, a);
                        (t.count > 0 || t.groups.length > 0) && (i.count += t.cameras.length,
                        i.groups.push(t))
                    }
                    )),
                    i
                }
                let P;
                function k() {
                    P && r.cancel(P),
                    P = r(M, 300)
                }
                function M() {
                    0 === S.search.length ? (S.filteredGroup = void 0 !== S.currentGroup && void 0 !== S.currentGroup.groups && 0 !== S.currentGroup.groups.length ? S.currentGroup : void 0,
                    S.filteredOrchids = w.isOrchid || void 0 === S.filteredGroup || ie(S.appSettings["groups.orchids.show"]) ? S.orchids : void 0) : (re(S.filteredGroup) || (S.filteredGroup = R(S.currentGroup, [])),
                    re(S.filteredOrchids) || (S.filteredOrchids = function(e, t) {
                        const i = [];
                        let a, r;
                        return o().forEach(e, (function(e) {
                            a = n("bagSearch")(e.cameras, t),
                            a.length > 0 && (r = o().copy(e),
                            r.cameras = a,
                            i.push(r))
                        }
                        )),
                        i
                    }(S.orchids, S.search))),
                    S.bagRenderInfo = Mt(S.filteredOrchids, S.filteredGroup, S.bagRenderInfo, C, S.layout),
                    P = void 0
                }
                function N(e, t) {
                    e.cameras = e.cameras.filter((function(e) {
                        return e.orchidId !== t.id
                    }
                    )),
                    o().forEach(e.groups, (function(e) {
                        N(e, t)
                    }
                    ))
                }
                function F(e, t) {
                    e.cameras = e.cameras.filter((function(e) {
                        return !(e.orchidId === t.orchidId && e.id === t.id)
                    }
                    )),
                    o().forEach(e.groups, (function(e) {
                        F(e, t)
                    }
                    ))
                }
                !1 === w.isOrchid && D.push(d.fetchCameraGroups(!0)),
                S.routeWatcher = e.$watch((function() {
                    return window.location.href
                }
                ), (function() {
                    const e = _();
                    null !== e && x(e)
                }
                )),
                Promise.allSettled(D).then((function(e) {
                    let[t,n] = e;
                    if (w.isOrchid) {
                        const e = S.orchids[0];
                        let t = e.cameras.map((function(t) {
                            return {
                                name: t.name,
                                orchidName: e.name,
                                detail: ee(t),
                                orchidId: e.id,
                                cameraId: t.id,
                                active: t.active
                            }
                        }
                        ));
                        S.bagRenderInfo = function(e) {
                            const t = {
                                renderItems: [],
                                runlengthEncoding: []
                            };
                            return t.renderItems = $t(e, ft.Large),
                            t.runlengthEncoding = Ut(t.renderItems),
                            t
                        }(t)
                    } else
                        "fulfilled" === n.status ? (S.rootGroup = n.value.data,
                        S.currentGroup = S.rootGroup,
                        S.bagFocus = S.rootGroup.groups.length < 1 ? "orchids" : "groups") : S.bagFocus = "orchids",
                        k();
                    const i = _();
                    null !== i ? x(i) : x()
                }
                )).catch((function(e) {
                    i.error("An error occurred while initializing the bag", e.data ? e.data.reason : e)
                }
                )).finally((function() {
                    return S.loading = !1
                }
                )),
                S.onSearchChange = function() {
                    S.filteredOrchids = {}
                }
                ,
                S.msgs = {
                    ...L.messages.bag,
                    dialogs: L.messages.dialogs
                },
                S.listeners = [],
                S.oldViewportHeight = window.innerHeight,
                e.isOrchid && (S.rootGroup = {
                    groups: []
                }),
                h.init(),
                A("stageChanged", (function() {
                    S.currentStage = void 0
                }
                )),
                A("stageInteract", (function() {
                    S.stageCycle.speed = 0,
                    O()
                }
                )),
                A("stageAdded", (function(e, t) {
                    -1 === I(t) && (S.stages.push(t),
                    S.stages = n("orderBy")(S.stages, "name"))
                }
                )),
                A("stageModified", (function(e, t) {
                    var i = I(t);
                    i >= 0 && (S.stages[i] = t,
                    S.stages = n("orderBy")(S.stages, "name"))
                }
                )),
                A("stageRemoved", (function(e, t) {
                    var n = I(t);
                    n >= 0 && S.stages.splice(n, 1)
                }
                )),
                A("cameraGroupsModified", (function(e, t) {
                    S.rootGroup.groups = t,
                    k()
                }
                )),
                A("orchidChanged", (function(e, t) {
                    !0 === t.defunct && N(S.rootGroup, t),
                    k()
                }
                )),
                A("orchidAdded", (function(e, t) {
                    k()
                }
                )),
                A("cameraChanged", (function(e, t) {
                    !0 === t.defunct && F(S.rootGroup, t),
                    k()
                }
                )),
                A("advancedRecover", (function(e, t) {
                    k()
                }
                )),
                A("advancedRecoverGroups", (function(e, t) {
                    S.rootGroup.groups = t,
                    k()
                }
                )),
                "Android" === f.getDeviceInfo().operatingSystem && A("resize", (function(e) {
                    o().isUndefined(S.searchElement) && (S.searchElement = document.querySelector("#bag-search-container input")),
                    document.activeElement === S.searchElement && window.innerHeight > S.oldViewportHeight && S.searchElement.blur(),
                    S.oldViewportHeight = window.innerHeight
                }
                )),
                a.$watch((function() {
                    return S.layout
                }
                ), M),
                a.$watch((function() {
                    return S.search.length
                }
                ), M),
                a.$watch((function() {
                    return S.orchids
                }
                ), M),
                !0 !== e.isOrchid && d.fetchStages().then((function(e) {
                    S.stages = n("orderBy")(e.data, "name")
                }
                )),
                a.$watch((function() {
                    return S.stageCycle.speed
                }
                ), (function(e, t) {
                    var n = t > 0 ? 1e3 * e : 300;
                    r.cancel(b),
                    S.stageCycle.speed > 0 && (b = a.$smartTimeout((function() {
                        S.cycleStages()
                    }
                    ), n)),
                    O()
                }
                )),
                a.$on("$destroy", (function() {
                    const e = s[0].querySelectorAll("md-select");
                    r((function() {
                        o().element.cleanData(e)
                    }
                    )),
                    o().forEach(S.listeners, (function(e) {
                        e()
                    }
                    )),
                    S.routeWatcher()
                }
                ))
            }
            function yn(e, t, i, a, r, s, c, l, d) {
                return {
                    restrict: "E",
                    template: n(44300),
                    bindToController: {
                        orchids: "=",
                        selectionMode: "="
                    },
                    controller: "BagController as bag",
                    link: function(n, u, m, h) {
                        let p, g, f, v = u[0], y = document.getElementById("drag-floater");
                        function b() {
                            e.$broadcast("resize")
                        }
                        function S(e, t) {
                            d3.select(y).style("opacity", .75).transition().duration(333).style("opacity", 0).style("left", e + "px").style("top", t + "px").each("end", (function() {
                                y.style.display = "none"
                            }
                            ))
                        }
                        function C(e) {
                            return e.preventDefault(),
                            e.stopPropagation(),
                            !1
                        }
                        function I(e) {
                            let t = d3.event.sourceEvent
                              , n = t.target;
                            window.TouchEvent && t instanceof window.TouchEvent && (self.dragStartPoint = {
                                x: t.touches[0].clientX,
                                y: t.touches[0].clientY
                            });
                            const i = function(e) {
                                return "STREAM-PREVIEW" === e.tagName || e.classList.contains("map-item-button")
                            };
                            for (; null !== n && !i(n); )
                                n = n.parentElement;
                            null !== n && i(n) && (e.target = n),
                            e.target ? "STREAM-PREVIEW" === e.target.tagName ? function(e) {
                                let t, n = e.target.querySelector("IMG");
                                t = n.offsetWidth > 0 && n.offsetHeight > 0 ? n : e.target;
                                e.offsetX = -1 * t.offsetWidth / 2,
                                e.offsetY = 80 - t.offsetHeight / 2,
                                d3.select(y).transition().duration(1).style("opacity", .75).style("left", "").style("top", "").style("width", t.clientWidth + "px").style("height", t.clientHeight + "px").style("display", "block"),
                                y.width = t.clientWidth,
                                y.height = t.clientHeight;
                                let i = y.getContext("2d");
                                n.offsetWidth > 0 && n.offsetHeight > 0 ? i.drawImage(n, 0, 0, e.target.clientWidth, e.target.clientHeight) : (i.beginPath(),
                                i.rect(0, 0, 999, 999),
                                i.fillStyle = "black",
                                i.fill())
                            }(e) : function(e) {
                                const t = 100
                                  , n = 56.25;
                                d3.select(y).transition().duration(1).style("opacity", .75).style("left", "").style("top", "").style("width", "").style("height", "").style("display", "block"),
                                e.offsetX = -1 * t / 2,
                                e.offsetY = n,
                                y.width = t,
                                y.height = n;
                                !function(e, t, n) {
                                    const i = (t - 9) / 2
                                      , a = (n + 9) / 2;
                                    e.font = 'bold 18px "Font Awesome 6 Pro"',
                                    e.strokeStyle = "white",
                                    e.lineWidth = 2,
                                    e.strokeText("", i, a),
                                    e.fillStyle = d.getPrimaryColorHex(),
                                    e.fillText("", i, a)
                                }(y.getContext("2d"), t, n)
                            }(e) : e.scroll = !0
                        }
                        function T(e) {
                            if (!e.drag && !e.scroll)
                                if (window.TouchEvent && d3.event.sourceEvent instanceof window.TouchEvent) {
                                    const t = d3.event.sourceEvent.touches[0].clientX
                                      , n = d3.event.sourceEvent.touches[0].clientY;
                                    Math.abs(t - self.dragStartPoint.x) >= Math.abs(n - self.dragStartPoint.y) ? (e.drag = !0,
                                    e.container.addEventListener("scroll", C),
                                    e.container.addEventListener("mousewheel", C),
                                    e.container.addEventListener("touchmove", C)) : e.scroll = !0
                                } else
                                    d3.event.sourceEvent instanceof MouseEvent && (e.drag = !0);
                            e.scroll ? f.scrollTop -= d3.event.dy : e.drag && (e.dragged = !0,
                            y.style.left = d3.event.x + e.offsetX + "px",
                            y.style.top = d3.event.y + e.offsetY + "px",
                            window.TouchEvent && d3.event.sourceEvent instanceof window.TouchEvent ? (e.pageX = d3.event.sourceEvent.touches[0].pageX,
                            e.pageY = d3.event.sourceEvent.touches[0].pageY) : (e.pageX = d3.event.sourceEvent.pageX,
                            e.pageY = d3.event.sourceEvent.pageY),
                            e.pageX > v.clientWidth ? a.dragOver(e.pageX, e.pageY) : a.dragClear())
                        }
                        function E(n) {
                            if (n.container.removeEventListener("scroll", C),
                            n.container.removeEventListener("mousewheel", C),
                            n.container.removeEventListener("touchmove", C),
                            n.target && n.dragged)
                                if (n.pageX < v.clientWidth) {
                                    const e = n.target.getBoundingClientRect();
                                    S(e.left, e.top),
                                    a.drop()
                                } else
                                    a.claimCellByCoordinates(n.pageX, n.pageY, (function(i) {
                                        if (!1 !== i) {
                                            i.element.node().firstElementChild && r.removeCellById(o().element(i.element.node().firstElementChild).scope().id, !0);
                                            let s = parseInt(n.target.dataset.cameraId)
                                              , d = w.isOrchid ? parseInt(n.target.dataset.orchidId) : n.target.dataset.orchidId;
                                            if (o().element(n.target).scope().orchid)
                                                O(o().element(n.target).scope().orchid, o().element(n.target).scope().camera, i);
                                            else if (void 0 !== s && void 0 !== d)
                                                O(c.findOrchid(d), c.findCamera(d, s), i);
                                            else {
                                                !function(n, i) {
                                                    const s = a.getElement();
                                                    e.$broadcast("stageInteract");
                                                    const o = i.top + s.offsetTop + i.height / 2
                                                      , c = i.left + s.offsetLeft + i.width / 2;
                                                    d3.select(y).style("opacity", .8).transition().duration(500).style("opacity", 0).style("top", o + "px").style("left", c + "px").each("end", (function() {
                                                        y.style.display = "none"
                                                    }
                                                    )),
                                                    t((async function() {
                                                        const e = await l.fetchCameraGroupById(n);
                                                        if (re(e) || re(e.mapConfiguration))
                                                            throw new Error("Could not find map configuration");
                                                        await r.addMap(e, i)
                                                    }
                                                    ), 500)
                                                }(n.target.dataset.groupId, i)
                                            }
                                            a.drop()
                                        } else
                                            S(n.target.offsetLeft, n.target.offsetTop - n.container.scrollTop),
                                            a.drop()
                                    }
                                    ));
                            else
                                n.target && d3.select(y).transition().style("display", "none");
                            delete n.drag,
                            delete n.dragged,
                            delete n.offsetX,
                            delete n.offsetY,
                            delete n.originalCoordinates,
                            delete n.scroll,
                            delete n.target
                        }
                        function _(e) {
                            for (var t, n, i, a, r, s, c = d3.event.sourceEvent.target, l = 160, d = 110, u = 0, m = 0; null !== c && !c.classList.contains("stage-row"); )
                                c = c.parentElement;
                            if (null !== c && c.classList.contains("stage-row") && (e.target = c),
                            e.target && !0 !== o().element(e.target).scope().editting) {
                                if (e.offsetX = -1 * e.target.parentElement.offsetWidth / 2,
                                e.offsetY = 60 - e.target.offsetHeight / 2,
                                d3.select(y).transition().duration(1).style("opacity", .75).style("left", "").style("top", "").style("width", "").style("height", ""),
                                y.style.opacity = .75,
                                y.style.width = "",
                                y.style.height = "",
                                y.width = l,
                                y.height = d,
                                (t = y.getContext("2d")).beginPath(),
                                t.rect(0, 0, 999, 999),
                                t.fillStyle = "black",
                                t.fill(),
                                (i = (r = o().element(e.target).scope().stage.stageMatrix).length) > 0) {
                                    d / i < l / (a = r[0].length) ? (u = (l - (a * (n = d / (5 * i + 1)) * 5 - n)) / 2,
                                    m = n) : (u = n = l / (5 * a + 1),
                                    m = (d - (i * n * 5 - n)) / 2);
                                    for (var h = 0; h < i; ++h)
                                        for (var p = 0; p < a; ++p)
                                            (s = r[h][p]).camera && s.camera.id && (s.rowSpan = s.rowSpan || 1,
                                            s.columnSpan = s.columnSpan || 1,
                                            t.fillStyle = "rgb(" + Math.floor(60 + 30 * Math.random()) + "," + Math.floor(60 + 30 * Math.random()) + "," + Math.floor(60 + 30 * Math.random()) + ")",
                                            t.fillRect(u + n * (5 * p), m + n * (5 * h), n * (5 * s.columnSpan - 1), n * (5 * s.rowSpan - 1)))
                                }
                            } else
                                e.scroll = !0
                        }
                        function x(e) {
                            e.scroll || e.drag || (e.originalCoordinates ? d3.event.x >= e.originalCoordinates.x + 60 ? e.drag = !0 : (d3.event.y >= e.originalCoordinates.y + 60 || d3.event.y <= e.originalCoordinates.y - 60) && (e.scroll = !0) : e.originalCoordinates = {
                                x: d3.event.x,
                                y: d3.event.y
                            }),
                            e.scroll ? e.container.scrollTop -= d3.event.dy : e.drag && (e.dragged = !0,
                            y.style.display = "",
                            y.style.left = d3.event.x + e.offsetX + "px",
                            y.style.top = d3.event.y + e.offsetY + "px",
                            window.TouchEvent && d3.event.sourceEvent instanceof window.TouchEvent ? (e.pageX = d3.event.sourceEvent.touches[0].pageX,
                            e.pageY = d3.event.sourceEvent.touches[0].pageY) : (e.pageX = d3.event.sourceEvent.pageX,
                            e.pageY = d3.event.sourceEvent.pageY),
                            e.pageX > v.clientWidth ? a.dragOver(e.pageX, e.pageY, !0) : a.dragClear())
                        }
                        function D(e) {
                            var t;
                            e.target && e.dragged && (e.pageX < v.clientWidth ? (S((t = e.target.getBoundingClientRect()).left, t.top),
                            a.drop()) : (y.style.display = "none",
                            a.drop(),
                            e.target.click())),
                            delete e.drag,
                            delete e.dragged,
                            delete e.offsetX,
                            delete e.offsetY,
                            delete e.originalCoordinates,
                            delete e.scroll,
                            delete e.target
                        }
                        function O(n, l, d, u) {
                            var m, h, p, g, f, v = a.getElement();
                            if (e.$broadcast("stageInteract"),
                            !0 === o().isUndefined(c.maxPlayerCount) || r.playerCount() < c.maxPlayerCount)
                                !0 === u ? r.addPlayer(n, l, d) : (h = (m = s.fillRectangle(d.left + v.offsetLeft, d.top + v.offsetTop, d.width, d.height, y.width, y.height)).width,
                                p = m.height,
                                g = m.top,
                                f = m.left,
                                d3.select(y).style("opacity", .75).transition().duration(333).style("opacity", .25).style("top", g + "px").style("left", f + "px").style("width", h + "px").style("height", p + "px").each("end", (function() {
                                    y.style.display = "none"
                                }
                                )),
                                t((function() {
                                    r.addPlayer(n, l, d)
                                }
                                ), 333));
                            else {
                                a.releaseCell(d, !1),
                                y.style.display = "none";
                                const {ok: e, bagDialog: t} = self.msg.dialogs
                                  , n = t.playerLimitExceeded();
                                i.show(i.alert().title(n).textContent(t.cannotViewMoreThanNPlayers({
                                    VALUE: c.maxPlayerCount
                                })).ariaLabel(n).ok(e()))
                            }
                        }
                        n.handleStreamPreviewDoubleClick = function(e) {
                            const t = c.findOrchid(e.orchidId)
                              , n = c.findCamera(e.orchidId, e.cameraId);
                            a.obtainContainer((function(i) {
                                let a = y.getContext("2d")
                                  , r = e.target.getBoundingClientRect();
                                "IMG" !== e.target.tagName && (a.beginPath(),
                                a.rect(0, 0, 999, 999),
                                a.fillStyle = "black",
                                a.fill()),
                                d3.select(y).style("opacity", .75).style("left", r.left + "px").style("top", r.top + "px").style("width", e.target.clientWidth + "px").style("height", e.target.clientHeight + "px").style("display", ""),
                                O(t, n, i)
                            }
                            ))
                        }
                        ,
                        n.toggle = function() {
                            v.classList.toggle("collapsed"),
                            v.classList.toggle("expanded"),
                            a.getElement().classList.toggle("expanded")
                        }
                        ,
                        n.$on("$destroy", (function() {
                            u.off("webkitTransitionEnd transitionend msTransitionEnd oTransitionEnd", b),
                            d3.select(g).on(".drag", null),
                            d3.select(p).on(".drag", null)
                        }
                        )),
                        t((function() {
                            !function() {
                                g = v.querySelector("#bag-render"),
                                p = v.querySelector(".stages-container"),
                                f = v.querySelector("#cameras-column");
                                const e = d3.behavior.drag().on("dragstart", I).on("drag", T).on("dragend", E)
                                  , t = d3.behavior.drag().on("dragstart", _).on("drag", x).on("dragend", D);
                                d3.select(g).call(e).data([{
                                    container: g,
                                    x: 0,
                                    y: 0
                                }]),
                                d3.select(p).call(t).data([{
                                    container: p,
                                    x: 0,
                                    y: 0
                                }]),
                                y || (y = document.createElement("canvas"),
                                y.id = "drag-floater",
                                y.style.position = "fixed",
                                y.style.zIndex = 60,
                                y.style.top = 0,
                                y.style.width = 0,
                                y.style.height = 0,
                                y.style.display = "none",
                                document.body.appendChild(y));
                                u.on("webkitTransitionEnd transitionend msTransitionEnd oTransitionEnd", b)
                            }()
                        }
                        ))
                    }
                }
            }
            function bn(e, t, n, i) {
                var a = this;
                return {
                    findByName: function(e, r) {
                        return a.promises = [],
                        a.orchidUsers = r,
                        {
                            parent: n.fetchOrchids().then((function(t) {
                                t.filter((function(e) {
                                    return !0 === e.isAvailable
                                }
                                )).forEach((function(t) {
                                    var n = i.fetchUsers(t).then((function(n) {
                                        for (var i, r, s = 0; s < n.length; ++s) {
                                            if (e.avoid && n[s].username === e.avoid) {
                                                r = s;
                                                break
                                            }
                                            n[s].username === e.match && (i = s)
                                        }
                                        angular.isDefined(r) ? a.orchidUsers.push({
                                            orchid: t,
                                            user: n[r],
                                            error: !1,
                                            noop: !1,
                                            avoid: !0
                                        }) : angular.isDefined(i) ? a.orchidUsers.push({
                                            orchid: t,
                                            user: n[i],
                                            error: !1,
                                            noop: !1
                                        }) : a.orchidUsers.push({
                                            orchid: t,
                                            error: !1,
                                            noUser: !0
                                        })
                                    }
                                    ), (function(e) {
                                        a.orchidUsers.push({
                                            orchid: t,
                                            error: !0,
                                            noUser: !0
                                        })
                                    }
                                    ));
                                    a.promises.push(n)
                                }
                                ))
                            }
                            ), (function() {
                                t.error("Failed to fetch Orchids")
                            }
                            )),
                            child: a.promises
                        }
                    }
                }
            }
            vn.$inject = ["$rootScope", "$window", "$filter", "$log", "$scope", "$timeout", "$element", "MatDialog", "AuthenticationService", "FusionDataService", "MatrixService", "UserSettingsService", "StageService", "UtilityService", "RenewableService", "BrowserInfoService", "FusionConfigService", "TimelineServiceFactory"],
            yn.$inject = ["$rootScope", "$timeout", "$mdDialog", "MatrixService", "StageService", "UtilityService", "RenewableService", "FusionDataService", "ThemeService"],
            o().module("ipconfigure.orchid.singularity").controller("BagController", vn).directive("bag", yn),
            angular.module("ipconfigure.orchid.singularity").factory("CrossOrchidDataService", bn),
            bn.$inject = ["$q", "$log", "DataService", "OrchidDataService"];
            var Sn = n(57937)
              , Cn = n.n(Sn);
            let wn = function() {
                function e() {
                    (0,
                    S.Z)(this, e),
                    this._events = {}
                }
                return (0,
                b.Z)(e, [{
                    key: "on",
                    value: function(e, t, n) {
                        re(t) || (this._events.hasOwnProperty(e) || (this._events[e] = []),
                        this._events[e].push({
                            handler: t,
                            cntx: n,
                            once: !1
                        }))
                    }
                }, {
                    key: "once",
                    value: function(e, t, n) {
                        re(t) || (this._events.hasOwnProperty(e) || (this._events[e] = []),
                        this._events[e].push({
                            handler: t,
                            cntx: n,
                            once: !0
                        }))
                    }
                }, {
                    key: "oncePromise",
                    value: function(e) {
                        this._events.hasOwnProperty(e) || (this._events[e] = []);
                        const t = oe();
                        return this.once(e, t.resolve),
                        t.promise
                    }
                }, {
                    key: "trigger",
                    value: function(e, t) {
                        let n = this._events[e];
                        if (n)
                            for (let i = 0; i < n.length; i++) {
                                const a = n[i];
                                void 0 !== a.handler && (a.handler.call(n[i].cntx, t),
                                a.once && this.off(e, a.handler))
                            }
                    }
                }, {
                    key: "off",
                    value: function(e, t) {
                        if (!this._events.hasOwnProperty(e))
                            throw `The event type ${e} could not be found`;
                        void 0 !== t ? (this._events[e] = this._events[e].filter((function(e, n, i) {
                            return e.handler !== t
                        }
                        )),
                        0 === this._events[e].length && delete this._events[e]) : delete this._events[e]
                    }
                }]),
                e
            }();
            var In, Tn = function(e, t, n) {
                this.x = e || 0,
                this.y = t || 0,
                this.z = n || 0
            };
            function En(e) {
                var t, n = this, i = !1, a = new Tn(0,0,0), r = new wn;
                function s(e) {
                    switch (e.axis) {
                    case 0:
                        a.x = e.value;
                        break;
                    case 1:
                        a.y = -1 * e.value;
                        break;
                    case 2:
                        a.z = e.value
                    }
                    n.emit("gamepadaxismove", a)
                }
                return n._animationFrameId = null,
                (t = new (Cn())({
                    axisThreshold: 0,
                    indices: {
                        standard: {
                            cursorX: 2,
                            cursorY: 3,
                            scrollX: 0,
                            scrollY: 1,
                            back: 9,
                            forward: 8,
                            vendor: 10,
                            zoomIn: 5,
                            zoomOut: 1
                        },
                        "46d-c216-Logitech Dual Action": {
                            cursorX: 3,
                            cursorY: 4,
                            scrollX: 1,
                            scrollY: 2,
                            back: 8,
                            forward: 9,
                            vendor: null,
                            zoomIn: 7,
                            zoomOut: 6
                        },
                        "79-6-Generic   USB  Joystick": {
                            cursorX: null,
                            cursorY: null,
                            scrollX: 3,
                            scrollY: 2,
                            back: 6,
                            forward: 7,
                            vendor: null,
                            zoomIn: 9,
                            zoomOut: 8
                        },
                        keyEvents: {
                            vendor: {
                                detail: {
                                    charCode: 0,
                                    key: "Escape",
                                    keyCode: 27
                                }
                            }
                        }
                    }
                })).polling = !1,
                n.on = function(e, t) {
                    if (!1 === i)
                        throw new Error("GamepadService.startListening() has not been called.");
                    if ("gamepadaxismove" !== e)
                        throw new Error("Event " + e + " not supported");
                    r.on(e, t)
                }
                ,
                n.off = function(e, t) {
                    r.off(e, t)
                }
                ,
                n.emit = function(e, t) {
                    r.trigger(e, t)
                }
                ,
                n.startListening = function() {
                    i || (e.addEventListener("gamepadaxismove", s),
                    i = !0,
                    t && t.gamepadsSupported && (t.updateStatus = function() {
                        t.update(),
                        n._animationFrameId = e.requestAnimationFrame(t.updateStatus)
                    }
                    ,
                    t.updateStatus()))
                }
                ,
                n.stopListening = function() {
                    e.removeEventListener("gamepadaxismove", s),
                    i = !1,
                    null !== n._animationFrameId && (e.cancelAnimationFrame(n._animationFrameId),
                    n._animationFrameId = null)
                }
                ,
                n
            }
            function _n(e, t, n) {
                return {
                    restrict: "E",
                    scope: {
                        contextId: "=",
                        fineOnly: "=",
                        selectionMode: "=",
                        eventSource: "="
                    },
                    link: function(i, a) {
                        var r, s, o, c, l = n.getContext(i.contextId), d = !1, u = 1, m = !0;
                        const h = 1e3 * w.secondsPlaybackFromLive;
                        c = new ipConfigure.components.timeline(a[0],{
                            millisecondsPlaybackFromLive: h,
                            draggableIndicator: !0 !== i.fineOnly,
                            onScaleAdjust: function(e) {
                                l.scaleChanged(e)
                            },
                            onTimeChange: function(e, t) {
                                Date.now() - e < h ? (r = Date.now(),
                                !0 !== i.fineOnly && (i.selectionMode = !1)) : (r = e,
                                !0 !== i.fineOnly && "via-fine" !== t && "via-fine-click" !== t && (i.selectionMode = !0)),
                                d = !1,
                                "via-fine" !== t && "via-needle" !== t && c.setFineTime(r),
                                l.timeChanged(r, {
                                    publish: !0
                                })
                            },
                            onEndReached: function(e) {
                                var t = Date.now() < e[1] ? Date.now() : e[1] - 1;
                                r = u < 0 ? t : e[0],
                                c.setFineTime(r),
                                l.timeChanged(r, {
                                    publish: !0
                                })
                            },
                            onRip: function(e, t) {
                                l.rip(e, t)
                            }
                        }),
                        l.storeTimeline(c),
                        r = Date.now(),
                        s = Date.now(),
                        c.trackLive(),
                        c.setTime(r),
                        i.$smartOn(l, "pause-set", (function(e, t) {
                            d = t
                        }
                        )),
                        i.$smartOn(l, "set-speed", (function(e, t) {
                            u = t
                        }
                        )),
                        i.$smartOn(l, "set-time", (function(e, t) {
                            r = t,
                            c.setFineTime(r)
                        }
                        )),
                        i.$smartOn(l, "set-scale", (function(e, t) {
                            c.setScale(t)
                        }
                        )),
                        i.$watch("selectionMode", (function() {
                            !0 === i.selectionMode ? c.trackPlayback() : !1 === i.selectionMode && c.trackLive(),
                            t((function() {
                                e.$broadcast("resize")
                            }
                            ), 350)
                        }
                        )),
                        i.$smartInterval((function() {
                            var e, t, n = Date.now();
                            !0 !== d && (e = n,
                            t = r,
                            !(u <= 0) && t > e - h ? (!1 === m && (m = !0,
                            l.timeChanged(n, {
                                publish: !0
                            })),
                            r = n) : (m = !1,
                            r += Math.floor((n - s) * u),
                            u < 0 && l.rip(r))),
                            s = n,
                            c.setTime(r),
                            l.storeTime(r)
                        }
                        ), 1e3 / 24, !1);
                        const p = e.$on("resize", g);
                        function g() {
                            t.cancel(o),
                            o = t((function() {
                                c.resize(),
                                document.documentElement.clientWidth < 425 && (i.selectionMode = !1)
                            }
                            ), 50)
                        }
                        i.$on("$destroy", (function() {
                            p(),
                            n.releaseContext(i.contextId),
                            l.storeTimeline(null)
                        }
                        )),
                        i.$on("resize.stage", g)
                    }
                }
            }
            function xn(e) {
                let t = e.search.substring(1).split("&");
                0 !== t.length && "" !== t[0] || (t = e.hash.substring(e.hash.indexOf("?") + 1).split("&"));
                const n = {};
                return t.forEach((e => {
                    if (e.length > 0) {
                        const t = e.split("=");
                        n[decodeURIComponent(t[0])] = decodeURIComponent(t[1])
                    }
                }
                )),
                n
            }
            angular.module("ipconfigure.orchid.singularity").factory("GamepadService", En),
            En.$inject = ["$window"],
            In = console,
            window.ipConfigure = window.ipConfigure || {},
            ipConfigure.components = ipConfigure.components || {},
            ipConfigure.core = ipConfigure.core || {},
            ipConfigure.core.mergeOptions = function(e, t) {
                var n, i = {};
                for (n in e)
                    !0 === e.hasOwnProperty(n) && (i[n] = e[n]);
                for (n in t)
                    !0 === t.hasOwnProperty(n) && (i[n] = t[n]);
                return i
            }
            ,
            ipConfigure.core.roundDateToHours = function(e, t) {
                var n = new Date(e.getTime())
                  , i = n.getHours() + n.getMinutes() / 60 + n.getSeconds() / 3600 + e.getMilliseconds() / 36e5;
                return n.setMinutes(0),
                n.setSeconds(0),
                n.setMilliseconds(0),
                n.setHours(Math.round(i / t) * t),
                n
            }
            ,
            ipConfigure.core.roundDateToMinutes = function(e, t) {
                var n = new Date(e.getTime())
                  , i = n.getMinutes() + n.getSeconds() / 60 + e.getMilliseconds() / 6e4;
                return n.setSeconds(0),
                n.setMilliseconds(0),
                n.setMinutes(Math.round(i / t) * t),
                n
            }
            ,
            ipConfigure.core.calculateLiveLabelWidth = function() {
                return 10 * L.messages.stage.live().length + 10
            }
            ,
            ipConfigure.components.timeline = function(e, t) {
                var n, i, a = this, r = !1, s = Date.now(), o = !1, c = d3.select(e), l = c.node().clientWidth, d = c.append("svg"), u = "", m = c.node().getBoundingClientRect().left, h = Date.now(), p = [], f = {
                    dragging: !1,
                    width: 120,
                    indicatorLabelFormat: d3.time.format("%b %-d%-H:%M:%S")
                }, v = {
                    width: ipConfigure.core.calculateLiveLabelWidth()
                }, y = {
                    fineChecksum: {},
                    fine: function(e) {
                        var t, n = e.getHours(), i = e.getMinutes(), a = e.getDate();
                        return 0 === i && 0 === n && (t = e.getMonth().toString() + a.toString() + n.toString() + i.toString(),
                        !0 !== y.fineChecksum[t]) ? (y.fineChecksum[t] = !0,
                        d3.time.format("%b %-d")(e) + ie(a)) : d3.time.format("%-H:%M:%S")(e)
                    },
                    month: d3.time.format("%B"),
                    monthDay: function(e) {
                        var t = e.getDate();
                        return 1 === t ? y.month(e) : d3.time.format("%b %-d")(e) + ie(t)
                    },
                    day: function(e) {
                        var t = e.getDate();
                        return 1 === t ? y.month(e) : t
                    },
                    minuteMinute: d3.time.format("%-H:%M"),
                    minute: function(e) {
                        var t = e.getHours();
                        return 0 === e.getMinutes() && 0 === t ? y.monthDay(e) : y.minuteMinute(e).toLowerCase()
                    }
                }, b = {
                    dragging: !1,
                    height: 63,
                    yOffset: 17,
                    xOffset: 0,
                    tickTimeFormat: function(e) {
                        return y.fine(e)
                    },
                    liveBar: {},
                    halfTimeSteps: [3e4, 12e4, 24e4, 96e4, 36e5, 216e5, 432e5, 864e5, 2592e5, 432e6],
                    liveHalfTime: 24e4
                }, S = {
                    configurations: [],
                    configurationIndex: 0,
                    height: 25,
                    yOffset: 0,
                    leftRightAdjustment: 0,
                    segmentWidth: 100,
                    scale: d3.time.scale(),
                    timeWindow: {},
                    timeWindowHandleWidth: 20,
                    timeWindowTriangleWidth: 15,
                    timeWindowMinimumWidth: 17,
                    liveBar: {}
                }, C = [], w = {
                    debug: !1,
                    interactive: !0,
                    draggableIndicator: !0,
                    millisecondsPlaybackFromLive: 5e3,
                    onTimeChange: function(e, t) {
                        _("onTimeChange event not subscribed to: ", e, t)
                    },
                    onCoarseTimeChange: function(e, t) {
                        _("onCoarseTimeChange event not subscribed to: ", e, t)
                    },
                    onEndReached: function() {
                        _("onEndReached")
                    },
                    onScaleAdjust: function(e) {
                        _("onScaleAdjust event not subscribed to: ", e)
                    },
                    onRip: function(e, t) {
                        _("onRip event not subscribed to: ", e, t)
                    }
                }, I = ipConfigure.core.mergeOptions(w, t), T = {
                    perDay: 864e5,
                    perHour: 36e5,
                    perMinute: 6e4
                }, E = new g.t4;
                function _() {
                    !0 === t.debug && In.log.apply(In, arguments)
                }
                var x = function(e, t, n) {
                    var i;
                    return function() {
                        var a = this
                          , r = arguments
                          , s = function() {
                            i = null,
                            n || e.apply(a, r)
                        }
                          , o = n && !i;
                        clearTimeout(i),
                        i = setTimeout(s, t),
                        o && e.apply(a, r)
                    }
                }((function(e) {
                    I.onTimeChange(e, "via-fine-click")
                }
                ), 50);
                function D(e) {
                    !(angular.isUndefined(d3.event.sourceEvent.touches) || d3.event.sourceEvent.touches.length <= 1) || !1 !== r || !0 !== I.interactive || 0 !== d3.event.sourceEvent.which && 1 !== d3.event.sourceEvent.which || (d3.event.sourceEvent.stopPropagation(),
                    void 0 === d3.event.sourceEvent.clientX && window.TouchEvent && d3.event.sourceEvent instanceof window.TouchEvent && (d3.event.sourceEvent.clientX = parseInt(d3.event.sourceEvent.changedTouches[0].clientX),
                    d3.event.sourceEvent.clientY = parseInt(d3.event.sourceEvent.changedTouches[0].clientY)),
                    m = c.node().getBoundingClientRect().left,
                    void 0 === d3.event.sourceEvent.offsetX && (d3.event.sourceEvent.offsetX = d3.event.sourceEvent.layerX - m),
                    e.startX = d3.event.sourceEvent.clientX - m,
                    e.startOffsetX = d3.event.sourceEvent.offsetX,
                    e.startTime = b.start,
                    e.stopTime = b.stop,
                    o = !0)
                }
                function O(e) {
                    var t, n, a, s, c, d, h, p = d3.time.scale().range(b.scale.range()), g = Date.now();
                    !(angular.isUndefined(d3.event.sourceEvent.touches) || d3.event.sourceEvent.touches.length <= 1) || !1 !== r || !0 !== o || !0 !== I.interactive || 0 !== d3.event.sourceEvent.which && 1 !== d3.event.sourceEvent.which || (void 0 === d3.event.sourceEvent.clientX && window.TouchEvent && d3.event.sourceEvent instanceof window.TouchEvent && (d3.event.sourceEvent.clientX = parseInt(d3.event.sourceEvent.changedTouches[0].clientX),
                    d3.event.sourceEvent.clientY = parseInt(d3.event.sourceEvent.changedTouches[0].clientY)),
                    b.dragging = !0,
                    t = b.scale.invert(1) - b.scale.invert(0),
                    c = e.startTime + t * (e.startX - d3.event.sourceEvent.clientX + m),
                    !0 === S.created && "live" !== u && (n = S.timeWindow.data()[0],
                    a = S.scale.invert(S.timeWindowTriangleWidth).getTime(),
                    s = S.scale.invert(l - n.width - S.timeWindowTriangleWidth).getTime(),
                    c = Math.max(c, a),
                    c = Math.min(c, s)),
                    d = c + (e.stopTime - e.startTime),
                    p.domain([new Date(c), new Date(d)]),
                    h = "live" === u ? p.invert(f.container.data()[0].x).getTime() : p.invert(Math.round(.5 * l)).getTime(),
                    "live" === u && h > g && (c -= h - g,
                    d -= h - g,
                    h = g),
                    i = h,
                    b.start = c,
                    b.stop = d,
                    ae(),
                    Q(),
                    "live" === u && (I.onRip(i, {
                        source: "via-fine",
                        timelineWidth: ce(),
                        fineStart: b.start,
                        fineStop: b.stop,
                        fineScale: b.scale
                    }),
                    J(ce() / 2),
                    ee(h)),
                    pe(b.start, b.stop, !1))
                }
                function A(e) {
                    var t, n, i;
                    !(angular.isUndefined(d3.event.sourceEvent.touches) || d3.event.sourceEvent.touches.length <= 1) || !1 !== r || !0 !== I.interactive || 0 !== d3.event.sourceEvent.which && 1 !== d3.event.sourceEvent.which || (o = !1,
                    !0 === b.dragging && e.startX !== d3.event.sourceEvent.clientX - m ? (b.dragging = !1,
                    t = b.scale.invert(f.container.data()[0].x).getTime(),
                    "live" === u ? I.onTimeChange(t, "via-fine") : "playback" === u && (t < b.start || t > b.stop) && I.onTimeChange(b.start, "via-fine")) : (b.dragging = !1,
                    n = b.scale(Date.now()),
                    e.startOffsetX >= n ? I.onTimeChange(Date.now(), "via-live") : (i = b.scale.invert(e.startX - b.xOffset).getTime(),
                    isNaN(i) || x(i))))
                }
                function R() {
                    var e, t, i = d3.event.sourceEvent;
                    if (null !== i && (t = i.touches,
                    !0 === I.interactive && "live" === u))
                        if ("wheel" === i.type || "mousewheel" === i.type)
                            d3.event.sourceEvent.stopPropagation(),
                            P(e = i.wheelDelta ? i.wheelDelta > 0 ? -1 : 1 : i.detail ? i.detail > 0 ? 1 : -1 : i.deltaY > 0 ? 1 : -1);
                        else if ("touchmove" == i.type && (angular.isDefined(i.scale) && 1 !== i.scale || i.touches.length > 1) && Date.now() - h > 350) {
                            if (angular.isUndefined(i.scale)) {
                                if (p.length < 6)
                                    return void p.push(function(e) {
                                        return Math.sqrt((e[0].clientX - e[1].clientX) * (e[0].clientX - e[1].clientX) + (e[0].clientY - e[1].clientY) * (e[0].clientY - e[1].clientY))
                                    }(t));
                                var a = p[0]
                                  , o = p.reduce((function(e, t) {
                                    return e + t
                                }
                                )) / p.length;
                                e = o > a ? -1 : 1,
                                p = []
                            } else
                                e = i.scale > 1 ? -1 : 1;
                            r = !0,
                            h = Date.now(),
                            d3.event.sourceEvent.preventDefault(),
                            d3.event.sourceEvent.stopPropagation(),
                            clearTimeout(n),
                            n = setTimeout((function() {
                                r = !1
                            }
                            ), 500),
                            s + 400 < Date.now() && (s = Date.now(),
                            P(e))
                        }
                }
                function P(e) {
                    var t, n, i = b.liveHalfTime;
                    if (1 === e) {
                        for (t = 0,
                        n = b.halfTimeSteps.length; t < n; t++)
                            if (b.halfTimeSteps[t] > b.liveHalfTime) {
                                b.liveHalfTime = b.halfTimeSteps[t];
                                break
                            }
                    } else
                        for (t = b.halfTimeSteps.length - 1,
                        n = -1; t > n; t--)
                            if (b.halfTimeSteps[t] < b.liveHalfTime) {
                                b.liveHalfTime = b.halfTimeSteps[t];
                                break
                            }
                    b.liveHalfTime !== i && (b.start += i,
                    b.stop -= i,
                    b.start -= b.liveHalfTime,
                    b.stop += b.liveHalfTime,
                    ae(!0))
                }
                function k() {
                    !0 === I.interactive && d3.event.sourceEvent.stopPropagation()
                }
                function M(e) {
                    var t, n, i, a, r, s;
                    !0 === I.interactive && !0 === I.draggableIndicator && (t = new Date,
                    n = b.xOffset > 0 ? ce() : ce() - 9,
                    i = b.xOffset > 0 ? 0 : 25,
                    a = Math.min(n, Math.max(i, d3.event.x)),
                    r = b.scale.invert(a),
                    f.dragging = !0,
                    e.x = r < t ? a : b.scale(t),
                    I.onRip((r < t ? r : t).getTime(), {
                        source: "via-needle",
                        timelineWidth: ce(),
                        fineStart: b.start,
                        fineStop: b.stop,
                        fineScale: b.scale
                    }),
                    J(e.x),
                    s = e.x,
                    f.label.text(f.indicatorLabelFormat(b.scale.invert(s))))
                }
                function N(e) {
                    !0 === I.interactive && !0 === I.draggableIndicator && !0 === f.dragging && (f.dragging = !1,
                    I.onTimeChange(b.scale.invert(e.x).getTime(), "via-fine"))
                }
                function F() {}
                function U(e) {
                    var t, n;
                    !0 === I.interactive && (e.dragged = !0,
                    e.x = d3.event.x,
                    e.x > l ? (e.x = l,
                    b.rightHandleGrabber.attr("transform", "translate(" + l + ")").data([{
                        ...e,
                        x: l
                    }]),
                    b.rightHandle.attr("width", l),
                    b.rightHandle.attr("transform", "translate(0)"),
                    b.resizeTimer || (b.resizeTimer = setInterval((function() {
                        var e, t = b.scale.invert(l / 2).getTime(), n = S.scale.invert(l - S.timeWindowTriangleWidth).getTime();
                        b.stop += parseInt(.005 * (b.stop - b.start), 10),
                        t > Date.now() && (e = t - Date.now(),
                        b.stop -= e),
                        b.stop > n && (e = b.stop - n,
                        b.stop -= e),
                        ae(),
                        pe(new Date(b.start), new Date(b.stop), !1)
                    }
                    ), 1e3 / 30))) : (b.resizeTimer && (clearInterval(b.resizeTimer),
                    delete b.resizeTimer),
                    (t = b.scale.invert(25)).setSeconds(t.getSeconds() + 10),
                    t.setMilliseconds(t.getMilliseconds() + 1),
                    n = b.scale(t),
                    e.x <= n && (e.x = n),
                    b.scale(Date.now()) > e.x - 12 ? b.rightHandleGrabber.selectAll("line").style("stroke", "white") : b.rightHandleGrabber.selectAll("line").style("stroke", "#c8e3f1"),
                    pe(new Date(b.start), b.scale.invert(e.x), !1),
                    b.rightHandleGrabber.attr("transform", "translate(" + e.x + ")").data([{
                        ...e,
                        x: e.x
                    }]),
                    b.rightHandle.attr("width", l - e.x),
                    b.rightHandle.attr("transform", "translate(0)")))
                }
                function $(e) {
                    var t;
                    !0 === I.interactive && !0 === e.dragged && (b.resizeTimer && (clearInterval(b.resizeTimer),
                    delete b.resizeTimer),
                    t = b.scale.invert(e.x - b.xOffset),
                    b.stop = t.getTime(),
                    ae(!0, (function() {
                        ne("via-fine-resize")
                    }
                    )),
                    e.x = ce() + b.xOffset,
                    b.rightHandleGrabber.data([{
                        x: e.x
                    }]).transition().attr("transform", "translate(" + e.x + ")"),
                    b.rightHandle.transition().attr("width", b.xOffset))
                }
                function j() {}
                function V(e) {
                    var t, n;
                    !0 === I.interactive && (e.dragged = !0,
                    e.x = d3.event.x,
                    e.x < 0 ? (b.leftHandle.attr("width", 0),
                    b.resizeTimer || (b.resizeTimer = setInterval((function() {
                        b.start -= parseInt(.005 * (b.stop - b.start), 10),
                        ae(),
                        pe(new Date(b.start), new Date(b.stop), !1)
                    }
                    ), 1e3 / 30))) : (b.resizeTimer && (clearInterval(b.resizeTimer),
                    delete b.resizeTimer),
                    (t = b.scale.invert(l - 25)).setSeconds(t.getSeconds() - 10),
                    t.setMilliseconds(t.getMilliseconds() + 1),
                    n = b.scale(t),
                    e.x > n && (e.x = n),
                    pe(b.scale.invert(e.x), new Date(b.stop), !1),
                    b.leftHandle.attr("width", e.x),
                    b.leftHandle.attr("transform", "translate(0)"),
                    b.leftHandlGrabberLineGroup.attr("transform", "translate(" + (e.x - 25 + 9) + ")")))
                }
                function G(e) {
                    var t;
                    !0 === I.interactive && !0 === e.dragged && (b.resizeTimer && (clearInterval(b.resizeTimer),
                    delete b.resizeTimer),
                    t = b.scale.invert(e.x - 25),
                    b.start = t.getTime(),
                    ae(!0, (function() {
                        ne("via-fine-resize")
                    }
                    )),
                    e.x = b.xOffset,
                    b.leftHandle.attr("width", b.xOffset).attr("transform", "translate(0)"),
                    b.leftHandlGrabberLineGroup.attr("transform", "translate(9)"))
                }
                function B() {
                    d3.event.sourceEvent.stopPropagation(),
                    S.dragging = !0
                }
                function z() {
                    var e, t, n, i, a = S.segmentContainer.data()[0], r = !1, s = S.configurations[S.configurationIndex], o = S.timeWindow.data()[0].x + .5 * S.timeWindow.data()[0].width;
                    n = (t = d3.event.x + S.leftRightAdjustment * S.segmentWidth) - a.x,
                    _(S.liveBar.container.data()[0].x, " + ", n, " < ", o, "??", t),
                    a.x = t,
                    a.x > 0 ? (i = Math.ceil(a.x / S.segmentWidth),
                    a.x -= i * S.segmentWidth,
                    S.startTime -= i * s.milliseconds,
                    S.leftRightAdjustment -= i,
                    r = !0) : a.x < -2 * S.segmentWidth && (i = Math.floor(Math.abs(a.x) / (2 * S.segmentWidth)),
                    a.x += i * S.segmentWidth,
                    S.startTime += i * s.milliseconds,
                    S.leftRightAdjustment += i,
                    r = !0),
                    S.segmentContainer.attr("transform", (function(e) {
                        return "translate(" + e.x + ", 0)"
                    }
                    )),
                    !0 === r && oe(),
                    ue(a.x),
                    e = S.timeWindow.data()[0],
                    b.start = S.scale.invert(e.x).getTime(),
                    b.stop = S.scale.invert(e.x + e.width).getTime(),
                    ae()
                }
                function H() {
                    S.dragging = !1,
                    S.leftRightAdjustment = 0,
                    ne("via-coarse")
                }
                function W() {
                    if (!0 === I.interactive && !1 === d3.event.defaultPrevented) {
                        var e = S.segmentContainer.data()[0].x
                          , t = Math.floor((d3.event.pageX - m - e) / S.segmentWidth)
                          , n = S.timeWindow.data()[0];
                        n.x = t * S.segmentWidth + (S.segmentWidth + e) - S.segmentWidth - S.segmentWidth / 2,
                        n.width = 2 * S.segmentWidth,
                        n.x = Math.max(n.x, 11),
                        te(n, !0),
                        b.start = S.scale.invert(n.x).getTime(),
                        b.stop = S.scale.invert(n.x + n.width).getTime(),
                        ae(!0),
                        ne("via-coarse"),
                        S.timeWindow.dragging = !1
                    }
                }
                function q() {
                    !0 === I.interactive && I.onTimeChange(Date.now(), "via-live")
                }
                function Y(e) {
                    d3.event.sourceEvent.stopPropagation(),
                    S.timeWindow.dragging = !0,
                    void 0 === d3.event.sourceEvent.clientX && window.TouchEvent && d3.event.sourceEvent instanceof window.TouchEvent && (d3.event.sourceEvent.clientX = d3.event.sourceEvent.changedTouches[0].clientX,
                    d3.event.sourceEvent.clientY = d3.event.sourceEvent.changedTouches[0].clientY),
                    e.initialOffset = d3.event.sourceEvent.clientX - m - e.x,
                    e.initialWidth = e.width,
                    e.element = d3.event.sourceEvent.target
                }
                function X(e) {
                    var t = e.element.className.baseVal;
                    "time-window-left-handle" === t ? function(e) {
                        var t, n, i;
                        t = e.x + e.width - S.timeWindowMinimumWidth,
                        n = Math.max(S.timeWindowTriangleWidth, d3.event.x - e.initialOffset),
                        (i = e.width + e.x - n) < 0 ? (e.element = S.timeWindowRightHandle[0][0],
                        e.initialOffset = S.timeWindowMinimumWidth,
                        e.initialWidth = S.timeWindowMinimumWidth,
                        e.width = S.timeWindowMinimumWidth,
                        e.x = t) : i > S.timeWindowMinimumWidth ? (e.x = n,
                        e.width = i) : (e.width = S.timeWindowMinimumWidth,
                        e.x = t)
                    }(e) : "time-window-center" === t ? function(e) {
                        var t;
                        t = Math.min(l - e.width - S.timeWindowTriangleWidth, Math.max(S.timeWindowTriangleWidth, d3.event.x - e.initialOffset)),
                        e.x = t
                    }(e) : "time-window-right-handle" === t && function(e) {
                        var t, n = e.initialOffset - e.initialWidth, i = d3.event.x - e.x - n;
                        i < -n ? (e.element = S.timeWindowLeftHandle[0][0],
                        e.initialOffset = 0,
                        e.initialWidth = 0,
                        e.width = S.timeWindowMinimumWidth) : (t = Math.min(l - e.x - S.timeWindowTriangleWidth, Math.max(S.timeWindowMinimumWidth, i)),
                        e.width = t)
                    }(e),
                    b.start = S.scale.invert(e.x).getTime(),
                    b.stop = S.scale.invert(e.x + e.width).getTime(),
                    te(e, !1),
                    ae()
                }
                function K() {
                    S.timeWindow.dragging = !1,
                    ne("via-coarse")
                }
                function Z() {
                    var e;
                    if (!0 !== b.created) {
                        b.scale = d3.time.scale().range([0, l]),
                        e = de(),
                        b.axis = d3.svg.axis().scale(b.scale).ticks(e).tickSize(14, 0).tickPadding(5).tickFormat(b.tickTimeFormat),
                        b.container.append("rect").attr("class", "fine-background").attr("width", "100%").attr("height", 71).attr("transform", "translate(0, " + b.yOffset + ")"),
                        b.axisGroup = b.container.append("g").attr("class", "x axis"),
                        b.axisMinorGroup = b.container.append("g").attr("class", "x axis minor"),
                        b.axisMotionGroup = b.container.append("g").attr("class", "x axis motion"),
                        b.liveBar.container = b.container.append("g").attr("class", "live"),
                        E.SAFARI && d3.select(document.body).on("wheel", (function() {}
                        ));
                        var t = d3.behavior.zoom().on("zoom", R).on("zoomend", (function() {
                            r = !1,
                            clearTimeout(n)
                        }
                        ));
                        b.container.append("rect").attr("class", "fine-foreground").attr("width", "100%").attr("height", b.height + S.height - b.yOffset).attr("transform", "translate(0, " + b.yOffset + ")").call(t).call(d3.behavior.drag().origin(Object).on("dragstart", D).on("drag", O).on("dragend", A)).on("touchcancel", (function(e) {
                            d3.event.sourceEvent = d3.event,
                            A(e)
                        }
                        )).data([{}]),
                        b.sizerGroup = b.container.append("g"),
                        b.liveBar.rect = b.liveBar.container.append("rect").attr("height", b.height + S.height - b.yOffset),
                        !0 !== f.created && (f.created = !0,
                        f.pointerGroup = f.container.append("g").attr("class", "pointer"),
                        f.pointerGroup.append("rect").attr("x", -1).attr("y", 0).attr("width", 2).attr("height", b.height + S.height),
                        !0 === I.draggableIndicator && (f.container.attr("class", "fine-indicator draggable"),
                        f.pointerGroup.append("polygon").attr("points", "-8,0 8,0 0,10").attr("transform", "translate(0, 15)").attr("style", "stroke-width: 1.5px; stroke: rgb(175,175,175)")),
                        f.labelGroup = f.container.append("g").attr("class", "label"),
                        f.labelGroup.append("rect").attr("width", f.width).attr("height", b.yOffset).attr("rx", 3).attr("ry", 3),
                        f.labelGroup.append("rect").attr("width", f.width - 3).attr("height", .1).attr("rx", 3).attr("x", 2).attr("y", b.yOffset).attr("style", "stroke-width: 0.5px; stroke: rgb(150,150,150)"),
                        f.label = f.labelGroup.append("text").attr("width", f.width).attr("height", b.yOffset).attr("x", f.width / 2).attr("y", 13).attr("text-anchor", "middle"),
                        f.container.call(d3.behavior.drag().origin(Object).on("dragstart", k).on("drag", M).on("dragend", N)).on("touchcancel", N)),
                        !0 !== v.created && (v.created = !0,
                        v.pointerGroup = v.container.append("g").attr("class", "pointer"),
                        v.pointerGroup.append("rect").attr("x", -1).attr("y", 0).attr("width", 2).attr("height", b.height + S.height),
                        v.labelGroup = v.container.append("g").attr("class", "label live").attr("transform", "translate(1)"),
                        v.labelGroup.append("rect").attr("width", v.width).attr("height", b.yOffset),
                        v.label = v.labelGroup.append("text").attr("width", v.width).attr("height", b.yOffset).attr("x", v.width / 2).attr("y", 12).attr("text-anchor", "middle").text(L.messages.stage.live()),
                        v.container.on("click", (function() {
                            !0 === I.interactive && I.onTimeChange(Date.now(), "via-live")
                        }
                        ))),
                        b.created = !0,
                        b.dragging = !1
                    }
                    c.style("height", b.height + "px")
                }
                function J(e) {
                    var t, n = f.width / 2, a = -n, r = ce(), s = "";
                    f.container.data([{
                        x: e
                    }]).attr("transform", (function(e) {
                        return "translate(" + Math.round(e.x + b.xOffset) + ")"
                    }
                    )),
                    e + b.xOffset < n ? (a = n - (e + b.xOffset) - n) > -b.xOffset && (s = "none") : (e + b.xOffset > l - n && (a = -n - (n - (l - (e + b.xOffset)))),
                    e > r && (s = "none")),
                    e + f.width / 2 - b.xOffset >= r - v.width ? a = r - e - v.width + b.xOffset - f.width : (t = "live" === u ? 0 : 25,
                    v.labelGroup.select("rect").node(0).getBoundingClientRect().left - m - 1 - t < e + f.width / 2 && (a = -(e + f.width / 2 - b.scale(Date.now())) - f.width / 2)),
                    !1 === isNaN(i) && v.labelGroup.attr("class", Date.now() - i < I.millisecondsPlaybackFromLive ? "label live" : "label"),
                    f.pointerGroup.style("display", s),
                    f.labelGroup.attr("transform", "translate(" + Math.round(a) + ")")
                }
                function Q() {
                    var e, t, n = {
                        containerPosition: 0,
                        rectWidth: l
                    }, i = {
                        containerPosition: b.xOffset,
                        labelGroupPosition: 0,
                        display: "none"
                    };
                    (e = b.scale(Date.now())) >= 0 && (t = ce(),
                    n.containerPosition = e + b.xOffset,
                    n.rectWidth = t,
                    i.display = "",
                    i.containerPosition = Math.round(e + b.xOffset),
                    e > t - v.width + b.xOffset && (i.labelGroupPosition = -Math.round(v.width - (t - e) - b.xOffset)),
                    e > t && (i.display = "none")),
                    b.liveBar.rect.attr("width", n.rectWidth).attr("transform", "translate(0)"),
                    b.liveBar.container.attr("transform", "translate(" + n.containerPosition + ", " + b.yOffset + ")"),
                    v.pointerGroup.style("display", i.display),
                    "none" === i.display ? (v.container.attr("transform", "translate(" + (l - v.width) + ")"),
                    v.labelGroup.attr("transform", "translate(0)")) : (v.container.attr("transform", "translate(" + i.containerPosition + ")"),
                    v.labelGroup.attr("transform", "translate(" + (0 === i.labelGroupPosition ? 1 : i.labelGroupPosition) + ")"))
                }
                function ee(e) {
                    f.label.text(f.indicatorLabelFormat(new Date(e)))
                }
                function te(e, t) {
                    var n = t ? S.timeWindow.transition() : S.timeWindow
                      , i = t ? S.timeWindowCenter.transition() : S.timeWindowCenter
                      , a = t ? S.timeWindowRightHandle.transition() : S.timeWindowRightHandle
                      , r = t ? S.leftMask.transition() : S.leftMask
                      , s = t ? S.leftMaskShadow.transition() : S.leftMaskShadow
                      , o = t ? S.rightMaskShadow.transition() : S.rightMaskShadow
                      , c = t ? S.rightMask.transition() : S.rightMask;
                    n.attr("transform", "translate(" + e.x + ")"),
                    i.attr("width", e.width),
                    a.attr("x", e.width - 5),
                    r.attr("transform", "translate(" + (e.x - 9e3 - 16) + ")"),
                    s.attr("transform", "translate(" + (e.x - 9e3 - 16) + ")"),
                    c.attr("transform", "translate(" + (e.x + e.width) + ")"),
                    o.attr("transform", "translate(" + (e.x + e.width) + ")")
                }
                function ne(e) {
                    var t = i;
                    (t < b.start || t > b.stop) && I.onTimeChange(b.start, e)
                }
                function ie(e) {
                    var t = "th"
                      , n = e % 100;
                    if (n < 11 || n > 13)
                        switch (n % 10) {
                        case 1:
                            t = "st";
                            break;
                        case 2:
                            t = "nd";
                            break;
                        case 3:
                            t = "rd"
                        }
                    return t
                }
                function ae(e, t) {
                    !0 !== b.animating && !0 === b.created && (b.scale.domain([new Date(b.start), new Date(b.stop)]),
                    y.fineChecksum = {},
                    e ? (b.animating = !0,
                    re(),
                    b.axisGroup.transition().duration(250).call(b.axis).each("end", (function() {
                        setTimeout(se),
                        b.animating = !1,
                        t && t()
                    }
                    ))) : (b.axisGroup.call(b.axis),
                    se(),
                    t && t()))
                }
                function re() {
                    b.axisMinorGroup.selectAll("line").remove(),
                    b.axisMotionGroup.selectAll("rect").remove()
                }
                function se() {
                    var e, t, n, i, a, r = [], s = [], o = {};
                    if (b.debounceRenderEnhancementTimer && (clearTimeout(b.debounceRenderEnhancementTimer),
                    delete b.debounceRenderEnhancementTimer),
                    b.axisGroup.selectAll("g").data().forEach((function(e) {
                        r.push({
                            date: e,
                            position: b.scale(e)
                        })
                    }
                    )),
                    r.length > 0) {
                        for (r.sort((function(e, t) {
                            return e.position - t.position
                        }
                        )),
                        t = r[0].position - 6; t > 0; t -= 6)
                            s.push(t);
                        for (e = 0; e < r.length - 1; e += 1)
                            for (t = r[e].position + 6; t < r[e + 1].position - 3; t += 6)
                                s.push(t);
                        for (t = r[r.length - 1].position + 6; t < ce(); t += 6)
                            s.push(t);
                        (n = b.axisMinorGroup.selectAll("line").data(s)).exit().remove(),
                        n.enter().append("line"),
                        b.axisMinorGroup.selectAll("line").attr("y2", 6).attr("x2", 0).attr("transform", (function(e) {
                            return "translate(" + e + ")"
                        }
                        )),
                        b.axisGroup.selectAll("text").style("font-weight", (function(e) {
                            var t = e.getMonth().toString() + e.getDate().toString() + e.getHours().toString() + e.getMinutes().toString()
                              , n = "";
                            return !0 === y.fineChecksum[t] && !0 !== o[t] && (o[t] = !0,
                            n = "bold"),
                            n
                        }
                        )),
                        (i = b.axisMotionGroup.selectAll("rect").data(C)).exit().remove(),
                        i.enter().append("rect").attr("height", 7),
                        a = Date.now(),
                        b.axisMotionGroup.selectAll("rect").attr("y", (function(e) {
                            return "smart-search" === e.source ? 5 : 35
                        }
                        )).attr("x", (function(e) {
                            return b.scale(e.start)
                        }
                        )).attr("width", (function(e) {
                            return e.start > a ? 0 : e.stop > a ? b.scale(a) - b.scale(e.start) : b.scale(e.stop) - b.scale(e.start) + 1
                        }
                        )).attr("class", (function(e) {
                            var t = "motion-event-bar";
                            return "smart-search" === e.source ? t + " smart-search" : t
                        }
                        ))
                    }
                }
                function oe() {
                    var e, t, n, i = S.configurations[S.configurationIndex], a = Math.ceil(l / S.segmentWidth) + 2;
                    S.stopTime = S.startTime + a * i.milliseconds,
                    S.scale.domain([new Date(S.startTime), new Date(S.stopTime)]),
                    I.onCoarseTimeChange(S.startTime, S.stopTime),
                    e = i.ranger(new Date(S.startTime), new Date(S.stopTime)),
                    (t = S.segmentContainer.selectAll("g").data(e)).select("rect"),
                    t.select("text").text(i.formatter),
                    t.exit().remove(),
                    (n = t.enter().append("g")).append("rect").attr("width", S.segmentWidth).attr("height", S.height),
                    n.append("text").attr("x", S.segmentWidth / 2).attr("y", 18).attr("text-anchor", "middle").text(i.formatter),
                    t.attr("transform", (function(e, t) {
                        return "translate(" + t * S.segmentWidth + ")"
                    }
                    ))
                }
                function ce() {
                    return "live" === u ? l : l - 50
                }
                function le(e, n, i, a) {
                    var r, s, o, c = S.timeWindow.data()[0], l = {};
                    if (function(e, t) {
                        var n, i, a, r = S.configurations[S.configurationIndex], s = S.configurations[t];
                        S.configurationIndex = t,
                        r.milliseconds > s.milliseconds ? (a = r.milliseconds / s.milliseconds - 1,
                        n = e * s.milliseconds * a,
                        S.startTime += n) : (a = s.milliseconds / r.milliseconds - 1,
                        n = e * r.milliseconds * a,
                        S.startTime -= n),
                        (i = s.rounder(S.startTime)) - S.startTime != 0 && (S.startTime = i)
                    }(e, n),
                    oe(),
                    ue(S.segmentContainer.data()[0].x),
                    !0 === i) {
                        for (o = 0,
                        l.x = Math.round(S.scale(a.start)),
                        l.start = S.scale.invert(l.x).getTime(); l.start > a.start; )
                            l.start = S.scale.invert(l.x - o).getTime(),
                            o += 1;
                        a.start = l.start,
                        S.scale(a.stop) - S.scale(a.start) < S.timeWindowMinimumWidth && (a.stop = S.scale.invert(S.scale(a.start) + S.timeWindowMinimumWidth).getTime()),
                        pe(a.start, a.stop, !0)
                    }
                    (r = S.scale.invert(c.x).getTime()) >= (s = S.scale.invert(c.x + c.width).getTime()) ? (b.start = r,
                    b.stop = r + 1e4) : (b.start = r,
                    b.stop = s),
                    ae(!0),
                    t.onScaleAdjust(n)
                }
                function de() {
                    return l < 300 ? 2 : l < 500 ? 3 : l < 900 ? 5 : 10
                }
                function ue(e) {
                    var t = Math.ceil(l / S.segmentWidth) + 2
                      , n = e + Math.round(S.segmentWidth / 2)
                      , i = S.segmentWidth * t + n;
                    S.scale.range([n, i])
                }
                function me(e, t) {
                    var n, i, a = 0, r = 0;
                    S.segmentContainer.selectAll("g").each((function(s, o) {
                        var c = d3.select(this);
                        n = o * S.segmentWidth,
                        e > o ? (i = n - (e - o) * S.segmentWidth,
                        c.transition().duration(200).each((function() {
                            ++a
                        }
                        )).each("end", (function() {
                            --a,
                            r + a === 0 && t()
                        }
                        )).attr("transform", "translate(" + i + ")")) : e < o && (i = n + (o - e) * S.segmentWidth,
                        c.transition().duration(200).each((function() {
                            ++r
                        }
                        )).each("end", (function() {
                            --r + a === 0 && t()
                        }
                        )).attr("transform", "translate(" + i + ")"))
                    }
                    ))
                }
                function he(e, t) {
                    var n, i, a, r, s, o = S.segmentContainer.selectAll("g"), c = 0, l = 0;
                    for (r = function() {
                        ++l
                    }
                    ,
                    s = function() {
                        --l + c === 0 && t()
                    }
                    ,
                    i = 1,
                    n = e + 2; n < o[0].length; n += 2)
                        a = n * S.segmentWidth - i * S.segmentWidth,
                        d3.select(o[0][n]).transition().duration(200).each(r).each("end", s).attr("transform", "translate(" + a + ")"),
                        i++;
                    for (r = function() {
                        ++c
                    }
                    ,
                    s = function() {
                        --c,
                        l + c === 0 && t()
                    }
                    ,
                    i = 1,
                    n = e - 1; n >= 0; n -= 2)
                        d3.select(o[0][n]).attr("transform", "translate(-" + S.segmentWidth + ")");
                    for (n = e - 2; n >= 0; n -= 2)
                        a = n * S.segmentWidth + i * S.segmentWidth,
                        d3.select(o[0][n]).transition().duration(200).each(r).each("end", s).attr("transform", "translate(" + a + ")"),
                        i++
                }
                function pe(e, t, n) {
                    var i, a;
                    !0 === S.created && (t - e == 0 && (e = S.scale.invert(S.scale(e) - 5).getTime(),
                    t = S.scale.invert(S.scale(e) + 5).getTime()),
                    i = S.timeWindow.data()[0],
                    e <= t && (a = l - S.timeWindowTriangleWidth,
                    i.x = Math.round(S.scale(e)),
                    i.x = Math.max(S.timeWindowTriangleWidth, i.x),
                    i.x = Math.min(a, i.x),
                    i.width = Math.round(S.scale(t) - i.x),
                    i.width = Math.max(0, i.width),
                    i.width = Math.min(a - i.x, i.width),
                    te(i, n)))
                }
                function ge() {
                    var e, n, i, a, r;
                    if (!0 === S.created) {
                        for (e = Math.ceil(l / S.segmentWidth) + 2,
                        i = b.stop - b.start,
                        n = S.configurations.length; n--; )
                            if ((a = i / S.configurations[n].milliseconds) <= .25) {
                                S.configurationIndex = n;
                                break
                            }
                        t.onScaleAdjust(S.configurationIndex),
                        r = (e - 2) / 2,
                        S.startTime = b.start - r * S.configurations[S.configurationIndex].milliseconds + a * S.configurations[S.configurationIndex].milliseconds / 2,
                        S.startTime = ipConfigure.core.roundDateToMinutes(new Date(S.startTime), 1).getTime(),
                        oe(),
                        ue(S.segmentContainer.data()[0].x),
                        pe(b.start, b.stop)
                    }
                }
                a.options = I,
                a.getTime = function() {
                    return i
                }
                ,
                a.setTime = function(e) {
                    isNaN(e) || !0 !== b.animating && (i = e,
                    "live" === u && !0 !== b.dragging && !0 !== f.dragging && (b.start = e - b.liveHalfTime,
                    b.stop = e + b.liveHalfTime,
                    ae()),
                    Q(),
                    "playback" === u && function() {
                        if (!0 === S.created && "playback" === u) {
                            var e = S.scale(Date.now());
                            e < 0 ? (S.liveBar.rect.attr("width", l).attr("height", b.height - b.yOffset),
                            S.liveBar.container.attr("transform", "translate(0, " + (b.height + S.yOffset) + ")").attr()) : e < l ? (S.liveBar.rect.attr("width", l).attr("height", b.height - b.yOffset),
                            S.liveBar.container.data([{
                                x: e
                            }]).attr("class", "live").attr("transform", "translate(" + e + ", " + (b.height + S.yOffset) + ")").attr()) : S.liveBar.container.data([{
                                x: l - 25
                            }]).attr("class", "live inactive").attr("transform", "translate(" + (l - 25) + ", " + (b.height + S.yOffset) + ")")
                        }
                    }(),
                    (!1 === f.dragging && !1 === b.dragging || "playback" === u && !0 === b.dragging) && (J(Math.round(b.scale(new Date(e)))),
                    ee(e)),
                    !0 === S.created && !1 === b.dragging && !1 === S.dragging && !1 === S.timeWindow.dragging && (e > b.stop || e < b.start) && I.onEndReached([b.start, b.stop]))
                }
                ,
                a.getCoarseTime = function() {
                    return [S.startTime, S.stopTime]
                }
                ,
                a.setCoarseTime = function(e) {
                    var t, n, a = S.configurations[S.configurationIndex], r = Math.ceil(l / S.segmentWidth) + 2, s = S.timeWindow.data()[0], o = l / 2, c = Date.now(), d = {
                        coarseStart: S.startTime,
                        coarseStop: S.stopTime,
                        fineStart: b.start,
                        fineStop: b.stop
                    }, u = e;
                    S.stopTime = u + r * a.milliseconds,
                    S.scale.domain([new Date(u), new Date(S.stopTime)]),
                    b.start = S.scale.invert(s.x).getTime(),
                    b.stop = S.scale.invert(s.x + s.width).getTime(),
                    b.scale.domain([new Date(b.start), new Date(b.stop)]),
                    o > (t = b.scale(c)) && (u -= b.scale.invert(o - t).getTime() - b.scale.invert(0).getTime()),
                    u = a.rounder(u),
                    d.coarseStart === u ? (S.startTime = d.coarseStart,
                    S.stopTime = d.coarseStop,
                    S.scale.domain([new Date(S.startTime), new Date(S.stopTime)]),
                    b.start = d.fineStart,
                    b.stop = d.fineStop,
                    b.scale.domain([new Date(b.start), new Date(b.stop)])) : (S.startTime = u,
                    me(S.startTime < d.coarseStart ? 0 : r, (function() {
                        oe(),
                        ((n = b.scale.invert(f.container.data()[0].x).getTime()) < b.start || n > b.stop) && I.onTimeChange(b.start, "via-coarse")
                    }
                    )),
                    S.stopTime = S.startTime + r * a.milliseconds,
                    S.scale.domain([new Date(S.startTime), new Date(S.stopTime)]),
                    b.start = S.scale.invert(s.x).getTime(),
                    b.stop = S.scale.invert(s.x + s.width).getTime(),
                    ae(!0),
                    b.start > i && b.stop < i && I.onTimeChange(b.start, "via-coarse"))
                }
                ,
                a.getFineTime = function() {
                    return [b.start, b.stop]
                }
                ,
                a.setFineTime = function(e) {
                    var t = b.stop - b.start;
                    "live" === u ? (i = e,
                    b.start = e - b.liveHalfTime,
                    b.stop = e + b.liveHalfTime,
                    ae(!0)) : b.stop > e && b.start <= e ? (i = e,
                    ae(!1)) : (b.stop = e + t,
                    b.start = e,
                    ge(),
                    ae(!0))
                }
                ,
                a.getTimeLengthFromPixels = function(e) {
                    return b.scale.invert(e).getTime() - b.scale.invert(0).getTime()
                }
                ,
                a.setMotionEvents = function(e) {
                    C = e,
                    b.debounceRenderEnhancementTimer = setTimeout((function() {
                        !0 !== b.animating && (re(),
                        se())
                    }
                    ), 50)
                }
                ,
                a.trackLive = function() {
                    var e, t = u;
                    u = "live",
                    Z(),
                    !0 === S.created && (b.sizerGroup.style("display", "none"),
                    setTimeout((function() {
                        S.container.style("display", "none")
                    }
                    ), 250)),
                    f.pointerGroup.select("rect").attr("height", b.height + S.height),
                    v.pointerGroup.select("rect").attr("height", b.height + S.height),
                    "playback" === t && (b.liveHalfTime = Math.floor((b.stop - b.start) / 2)),
                    b.scale.range([0, ce()]),
                    "playback" === t && (e = b.scale.invert(b.xOffset) - b.scale.invert(0),
                    b.start -= e,
                    b.stop += e),
                    b.xOffset = 0,
                    b.axisGroup.attr("transform", "translate(0, " + b.yOffset + ")"),
                    b.axisMinorGroup.attr("transform", "translate(0, " + b.yOffset + ")"),
                    b.axisMotionGroup.attr("transform", "translate(0, " + b.yOffset + ")"),
                    J(l / 2)
                }
                ,
                a.trackPlayback = function() {
                    var e, t, n, i = u;
                    u = "playback",
                    !0 === S.created && (b.sizerGroup.style("display", ""),
                    S.container.style("display", "")),
                    Z(),
                    !0 !== S.created && (t = b.height + S.yOffset,
                    S.configurations = [{
                        scale: "1 day",
                        formatter: y.monthDay,
                        ranger: d3.time.days,
                        rounder: function(e) {
                            return ipConfigure.core.roundDateToHours(new Date(e), 24).getTime()
                        },
                        milliseconds: T.perDay,
                        isKeySegment: function(e) {
                            return 1 === e.getDate()
                        }
                    }, {
                        scale: "12 hours",
                        formatter: y.minute,
                        ranger: function(e, t) {
                            return d3.time.hours(e, t, 12)
                        },
                        rounder: function(e) {
                            return ipConfigure.core.roundDateToHours(new Date(e), 12).getTime()
                        },
                        milliseconds: 12 * T.perHour,
                        isKeySegment: function(e) {
                            return 1 === e.getDate() && 0 === e.getHours()
                        }
                    }, {
                        scale: "6 hours",
                        formatter: y.minute,
                        ranger: function(e, t) {
                            return d3.time.hours(e, t, 6)
                        },
                        rounder: function(e) {
                            return ipConfigure.core.roundDateToHours(new Date(e), 6).getTime()
                        },
                        milliseconds: 6 * T.perHour,
                        isKeySegment: function(e) {
                            return 1 === e.getDate() && 0 === e.getHours()
                        }
                    }, {
                        scale: "3 hours",
                        formatter: y.minute,
                        ranger: function(e, t) {
                            return d3.time.hours(e, t, 3)
                        },
                        rounder: function(e) {
                            return ipConfigure.core.roundDateToHours(new Date(e), 3).getTime()
                        },
                        milliseconds: 3 * T.perHour,
                        isKeySegment: function(e) {
                            return 1 === e.getDate() && 0 === e.getHours()
                        }
                    }, {
                        scale: "1 hour",
                        formatter: y.minute,
                        ranger: function(e, t) {
                            return d3.time.hours(e, t, 1)
                        },
                        rounder: function(e) {
                            return ipConfigure.core.roundDateToHours(new Date(e), 1).getTime()
                        },
                        milliseconds: T.perHour,
                        isKeySegment: function(e) {
                            return 0 === e.getHours()
                        }
                    }, {
                        scale: "30 minutes",
                        formatter: y.minute,
                        ranger: function(e, t) {
                            return d3.time.minutes(e, t, 30)
                        },
                        rounder: function(e) {
                            return ipConfigure.core.roundDateToMinutes(new Date(e), 30).getTime()
                        },
                        milliseconds: 30 * T.perMinute,
                        isKeySegment: function(e) {
                            return 0 === e.getHours() && 0 === e.getMinutes()
                        }
                    }, {
                        scale: "15 minutes",
                        formatter: y.minute,
                        ranger: function(e, t) {
                            return d3.time.minutes(e, t, 15)
                        },
                        rounder: function(e) {
                            return ipConfigure.core.roundDateToMinutes(new Date(e), 15).getTime()
                        },
                        milliseconds: 15 * T.perMinute,
                        isKeySegment: function(e) {
                            return 0 === e.getHours() && 0 === e.getMinutes()
                        }
                    }, {
                        scale: "5 minutes",
                        formatter: y.minute,
                        ranger: function(e, t) {
                            return d3.time.minutes(e, t, 5)
                        },
                        rounder: function(e) {
                            return ipConfigure.core.roundDateToMinutes(new Date(e), 5).getTime()
                        },
                        milliseconds: 5 * T.perMinute,
                        isKeySegment: function(e) {
                            return 0 === e.getHours() && 0 === e.getMinutes()
                        }
                    }, {
                        scale: "1 minute",
                        formatter: y.minute,
                        ranger: function(e, t) {
                            return d3.time.minutes(e, t, 1)
                        },
                        rounder: function(e) {
                            return ipConfigure.core.roundDateToMinutes(new Date(e), 1).getTime()
                        },
                        milliseconds: T.perMinute,
                        isKeySegment: function(e) {
                            return 0 === e.getHours() && 0 === e.getMinutes()
                        }
                    }],
                    S.coarseContainer = S.container.append("g").attr("class", "coarse-container").attr("transform", "translate(0, " + t + ")"),
                    S.coarseContainer.append("rect").attr("class", "coarse-background").attr("width", "100%").attr("height", S.height - S.yOffset + "px"),
                    S.segmentContainer = S.coarseContainer.append("g").attr("class", "segment-container").data([{
                        x: -S.segmentWidth
                    }]).attr("transform", (function(e) {
                        return "translate(" + e.x + ")"
                    }
                    )),
                    S.liveBar.container = S.container.append("g").attr("class", "live inactive").on("click", q),
                    S.liveBar.rect = S.liveBar.container.append("rect"),
                    S.timeWindowMask = S.container.append("g").attr("class", "time-window-mask"),
                    S.timeWindow = S.container.append("g").attr("class", "time-window"),
                    S.timeWindowCenter = S.timeWindow.append("rect").attr("class", "time-window-center").attr("x", 0).attr("y", t).attr("height", S.height),
                    S.timeWindowLeftHandle = S.timeWindow.append("rect").attr("class", "time-window-left-handle").attr("x", -15).attr("y", t).attr("width", S.timeWindowHandleWidth).attr("height", S.height),
                    S.timeWindowRightHandle = S.timeWindow.append("rect").attr("class", "time-window-right-handle").attr("y", t).attr("width", S.timeWindowHandleWidth).attr("height", S.height),
                    n = d3.behavior.drag().origin((function() {
                        return S.segmentContainer.data()[0]
                    }
                    )).on("dragstart", B).on("drag", z).on("dragend", H),
                    S.leftMask = S.timeWindowMask.append("polygon").attr("class", "time-window-left-mask").attr("points", "0," + t + " 9000," + t + " 9015," + (t + 15) + "  9015," + (t + S.height) + " 0," + (t + 25)).on("click", W).on("touchcancel", H).call(n),
                    S.rightMask = S.timeWindowMask.append("polygon").attr("class", "time-window-right-mask").attr("points", "15," + t + " 9000," + t.toString() + " 9000," + (t + S.height) + " 0," + (t + S.height) + " 0," + (t + 15)).on("click", W).on("touchcancel", H).call(n),
                    S.leftMaskShadow = S.timeWindowMask.append("g").attr("class", "time-window-mask-left-shadow"),
                    S.leftMaskShadow.append("line").attr("y1", 63).attr("x1", 0).attr("y2", 63).attr("x2", 9e3).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .33),
                    S.leftMaskShadow.append("line").attr("y1", 64).attr("x1", 0).attr("y2", 64).attr("x2", 9001).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .25),
                    S.leftMaskShadow.append("line").attr("y1", 65).attr("x1", 0).attr("y2", 65).attr("x2", 9002).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .1),
                    S.leftMaskShadow.append("line").attr("y1", 64).attr("x1", 9e3).attr("y2", 78).attr("x2", 9014).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .33),
                    S.leftMaskShadow.append("line").attr("y1", 64).attr("x1", 8999).attr("y2", 79).attr("x2", 9014).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .25),
                    S.leftMaskShadow.append("line").attr("y1", 79).attr("x1", 9014).attr("y2", 88).attr("x2", 9014).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .33),
                    S.rightMaskShadow = S.timeWindowMask.append("g").attr("class", "time-window-mask-right-shadow"),
                    S.rightMaskShadow.append("line").attr("y1", 63).attr("x1", 15).attr("y2", 63).attr("x2", 9e3).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .33),
                    S.rightMaskShadow.append("line").attr("y1", 64).attr("x1", 14).attr("y2", 64).attr("x2", 9001).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .25),
                    S.rightMaskShadow.append("line").attr("y1", 65).attr("x1", 13).attr("y2", 65).attr("x2", 9002).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .1),
                    S.rightMaskShadow.append("line").attr("y1", 65).attr("x1", 14).attr("y2", 78).attr("x2", 1).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .33),
                    S.rightMaskShadow.append("line").attr("y1", 65).attr("x1", 15).attr("y2", 79).attr("x2", 1).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .25),
                    S.rightMaskShadow.append("line").attr("y1", 79).attr("x1", 1).attr("y2", 88).attr("x2", 1).attr("stroke-width", 1).attr("stroke", "black").attr("shape-rendering", "crispEdges").attr("opacity", .33),
                    S.timeWindow.data([{
                        x: 0,
                        width: 0
                    }]).call(d3.behavior.drag().on("dragstart", Y).on("drag", X).on("dragend", K)).on("touchcancel", K),
                    b.rightHandleGrabber = b.sizerGroup.append("g").style("cursor", "ew-resize").attr("transform", "translate(" + (l - 25) + ")").data([{
                        x: l - 25
                    }]).call(d3.behavior.drag().origin(Object).on("dragstart", F).on("drag", U).on("dragend", $)).on("touchcancel", $),
                    b.rightHandle = b.rightHandleGrabber.append("rect").attr("x", 0).attr("y", b.yOffset).attr("width", 25).attr("height", b.height - b.yOffset).attr("fill", "#0f313d").attr("fill-opacity", "0.5"),
                    b.rightHandleGrabber.append("line").attr("x1", 9.5).attr("x2", 9.5).attr("y1", b.yOffset + 15).attr("y2", b.yOffset + 15 + 18).attr("stroke", "#c8e3f1"),
                    b.rightHandleGrabber.append("line").attr("x1", 12.5).attr("x2", 12.5).attr("y1", b.yOffset + 15).attr("y2", b.yOffset + 15 + 18).attr("stroke", "#c8e3f1"),
                    b.rightHandleGrabber.append("line").attr("x1", 15.5).attr("x2", 15.5).attr("y1", b.yOffset + 15).attr("y2", b.yOffset + 15 + 18).attr("stroke", "#c8e3f1"),
                    b.leftHandleGrabber = b.sizerGroup.append("g").style("cursor", "ew-resize").call(d3.behavior.drag().origin(Object).on("dragstart", j).on("drag", V).on("dragend", G)).on("touchcancel", G).data([{
                        x: 25
                    }]),
                    b.leftHandle = b.leftHandleGrabber.append("rect").attr("x", 0).attr("y", b.yOffset).attr("width", 25).attr("height", b.height - b.yOffset).attr("fill", "#0f313d").attr("fill-opacity", "0.5"),
                    b.leftHandlGrabberLineGroup = b.leftHandleGrabber.append("g").attr("transform", "translate(9)"),
                    b.leftHandlGrabberLineGroup.append("line").attr("x1", .5).attr("x2", .5).attr("y1", b.yOffset + 15).attr("y2", b.yOffset + 15 + 18).attr("stroke", "white"),
                    b.leftHandlGrabberLineGroup.append("line").attr("x1", 3.5).attr("x2", 3.5).attr("y1", b.yOffset + 15).attr("y2", b.yOffset + 15 + 18).attr("stroke", "white"),
                    b.leftHandlGrabberLineGroup.append("line").attr("x1", 6.5).attr("x2", 6.5).attr("y1", b.yOffset + 15).attr("y2", b.yOffset + 15 + 18).attr("stroke", "white"),
                    S.created = !0,
                    S.dragging = !1,
                    S.timeWindow.dragging = !1),
                    c.style("height", b.height + S.height + "px"),
                    f.pointerGroup.select("rect").attr("height", b.height),
                    v.pointerGroup.select("rect").attr("height", b.height),
                    b.xOffset = 25,
                    b.axisGroup.attr("transform", "translate(" + b.xOffset + ", " + b.yOffset + ")"),
                    b.axisMinorGroup.attr("transform", "translate(" + b.xOffset + ", " + b.yOffset + ")"),
                    b.axisMotionGroup.attr("transform", "translate(" + b.xOffset + ", " + b.yOffset + ")"),
                    "live" === i && (e = b.scale.invert(b.xOffset) - b.scale.invert(0),
                    b.start += e,
                    b.stop -= e,
                    ge()),
                    b.scale.range([0, ce()]),
                    ae()
                }
                ,
                a.resize = function() {
                    var e, t;
                    return l = c.node().clientWidth,
                    t = ce(),
                    m = c.node().getBoundingClientRect().left,
                    !0 === b.created && (b.scale.range([0, t]),
                    e = de(),
                    b.axis.ticks(e)),
                    "live" === u ? J(l / 2) : (ae(),
                    !0 === S.created && oe()),
                    !0 === S.created && b.rightHandleGrabber.attr("transform", "translate(" + (l - 25) + ")").data([{
                        x: l - 25
                    }]),
                    l
                }
                ,
                a.setSpeed = function(e) {
                    a.speed = e
                }
                ,
                a.setScale = function(e, t) {
                    a.adjustScale(e - S.configurationIndex, t)
                }
                ,
                a.adjustScale = function(e, t) {
                    var n, i = Math.ceil(l / S.segmentWidth) + 2, a = -1 === e ? i - 1 : 1, r = -1 === e ? he : me, s = S.configurationIndex, o = {
                        start: b.start,
                        stop: b.stop
                    };
                    0 !== (a = Math.floor(S.scale(b.start) / S.segmentWidth) + 1) && 1 !== a && 2 !== a || (a = -1 === e ? 3 : 0),
                    s !== (n = Math.min(Math.max(0, S.configurationIndex + e), S.configurations.length - 1)) ? r(a, (function() {
                        le(a, n, !0, o),
                        "function" == typeof t && t()
                    }
                    )) : "function" == typeof t && t()
                }
                ,
                a.getMode = function() {
                    return u
                }
                ,
                a.destroy = function() {
                    _("timeline destroy")
                }
                ,
                function() {
                    if (_("timeline options", I),
                    v.width = ipConfigure.core.calculateLiveLabelWidth(),
                    void 0 !== v.label) {
                        const e = 10 * L.messages.stage.live().length + 10;
                        v.labelGroup.select("rect").attr("width", e),
                        v.labelGroup.select("text").text(L.messages.stage.live()).attr("width", e).attr("x", e / 2)
                    }
                    d.append("defs"),
                    d.attr("width", "100%"),
                    d.attr("class", "timeline"),
                    b.container = d.append("g").attr("class", "fine"),
                    S.container = d.append("g").attr("class", "coarse"),
                    f.container = d.append("g").attr("class", "fine-indicator"),
                    v.container = d.append("g").attr("class", "live-indicator clickable")
                }()
            }
            ,
            _n.$inject = ["$rootScope", "$timeout", "TimelineServiceFactory"],
            angular.module("ipconfigure.orchid.singularity").directive("timeline", _n);
            var Dn, On, An = n(6708);
            let Rn = class {
                constructor() {
                    this.archivesPerDay = {},
                    this.maxDate = new Date(Date.now()),
                    this.minDate = new Date(2e3,0,1),
                    this._mostArchivesPerDay = 0,
                    this._yearsWithArchives = [],
                    this._monthsWithArchives = [],
                    this._daysWithArchives = [],
                    this.dateClass = (e, t) => {
                        const n = []
                          , [i,a,r] = e.toISOString().split("T")[0].split("-");
                        if ("month" === t && this._daysWithArchives.includes(`${i}-${a}-${r}`)) {
                            n.push("archives-month");
                            const e = this.archivesPerDay[`${i}-${a}-${r}`] / this._mostArchivesPerDay;
                            e > .9 && n.push("archives-high"),
                            e < .5 && n.push("archives-low")
                        }
                        return "year" === t && this._monthsWithArchives.includes(`${i}-${a}`) && n.push("archives-year archives-high"),
                        "multi-year" === t && this._yearsWithArchives.includes(i) && n.push("archives-multi-year archives-high"),
                        n.join(" ")
                    }
                }
                onDateSelected(e) {
                    this.date.setValue(e)
                }
                ngOnInit() {
                    for (const [e,t] of Object.entries(this.archivesPerDay)) {
                        const [n,i,a] = e.split("-");
                        this._yearsWithArchives.includes(n) || this._yearsWithArchives.push(n),
                        this._monthsWithArchives.includes(`${n}-${i}`) || this._monthsWithArchives.push(`${n}-${i}`),
                        this._daysWithArchives.includes(`${n}-${i}-${a}`) || this._daysWithArchives.push(`${n}-${i}-${a}`),
                        t > this._mostArchivesPerDay && (this._mostArchivesPerDay = t)
                    }
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Dn = void 0 !== p.TO && p.TO) ? Dn : Object)], Rn.prototype, "date", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (On = "undefined" != typeof Record && Record) ? On : Object)], Rn.prototype, "archivesPerDay", void 0),
            Rn = (0,
            c.gn)([(0,
            i.Component)({
                selector: "calendar-input",
                template: n(28815)
            })], Rn);
            var Pn, kn, Mn, Ln = n(81480);
            !function(e) {
                e.min = "min",
                e.max = "max"
            }(Pn || (Pn = {}));
            let Nn = class {
                constructor() {
                    this.min = 0,
                    this.max = 23,
                    this.placeHolder = "00",
                    this.rollOverSubjectSupplied = !1,
                    this.isInputValid = new i.EventEmitter,
                    this.subscriptions = []
                }
                get currentValueZeroPadded() {
                    if (this.fakeNumberInputControl && !this.valid)
                        return this.fakeNumberInputControl.value;
                    const e = this.currentActualValue;
                    return "number" != typeof e ? e : this.nextValueWithinLimits(e) ? `${e < 10 && e >= 0 ? 0 : ""}${e}` : -1 === e ? "" : `${e}`
                }
                get incrementButtonId() {
                    return `increment-${this.fieldName}`
                }
                get decrementButtonId() {
                    return `decrement-${this.fieldName}`
                }
                get inputId() {
                    return `${this.fieldName}-input`
                }
                get currentActualValue() {
                    return this.group ? this.group.controls[this.fieldName].value : ""
                }
                get valid() {
                    const e = this.fakeNumberInputControl.valid;
                    return this.isInputValid.emit(e),
                    e
                }
                ngOnInit() {
                    this.fakeNumberInputControl = new p.NI(this.currentValueZeroPadded,[p.kI.required, p.kI.pattern(/^[0-9]{1,2}$/), p.kI.min(this.min), p.kI.max(this.max)]);
                    this.subscriptions.push(this.fakeNumberInputControl.valueChanges.pipe((e => new Ln.y((t => e.subscribe((e => {
                        if (null === e || "" === e || " " === e)
                            return t.next(-1);
                        const n = parseInt(e, 10);
                        t.next(isNaN(n) ? e : n)
                    }
                    )))))).subscribe((e => {
                        this._setNextValue(e)
                    }
                    ))),
                    this.rollover$ instanceof St.x && (this.rollOverSubjectSupplied = !0,
                    "seconds" !== this.fieldName && this.subscriptions.push(this.rollover$.subscribe((e => this.onRollover(e)))))
                }
                ngOnDestroy() {
                    this.subscriptions.forEach((e => {
                        e.unsubscribe()
                    }
                    ))
                }
                incrementTime() {
                    if (this.valid) {
                        const e = this.currentActualValue;
                        "number" == typeof e && (this.setValueAndMaybeHandleRollover(e + 1),
                        this._zeroPad())
                    }
                }
                decrementTime() {
                    if (this.valid) {
                        const e = this.currentActualValue;
                        "number" == typeof e && (this.setValueAndMaybeHandleRollover(e - 1),
                        this._zeroPad())
                    }
                }
                notifyRollover(e) {
                    this.rollOverSubjectSupplied && this.rollover$.next({
                        field: this.fieldName,
                        kind: e
                    })
                }
                onRollover(e) {
                    if (("hours" === this.fieldName && "minutes" === e.field || "minutes" === this.fieldName && "seconds" === e.field) && this.valid) {
                        const t = this.currentActualValue;
                        "number" == typeof t && (this.setValueAndMaybeHandleRollover(e.kind === Pn.max ? t + 1 : t - 1),
                        this._zeroPad())
                    }
                }
                nextValueWithinLimits(e) {
                    return e >= this.min && e <= this.max
                }
                setValueAndMaybeHandleRollover(e) {
                    let t = !1
                      , n = e
                      , i = Pn.min;
                    n < this.min ? (n = this.max,
                    t = !0) : n > this.max && (i = Pn.max,
                    n = this.min,
                    t = !0),
                    this._setNextValue(n),
                    this.rollOverSubjectSupplied && t && this.notifyRollover(i)
                }
                displayZeroPaddedNumber() {
                    this.valid && this._zeroPad()
                }
                _zeroPad() {
                    this.fakeNumberInputControl.setValue(this.currentValueZeroPadded, {
                        emitEvent: !1
                    })
                }
                _setNextValue(e) {
                    this.group.controls[this.fieldName].setValue(e)
                }
            }
            ;
            var Fn, Un, $n, jn;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Nn.prototype, "min", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Nn.prototype, "max", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (kn = void 0 !== p.cw && p.cw) ? kn : Object)], Nn.prototype, "group", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Nn.prototype, "fieldName", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Nn.prototype, "placeHolder", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Mn = void 0 !== St.x && St.x) ? Mn : Object)], Nn.prototype, "rollover$", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], Nn.prototype, "isInputValid", void 0),
            Nn = (0,
            c.gn)([(0,
            i.Component)({
                selector: "time-input",
                template: n(46947)
            })], Nn);
            let Vn = class {
                constructor() {
                    this.hideSeconds = !1,
                    this.hoursMin = 0,
                    this.hoursMax = 23,
                    this.minutesMin = 0,
                    this.minutesMax = 59,
                    this.secondsMin = 0,
                    this.secondsMax = 59,
                    this.isTimeInputsValid = new i.EventEmitter,
                    this._isHoursInputValid = !0,
                    this._isMinutesInputValid = !0,
                    this._isSecondsInputValid = !0,
                    this.rollover$ = new St.x
                }
                isHoursInputValid(e) {
                    this._isHoursInputValid = e,
                    this._isTimeInputsValid()
                }
                isMinutesInputValid(e) {
                    this._isMinutesInputValid = e,
                    this._isTimeInputsValid()
                }
                isSecondsInputValid(e) {
                    this._isSecondsInputValid = e,
                    this._isTimeInputsValid()
                }
                _isTimeInputsValid() {
                    this.isTimeInputsValid.emit(this._isHoursInputValid && this._isMinutesInputValid && this._isSecondsInputValid)
                }
                get valid() {
                    if (void 0 === this.hoursInput || void 0 === this.minutesInput)
                        return !1;
                    const e = this.hoursFieldValid && this.minutesFieldValid;
                    return this.secondsInput ? e && this.secondsFieldValid : e
                }
                get hoursFieldValid() {
                    return void 0 !== this.hoursInput && this.hoursInput.valid
                }
                get minutesFieldValid() {
                    return void 0 !== this.minutesInput && this.minutesInput.valid
                }
                get secondsFieldValid() {
                    return !!this.hideSeconds || void 0 !== this.secondsInput && this.secondsInput.valid
                }
            }
            ;
            var Gn, Bn, zn;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Fn = void 0 !== p.cw && p.cw) ? Fn : Object)], Vn.prototype, "group", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Vn.prototype, "hideSeconds", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Vn.prototype, "hoursMin", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Vn.prototype, "hoursMax", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Vn.prototype, "minutesMin", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Vn.prototype, "minutesMax", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Vn.prototype, "secondsMin", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Vn.prototype, "secondsMax", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], Vn.prototype, "isTimeInputsValid", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("hoursTimeInput"), (0,
            c.w6)("design:type", "function" == typeof (Un = void 0 !== Nn && Nn) ? Un : Object)], Vn.prototype, "hoursInput", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("minutesTimeInput"), (0,
            c.w6)("design:type", "function" == typeof ($n = void 0 !== Nn && Nn) ? $n : Object)], Vn.prototype, "minutesInput", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("secondsInput"), (0,
            c.w6)("design:type", "function" == typeof (jn = void 0 !== Nn && Nn) ? jn : Object)], Vn.prototype, "secondsInput", void 0),
            Vn = (0,
            c.gn)([(0,
            i.Component)({
                selector: "time-inputs",
                template: n(34744)
            })], Vn);
            let Hn = class {
                constructor() {
                    this.hideTime = !1,
                    this.hideSeconds = !1,
                    this.archivesPerDay = {}
                }
                get valid() {
                    return !this.datetimeFG || this.datetimeFG.valid
                }
                get datetime() {
                    if (this.datetimeFG instanceof p.cw && this.valid) {
                        const {date: e, hours: t, minutes: n, seconds: i} = this.datetimeFG.value;
                        return this.hideTime ? e.setHours(0, 0, 0, 0) : e.setHours(t, n, this.hideSeconds ? 0 : "number" == typeof i ? i : 0, 0),
                        e
                    }
                }
                get timeInputsValidatorValue() {
                    return this.timeInputs ? this.timeInputs.valid ? null : {
                        timeInputsInvalid: !0
                    } : null
                }
                ngOnInit() {
                    void 0 === this.date && (this.date = new Date),
                    this.datetimeFG = new p.cw({
                        date: new p.NI(this.date),
                        hours: new p.NI(this.date.getHours()),
                        minutes: new p.NI(this.date.getMinutes()),
                        seconds: new p.NI(this.date.getSeconds())
                    },( () => this.timeInputsValidatorValue))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Gn = "undefined" != typeof Date && Date) ? Gn : Object)], Hn.prototype, "date", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Hn.prototype, "hideTime", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Hn.prototype, "hideSeconds", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Bn = "undefined" != typeof Record && Record) ? Bn : Object)], Hn.prototype, "archivesPerDay", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(Vn), (0,
            c.w6)("design:type", "function" == typeof (zn = void 0 !== Vn && Vn) ? zn : Object)], Hn.prototype, "timeInputs", void 0),
            Hn = (0,
            c.gn)([(0,
            i.Component)({
                selector: "date-time-picker",
                template: n(61473)
            })], Hn);
            var Wn, qn, Yn, Xn, Kn, Zn = n(30250);
            let Jn = Wn = class {
                constructor(e, t, n, i) {
                    this._mdDialogRef = e,
                    this.data = t,
                    this.overlayContainer = n,
                    this._orchidDataService = i,
                    this.archivesPerDay = {},
                    this.loading = !1,
                    this.useOrchidTheme && !0 === this.useOrchidTheme && this.overlayContainer.getContainerElement().classList.add("date-picker-theme")
                }
                static show(e, t) {
                    return e.open(Wn, {
                        panelClass: "datetime-picker-dialog-panel",
                        data: Object.assign({
                            date: new Date,
                            okText: L.messages.dialogs.ok(),
                            cancelText: L.messages.dialogs.cancel(),
                            title: L.messages.stage.dateTimeNavigation(),
                            hideTime: !1,
                            hideSeconds: !1,
                            useOrchidTheme: !1,
                            orchidsAndStreams: []
                        }, t)
                    }).afterClosed()
                }
                ngOnInit() {
                    this.loading = !0;
                    const e = [];
                    this.data.orchidsAndStreams.forEach((t => {
                        t.streamIds.length > 0 && e.push(this._orchidDataService.fetchArchiveCount(t.streamIds, t.orchid))
                    }
                    )),
                    Promise.all(e).then((e => {
                        e.forEach((e => {
                            this.archivesPerDay = this._joinArchivesPerDay(this.archivesPerDay, e.data.archivesPerDay)
                        }
                        ))
                    }
                    )).catch(( () => {}
                    )).finally(( () => {
                        this.loading = !1
                    }
                    ))
                }
                _joinArchivesPerDay(e, t) {
                    const n = xt(e);
                    return Object.keys(t).forEach((e => {
                        void 0 === n[e] ? n[e] = t[e] : n[e] += t[e]
                    }
                    )),
                    n
                }
                get valid() {
                    return !this.datetimePicker || this.datetimePicker.valid
                }
                get useOrchidTheme() {
                    return this.data.useOrchidTheme
                }
                get cancelText() {
                    return this.data.cancelText
                }
                get okText() {
                    return this.data.okText
                }
                get titleText() {
                    return this.data.title
                }
                cancel() {
                    this.close(!0)
                }
                close(e) {
                    this._mdDialogRef.close(e ? void 0 : this.datetimePicker.datetime)
                }
                ngOnDestroy() {
                    !0 === this.useOrchidTheme && this.overlayContainer.getContainerElement().classList.remove("date-picker-theme")
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.ViewChild)(Hn), (0,
            c.w6)("design:type", "function" == typeof (qn = void 0 !== Hn && Hn) ? qn : Object)], Jn.prototype, "datetimePicker", void 0),
            Jn = Wn = (0,
            c.gn)([(0,
            i.Component)({
                selector: "date-time-picker-dialog",
                template: n(99955)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(2, (0,
            i.Inject)(Zn.Xj)), (0,
            c.fM)(3, (0,
            i.Inject)(pt)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Yn = void 0 !== hn.so && hn.so) ? Yn : Object, Object, "function" == typeof (Xn = void 0 !== Zn.Xj && Zn.Xj) ? Xn : Object, "function" == typeof (Kn = pt) ? Kn : Object])], Jn);
            var Qn = n(11546)
              , ei = n(35864)
              , ti = n(34357)
              , ni = n(27028)
              , ii = n(60957)
              , ai = n(26e3)
              , ri = n(6575)
              , si = n(89017)
              , oi = n(31584)
              , ci = n(53632)
              , li = n(36565)
              , di = n(73661)
              , ui = n(16075)
              , mi = n(12097)
              , hi = n(52773)
              , pi = n(10573)
              , gi = n(66589)
              , fi = n(79925)
              , vi = n(5766)
              , yi = n(48802)
              , bi = n(84963)
              , Si = n(83308)
              , Ci = n(92451)
              , wi = n(99929)
              , Ii = n(89390)
              , Ti = n(61544)
              , Ei = n(73963)
              , _i = n(29241)
              , xi = n(79112)
              , Di = n(45711)
              , Oi = n(42658);
            let Ai = class {
            }
            ;
            Ai = (0,
            c.gn)([(0,
            i.NgModule)({
                exports: [d.fX, Qn.Bb, ei.g, ti.ot, ni.vV, ii.QW, ai.p9, ri.Hi, si.BQ, oi.FA, hn.Is, ci.To, li.lN, di.Ps, ui.c, mi.ie, hi.Tx, si.XK, si.Ng, pi.TU, gi.Cv, fi.Cq, vi.Fk, si.si, yi.LD, bi.SJ, Si.rP, Ci.KP, wi.ZX, Ii.JX, Ti.T5, Ei.p0, _i.Nh, xi.g0, Di.AV, Oi.dp]
            })], Ai);
            let Ri = class {
            }
            ;
            function Pi(e, t) {
                return Jn.show(e, t)
            }
            Ri = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [Rn, Hn, Jn, Nn, Vn],
                entryComponents: [Jn],
                exports: [Rn, Hn, Nn, Vn],
                imports: [An.rt, l.ez, Ai, p.UX]
            })], Ri),
            Li.$inject = ["$rootScope", "$scope", "$mdDialog", "$mdToast", "$timeout", "TimelineServiceFactory", "OrchidDataService", "FusionDataService", "FusionConfigService", "AuthenticationService", "BrowserInfoService", "TimeService", "DownloaderService", "Router", "MatDialog"];
            const ki = O("ExportDialog");
            let Mi = function() {
                function e(t, n) {
                    (0,
                    S.Z)(this, e),
                    this.stream = t,
                    this.isOnvif = n,
                    this.name = this._getName()
                }
                return (0,
                b.Z)(e, [{
                    key: "_getName",
                    value: function() {
                        if (this.isOnvif) {
                            const e = this.stream.configuration.Video;
                            return [e.Resolution, L.messages.library.valueFps({
                                VALUE: e.FrameRate
                            }), e.Encoder].join(", ")
                        }
                        return this.stream.name
                    }
                }], [{
                    key: "fromCamera",
                    value: function(t) {
                        let n = [t.primaryStream];
                        t.secondaryStreams.forEach((function(e) {
                            !0 === e.recording && n.push(e)
                        }
                        ));
                        const i = t.driver === Q.ONVIF;
                        return n.map((function(t) {
                            return new e(t,i)
                        }
                        ))
                    }
                }, {
                    key: "sortOnvifOptionsByResolution",
                    value: function(e) {
                        let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
                        if (!e.every((function(e) {
                            return e.isOnvif
                        }
                        )))
                            return ki.error("Attempted to sort non-ONVIF options", e),
                            e;
                        const n = [...e];
                        return n.sort((function(e, t) {
                            const n = i(e)
                              , a = i(t)
                              , r = [n[0] - a[0], n[1] - a[1]].find((function(e) {
                                return 0 !== e
                            }
                            ));
                            return r || 0
                        }
                        )),
                        !0 === t ? n.reverse() : n;
                        function i(e) {
                            const t = [1, 1];
                            let n = e.stream.configuration.Video.Resolution.split("x");
                            return 2 !== n.length ? t : (n = n.map((function(e) {
                                return parseInt(e)
                            }
                            )),
                            n.includes(NaN) ? t : n)
                        }
                    }
                }]),
                e
            }();
            function Li(e, t, n, i, a, r, s, o, c, l, d, u, m, h, p) {
                var g, f = this;
                let v = xn(location)["show-dewarp"];
                function y(e) {
                    return e.getTime()
                }
                f.hasDewarpOption = void 0 === v || "1" === v || "true" === v,
                f.orchidStreamPairs = [],
                f.showFormats = !1,
                f.isOrchid = w.isOrchid,
                f.events = [],
                f.isMobileSafari = d.isMobileSafari(),
                f.browser = d.getBrowserInfo(),
                f.canExportSafari = "MacIntel" === f.browser.platform && f.browser.version >= 12 || f.isMobileSafari && f.browser.version >= 13,
                f.libraryItemName = null,
                f.libraryError = null,
                f.selectedTab = 0,
                f.showLibrary = !f.isOrchid && l.getAuthenticationData().hasLibraryAccess(),
                f.showLibrary && (f.maxLibraryExportHours = c.getConfigPostAuth().maxLibraryExportHours,
                f.maxLibraryExportMs = 60 * f.maxLibraryExportHours * 60 * 1e3),
                f.close = function() {
                    return n.cancel()
                }
                ,
                f.isRangeValid = function(e, t) {
                    return t.getTime() >= e.getTime() + 1e4 && t.getTime() <= Date.now()
                }
                ,
                f.isLibraryFormValid = function() {
                    return f.orchidStreamPairs.some((function(e) {
                        return e.librarySelected
                    }
                    )) && f.isRangeValid(f.libraryStartTime, f.libraryStopTime) && f.libraryStopTime - f.libraryStartTime <= f.maxLibraryExportMs && !1 === re(f.libraryItemName)
                }
                ,
                f.saveToLibrary = async function() {
                    f.libraryError = null,
                    f.orchidStreamPairs.forEach((function(e) {
                        e.libraryError = null
                    }
                    ));
                    let e = [];
                    for (const n of f.orchidStreamPairs.filter((function(e) {
                        return e.librarySelected
                    }
                    ))) {
                        var t = u.getOrchidTimeOffset(n.orchid.id);
                        const i = {
                            name: f.libraryItemName,
                            request: {
                                startTimeMs: f.libraryStartTime.getTime() - t,
                                stopTimeMs: f.libraryStopTime.getTime() - t,
                                source: {
                                    orchidId: n.orchid.id,
                                    streamId: n.selectedLibraryOption.stream.id
                                }
                            }
                        };
                        let a = o.newLibraryExport(i).catch((function(e) {
                            throw n.libraryError = e.data.reason,
                            e
                        }
                        ));
                        e.push(a)
                    }
                    try {
                        await Promise.all(e),
                        await f.close(),
                        w.singlePlayerMode || await function() {
                            const e = i.simple().textContent(f.msgs.theSelectedVideosHaveBeenSentToTheLibrary()).action(f.msgs.goToLibrary()).highlightAction(!0).highlightClass("md-primary").toastClass("library-toast").position("bottom right").hideDelay(5e3);
                            i.show(e).then((function(e) {
                                "ok" === e && h.navigateByUrl("/library")
                            }
                            )).catch((function() {
                                return angular.noop()
                            }
                            ))
                        }()
                    } catch (e) {
                        f.libraryError = f.msgs.oneOrMoreOfTheLibraryItemsFailedToBeCreated()
                    }
                }
                ,
                f.setLibraryFocus = function() {
                    a((function() {
                        return document.querySelector(".library-focus").focus()
                    }
                    ), 500)
                }
                ,
                f.exportStream = function(e, t) {
                    var n, i = u.getOrchidTimeOffset(e.orchid.id), a = f.startTimeEpoch - i, r = f.stopTimeEpoch - i;
                    s.testExport(a, r, e.selectedDownloadOption.stream.id, e.orchid).then((function(i) {
                        let o = t;
                        n = s.exportUrl(e.orchid, e.selectedDownloadOption.stream.id, a, r, o);
                        m.createDownloader().download(n)
                    }
                    ), (function(e) {
                        var t;
                        t = 404 === e.status ? f.msgs.thereAreNoArchivesInRegion() : f.msgs.errorOccurredWhileExportingVideo(),
                        alert(t)
                    }
                    ))
                }
                ,
                f.onDownloadOptionSelect = function(e, t) {
                    e.selectedDownloadOption = t
                }
                ,
                f.onLibraryOptionSelect = function(e, t) {
                    t !== e.selectedLibraryOption && (e.selectedLibraryOption = t)
                }
                ,
                f.onLibraryCardClick = function(e) {
                    e.disableLibraryExport ? e.librarySelected = !1 : e.librarySelected = !e.librarySelected
                }
                ,
                f.showDateTimePicker = function(e) {
                    var t, n;
                    0 === f.selectedTab ? (t = f.startTime,
                    n = f.stopTime) : (t = f.libraryStartTime,
                    n = f.libraryStopTime),
                    (0,
                    dt.z)(Pi(p, {
                        date: e ? n : t,
                        title: e ? f.msgs.to() : f.msgs.from(),
                        okText: f.msgs.go(),
                        orchidsAndStreams: f.linkedStreams,
                        useOrchidTheme: !1
                    })).then((function(t) {
                        t && (0 === f.selectedTab ? e ? f.stopTime = t : f.startTime = t : e ? f.libraryStopTime = t : f.libraryStartTime = t)
                    }
                    ))
                }
                ,
                f.$onInit = function() {
                    f.msgs = {
                        ...L.messages.dialogs,
                        ...L.messages.stage,
                        ...L.messages.library,
                        noStreamsConfigured: L.messages.player.noStreamsConfigured
                    },
                    f.dateTimeFormat = L.formats.ipcDatePicker.seconds;
                    var n, i = r.getContext("master");
                    g = i.getCurrentState();
                    const a = new Date(g.fineTime.start);
                    a.setMilliseconds(0);
                    const s = new Date(g.fineTime.stop)
                      , o = s > Date.now() ? new Date : s;
                    o.setMilliseconds(0),
                    n = i.getLinkedCameras(),
                    f.linkedStreams = i.getLinkedStreams({
                        playback: !0
                    }),
                    f.startTime = a,
                    f.libraryStartTime = a,
                    f.stopTime = o,
                    f.libraryStopTime = o,
                    f.startTimeEpoch = y(f.startTime),
                    f.stopTimeEpoch = y(f.stopTime);
                    let c = t.$watch((function() {
                        return f.startTime + f.stopTime + f.libraryStartTime + f.libraryStopTime
                    }
                    ), (function() {
                        f.startTimeEpoch = y(f.startTime),
                        f.stopTimeEpoch = y(f.stopTime),
                        f.error = void 0,
                        angular.forEach(f.orchidStreamPairs, (function(e) {
                            e.error = void 0,
                            e.disableLibraryExport = !1
                        }
                        )),
                        !1 === f.isRangeValid(f.startTime, f.stopTime) ? f.error = f.msgs.timeRangeError() : (f.isOrchid && (f.stopTimeEpoch - f.startTimeEpoch > 1e3 * e.orchids[0].discoverableOrchid.maxExportHours * 60 * 60 ? f.error = f.msgs.maximumExportDuration({
                            VALUE: e.orchids[0].discoverableOrchid.maxExportHours
                        }) : f.error = void 0),
                        angular.forEach(f.orchidStreamPairs, (function(e) {
                            se(e.camera.primaryStream) ? (e.error = f.msgs.noStreamsConfigured(),
                            e.libraryError = f.msgs.noStreamsConfigured(),
                            e.disableLibraryExport = !0) : f.stopTimeEpoch - f.startTimeEpoch > 1e3 * e.orchid.discoverableOrchid.maxExportHours * 60 * 60 && (e.error = f.msgs.maximumExportDuration({
                                VALUE: e.orchid.discoverableOrchid.maxExportHours
                            }))
                        }
                        ))),
                        f.showLibrary && (f.libraryError = "",
                        f.libraryStartTime = new Date(f.libraryStartTime - f.libraryStartTime % 1e3),
                        f.libraryStopTime = new Date(f.libraryStopTime - f.libraryStopTime % 1e3),
                        !1 === f.isRangeValid(f.libraryStartTime, f.libraryStopTime) ? f.libraryError = f.msgs.timeRangeError() : f.libraryStopTime - f.libraryStartTime > f.maxLibraryExportMs && (f.libraryError = f.msgs.maximumExportDuration({
                            VALUE: f.maxLibraryExportHours
                        })))
                    }
                    ));
                    t.$on("$destroy", c),
                    n.forEach((function(e) {
                        e.cameras.forEach((function(t) {
                            if (!0 === t.permissions.actions.export) {
                                let i, a, r = !1, s = [];
                                if (!se(t.primaryStream)) {
                                    let e = t.primaryStream;
                                    if (null !== e && e.dewarpConfiguration) {
                                        var n = te(e.dewarpConfiguration);
                                        r = null !== n && n.enable
                                    }
                                    s = Mi.fromCamera(t),
                                    t.driver === Q.ONVIF && (s = Mi.sortOnvifOptionsByResolution(s, !0)),
                                    t.driver === Q.ONVIF ? (i = s[0],
                                    a = i) : (i = s.find((function(e) {
                                        return e.stream.id === t.primaryStream.id
                                    }
                                    )),
                                    a = i)
                                }
                                f.orchidStreamPairs.push({
                                    orchid: e.orchid,
                                    camera: t,
                                    isDewarp: r,
                                    streamOptions: s,
                                    selectedDownloadOption: i,
                                    selectedLibraryOption: a
                                })
                            }
                        }
                        )),
                        f.orchidStreamPairs.sort((function(e, t) {
                            return e.orchid.name.localeCompare(t.orchid.name) || e.camera.name.localeCompare(t.camera.name)
                        }
                        ))
                    }
                    ))
                }
            }
            function Ni(e, t, i, a, r, s, c, l, d, u) {
                var m, h, p = this;
                function g(e) {
                    var t = p.scaleIndex + e;
                    !1 === p.scaleAdjusting && t > 0 && t < p.scales.length - 1 && (p.scaleAdjusting = !0,
                    m.setScale(t),
                    a((function() {
                        p.scaleAdjusting = !1
                    }
                    ), 333))
                }
                m = o().isUndefined(c.getContext("master")) ? c.createContext("master") : c.getContext("master"),
                p.paused = !1,
                p.speed = 1,
                p.speedDirection = 1,
                p.speedDisplay = "1",
                p.showSpeedControl = !1,
                p.canExport = !1,
                s.getAuthenticationDataPromise().then((function(e) {
                    p.canExport = "viewer" !== e.getRole() && "live viewer" !== e.getRole()
                }
                )),
                p.speedChangeTimout,
                p.speedSteps = ["1/4", "1/2", "1", "2", "4", "8", "16", "32", "64"],
                p.scaleAdjusting = !1,
                p.exportVideo = function(e) {
                    t.show({
                        template: n(79871),
                        controller: "ExportDialogController as exportDialog",
                        parent: o().element(document.body),
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        locals: {}
                    })
                }
                ,
                p.togglePaused = function() {
                    p.setPaused(!p.paused, {
                        allowPlay: !0
                    })
                }
                ,
                p.toggleSelectionMode = function() {
                    p.selectionMode = !p.selectionMode
                }
                ,
                p.scaleLeft = function() {
                    g(1)
                }
                ,
                p.scaleRight = function() {
                    g(-1)
                }
                ,
                p.showDatePicker = function(e) {
                    (0,
                    dt.z)(Pi(d, {
                        date: new Date(m.getCurrentState().time),
                        title: p.msgs.dateTimeNavigation(),
                        okText: L.messages.dialogs.go(),
                        orchidsAndStreams: m.getLinkedStreams({
                            playback: !0
                        })
                    })).then((function(e) {
                        e && (p.selectionMode = !1,
                        m.setTime(e.getTime(), {
                            publish: !0
                        }))
                    }
                    ))
                }
                ,
                p.nextMotionEvent = async function(e) {
                    var t = m.getCurrentState();
                    p.processing = !0;
                    const n = {
                        minSegment: m.getTimeLengthFromPixels(1 / 3),
                        speed: t.speed,
                        start: t.fineTime.start,
                        stop: t.fineTime.stop,
                        time: t.time
                    };
                    for (; p.processing; )
                        try {
                            let a = await l.fetchEvent(e, n.time, n.speed);
                            if (null === a || a > Date.now)
                                return;
                            if (p.selectionMode)
                                if ((i = a) > t.fineTime.start && i < t.fineTime.stop)
                                    !0 === p.paused && (p.paused = !1);
                                else {
                                    const t = "next" === e ? n.start : n.stop;
                                    a = await l.fetchEvent(e, t, n.speed)
                                }
                            else
                                !0 === p.paused && (p.paused = !1);
                            m.setTime(a, {
                                publish: !0
                            })
                        } catch (e) {
                            o().noop()
                        } finally {
                            p.processing = !1
                        }
                    var i
                }
                ,
                p.toggleSpeedControl = function() {
                    p.showSpeedControl = !p.showSpeedControl,
                    a((function() {
                        i.$broadcast("rzSliderForceRender")
                    }
                    ))
                }
                ,
                p.setSpeed = function(e, t) {
                    switch (p.speed = e,
                    Math.abs(p.speed)) {
                    case .25:
                        p.speedDisplay = "1/4";
                        break;
                    case .5:
                        p.speedDisplay = "1/2";
                        break;
                    default:
                        p.speedDisplay = String(Math.abs(e))
                    }
                    p.speedDirection = e < 0 ? -1 : 1,
                    m.setSpeed(p.speed, t)
                }
                ,
                p.updateSpeed = function(e) {
                    var t;
                    switch (o().isDefined(e) && (p.speedDirection = e),
                    p.speedDisplay) {
                    case "1/4":
                        t = .25;
                        break;
                    case "1/2":
                        t = .5;
                        break;
                    default:
                        t = Number(p.speedDisplay)
                    }
                    p.setSpeed(p.speedDirection * t, {
                        publish: !0
                    })
                }
                ,
                p.speedSliderOptions = {
                    vertical: !0,
                    stepsArray: p.speedSteps,
                    showTicksValues: !0,
                    translate: function(e) {
                        return e + "x"
                    },
                    onChange: function(e, t) {
                        a.cancel(p.speedChangeTimeout),
                        p.speedChangeTimeout = a((function() {
                            p.updateSpeed()
                        }
                        ), 200)
                    }
                },
                p.preserveTimelineState = function() {
                    p.background = {},
                    p.background.speed = p.speed,
                    p.background.paused = p.paused,
                    p.background.time = m.getTime(),
                    p.background.live = !p.paused && r.isLive(p.background.time)
                }
                ,
                p.restoreTimelineState = function() {
                    p.selectionMode = !1,
                    p.setSpeed(p.background.speed, {
                        publish: !1
                    }),
                    p.setPaused(p.background.paused, {
                        allowPlay: !1
                    }),
                    m.setTime(p.background.live ? Date.now() : p.background.time, {
                        publish: !0
                    })
                }
                ,
                p.setPaused = function(e, t) {
                    m.setPaused(e, {
                        publish: t.allowPlay
                    }),
                    p.paused = e
                }
                ,
                p.msgs = L.messages.stage,
                p.scales = [p.msgs.scales["1day"](), p.msgs.scales["12hr"](), p.msgs.scales["6hr"](), p.msgs.scales["3hr"](), p.msgs.scales["1hr"](), p.msgs.scales["30min"](), p.msgs.scales["15min"](), p.msgs.scales["5min"](), p.msgs.scales["1min"]()],
                p.scaleIndex = p.scales.length - 1,
                l.setTimelineStateFn((function() {
                    const e = m.getCurrentState();
                    return {
                        minSegment: m.getTimeLengthFromPixels(1 / 3),
                        speed: e.speed,
                        start: e.fineTime.start,
                        stop: e.fineTime.stop,
                        time: e.time
                    }
                }
                )),
                m.subscribeEventSource(l.events$),
                i.$smartOn(m, "scale-changed", (function(e, t) {
                    p.scaleIndex = t
                }
                )),
                i.$smartOn(m, "time-changed", (function(e, t) {
                    var n = t.time;
                    !0 === p.paused && (p.paused = !1,
                    m.setPaused(p.paused, {
                        publish: !1
                    })),
                    1 !== p.speed && (p.speed > 1 || !0 !== p.selectionMode) && Date.now() - n < 1e3 * w.secondsPlaybackFromLive && p.setSpeed(1, {
                        publish: !0
                    })
                }
                )),
                h = u.fullscreenState$.subscribe((function(t) {
                    t && !1 === t.linked && (!0 === t.isFullscreen ? (p.preserveTimelineState(),
                    p.selectionMode = !1,
                    m.setTime(t.state.time, {
                        publish: !1
                    }),
                    p.setSpeed(1, {
                        publish: !0
                    }),
                    p.setPaused(!1, {
                        allowPlay: !1
                    })) : (t.state = {},
                    t.state.time = p.background.live ? Date.now() : p.background.time,
                    t.state.speed = p.background.speed,
                    t.state.paused = p.background.paused,
                    p.restoreTimelineState())),
                    a((function() {
                        e.$broadcast("fullscreen-changed", t)
                    }
                    ), 100)
                }
                )),
                i.$on("$destroy", (function() {
                    h.unsubscribe(),
                    c.releaseContext("master"),
                    m.unsubscribeEventSource()
                }
                ))
            }
            angular.module("ipconfigure.orchid.singularity").controller("ExportDialogController", Li),
            Ni.$inject = ["$rootScope", "$mdDialog", "$scope", "$timeout", "UtilityService", "AuthenticationService", "TimelineServiceFactory", "TimelineEventService", "MatDialog", "NGStageService"],
            o().module("ipconfigure.orchid.singularity").controller("StageControlController", Ni).directive("stageControl", [function() {
                return {
                    restrict: "E",
                    template: n(81708),
                    controller: "StageControlController as stageControl",
                    bindToController: !0,
                    scope: {
                        selectionMode: "=",
                        hideControls: "="
                    },
                    link: function(e, t, n) {}
                }
            }
            ]),
            function() {
                function e(e, t, n, i, a) {
                    var r = this;
                    e.webrtcTimeoutBehavior = "prompt",
                    this.aPlayerIsFullscreen = a.isInFullscreenMode,
                    this.authenticationData = n.getAuthenticationData(),
                    this.hideTimeline = e.hideTimeline || !1,
                    "live viewer" === this.authenticationData.getRole() && (this.hideTimeline = !0),
                    t.startListening(),
                    this.fullscreenSubscription = a.fullscreenState$.subscribe((function() {
                        r.aPlayerIsFullscreen = a.isInFullscreenMode
                    }
                    )),
                    this.$onDestroy = function() {
                        t.stopListening(),
                        i.cleanup(),
                        this.fullscreenSubscription.unsubscribe()
                    }
                }
                e.$inject = ["$rootScope", "GamepadService", "AuthenticationService", "StageService", "NGStageService"],
                angular.module("ipconfigure.orchid.singularity").controller("StageController", e).directive("stage", [function() {
                    return {
                        restrict: "E",
                        template: n(55608),
                        bindToController: {
                            orchids: "="
                        },
                        scope: {},
                        controller: "StageController as stage",
                        link: function(e, t, n, i) {
                            e.$watch((function() {
                                return i.selectionMode
                            }
                            ), (function() {
                                !0 === i.selectionMode ? t[0].classList.add("selection-mode") : !1 === i.selectionMode && t[0].classList.remove("selection-mode")
                            }
                            ))
                        }
                    }
                }
                ])
            }(),
            function() {
                function e(e) {
                    this.router = e
                }
                e.$inject = ["Router"],
                angular.module("ipconfigure.orchid.singularity").controller("SignedOutController", e).directive("signedOut", [function() {
                    return {
                        restrict: "E",
                        template: n(20466),
                        transclude: !0,
                        controller: "SignedOutController as signedOut"
                    }
                }
                ])
            }();
            n(24603),
            n(28450);
            const Fi = "name"
              , Ui = "value"
              , $i = "active";
            function ji(e) {
                null != e && (e.checkOthers = !1,
                e.$setTouched(),
                e.$validate(),
                e.checkOthers = !0)
            }
            function Vi(e, t, n) {
                return t.checkOthers = !0,
                function() {
                    return t.checkOthers && function(e, t, n) {
                        if (!e.locked) {
                            if (e.custom && n === Ui && ji(t.$$parentForm[e.nameKey]),
                            n === $i && (ji(t.$$parentForm[e.valueKey]),
                            e.custom)) {
                                const n = t.$$parentForm[e.nameKey];
                                n && n.singEnsureCustomNameUniquenessChangeListener && n.singEnsureCustomNameUniquenessChangeListener(),
                                ji(t.$$parentForm[e.nameKey])
                            }
                            n === Fi && ji(t.$$parentForm[e.valueKey])
                        }
                    }(e, t, n),
                    !0
                }
            }
            function Gi(e, t) {
                return !(!t.$$parentForm[e.activeKey] || !t.$$parentForm[e.activeKey].$$rawModelValue)
            }
            function Bi(e) {
                let {property: t, ngModel: n, checkOthers: i, validationFn: a} = e;
                return function(e) {
                    if (!Gi(t, n))
                        return !0;
                    const r = a(e);
                    return r || i(),
                    r
                }
            }
            angular.module("ipconfigure.orchid.singularity").directive("validatePropertyActiveState", (function() {
                return {
                    restrict: "A",
                    scope: !1,
                    require: {
                        ngModel: "ngModel",
                        propertyEditor: "^^"
                    },
                    link(e, t, n, i) {
                        let {ngModel: a, propertyEditor: r} = i;
                        const s = e.$eval(n.validatePropertyActiveState);
                        if (!s)
                            throw new Error("validate-property-value requires that you set this attribute directive to the property being edited");
                        if (!s.locked && (a.$validators.checkOthers = Vi(s, a, $i),
                        s.custom)) {
                            let e;
                            a.$viewChangeListeners.push((function() {
                                const t = a.$$rawModelValue;
                                "boolean" == typeof t && e !== t && r.triggerValidationOfCustomPropNames(a.$$parentForm, s.id),
                                e = a.$$rawModelValue
                            }
                            ))
                        }
                    }
                }
            }
            )).directive("validatePropertyName", (function() {
                return {
                    restrict: "A",
                    scope: !1,
                    require: {
                        ngModel: "ngModel",
                        propertyEditor: "^^"
                    },
                    link(e, t, n, i) {
                        let {ngModel: a, propertyEditor: r} = i;
                        const s = e.$eval(n.validatePropertyName);
                        if (!s)
                            throw new Error("validate-property-name requires that you set this attribute directive to the property being edited");
                        if (s.locked || !s.custom)
                            return;
                        const o = Vi(s, a, Fi);
                        let c;
                        a.singEnsureCustomNameUniquenessChangeListener = function() {
                            const e = a.$modelValue;
                            if (Gi(s, a)) {
                                if (e) {
                                    const t = r.customPropNames.get(e);
                                    t ? t === s.id && r.customPropNames.set(e, s.id) : r.customPropNames.set(e, s.id)
                                }
                                if (c && c !== e) {
                                    const e = r.customPropNames.get(c);
                                    e && e === s.id && r.customPropNames.delete(c)
                                }
                            } else {
                                const t = r.customPropNames.get(e);
                                if (t && t === s.id && r.customPropNames.delete(e),
                                c) {
                                    const e = r.customPropNames.get(c);
                                    e && e === s.id && r.customPropNames.delete(c)
                                }
                            }
                            c = e
                        }
                        ,
                        a.$viewChangeListeners.push(a.singEnsureCustomNameUniquenessChangeListener),
                        a.$validators.uniquePropertyName = Bi({
                            property: s,
                            ngModel: a,
                            checkOthers: o,
                            validationFn(e) {
                                if (a.$isEmpty(e))
                                    return !0;
                                const t = !r.existingPropNames.has(e)
                                  , n = r.customPropNames.get(e);
                                return n ? n === s.id && t : t
                            }
                        }),
                        a.$validators.propertyNameNotEmpty = Bi({
                            property: s,
                            ngModel: a,
                            checkOthers: o,
                            validationFn: function(e) {
                                return !a.$isEmpty(e)
                            }
                        });
                        a.$validators.propertyPrefixValid = Bi({
                            property: s,
                            ngModel: a,
                            checkOthers: o,
                            validationFn: function(e) {
                                return !angular.isDefined(e) || !e.toLowerCase().startsWith("orchid.sprout")
                            }
                        }),
                        a.$validators.checkOthers = o,
                        a.customPropNameValidateByPropEditor = function() {
                            a.singEnsureCustomNameUniquenessChangeListener(),
                            ji(a)
                        }
                    }
                }
            }
            )).directive("validatePropertyValue", (function() {
                return {
                    restrict: "A",
                    scope: !1,
                    require: {
                        ngModel: "ngModel"
                    },
                    link(e, t, n, i) {
                        let {ngModel: a} = i;
                        const r = e.$eval(n.validatePropertyValue);
                        if (!r)
                            throw new Error("validate-property-value requires that you set this attribute directive to the property being edited");
                        if (r.locked)
                            return;
                        const s = Vi(r, a, Ui);
                        a.$validators.propertyValueNotEmpty = Bi({
                            property: r,
                            ngModel: a,
                            checkOthers: s,
                            validationFn: function(e) {
                                return !!angular.isDefined(e) && 0 !== e.length
                            }
                        }),
                        a.$validators.checkOthers = s
                    }
                }
            }
            )).directive("validatePropertyInputCharacters", (function() {
                return {
                    restrict: "A",
                    scope: !1,
                    require: "ngModel",
                    link(e, t, n, i) {
                        const a = Ge(e, n.validatePropertyInputCharacters);
                        if (!a.initialChecksPassed || a.evaluationFailed || re(a.value) || re(a.value.property))
                            return;
                        const r = a.value.property
                          , s = a.value.regex instanceof RegExp ? a.value.regex : new RegExp(a.value.regex)
                          , o = !re(a.value.invalid) && a.value.invalid;
                        i.$validators.badCharacters = function(e) {
                            if (i.$isEmpty(e) || !Gi(r, i))
                                return !0;
                            const t = s.test(e);
                            return o ? !t : t
                        }
                    }
                }
            }
            ));
            let zi = function() {
                function e() {
                    (0,
                    S.Z)(this, e)
                }
                return (0,
                b.Z)(e, [{
                    key: "$onInit",
                    value: function() {
                        this.loadingMsgClass || (this.loadingMsgClass = "loading-progress"),
                        this.cardClass || (this.cardClass = "form-card"),
                        this.loadingContainerClass || (this.loadingContainerClass = "loading-container")
                    }
                }, {
                    key: "errorState",
                    get: function() {
                        return null !== this.error && void 0 !== this.error
                    }
                }]),
                e
            }();
            angular.module("ipconfigure.orchid.singularity").controller("PageLoadingController", zi).directive("pageLoading", (function() {
                return {
                    scope: {
                        cardClass: "@",
                        loadingMsgClass: "@",
                        loadingContainerClass: "@",
                        error: "<",
                        progress: "<"
                    },
                    bindToController: !0,
                    controller: "PageLoadingController",
                    controllerAs: "$ctrl",
                    transclude: !0,
                    restrict: "E",
                    template: n(49610)
                }
            }
            ));
            const Hi = "confirm"
              , Wi = "loading"
              , qi = "loaded";
            let Yi = function() {
                function e(t, n, i) {
                    (0,
                    S.Z)(this, e),
                    this.$scope = t,
                    this.$element = n,
                    this.$timeout = i,
                    this.showing = Wi
                }
                return (0,
                b.Z)(e, [{
                    key: "$postLink",
                    value: function() {
                        this.propertyEditor.performInit(this)
                    }
                }, {
                    key: "$onDestroy",
                    value: function() {
                        const e = this.$element[0].querySelectorAll("form");
                        this.$timeout((function() {
                            angular.element.cleanData(e)
                        }
                        ))
                    }
                }, {
                    key: "confirmationNeeded",
                    value: function() {
                        this.showing = Hi,
                        this.safeScopeApply()
                    }
                }, {
                    key: "loading",
                    value: function() {
                        this.showing = Wi,
                        this.safeScopeApply()
                    }
                }, {
                    key: "fetchedProps",
                    value: function() {
                        this.showing = qi,
                        this.safeScopeApply()
                    }
                }, {
                    key: "safeScopeApply",
                    value: function() {
                        if (!this.$scope.$root || "$digest" !== this.$scope.$root.$$phase)
                            try {
                                this.$scope.$apply()
                            } catch (e) {}
                    }
                }]),
                e
            }();
            Yi.$inject = ["$scope", "$element", "$timeout"],
            angular.module("ipconfigure.orchid.singularity").controller("PropertyEditorInitController", Yi).directive("propertyEditorInit", (function() {
                return {
                    priority: 1001,
                    scope: !1,
                    replace: !0,
                    transclude: {
                        loading: "pageLoading",
                        confirm: "propertyEditorConfirm",
                        form: "form"
                    },
                    require: {
                        propertyEditor: "^^"
                    },
                    bindToController: !0,
                    controller: "PropertyEditorInitController",
                    controllerAs: "$ctrl",
                    template: () => '<md-content\n        ng-switch\n        on="$ctrl.showing"\n        >\n        <ng-transclude ng-switch-when="loading" ng-transclude-slot="loading"></ng-transclude>\n        <ng-transclude ng-switch-when="confirm" ng-transclude-slot="confirm"></ng-transclude>\n        <ng-transclude ng-switch-when="loaded" ng-transclude-slot="form"></ng-transclude>\n </md-content>'
                }
            }
            ));
            let Xi = function() {
                function e() {
                    let t = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : 1e4;
                    (0,
                    S.Z)(this, e),
                    this._pollingState = {
                        firstPoll: !0,
                        shouldPoll: !0,
                        exitPollingDelayEarly: null,
                        exitRequestEarly: null
                    },
                    this._pollingDelay = t
                }
                return (0,
                b.Z)(e, [{
                    key: "configuredPollingDelay",
                    get: function() {
                        return this._pollingDelay
                    }
                }, {
                    key: "shouldPoll",
                    get: function() {
                        return this._pollingState.shouldPoll
                    }
                }, {
                    key: "shouldStopPollingBasedOnRequestResult",
                    value: function(e) {}
                }, {
                    key: "makeRequest",
                    value: function() {}
                }, {
                    key: "afterStopPolling",
                    value: function() {}
                }, {
                    key: "stopPolling",
                    value: function() {
                        let e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];
                        this._pollingState.shouldPoll = !1,
                        re(this._pollingState.exitPollingDelayEarly) || (clearTimeout(this._pollingState.exitPollingDelayEarly.timeoutId),
                        this._pollingState.exitPollingDelayEarly.resolve(),
                        this._pollingState.exitPollingDelayEarly = null),
                        re(this._pollingState.exitRequestEarly) || (this._pollingState.exitRequestEarly.resolve(),
                        this._pollingState.exitRequestEarly = null),
                        e && this.afterStopPolling()
                    }
                }, {
                    key: "pollingDelay",
                    value: async function() {
                        if (this._pollingState.firstPoll)
                            this._pollingState.firstPoll = !1;
                        else {
                            const e = oe();
                            this._pollingState.exitPollingDelayEarly = {
                                resolve: e.resolve,
                                timeoutId: setTimeout(e.resolve, this._pollingDelay)
                            },
                            await e.promise.catch(de),
                            this._pollingState.exitPollingDelayEarly = null
                        }
                    }
                }, {
                    key: "startPolling",
                    value: async function() {
                        for (; ; ) {
                            if (!this._pollingState.shouldPoll)
                                return void this.stopPolling();
                            if (await this.pollingDelay(),
                            !this._pollingState.shouldPoll)
                                return void this.stopPolling();
                            let e;
                            this._pollingState.exitRequestEarly = oe();
                            try {
                                e = await Promise.race([this.makeRequest().catch(de), this._pollingState.exitRequestEarly.promise.catch(de)])
                            } catch (e) {}
                            if (this._pollingState.exitRequestEarly = null,
                            !this._pollingState.shouldPoll)
                                return void this.stopPolling();
                            if (this.shouldStopPollingBasedOnRequestResult(e))
                                return void this.stopPolling(!0)
                        }
                    }
                }]),
                e
            }()
              , Ki = function(e) {
                (0,
                _.Z)(n, e);
                var t = (0,
                x.Z)(n);
                function n(e) {
                    var i;
                    return (0,
                    S.Z)(this, n),
                    (i = t.call(this)).DataService = e,
                    i
                }
                return (0,
                b.Z)(n, [{
                    key: "$onInit",
                    value: function() {
                        var e = this;
                        this.isOrchid || this.startPolling().catch((function(t) {
                            e.stopPolling()
                        }
                        ))
                    }
                }, {
                    key: "$onDestroy",
                    value: function() {
                        this.stopPolling()
                    }
                }, {
                    key: "isOrchid",
                    get: function() {
                        return w.isOrchid
                    }
                }, {
                    key: "orchid",
                    get: function() {
                        return this.propertyEditor.orchid
                    }
                }, {
                    key: "showingActionSpinner",
                    get: function() {
                        return this.propertyEditor.showingActionSpinner
                    }
                }, {
                    key: "actionFailed",
                    get: function() {
                        return this.propertyEditor.actionFailed
                    }
                }, {
                    key: "actionError",
                    get: function() {
                        return this.propertyEditor.actionError
                    }
                }, {
                    key: "clearActionErrors",
                    value: function() {
                        this.propertyEditor.clearActionErrors()
                    }
                }, {
                    key: "confirmProperties",
                    value: function() {
                        this.propertyEditor.saveOrConfirmProperties()
                    }
                }, {
                    key: "afterStopPolling",
                    value: function() {
                        this.propertyEditor.fetchProperties()
                    }
                }, {
                    key: "shouldStopPollingBasedOnRequestResult",
                    value: function(e) {
                        return !re(e) && !re(e.confirm) && !re(e.alive) && !re(e.alive.data) && !e.confirm.wasError && e.alive.data.isAvailable && !e.alive.data.defunct && e.confirm.data.propertiesConfirmed
                    }
                }, {
                    key: "makeRequest",
                    value: async function() {
                        const [e,t] = await Promise.all([this.DataService.doPropertiesNeedToBeConfirmed(this.orchid).catch(angular.noop), this.DataService.fetchUpdatedOrchidInfo(this.orchid.id).catch(angular.noop)]);
                        return {
                            confirm: e,
                            alive: t
                        }
                    }
                }]),
                n
            }(Xi);
            function Zi(e) {
                return ("string" == typeof e || e instanceof String) && 0 !== e.length
            }
            Ki.$inject = ["DataService"],
            angular.module("ipconfigure.orchid.singularity").controller("PropertyEditorConfirmController", Ki).component("propertyEditorConfirm", {
                controller: "PropertyEditorConfirmController",
                controllerAs: "$ctrl",
                require: {
                    propertyEditor: "^^"
                },
                template: n(50127)
            });
            let Ji = function() {
                function e(t) {
                    let {id: n, custom: i, info: a={
                        locked: !1
                    }, prop: r} = t;
                    (0,
                    S.Z)(this, e),
                    this._custom = i,
                    this._id = n,
                    this._nameKey = `${n}-name`,
                    this._valueKey = `${n}-value`,
                    this._activeKey = `${n}-active`,
                    this._name = "",
                    this._value = "",
                    this._description = "",
                    this._active = !1,
                    this._infoOnly = !1,
                    this._locked = !1,
                    this._touched = !1,
                    this._originalValues = {
                        name: "",
                        value: "",
                        active: !1
                    },
                    i || (this._name = a.name,
                    this._description = a.description || "",
                    r ? (r.name && (this._name = r.name),
                    r.value && (this._value = r.value)) : this._infoOnly = !0,
                    this._locked = a.locked,
                    a.locked ? this._active = !1 : r && void 0 !== r.value && (this._active = !0),
                    this._originalValues.name = this._name,
                    this._originalValues.value = this._value,
                    this._originalValues.active = this._active)
                }
                return (0,
                b.Z)(e, [{
                    key: "kind",
                    get: function() {
                        return this._custom ? "custom" : this._locked ? "locked" : "normal"
                    }
                }, {
                    key: "modified",
                    get: function() {
                        return !!this._touched && (this._originalValues.active !== this._active || this._originalValues.name !== this._name || this._originalValues.value !== this._value)
                    }
                }, {
                    key: "locked",
                    get: function() {
                        return this._locked
                    }
                }, {
                    key: "infoOnly",
                    get: function() {
                        return this._infoOnly
                    }
                }, {
                    key: "active",
                    get: function() {
                        return this._active
                    },
                    set: function(e) {
                        this._locked || (this._touched || (this._touched = !0),
                        this._active = e)
                    }
                }, {
                    key: "custom",
                    get: function() {
                        return this._custom
                    }
                }, {
                    key: "description",
                    get: function() {
                        return this._description
                    }
                }, {
                    key: "name",
                    get: function() {
                        return this._name
                    },
                    set: function(e) {
                        this._custom && (this._touched || (this._touched = !0),
                        this._name = e)
                    }
                }, {
                    key: "search",
                    get: function() {
                        return this._name
                    }
                }, {
                    key: "value",
                    get: function() {
                        return this._value
                    },
                    set: function(e) {
                        this._locked || (this._touched || (this._touched = !0),
                        this._value = e)
                    }
                }, {
                    key: "activeKey",
                    get: function() {
                        return this._activeKey
                    }
                }, {
                    key: "nameKey",
                    get: function() {
                        return this._nameKey
                    }
                }, {
                    key: "valueKey",
                    get: function() {
                        return this._valueKey
                    }
                }, {
                    key: "id",
                    get: function() {
                        return this._id
                    }
                }, {
                    key: "sendToBackend",
                    get: function() {
                        if (this._locked && !this._infoOnly)
                            return !0;
                        if (!this._active)
                            return !1;
                        const e = Zi(this._value);
                        return this._custom ? Zi(this._name) && e : e
                    }
                }, {
                    key: "showInput",
                    get: function() {
                        return !this._locked || 0 !== this._value.length
                    }
                }, {
                    key: "toJSON",
                    value: function() {
                        return {
                            name: this._name.trim(),
                            value: this._value.trim()
                        }
                    }
                }]),
                e
            }()
              , Qi = function() {
                function e(t, n) {
                    (0,
                    S.Z)(this, e),
                    this.$mdDialog = t,
                    this.theme = n.getTheme()
                }
                return (0,
                b.Z)(e, [{
                    key: "clickedYes",
                    value: function() {
                        this.$mdDialog.hide(!0)
                    }
                }, {
                    key: "clickedNoButton",
                    value: function() {
                        this.$mdDialog.hide(!1)
                    }
                }]),
                e
            }();
            function ea(e, t) {
                return e.sort(t),
                e
            }
            Qi.$inject = ["$mdDialog", "UserSettingsService"],
            angular.module("ipconfigure.orchid.singularity").controller("YesNoDialogController", Qi);
            let ta = function(e) {
                (0,
                _.Z)(i, e);
                var t = (0,
                x.Z)(i);
                function i(e, n, a, r) {
                    var s;
                    return (0,
                    S.Z)(this, i),
                    (s = t.call(this, 1e3)).$mdDialog = e,
                    s.theme = r.getTheme(),
                    s.DataService = n,
                    s.config = a,
                    s._orchidWentDown = !1,
                    s
                }
                return (0,
                b.Z)(i, [{
                    key: "$onInit",
                    value: function() {
                        var e = this;
                        this.startPolling().catch((function(t) {
                            e.stopPolling()
                        }
                        ))
                    }
                }, {
                    key: "$onDestroy",
                    value: function() {
                        this.stopPolling()
                    }
                }, {
                    key: "receivedResponse",
                    value: function(e) {
                        return !re(e) && !re(e.data)
                    }
                }, {
                    key: "startPolling",
                    value: async function() {
                        const e = await this.DataService.fetchUpdatedOrchidInfo(this.config.orchid.id).catch(angular.noop);
                        if (this.receivedResponse(e) && !e.data.defunct)
                            return e.data.isAvailable || (this._orchidWentDown = !0),
                            (0,
                            T.Z)((0,
                            E.Z)(i.prototype), "startPolling", this).call(this);
                        this.$mdDialog.hide()
                    }
                }, {
                    key: "makeRequest",
                    value: function() {
                        return this.DataService.fetchUpdatedOrchidInfo(this.config.orchid.id)
                    }
                }, {
                    key: "shouldStopPollingBasedOnRequestResult",
                    value: function(e) {
                        if (this.receivedResponse(e))
                            if (this._orchidWentDown || e.data.isAvailable) {
                                if (e.data.isAvailable)
                                    return !0
                            } else
                                this._orchidWentDown = !0;
                        return !1
                    }
                }, {
                    key: "afterStopPolling",
                    value: function() {
                        this.$mdDialog.hide()
                    }
                }], [{
                    key: "show",
                    value: function(e, t) {
                        return e.show({
                            template: n(52386),
                            controller: "FusionSaveDialogController",
                            bindToController: !0,
                            controllerAs: "$ctrl",
                            clickOutsideToClose: !1,
                            escapeToClose: !1,
                            fullScreen: !0,
                            autoWrap: !1,
                            locals: {
                                config: t
                            }
                        })
                    }
                }]),
                i
            }(Xi);
            ta.$inject = ["$mdDialog", "DataService", "config", "UserSettingsService"],
            angular.module("ipconfigure.orchid.singularity").controller("FusionSaveDialogController", ta);
            var na, ia = n(75125);
            !function(e) {
                e.CHIPS = "chips",
                e.NO_CHIPS = "no-chips"
            }(na || (na = {}));
            let aa = class {
                constructor() {
                    this.msgs = Object.assign(Object.assign({}, L.messages.bag), L.messages.cameras.cameraPicker),
                    this.data = [],
                    this.searchPlaceholder = this.msgs.search(),
                    this.searchLabel = this.msgs.search(),
                    this.disabled = !1,
                    this.SearchModes = na,
                    this.searchMode = na.CHIPS,
                    this.searchTerms = [],
                    this.searchTermsChange = new i.EventEmitter,
                    this.filteredData = new i.EventEmitter,
                    this.separatorKeysCodes = [ia.K5, ia.OC],
                    this.filteredList = [],
                    this.searchInput = new p.NI
                }
                ngOnChanges(e) {
                    e.searchTerms && !e.searchTerms.firstChange && (this.searchTerms.length > 0 || this.searchMode === na.NO_CHIPS && this.searchInput.value) && (this.searchTermsChange.emit([]),
                    this.searchInput.setValue("")),
                    this.disabled ? this.searchInput.disable() : this.searchInput.enable()
                }
                updateSearch(e) {
                    this.searchMode === na.NO_CHIPS && (this.searchTerms = [e],
                    this.applyFilter())
                }
                onSearchTermAdded(e) {
                    var t, n;
                    if ("" === (null === (t = e.chipInput) || void 0 === t ? void 0 : t.inputElement.value) || this.searchMode === na.NO_CHIPS)
                        return;
                    const i = e.value.toLocaleLowerCase();
                    if ((i || "").trim()) {
                        const e = [...this.searchTerms];
                        e.push(i),
                        this.searchTerms = e
                    }
                    this.applyFilter();
                    const a = null === (n = e.chipInput) || void 0 === n ? void 0 : n.inputElement;
                    a && (a.value = "")
                }
                onSearchTermRemoved(e) {
                    const t = this.searchTerms.indexOf(e);
                    if (t > -1) {
                        const e = [...this.searchTerms];
                        e.splice(t, 1),
                        this.searchTerms = e
                    }
                    this.applyFilter()
                }
                _applySearchFilter(e) {
                    if (0 === this.searchTerms.length || 1 === this.searchTerms.length && this.searchTerms[0] === this.msgs.selectedOnly().toLocaleLowerCase())
                        return e;
                    {
                        const t = e.filter((e => {
                            var t, n;
                            const i = null !== (n = null === (t = this.selectorFunction) || void 0 === t ? void 0 : t.call(this, e)) && void 0 !== n ? n : e;
                            return (Array.isArray(i) ? [...i] : [i]).some((e => !!o().isDefined(e) && this.searchTerms.some((t => e.toLocaleLowerCase().includes(t.toLocaleLowerCase())))))
                        }
                        ));
                        return t
                    }
                }
                applyFilter() {
                    this.filteredList = this._applySearchFilter(this.data),
                    this.filteredData.emit(this.filteredList)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], aa.prototype, "data", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], aa.prototype, "searchPlaceholder", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], aa.prototype, "searchLabel", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], aa.prototype, "disabled", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], aa.prototype, "searchMode", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], aa.prototype, "searchTerms", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], aa.prototype, "searchTermsChange", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Function)], aa.prototype, "selectorFunction", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], aa.prototype, "filteredData", void 0),
            aa = (0,
            c.gn)([(0,
            i.Component)({
                selector: "search-bar",
                template: n(93842)
            })], aa);
            var ra = n(94975)
              , sa = n(42006)
              , oa = n(83505);
            const ca = {
                SAVE: Symbol("save"),
                CONFIRM: Symbol("confirm"),
                NONE: Symbol("none")
            }
              , la = "fetching"
              , da = "fetched"
              , ua = "error"
              , ma = "fetching-properties"
              , ha = "checking-confirmation-status"
              , pa = "need-confirmation"
              , ga = "fetch-properties"
              , fa = "orchid.sprout";
            let va = function() {
                function e(t, n, i, a, r, s, o, c, l, d) {
                    (0,
                    S.Z)(this, e),
                    this.DataService = s,
                    this.$mdDialog = n,
                    this.$timeout = i,
                    this.$document = a,
                    this.UserSettingsService = c,
                    this.$scope = t,
                    this.uuid = r,
                    this.isOrchid = this.$scope.$root.isOrchid,
                    this._ControlledShutdownService = o,
                    this._renewableService = d,
                    this._destroy$ = new St.x,
                    this._FusionDataService = l,
                    this.msgs = {},
                    this.serverTags = [],
                    this.properties = [],
                    this.propertyNames = [],
                    this.searchTerms = [],
                    this.searchMode = na.NO_CHIPS,
                    this.propertiesDisplay = [],
                    this.existingPropNames = new Set,
                    this.customPropNames = new Map,
                    this.propertiesFetchState = {
                        fetched: !1,
                        error: null,
                        status: L.messages.propertyEditor.loadingProperties(),
                        state: la
                    },
                    this.actionState = {
                        action: ca.NONE,
                        performing: !1,
                        error: null
                    },
                    this.propertiesNeedConfirmation = !1,
                    this.propertyMsgs = {
                        lockedTooltip: L.messages.propertyEditor.thisPropertyIsLockedAndCannotBeChangedViaThisInterface(),
                        checkedTooltip: L.messages.propertyEditor.unCheckingWillDisableTheProperty(),
                        uncheckedTooltip: L.messages.propertyEditor.checkingWillEnableTheProperty(),
                        customPropNotUniqueName: L.messages.propertyEditor.aPropertyWithThisNameAlreadyExists(),
                        activePropHasNoName: L.messages.propertyEditor.thisPropertyIsMarkedAsActiveButHasNoName(),
                        activePropHasNoValue: L.messages.propertyEditor.thisPropertyIsMarkedAsActiveButHasNoValue(),
                        propertyNamePlaceholder: L.messages.propertyEditor.propertyName(),
                        propertyValuePlaceholder: L.messages.propertyEditor.propertyValue(),
                        propertyLabel: L.messages.propertyEditor.propertyName(),
                        propertyPlaceholder: L.messages.propertyEditor.searchForProperty(),
                        removeCustomProperty: L.messages.propertyEditor.removeCustomProperty(),
                        advancedSettings: L.messages.navigation.advancedSettings()
                    },
                    this.skipDeactivationGuard = !1,
                    this._initState = {
                        state: ha,
                        progress: L.messages.propertyEditor.checkingIfPropertiesNeedConfirming()
                    },
                    this.logger = O("PropertyEditorComponent"),
                    this.propertyEditorInit = null,
                    this.route.snapshot.data.canDeactivate = async function() {
                        if (this.isOrchid && !1 === this.skipDeactivationGuard) {
                            if (this.haveUnsavedChanged()) {
                                var e = !1;
                                return await this.$mdDialog.show(this.$mdDialog.confirm().theme(this.UserSettingsService.getTheme()).title(L.messages.propertyEditor.dialogs.unsavedProps.title()).textContent(L.messages.propertyEditor.dialogs.unsavedProps.body()).ok(L.messages.propertyEditor.dialogs.unsavedProps.yes()).cancel(L.messages.propertyEditor.dialogs.unsavedProps.no())).then((function(t) {
                                    e = t
                                }
                                )).catch((function() {
                                    e = !1
                                }
                                )),
                                e
                            }
                            return !0
                        }
                        return !0
                    }
                    .bind(this)
                }
                return (0,
                b.Z)(e, [{
                    key: "propertySaveOrConfirmDialogConfig",
                    get: function() {
                        return this.propertiesNeedConfirmation ? {
                            body: L.messages.propertyEditor.dialogs.confirm.body(),
                            yesButtonText: L.messages.propertyEditor.dialogs.confirm.yes(),
                            noButtonText: L.messages.propertyEditor.dialogs.confirm.no()
                        } : {
                            body: L.messages.propertyEditor.dialogs.save.body(),
                            yesButtonText: L.messages.propertyEditor.dialogs.save.yes(),
                            noButtonText: L.messages.propertyEditor.dialogs.save.no()
                        }
                    }
                }, {
                    key: "isFetchingPropsOrFetchFailed",
                    get: function() {
                        return this.fetchingProperties || this.propertiesFetchedError
                    }
                }, {
                    key: "fetchingProperties",
                    get: function() {
                        return !this.propertiesFetchState.fetched
                    }
                }, {
                    key: "fetchingPropertiesState",
                    get: function() {
                        if (this.propertiesFetchState.state === da)
                            return this.propertiesFetchState.state
                    }
                }, {
                    key: "propertiesFetchedError",
                    get: function() {
                        return this.propertiesFetchState.fetched && null !== this.propertiesFetchState.error
                    }
                }, {
                    key: "propertiesFetchedSuccess",
                    get: function() {
                        return this.propertiesFetchState.fetched && null === this.propertiesFetchState.error
                    }
                }, {
                    key: "propertiesFetchProgress",
                    get: function() {
                        return this.propertiesFetchState.status
                    }
                }, {
                    key: "showingActionSpinner",
                    get: function() {
                        return this.actionState.performing
                    }
                }, {
                    key: "showConfirmButtonText",
                    get: function() {
                        return this.propertiesNeedConfirmation && !this.showingActionSpinner
                    }
                }, {
                    key: "showSaveButtonText",
                    get: function() {
                        return !this.propertiesNeedConfirmation && !this.showingActionSpinner
                    }
                }, {
                    key: "buttonsDisabled",
                    get: function() {
                        return this.propertiesNeedConfirmation || this.showingActionSpinner
                    }
                }, {
                    key: "propertyFilterDisabled",
                    get: function() {
                        return this.buttonsDisabled
                    }
                }, {
                    key: "actionFailed",
                    get: function() {
                        return !re(this.actionError)
                    }
                }, {
                    key: "actionError",
                    get: function() {
                        return re(this.propertiesFetchState.error) ? this.actionState.error : this.propertiesFetchState.error
                    }
                }, {
                    key: "noPropertiesToDisplayMsg",
                    get: function() {
                        return 0 === this.properties.length ? L.messages.propertyEditor.noPropertiesExist() : L.messages.propertyEditor.noPropertiesMatchTheSearch()
                    }
                }, {
                    key: "initProgress",
                    get: function() {
                        return this._initState.progress
                    }
                }, {
                    key: "$onInit",
                    value: function() {
                        var e = this;
                        if (this.msgs = L.messages.propertyEditor,
                        this.serverTags = this.orchid.discoverableOrchid.tags ? this.orchid.discoverableOrchid.tags : [],
                        !w.isOrchid) {
                            const t = ["ORCHID_TAG_MODIFIED", "ORCHID_BULK_TAG_END"];
                            this._renewableService.messages$.pipe((0,
                            ra.h)((function(e) {
                                return t.includes(e.eventType)
                            }
                            )), (0,
                            sa.b)((function() {
                                e._FusionDataService.purgeOrchid(e.orchid).then((function(t) {
                                    var n, i;
                                    e.serverTags = null !== (n = null === (i = t.data) || void 0 === i ? void 0 : i.discoverableOrchid.tags) && void 0 !== n ? n : []
                                }
                                ))
                            }
                            )), (0,
                            oa.R)(this._destroy$)).subscribe()
                        }
                    }
                }, {
                    key: "$onDestroy",
                    value: function() {
                        delete this.route.snapshot.data.canDeactivate,
                        this._destroy$.next(),
                        this._destroy$.complete()
                    }
                }, {
                    key: "saveButtonDisabled",
                    value: function(e) {
                        return this.buttonsDisabled || !e.$valid
                    }
                }, {
                    key: "haveUnsavedChanged",
                    value: function() {
                        for (let e = 0; e < this.properties.length; e++)
                            if (this.properties[e].modified)
                                return !0;
                        return !1
                    }
                }, {
                    key: "updateServerTags",
                    value: function(e) {
                        w.isOrchid || this._FusionDataService.purgeOrchid(this.orchid),
                        this.orchid.discoverableOrchid.tags = e,
                        this.serverTags = e
                    }
                }, {
                    key: "triggerValidationOfCustomPropNames",
                    value: function(e, t) {
                        var n = this;
                        this._to && this.$timeout.cancel(this._to),
                        this._to = this.$timeout((function() {
                            n._to = null;
                            for (let i = 0; i < n.properties.length; i++) {
                                const a = n.properties[i];
                                if (!a.custom)
                                    return;
                                if (a.id !== t && a.active) {
                                    const t = e[a.nameKey];
                                    t && t.customPropNameValidateByPropEditor && t.customPropNameValidateByPropEditor()
                                }
                            }
                        }
                        ), 250)
                    }
                }, {
                    key: "setActionStateToSaveOrConfirm",
                    value: function() {
                        this.actionState.action = this.propertiesNeedConfirmation ? ca.CONFIRM : ca.SAVE,
                        this.actionState.performing = !0
                    }
                }, {
                    key: "setActionStateToErrorOrPerformed",
                    value: function(e) {
                        this.actionState.error = e ? this.transformErrorForDisplay(e) : null,
                        this.actionState.action = ca.NONE,
                        this.actionState.performing = !1
                    }
                }, {
                    key: "setPropertiesFetchStateToErrorOrFetched",
                    value: function(e, t) {
                        if (this.propertiesFetchState.fetched = !0,
                        e) {
                            const n = "An very unexpected error happened while fetching the props and info";
                            this.logger("error", re(t) ? n : `${n}. Context - ${t}`, e),
                            this.propertiesFetchState.error = this.transformErrorForDisplay(e, L.messages.propertyEditor.anUnexpectedErrorOccurredWhileFetchingProperties())
                        } else
                            this.propertiesFetchState.error = null;
                        this.propertiesFetchState.state = re(e) ? da : ua
                    }
                }, {
                    key: "clearActionErrors",
                    value: function() {
                        this.actionState.error = null,
                        this.propertiesFetchState.error = null
                    }
                }, {
                    key: "safeScopeApply",
                    value: function() {
                        if (!this.$scope.$root || "$digest" !== this.$scope.$root.$$phase)
                            try {
                                this.$scope.$apply()
                            } catch (e) {}
                    }
                }, {
                    key: "saveOrConfirmProperties",
                    value: function() {
                        var e = this;
                        if (this.showingActionSpinner)
                            return;
                        const t = function(t) {
                            t && (e.logger("error", `The ${e.propertiesNeedConfirmation ? "confirm" : "save"} dialog encountered an error.`, t),
                            e.setActionStateToErrorOrPerformed(t)),
                            e.safeScopeApply()
                        };
                        this.showSaveOrConfirmDialog().then(t).catch(t)
                    }
                }, {
                    key: "transformPropertiesForBackend",
                    value: function() {
                        return re(this.properties) ? [] : this.properties.filter((function(e) {
                            return e.sendToBackend
                        }
                        ))
                    }
                }, {
                    key: "removeCustomProperty",
                    value: function(e, t) {
                        const n = this.properties.indexOf(this.propertiesDisplay[e])
                          , i = this.properties[n];
                        !re(i) && i.custom && (this.properties.splice(n, 1),
                        this.propertiesDisplay.splice(e, 1),
                        this.customPropNames.get(i.name) === i.id && (this.customPropNames.delete(i.name),
                        this.triggerValidationOfCustomPropNames(t, i.id)),
                        this.propertyNames = this.properties.map((function(e) {
                            return e.name
                        }
                        )),
                        0 === this.propertiesDisplay.length && (this.propertiesDisplay = [...this.properties],
                        this.searchTerms = []))
                    }
                }, {
                    key: "addNewProperty",
                    value: function() {
                        this.properties.unshift(new Ji({
                            id: this.uuid(),
                            custom: !0
                        })),
                        this.propertiesDisplay = [...this.properties],
                        this.searchTerms = []
                    }
                }, {
                    key: "updateNames",
                    value: function(e, t) {
                        this.triggerValidationOfCustomPropNames(e, t),
                        this.searchTerms = [],
                        this.propertyNames = this.properties.map((function(e) {
                            return e.name
                        }
                        )),
                        this.propertiesDisplay = [...this.properties]
                    }
                }, {
                    key: "getTooltipText",
                    value: function(e) {
                        return e.locked ? this.propertyMsgs.lockedTooltip : e.active ? this.propertyMsgs.checkedTooltip : this.propertyMsgs.uncheckedTooltip
                    }
                }, {
                    key: "updateFilteredData",
                    value: function(e) {
                        var t = this;
                        this.propertiesDisplay = [],
                        this.properties.forEach((function(n) {
                            n.name || (t.propertyNames[t.propertyNames.indexOf(n.name)] = "",
                            n.name = ""),
                            e.forEach((function(e) {
                                n.name !== e || t.propertiesDisplay.includes(n) || e.toLowerCase().startsWith(fa) || t.propertiesDisplay.push(n)
                            }
                            ))
                        }
                        ))
                    }
                }, {
                    key: "performSaveOrConfirmAction",
                    value: function() {
                        return this.propertiesNeedConfirmation ? this.confirmProperties() : this.saveProperties()
                    }
                }, {
                    key: "confirmProperties",
                    value: function() {
                        return this.DataService.confirmProperties(this.orchid).catch((function(e) {
                            return {
                                wasError: !0,
                                data: null,
                                error: e
                            }
                        }
                        ))
                    }
                }, {
                    key: "saveProperties",
                    value: function() {
                        return this.DataService.updateProperties(this.orchid, this.transformPropertiesForBackend()).catch((function(e) {
                            return {
                                wasError: !0,
                                data: null,
                                error: e
                            }
                        }
                        ))
                    }
                }, {
                    key: "transformErrorForDisplay",
                    value: function(e, t) {
                        const n = t || L.messages.errors.unexpectedErrorOccurred();
                        return e instanceof Error ? n : e && e.data && e.data.reason ? e.data.reason : n
                    }
                }, {
                    key: "isSmallScreen",
                    value: function() {
                        return window.innerWidth < 960
                    }
                }, {
                    key: "getHiddenClass",
                    value: function(e) {
                        return !e.custom && e.name.toLowerCase().startsWith(fa)
                    }
                }, {
                    key: "performInit",
                    value: async function(e) {
                        this.propertyEditorInit = e;
                        try {
                            await this.checkToSeeIfPropertyChangesNeedConfirming()
                        } catch (e) {
                            this.setActionStateToErrorOrPerformed(e),
                            this.propertyEditorInit.loading()
                        }
                        if (!this.propertiesNeedConfirmation && re(this.actionState.error))
                            try {
                                await this.fetchProperties()
                            } catch (e) {
                                this.setPropertiesFetchStateToErrorOrFetched(e),
                                this.propertyEditorInit.loading()
                            }
                        else
                            this.propertiesNeedConfirmation && (this._initState.state = pa,
                            this.propertyEditorInit.confirmationNeeded())
                    }
                }, {
                    key: "fetchProperties",
                    value: async function() {
                        this._initState.progress = L.messages.propertyEditor.loadingProperties(),
                        this._initState.state = ma,
                        this.propertiesNeedConfirmation && (this.propertiesNeedConfirmation = !1,
                        this.propertyEditorInit.loading()),
                        this.propertiesFetchState.state = la;
                        let {properties: {data: e, error: t}, propertiesInfo: {data: n, error: i}} = await this.DataService.getPropertiesAndInfo(this.orchid);
                        const a = re(t) && re(i);
                        if (this.setPropertiesFetchStateToErrorOrFetched(t || i, a ? void 0 : "Fetching the " + (t ? "properties" : "property info")),
                        !a)
                            return void this.propertyEditorInit.loading();
                        this.properties.length && (this.properties = [],
                        this.existingPropNames.clear(),
                        this.customPropNames.clear());
                        const r = function(e, t) {
                            const n = new Map
                              , i = "function" == typeof t;
                            for (let a = 0; a < e.length; a++) {
                                const r = e[a];
                                n.set(i ? t(r) : r[t], r)
                            }
                            return n
                        }(e, "name")
                          , s = []
                          , o = []
                          , c = [];
                        for (let e = 0; e < n.length; ++e) {
                            const t = n[e]
                              , i = r.get(t.name);
                            r.delete(t.name),
                            this.existingPropNames.add(t.name);
                            const a = new Ji({
                                id: this.uuid(),
                                custom: !1,
                                prop: i,
                                info: t
                            });
                            a.locked ? c.push(a) : a.active ? s.push(a) : o.push(a)
                        }
                        if (r.size)
                            for (const e of r.values())
                                this.existingPropNames.add(e.name),
                                s.push(new Ji({
                                    id: this.uuid(),
                                    custom: !1,
                                    prop: e
                                }));
                        const l = function(e, t) {
                            return e.name.localeCompare(t.name, "en")
                        };
                        this.properties = this.properties.concat(ea(s, l), ea(o, l), ea(c, l)),
                        this.propertyNames = this.properties.map((function(e) {
                            return e.name
                        }
                        )),
                        this.propertiesDisplay = this.properties,
                        this.propertyEditorInit.fetchedProps(),
                        this._initState.state = ga,
                        this.propertiesFetchState.state = da
                    }
                }, {
                    key: "checkToSeeIfPropertyChangesNeedConfirming",
                    value: async function() {
                        const e = await this.DataService.doPropertiesNeedToBeConfirmed(this.orchid);
                        if (e.wasError)
                            return this.logger("error", "Failed to determine if we need to confirm properties", e.error),
                            this.setActionStateToErrorOrPerformed(e.error),
                            void this.propertyEditorInit.loading();
                        e.data.propertiesConfirmed || (this._initState.state = pa,
                        this.propertiesNeedConfirmation = !0,
                        this.isOrchid && this._ControlledShutdownService.assumeControlForImminentShutdown(this.orchid))
                    }
                }, {
                    key: "showSaveOrConfirmDialog",
                    value: async function() {
                        const e = this.propertiesNeedConfirmation ? "Confirm Properties" : "Save Properties";
                        if (!this.propertiesNeedConfirmation) {
                            const e = await async function(e, t) {
                                try {
                                    return {
                                        wasError: !1,
                                        yes: await e.show({
                                            template: n(70671),
                                            controller: "YesNoDialogController",
                                            bindToController: !0,
                                            controllerAs: "$ctrl",
                                            clickOutsideToClose: !1,
                                            escapeToClose: !1,
                                            fullScreen: !0,
                                            multiple: t.multiple,
                                            locals: {
                                                config: t
                                            }
                                        }),
                                        error: null
                                    }
                                } catch (e) {
                                    return {
                                        wasError: !0,
                                        yes: !1,
                                        error: e
                                    }
                                }
                            }(this.$mdDialog, this.propertySaveOrConfirmDialogConfig);
                            if (e.wasError || !e.yes)
                                return
                        }
                        this.setActionStateToSaveOrConfirm();
                        const t = await this.performSaveOrConfirmAction();
                        this.setActionStateToErrorOrPerformed(t.error),
                        t.wasError ? this.logger("error", `${e} - Encountered an error`, t.error) : this.isOrchid || this.propertiesNeedConfirmation ? this.propertiesNeedConfirmation ? (this._ControlledShutdownService.hideShutdownAlert(this.orchid),
                        await this.fetchProperties()) : (this.skipDeactivationGuard = !0,
                        this._ControlledShutdownService.assumeControlForImmediateShutdown(this.orchid, L.messages.propertyEditor.savingPropertiesShutdownReason())) : ta.show(this.$mdDialog, {
                            orchid: this.orchid
                        })
                    }
                }]),
                e
            }();
            va.$inject = ["$scope", "$mdDialog", "$timeout", "$document", "uuid", "OrchidDataService", "ControlledShutdownService", "UserSettingsService", "FusionDataService", "RenewableService"],
            angular.module("ipconfigure.orchid.singularity").controller("PropertyEditor", va).component("propertyEditor", {
                controller: "PropertyEditor",
                controllerAs: "propertyEditor",
                bindings: {
                    orchid: "=",
                    route: "="
                },
                template: n(8986)
            });
            const ya = Symbol("Controlled Shutdown: Sentinel Key")
              , ba = Symbol("Controlled Shutdown: Kind Key")
              , Sa = Symbol("Controlled Shutdown: Config Key")
              , Ca = Symbol("Controlled Shutdown: Navigation Lock")
              , wa = {
                IMMEDIATE: Symbol("immediate-shutdown"),
                IMMINENT: Symbol("imminent-shutdown")
            }
              , Ia = "pending-shutdown"
              , Ta = "hide-server-shutdown-alert";
            let Ea = function(e) {
                (0,
                _.Z)(n, e);
                var t = (0,
                x.Z)(n);
                function n(e, i, a, r) {
                    var s;
                    return (0,
                    S.Z)(this, n),
                    (s = t.call(this))._uuid = r,
                    s._$window = e,
                    s._router = a,
                    s._$timeout = i,
                    s._knownShutdownKinds = new Set(Object.values(wa)),
                    s[ya] = null,
                    s[ba] = null,
                    s[Sa] = null,
                    s[Ca] = null,
                    s._immediateShutdownSafetyTo = null,
                    s
                }
                return (0,
                b.Z)(n, [{
                    key: "sentinel",
                    get: function() {
                        return this[ya]
                    }
                }, {
                    key: "shutdownKind",
                    get: function() {
                        return this[ba]
                    }
                }, {
                    key: "message",
                    get: function() {
                        return this[Sa] ? this[Sa].message : null
                    }
                }, {
                    key: "isImmediateShutdown",
                    get: function() {
                        return !re(this.sentinel) && this.shutdownKind === wa.IMMEDIATE
                    }
                }, {
                    key: "isImminentShutdown",
                    get: function() {
                        return !re(this.sentinel) && this.shutdownKind === wa.IMMINENT
                    }
                }, {
                    key: "shouldHandleApplicationDeathNormally",
                    get: function() {
                        return !this.isImmediateShutdown
                    }
                }, {
                    key: "requireApplicationReloadControl",
                    get: function() {
                        return this.isImmediateShutdown
                    }
                }, {
                    key: "allowRouting",
                    get: function() {
                        return !0 !== this[Ca]
                    }
                }, {
                    key: "trackingOrchid",
                    value: function(e) {
                        return !1
                    }
                }, {
                    key: "gotoStage",
                    value: function() {
                        return this._router.navigateByUrl("/stage")
                    }
                }, {
                    key: "trigger",
                    value: function(e, t) {}
                }, {
                    key: "hideShutdownAlert",
                    value: function(e) {
                        this.isImminentShutdown && (this._clearShutdownState(),
                        (0,
                        T.Z)((0,
                        E.Z)(n.prototype), "trigger", this).call(this, Ta))
                    }
                }, {
                    key: "reloadApplication",
                    value: function() {
                        var e = this;
                        if (this.isImmediateShutdown) {
                            if (this._immediateShutdownSafetyTo && this._$timeout.cancel(this._immediateShutdownSafetyTo),
                            re(this[Sa]) || re(this[Sa].lastUrl))
                                return this._$window.location.reload();
                            const t = function() {
                                e._$window.location.reload()
                            };
                            this[Ca] = null,
                            this._router.navigateByUrl(this[Sa].lastUrl).then(t).catch(t)
                        }
                    }
                }, {
                    key: "assumeControlForImmediateShutdown",
                    value: function(e, t) {
                        this._shutdownInitiated({
                            orchid: e,
                            message: t,
                            kind: wa.IMMEDIATE
                        })
                    }
                }, {
                    key: "assumeControlForImminentShutdown",
                    value: function(e, t) {
                        this._shutdownInitiated({
                            orchid: e,
                            message: t,
                            kind: wa.IMMINENT
                        })
                    }
                }, {
                    key: "_shutdownInitiated",
                    value: function(e) {
                        var t = this;
                        if (null === this[ya] && this._knownShutdownKinds.has(e.kind)) {
                            if (this[ba] = e.kind,
                            this[ya] = Symbol(`Controlled Shutdown: All Is Well - ${this._uuid()}`),
                            this.isImmediateShutdown)
                                return this[Sa] = {
                                    lastUrl: this._router.url,
                                    lastLocation: this._$window.location.href,
                                    message: e.message
                                },
                                void this._router.navigateByUrl("/server-restarting").then((function() {
                                    t[Ca] = !0,
                                    t._immediateShutdownSafetyTo = t._$timeout((function() {
                                        t._immediateShutdownSafetyTo = null,
                                        t.reloadApplication()
                                    }
                                    ), 9e4)
                                }
                                ));
                            (0,
                            T.Z)((0,
                            E.Z)(n.prototype), "trigger", this).call(this, Ia)
                        }
                    }
                }, {
                    key: "_clearShutdownState",
                    value: function() {
                        this[ya] = null,
                        this[Sa] = null,
                        this[ba] = null,
                        this[Ca] = null
                    }
                }]),
                n
            }(wn);
            Ea.$inject = ["$window", "$timeout", "Router", "uuid"];
            let _a = function() {
                function e(t, n, i) {
                    (0,
                    S.Z)(this, e),
                    this.$document = n,
                    this.$scope = t,
                    this.ControlledShutdownService = i,
                    this.body = i.message || L.messages.propertyEditor.savingPropertiesShutdownReason()
                }
                return (0,
                b.Z)(e, [{
                    key: "$onInit",
                    value: function() {
                        if (this.isOrchid) {
                            if (!this.ControlledShutdownService.isImmediateShutdown)
                                return this.ControlledShutdownService.gotoStage();
                            this.$document.find("body").css("overflow", "hidden")
                        }
                    }
                }, {
                    key: "$onDestroy",
                    value: function() {
                        this.isOrchid && this.$document.find("body").css("overflow", "")
                    }
                }, {
                    key: "isOrchid",
                    get: function() {
                        return this.$scope.$root.isOrchid
                    }
                }, {
                    key: "showWithCard",
                    get: function() {
                        return re(this.cardless)
                    }
                }]),
                e
            }();
            _a.$inject = ["$scope", "$document", "ControlledShutdownService"];
            let xa = function() {
                function e(t, n, i) {
                    (0,
                    S.Z)(this, e),
                    this._hiding = !0,
                    this.$element = t,
                    this.$scope = n,
                    this.isOrchid = w.isOrchid,
                    this._ControlledShutdownService = i,
                    i.on(Ia, this.show, this),
                    i.on(Ta, this.hide, this)
                }
                return (0,
                b.Z)(e, [{
                    key: "$onDestroy",
                    value: function() {
                        this._ControlledShutdownService.off(Ia, this.show),
                        this._ControlledShutdownService.off(Ta, this.hide)
                    }
                }, {
                    key: "showing",
                    get: function() {
                        return !this._hiding
                    }
                }, {
                    key: "shouldShowOrHide",
                    value: function(e) {
                        return !!this.isOrchid || !re(e) && !re(this.orchid) && e.id === this.orchid.id
                    }
                }, {
                    key: "show",
                    value: function(e) {
                        this.shouldShowOrHide(e) && this._hiding && this.toggleShowHide()
                    }
                }, {
                    key: "hide",
                    value: function(e) {
                        this.shouldShowOrHide(e) && !this._hiding && this.toggleShowHide()
                    }
                }, {
                    key: "toggleShowHide",
                    value: function() {
                        this._hiding = !this._hiding,
                        this.$element.toggleClass("sing-hidden", this._hiding)
                    }
                }]),
                e
            }();
            xa.$inject = ["$element", "$scope", "ControlledShutdownService"],
            angular.module("ipconfigure.orchid.singularity").controller("ControlledServerShutdownController", _a).component("controlledServerShutdown", {
                bindings: {
                    cardless: "@"
                },
                controller: "ControlledServerShutdownController",
                controllerAs: "$ctrl",
                template: n(74817)
            }).controller("ServerShutdownAlertController", xa).component("serverShutdownAlert", {
                controller: "ServerShutdownAlertController",
                controllerAs: "$ctrl",
                bindings: {
                    orchid: "<?"
                },
                template: n(26574)
            });
            n(12207),
            n(82025),
            n(46450),
            n(15784);
            angular.module("ipconfigure.orchid.singularity").service("BigSummerBlowoutUtilityService", function() {
                function e() {
                    (0,
                    S.Z)(this, e)
                }
                return (0,
                b.Z)(e, [{
                    key: "collapseExpandedElement",
                    value: function() {
                        const e = document.querySelector(".big-summer-blowout.ready.expanded");
                        return !(!e || "function" != typeof e.activate || (e.activate(),
                        0))
                    }
                }]),
                e
            }()).directive("bigSummerBlowout", ["$parse", "$document", "$window", "$timeout", "BrowserInfoService", "EasingService", function(e, t, n, i, a, r) {
                return {
                    restrict: "A",
                    scope: {
                        bigSummerBlowout: "=",
                        onExpand: "&",
                        onClose: "&"
                    },
                    link: function(s, o, c) {
                        var l;
                        function d(e) {
                            l = n.getSelection().isCollapsed
                        }
                        function u(e) {
                            var t = n.getSelection();
                            e.stopPropagation(),
                            1 === e.which && t.isCollapsed === l && !0 === t.isCollapsed && h()
                        }
                        function m() {
                            return n.pageYOffset || document.documentElement.scrollTop || document.body.scrollTop || 0
                        }
                        function h() {
                            var n = o[0].parentNode.querySelector(".expanded")
                              , a = o[0].parentNode.querySelector("[big-summer-blowout]")
                              , c = o[0].classList.contains("expanded")
                              , l = o[0].querySelector(".blowout-header");
                            if (n && o[0].getBoundingClientRect().top > n.getBoundingClientRect().top) {
                                var d = n.scrollHeight - l.scrollHeight + 31
                                  , u = m() - d;
                                t[0].documentElement.scrollTop = u,
                                t[0].body.parentNode.scrollTop = u,
                                t[0].body.scrollTop = u,
                                i((function() {
                                    t[0].documentElement.scrollTop = u,
                                    t[0].body.parentNode.scrollTop = u,
                                    t[0].body.scrollTop = u
                                }
                                ), 100),
                                i((function() {
                                    t[0].documentElement.scrollTop = u,
                                    t[0].body.parentNode.scrollTop = u,
                                    t[0].body.scrollTop = u
                                }
                                ), 200)
                            } else
                                n && n !== o[0] || a === o[0] || r.scrollTo(m() + (c ? -32 : 32), (function() {}
                                ), 175);
                            n && (n.classList.toggle("expanded"),
                            n !== o[0] && e(angular.element(n).attr("big-summer-blowout")).assign(angular.element(n).scope(), !1),
                            s.onClose()),
                            n !== o[0] && (o[0].classList.toggle("expanded"),
                            !1 === c && s.onExpand()),
                            s.bigSummerBlowout = !c,
                            s.$apply()
                        }
                        a.getBrowserInfo(),
                        o[0].classList.add("big-summer-blowout"),
                        i((function() {
                            o[0].classList.add("ready")
                        }
                        )),
                        o.on("mousedown", d),
                        o.on("mouseup", u),
                        s.$on("$destroy", (function() {
                            o.off("click", h),
                            o.off("mouseup", u),
                            o.off("mousedown", d)
                        }
                        )),
                        o[0].activate = function() {
                            h()
                        }
                        ,
                        o[0].expandMe = function() {
                            o[0].classList.toggle("expanded")
                        }
                    }
                }
            }
            ]);
            n(69810);
            var Da = n(42152)
              , Oa = n.n(Da);
            n(88774),
            n(14435),
            n(82472),
            n(38012),
            n(33105),
            n(37380),
            n(1118),
            n(3462),
            n(33824);
            angular.module("ipconfigure.orchid.singularity").factory("canvasMaskFactory", (function() {
                var e = {
                    createMask: function(e, t) {
                        return new Na(e,t)
                    }
                };
                return e
            }
            ));
            const Aa = 255
              , Ra = 255
              , Pa = 255
              , ka = 0
              , Ma = 0
              , La = 0;
            function Na(e, t) {
                this.drawingMode = "draw",
                this.context = e,
                this.fullScaleContext = t,
                HTMLCanvasElement.prototype.toBlob || Object.defineProperty(HTMLCanvasElement.prototype, "toBlob", {
                    value: function(e, t, n) {
                        var i = this.toDataURL(t, n).split(",")[1];
                        setTimeout((function() {
                            for (var n = atob(i), a = n.length, r = new Uint8Array(a), s = 0; s < a; s++)
                                r[s] = n.charCodeAt(s);
                            e(new Blob([r],{
                                type: t || "image/png"
                            }))
                        }
                        ))
                    }
                })
            }
            Na.prototype.setMode = function(e) {
                this.drawingMode = e
            }
            ,
            Na.prototype.setBrushSize = function(e) {
                this.brushSize = e
            }
            ,
            Na.prototype.setBrushColor = function(e) {
                this.brushColor = e
            }
            ,
            Na.prototype.getMask = function() {
                var e = this;
                return new Promise((function(t, n) {
                    for (var i = e.fullScaleContext.getImageData(0, 0, e.fullScaleContext.canvas.width, e.fullScaleContext.canvas.height), a = !1, r = 0, s = i.data.length; r < s; r += 4) {
                        var o = i.data[r]
                          , c = i.data[r + 1]
                          , l = i.data[r + 2];
                        o !== ka && o > 10 || c !== La && c > 10 || l !== Ma && l > 10 ? (a = !0,
                        i.data[r] = Aa,
                        i.data[r + 1] = Pa,
                        i.data[r + 2] = Ra,
                        i.data[r + 3] = 255) : (i.data[r] = ka,
                        i.data[r + 1] = La,
                        i.data[r + 2] = Ma,
                        i.data[r + 3] = 255)
                    }
                    if (a) {
                        var d = document.createElement("canvas");
                        d.height = e.fullScaleContext.canvas.height,
                        d.width = e.fullScaleContext.canvas.width;
                        var u = d.getContext("2d");
                        u.putImageData(i, 0, 0),
                        d.toBlob((function(e) {
                            t(e),
                            d = void 0,
                            u = void 0
                        }
                        ))
                    } else
                        t(null)
                }
                ))
            }
            ,
            Na.prototype.setMask = function(e) {
                var t = this;
                return new Promise((function(n, i) {
                    if (null !== e && "" !== e) {
                        var a = new Image;
                        a.crossOrigin = "Anonymous",
                        a.onload = function() {
                            t.context.clearRect(0, 0, t.context.canvas.width, t.context.canvas.height),
                            t.fullScaleContext.clearRect(0, 0, t.fullScaleContext.canvas.width, t.fullScaleContext.canvas.height),
                            t.drawScaledMask(a),
                            t.fullScaleContext.drawImage(a, 0, 0, t.fullScaleContext.canvas.width, t.fullScaleContext.canvas.height),
                            n()
                        }
                        ,
                        a.onerror = function() {
                            i("Could not load mask")
                        }
                        ,
                        a.src = e
                    } else
                        n()
                }
                ))
            }
            ,
            Na.prototype.start = function(e, t) {
                this.drawing = !0,
                this.draw(e, t)
            }
            ,
            Na.prototype.draw = function(e, t, n) {
                if (this.drawing) {
                    "draw" === this.drawingMode ? (this.context.globalCompositeOperation = "source-over",
                    this.fullScaleContext.globalCompositeOperation = "source-over") : (this.context.globalCompositeOperation = "destination-out",
                    this.fullScaleContext.globalCompositeOperation = "destination-out");
                    var i = this.fullScaleContext.canvas.width / this.context.canvas.width;
                    this.context.fillStyle = this.brushColor,
                    this.context.strokeStyle = this.brushColor,
                    this.context.lineJoin = "round",
                    this.context.lineWidth = this.brushSize,
                    this.fullScaleContext.fillStyle = "white",
                    this.fullScaleContext.strokeStyle = "white",
                    this.fullScaleContext.lineJoin = "round",
                    this.fullScaleContext.lineWidth = this.brushSize * i,
                    this.context.beginPath(),
                    this.fullScaleContext.beginPath(),
                    n ? (this.context.moveTo(this.lastX, this.lastY),
                    this.context.lineTo(e, t),
                    this.fullScaleContext.moveTo(this.lastX * i, this.lastY * i),
                    this.fullScaleContext.lineTo(e * i, t * i)) : (this.context.arc(e, t, this.brushSize / 2, 0, 2 * Math.PI, !1),
                    this.context.fill(),
                    this.context.lineWidth = 1,
                    this.fullScaleContext.arc(e * i, t * i, this.brushSize / 2 * i, 0, 2 * Math.PI, !1),
                    this.fullScaleContext.fill(),
                    this.fullScaleContext.lineWidth = 1),
                    this.context.closePath(),
                    this.fullScaleContext.closePath(),
                    this.context.stroke(),
                    this.fullScaleContext.stroke(),
                    this.lastX = e,
                    this.lastY = t
                }
            }
            ,
            Na.prototype.stop = function(e, t) {
                this.draw(e, t, !0),
                this.drawing = !1
            }
            ,
            Na.prototype.clear = function() {
                this.context.clearRect(0, 0, this.context.canvas.width, this.context.canvas.height),
                this.fullScaleContext.clearRect(0, 0, this.fullScaleContext.canvas.width, this.fullScaleContext.canvas.height)
            }
            ,
            Na.prototype.resize = function(e) {
                this.context.canvas.width = e.width,
                this.context.canvas.height = e.height,
                this.drawScaledMask(this.fullScaleContext.canvas)
            }
            ,
            Na.prototype.drawScaledMask = function(e) {
                this.context.imageSmoothingEnabled = !1,
                this.context.drawImage(e, 0, 0, this.context.canvas.width, this.context.canvas.height);
                for (var t = this.context.getImageData(0, 0, this.context.canvas.width, this.context.canvas.height), n = function(e) {
                    var t = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
                    e = e.replace(t, (function(e, t, n, i) {
                        return t + t + n + n + i + i
                    }
                    ));
                    var n = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(e);
                    return n ? {
                        r: parseInt(n[1], 16),
                        g: parseInt(n[2], 16),
                        b: parseInt(n[3], 16)
                    } : null
                }(this.brushColor), i = 0, a = t.data.length; i < a; i += 4) {
                    var r = t.data[i]
                      , s = t.data[i + 1]
                      , o = t.data[i + 2];
                    r !== Aa && s !== Pa && o !== Ra ? t.data[i + 3] = 0 : (t.data[i] = n.r,
                    t.data[i + 1] = n.g,
                    t.data[i + 2] = n.b,
                    t.data[i + 3] = 255)
                }
                this.context.putImageData(t, 0, 0)
            }
            ;
            var Fa;
            n(65934);
            angular.module("ipconfigure.orchid.singularity").controller("MotionDetectionConfigurationController", ["$scope", "$element", "$mdDialog", "OrchidDataService", "orchid", "camera", "brushColor", "ActiveStreamStateService", function(e, t, n, i, a, r, s, o) {
                var c, l, d = this;
                d.$onInit = function() {
                    if (d.msgs = L.messages.cameras,
                    !(c = t[0].querySelector("#mask-image")))
                        throw Error("Missing the #mask-image element");
                    if (d.maskPromise = Promise.resolve(null),
                    d.missingImage = null,
                    d.maskMode = "draw",
                    d.brushSize = 40,
                    d.brushColor = s,
                    se(l = r.primaryStream))
                        d.missingImage = d.msgs.theCameraDoesNotHavePrimaryStream();
                    else {
                        var n = l.recordingConfiguration.bgseg
                          , u = null
                          , m = 5;
                        n.motionMask && n.motionMask.href && (u = i.motionMaskUrl(a, n.motionMask.href)),
                        n.boxArea && (m = Math.min(Math.max(parseInt(n.boxArea), 0), 100)),
                        d.configuration = {
                            objectSize: m,
                            maskHref: u
                        };
                        try {
                            "PROXY_ONLY_MODE" === l.recordingConfiguration.mode ? d.missingImage = d.msgs.theCameraInProxyOnlyMode() : o.activeStreamsMap[l.id] && "running" !== o.activeStreamsMap[l.id].streamState ? d.missingImage = d.msgs.theCameraNotInRunningState() : (d.backgroundImageSrc = i.cameraFrameUrl(a, r, 0, {
                                width: 0,
                                height: 0
                            }, !1),
                            d.loading = !0)
                        } catch (e) {
                            d.missingImage = e.message
                        }
                    }
                    e.$smartInterval((function() {
                        if (void 0 !== c && void 0 !== d.dimensions) {
                            var e = {
                                height: c.height,
                                width: c.width,
                                naturalWidth: c.naturalWidth,
                                naturalHeight: c.naturalHeight
                            };
                            e.width === d.dimensions.width && e.height === d.dimensions.height || (d.dimensions = e)
                        }
                    }
                    ), 300),
                    e.$smartAddEventListener(c, "load", (function() {
                        d.dimensions = {
                            width: c.width,
                            height: c.height,
                            naturalWidth: c.naturalWidth,
                            naturalHeight: c.naturalHeight
                        },
                        d.loading = !1
                    }
                    )),
                    e.$smartAddEventListener(c, "error", (function() {
                        d.missingImage = d.msgs.cameraImageCouldNotBeRetrieved(),
                        d.loading = !1
                    }
                    ))
                }
                ,
                d.cancel = function() {
                    n.cancel()
                }
                ,
                d.clearMask = function() {
                    e.$broadcast("clearmask")
                }
                ,
                d.save = function() {
                    d.processing = !0,
                    l.recordingConfiguration.bgseg.boxArea = d.configuration.objectSize,
                    i.updateStream(a, r, l).then((function() {
                        return d.maskPromise
                    }
                    )).then((function(e) {
                        return e ? i.saveMotionMask(a, r, e) : d.configuration.maskHref ? i.deleteMotionMask(a, r) : void 0
                    }
                    )).then((function() {
                        return d.processing = !1,
                        n.hide()
                    }
                    )).catch((function(e) {
                        d.error = e.data.reason,
                        d.processing = !1
                    }
                    ))
                }
                ,
                d.disallowFloats = function(e) {
                    "." === e.key && e.preventDefault()
                }
            }
            ]),
            angular.module("ipconfigure.orchid.singularity").controller("DewarpConfigController", ["$window", "$scope", "$element", "$mdDialog", "$interval", "camera", "orchid", "OrchidDataService", "fisheyeFactory", "ActiveStreamStateService", function(e, t, n, i, a, r, s, o, c, l) {
                let d = this;
                d.settings,
                d.viewLimits,
                d.imageLoadErrorMessage = null,
                d.loading = !0,
                d.error = "",
                d.orientation = S,
                d.pan = function(e) {
                    if (void 0 === e)
                        return d.settings.defaultPerspectiveView.pan;
                    d.settings.defaultPerspectiveView.pan = e,
                    C()
                }
                ,
                d.tilt = function(e) {
                    if (void 0 === e)
                        return d.settings.defaultPerspectiveView.tilt;
                    d.settings.defaultPerspectiveView.tilt = e,
                    C()
                }
                ,
                d.zoom = function(e) {
                    if (void 0 === e)
                        return d.settings.defaultPerspectiveView.zoom;
                    d.settings.defaultPerspectiveView.zoom = e,
                    C()
                }
                ,
                d.depth = function(e) {
                    if (void 0 === e)
                        return d.settings.perspectiveDepth;
                    d.settings.perspectiveDepth = e,
                    C()
                }
                ,
                d.panoramaAspectRatio = function(e) {
                    if (void 0 === e)
                        return d.settings.panoramaAspectRatio;
                    d.settings.panoramaAspectRatio = e,
                    C()
                }
                ,
                d.panoramaShift = function(e) {
                    if (void 0 === e)
                        return d.settings.panoramaShift;
                    d.settings.panoramaShift = e,
                    C()
                }
                ;
                let u = document.createElement("img");
                u.crossOrigin = "Anonymous";
                let m, h = 1, p = null, g = null, f = null;
                const v = {
                    containerWidth: Number.MIN_VALUE,
                    containerHeight: Number.MIN_VALUE
                };
                function y() {
                    p && g && m && (m.offsetWidth === v.containerWidth && m.offsetHeight === v.containerHeight || C())
                }
                const b = [function() {
                    null !== f && a.cancel(f),
                    f = null
                }
                , t.$on("$destroy", (function() {
                    Kt.removeScopeListeners(b),
                    u.src = "",
                    u.onload = null,
                    u.onerror = null,
                    c.release(p),
                    p = null,
                    c.release(g),
                    g = null
                }
                ))];
                function S(e) {
                    if (void 0 === e)
                        return d.settings.orientation;
                    p.orientation = e,
                    g.orientation = e;
                    var t = p.getViewLimitsDegrees();
                    d.viewLimits.tilt = t.pitch,
                    d.viewLimits.pan = t.yaw,
                    d.settings.defaultPerspectiveView.tilt = p.pitchDegrees,
                    d.settings.defaultPerspectiveView.pan = p.yawDegrees,
                    d.settings.defaultPerspectiveView.zoom = p.zoom,
                    d.settings.orientation = e,
                    C()
                }
                function C() {
                    const {containerWidth: e, containerHeight: t} = (v.containerWidth = m.offsetWidth,
                    v.containerHeight = m.offsetHeight,
                    v);
                    p.canvasSize = {
                        width: e,
                        height: t
                    },
                    p.cameraPoseDegrees = {
                        pitch: d.settings.defaultPerspectiveView.tilt,
                        yaw: d.settings.defaultPerspectiveView.pan
                    },
                    p.zoom = d.settings.defaultPerspectiveView.zoom,
                    p.orientation = d.settings.orientation,
                    p.setSphereScale(1 / d.settings.perspectiveDepth, 1 / d.settings.perspectiveDepth, 1),
                    p.render(),
                    e > t && t * d.settings.panoramaAspectRatio < e ? (g.width = t * d.settings.panoramaAspectRatio,
                    g.height = t) : (g.width = e,
                    g.height = e / d.settings.panoramaAspectRatio),
                    g.shiftDegrees = d.settings.panoramaShift,
                    g.render()
                }
                d.$onInit = function() {
                    d.msgs = L.messages.cameras,
                    d.settings = {
                        enable: !1,
                        defaultMode: "perspective",
                        orientation: "ceiling",
                        perspectiveDepth: 1,
                        defaultPerspectiveView: {
                            pan: 0,
                            tilt: 45,
                            zoom: .5
                        },
                        panoramaAspectRatio: 4,
                        panoramaShift: 0
                    },
                    d.viewLimits = {
                        tilt: {
                            min: 0,
                            max: 90
                        },
                        pan: {
                            min: 0,
                            max: 360
                        }
                    }
                }
                ,
                d.init = function() {
                    m = n[0].querySelector(".dewarp-wrapper");
                    const e = r.primaryStream;
                    return se(e) ? (d.loading = !1,
                    void (d.imageLoadErrorMessage = d.msgs.theCameraDoesNotHavePrimaryStream())) : "PROXY_ONLY_MODE" === e.recordingConfiguration.mode ? (d.loading = !1,
                    void (d.imageLoadErrorMessage = d.msgs.theCameraInProxyOnlyMode())) : l.activeStreamsMap[r.primaryStream.id] && "running" !== l.activeStreamsMap[r.primaryStream.id].streamState ? (d.loading = !1,
                    void (d.imageLoadErrorMessage = d.msgs.theCameraNotInRunningState())) : (u.src = o.cameraFrameUrl(s, r, 0, {
                        width: 0,
                        height: 0
                    }, !1),
                    u.onload = function() {
                        return function(e) {
                            try {
                                if (p = c.createPerspective(),
                                p.src = u,
                                p.fisheyeRegion = {
                                    centerX: u.naturalWidth / 2,
                                    centerY: u.naturalHeight / 2,
                                    radius: Math.min(u.naturalWidth, u.naturalHeight) / 2
                                },
                                g = c.createEquirectangular(),
                                g.src = u,
                                g.fisheyeRegion = {
                                    centerX: u.naturalWidth / 2,
                                    centerY: u.naturalHeight / 2,
                                    radius: Math.min(u.naturalWidth, u.naturalHeight) / 2
                                },
                                null !== e) {
                                    let t = te(e.dewarpConfiguration);
                                    null !== t && (S(t.orientation),
                                    d.settings = t)
                                }
                                m.appendChild(p.canvas),
                                d.loading = !1,
                                C(),
                                f = a(y, 1e3 / 30)
                            } catch (e) {
                                d.loading = !1,
                                d.imageLoadErrorMessage = d.msgs.failedToInitializeDewarper()
                            }
                            t.$apply()
                        }(e)
                    }
                    ,
                    void (u.onerror = function() {
                        return d.loading = !1,
                        d.imageLoadErrorMessage = d.msgs.failedToLoadPreview(),
                        void t.$apply()
                    }
                    ))
                }
                ,
                d.cancel = function() {
                    i.cancel()
                }
                ,
                d.save = function() {
                    var e = {
                        id: r.primaryStream.id,
                        dewarpConfiguration: d.settings
                    };
                    o.patchStream(s, r, e).then((function() {
                        r.primaryStream.dewarpConfiguration = e.dewarpConfiguration,
                        i.hide()
                    }
                    )).catch((function(e) {
                        let t = d.msgs.failedToSaveDewarpConfig();
                        d.error = t
                    }
                    ))
                }
                ,
                d.enablePerspectiveMode = function() {
                    d.isLoaded() && 1 !== h && (h = 1,
                    m.replaceChild(p.canvas, g.canvas))
                }
                ,
                d.enablePanoramaMode = function() {
                    d.isLoaded() && 2 !== h && (h = 2,
                    m.replaceChild(g.canvas, p.canvas))
                }
                ,
                d.isLoaded = function() {
                    return !1 === d.loading && null === d.imageLoadErrorMessage
                }
            }
            ]),
            function(e) {
                e.SERVER = "server",
                e.CAMERA = "camera"
            }(Fa || (Fa = {}));
            const Ua = Object.values(Fa)
              , $a = {
                [Fa.CAMERA]: {
                    id: Fa.CAMERA,
                    localizedName: () => L.messages.cameras.motionStyles.camera(),
                    test: e => {
                        var t;
                        return Ga(e.recordingConfiguration) && "true" === (null === (t = e.recordingConfiguration.metadata) || void 0 === t ? void 0 : t.bgseg.enabled)
                    }
                    ,
                    updateMetaConfiguration: (e, t) => {
                        e.configuration.Metadata = {
                            Mode: "On",
                            TopicFilter: []
                        };
                        const n = t;
                        e.recordingConfiguration.metadata = {
                            bgseg: {
                                topic: n.topic,
                                data: n.data,
                                enabled: "true"
                            }
                        }
                    }
                },
                [Fa.SERVER]: {
                    id: Fa.SERVER,
                    localizedName: () => L.messages.cameras.motionStyles.server(),
                    test: e => {
                        var t;
                        return !Ga(e.recordingConfiguration) || "false" === (null === (t = e.recordingConfiguration.metadata) || void 0 === t ? void 0 : t.bgseg.enabled)
                    }
                    ,
                    updateMetaConfiguration: e => {
                        e.recordingConfiguration.metadata && (e.recordingConfiguration.metadata.bgseg.enabled = "false"),
                        e.configuration.Metadata && (e.configuration.Metadata.Mode = "Off")
                    }
                }
            }
              , ja = $a[Fa.SERVER];
            function Va(e) {
                if (void 0 === e || void 0 === e.recordingConfiguration || void 0 === e.configuration)
                    return ja;
                const t = Ua.find((t => $a[t].test(e)));
                if (void 0 === t)
                    throw new Error(L.messages.cameras.unableToDetermineMotionStyle());
                return $a[t]
            }
            function Ga(e) {
                return void 0 !== e && void 0 !== e.metadata && void 0 !== e.metadata.bgseg && void 0 !== e.metadata.bgseg.enabled && void 0 !== e.metadata.bgseg.topic && void 0 !== e.metadata.bgseg.data && void 0 !== e.metadata.bgseg.data.name && void 0 !== e.metadata.bgseg.data.type
            }
            function Ba(e, t) {
                let n;
                return e.metadata && (n = {
                    name: e.metadata.bgseg.topic,
                    data: e.metadata.bgseg.data
                }),
                Object.keys(t).find((e => t[e].name === n.name && JSON.stringify(t[e].data) === JSON.stringify(n.data)))
            }
            function za(e) {
                let t = "";
                const n = e.split("/");
                return n.forEach(( (e, i) => {
                    t += e.split(":").pop(),
                    i !== n.length - 1 && (t += "/")
                }
                )),
                t
            }
            function Ha(e, t) {
                const n = e.options
                  , i = e.capabilities;
                if (!n || !i)
                    return {};
                const a = {};
                n.forEach((e => {
                    if (i[e]) {
                        const n = [];
                        i[e].MessageType.Data && i[e].MessageType.Data.forEach((e => {
                            t.includes(e.Type) && n.push({
                                name: e.Name,
                                type: e.Type
                            })
                        }
                        )),
                        n.forEach((t => {
                            const i = za(e);
                            if (1 === n.length)
                                a[i] = {
                                    name: e,
                                    data: n[0]
                                };
                            else if (n.length > 1) {
                                const n = ` - ${t.name}`;
                                a[i + n] = {
                                    name: e,
                                    data: t
                                }
                            }
                        }
                        ))
                    }
                }
                ));
                let r = {};
                return r = Object.keys(a).sort().reduce(( (e, t) => (e[t] = a[t],
                e)), {}),
                r
            }
            var Wa, qa;
            !function(e) {
                e.CONTINUOUS = "continuous",
                e.NON_CONTINUOUS = "non-continuous",
                e.NON_RECORDING = "non-recording"
            }(Wa || (Wa = {})),
            function(e) {
                e.CONTINUOUS_MOTION = "continuous-motion",
                e.CONTINUOUS_NO_MOTION = "continuous-no-motion",
                e.CONTINUOUS_MOTION_ADAPTIVE = "continuous-motion-adaptive",
                e.PROXY_ONLY = "proxy-only",
                e.MOTION_ONLY = "motion-only"
            }(qa || (qa = {}));
            const Ya = Object.values(qa)
              , Xa = {
                [qa.CONTINUOUS_MOTION]: {
                    group: Wa.CONTINUOUS,
                    id: qa.CONTINUOUS_MOTION,
                    metaOptions: [Fa.SERVER, Fa.CAMERA],
                    noMetaOptions: [Fa.SERVER],
                    localizedName: () => L.messages.cameras.recordingsStyles.name.continuousMotion(),
                    test: e => "ALL_FEATURES_MODE" === e.mode && "0" === e.filesplit.motionMode && "false" === e.motionReducer,
                    updateRecordingConfiguration: e => {
                        e.filesplit.motionMode = "0",
                        e.filesplit.recordState = "true",
                        e.motionReducer = "false",
                        e.mode = "ALL_FEATURES_MODE"
                    }
                },
                [qa.CONTINUOUS_NO_MOTION]: {
                    group: Wa.CONTINUOUS,
                    id: qa.CONTINUOUS_NO_MOTION,
                    metaOptions: [],
                    noMetaOptions: [],
                    localizedName: () => L.messages.cameras.recordingsStyles.name.continuousNoMotion(),
                    test: e => "EMBEDDED_LITE_MODE" === e.mode,
                    updateRecordingConfiguration: e => {
                        e.filesplit.motionMode = "0",
                        e.filesplit.recordState = "true",
                        e.motionReducer = "false",
                        e.mode = "EMBEDDED_LITE_MODE"
                    }
                },
                [qa.CONTINUOUS_MOTION_ADAPTIVE]: {
                    group: Wa.CONTINUOUS,
                    id: qa.CONTINUOUS_MOTION_ADAPTIVE,
                    localizedName: () => L.messages.cameras.recordingsStyles.name.continuousAdaptiveMotion(),
                    metaOptions: [Fa.SERVER, Fa.CAMERA],
                    noMetaOptions: [Fa.SERVER],
                    test: e => "ALL_FEATURES_MODE" === e.mode && "0" === e.filesplit.motionMode && "true" === e.motionReducer,
                    updateRecordingConfiguration: e => {
                        e.filesplit.motionMode = "0",
                        e.filesplit.recordState = "true",
                        e.motionReducer = "true",
                        e.mode = "ALL_FEATURES_MODE"
                    }
                },
                [qa.PROXY_ONLY]: {
                    group: Wa.NON_RECORDING,
                    id: qa.PROXY_ONLY,
                    localizedName: () => L.messages.cameras.recordingsStyles.name.proxyOnlyNoVideo(),
                    metaOptions: [],
                    noMetaOptions: [],
                    test: e => "PROXY_ONLY_MODE" === e.mode,
                    updateRecordingConfiguration: e => {
                        e.filesplit.motionMode = "0",
                        e.filesplit.recordState = "false",
                        e.motionReducer = "false",
                        e.mode = "PROXY_ONLY_MODE"
                    }
                },
                [qa.MOTION_ONLY]: {
                    group: Wa.NON_CONTINUOUS,
                    id: qa.MOTION_ONLY,
                    metaOptions: [Fa.SERVER, Fa.CAMERA],
                    noMetaOptions: [Fa.SERVER],
                    localizedName: () => L.messages.cameras.recordingsStyles.name.recordOnlyWhenMotionDetected(),
                    test: e => "ALL_FEATURES_MODE" === e.mode && "2" === e.filesplit.motionMode,
                    updateRecordingConfiguration: e => {
                        e.filesplit.motionMode = "2",
                        e.filesplit.recordState = "false",
                        e.motionReducer = "false",
                        e.mode = "ALL_FEATURES_MODE"
                    }
                }
            }
              , Ka = Xa[qa.CONTINUOUS_MOTION];
            function Za(e) {
                if (void 0 === e)
                    return Ka;
                const t = Ya.find((t => Xa[t].test(e)));
                if (void 0 === t)
                    throw new Error("Unable to determine Recording Style from recording configuration");
                return Xa[t]
            }
            let Ja = class {
                transform(e) {
                    const t = [L.messages.bitrateUnits.bits(), L.messages.bitrateUnits.kb(), L.messages.bitrateUnits.mb(), L.messages.bitrateUnits.gb(), L.messages.bitrateUnits.tb()]
                      , n = parseFloat(e);
                    if (isNaN(n) || !isFinite(n) || n < 0)
                        return "-";
                    if (0 === n)
                        return `0 ${t[0]}${L.messages.cameras.perSecond()}`;
                    let i = Math.floor(Math.log(n) / Math.log(1024));
                    i < 0 && (i = 0),
                    i = Math.min(i, t.length - 1);
                    const a = (n / Math.pow(1024, i)).toFixed(1);
                    return `${L.messages.bits({
                        VALUE: a
                    })} ${t[i]}${L.messages.cameras.perSecond()}`
                }
            }
            ;
            var Qa;
            Ja = (0,
            c.gn)([(0,
            i.Pipe)({
                name: "bitrate"
            })], Ja);
            let er = Qa = class {
                transform(e) {
                    return Qa.transform(e)
                }
                static transform(e) {
                    const t = [L.messages.storageUnits.bytes(), L.messages.storageUnits.kb(), L.messages.storageUnits.mb(), L.messages.storageUnits.gb(), L.messages.storageUnits.tb(), L.messages.storageUnits.pb(), L.messages.storageUnits.eb(), L.messages.storageUnits.zb(), L.messages.storageUnits.yb()]
                      , n = "string" == typeof e ? parseFloat(e) : e;
                    if (isNaN(n) || !isFinite(n) || n < 0)
                        return "-";
                    if (0 === n)
                        return `0 ${t[0]}`;
                    let i = Math.floor(Math.log(n) / Math.log(1024));
                    i < 0 && (i = 0),
                    i = Math.min(i, t.length - 1);
                    const a = (n / Math.pow(1024, i)).toFixed(1);
                    return `${L.messages.bytes({
                        VALUE: a
                    })} ${t[i]}`
                }
            }
            ;
            er = Qa = (0,
            c.gn)([(0,
            i.Pipe)({
                name: "bytes"
            })], er);
            let tr = class {
                transform(e) {
                    if (!e)
                        return " - ";
                    const t = new Date(e);
                    return new Intl.DateTimeFormat(void 0,{
                        timeZoneName: "short",
                        month: "2-digit",
                        day: "2-digit",
                        year: "numeric",
                        hour: "2-digit",
                        hourCycle: "h23",
                        minute: "2-digit",
                        second: "2-digit"
                    }).format(t)
                }
            }
            ;
            var nr;
            tr = (0,
            c.gn)([(0,
            i.Pipe)({
                name: "localizeDate"
            })], tr),
            function(e) {
                e.Disabled = "disabled",
                e.Manual = "manual",
                e.Dhcp = "dhcp"
            }(nr || (nr = {}));
            class ir {
                constructor(e) {
                    this.$scope = e,
                    this.model = {
                        Server: void 0
                    },
                    this.ntpMode = nr.Disabled,
                    this.NTPModes = nr,
                    this._valid = !0
                }
                get valid() {
                    return this._valid
                }
                get ntpServerRequired() {
                    return this.ntpMode === nr.Manual
                }
                get ntpServer() {
                    return Ke(this.model.Server) ? this.model.Server : ""
                }
                get ntpServerDisabled() {
                    return !this.ntpServerRequired
                }
                get ntpServerPlaceholder() {
                    var e, t;
                    return null !== (t = null === (e = this.camera.capabilities.camera.NTP) || void 0 === e ? void 0 : e.Mode.capabilities.manual.Server.default) && void 0 !== t ? t : ""
                }
                $onInit() {
                    var e;
                    this.msgs = L.messages.cameras,
                    this.camera = this.editDialog.camera,
                    this.editDialog.registerNtpTzForm(this);
                    const t = this.camera.configuration.NTP;
                    switch (null !== (e = null == t ? void 0 : t.Mode) && void 0 !== e ? e : nr.Disabled) {
                    case nr.Dhcp:
                        this.ntpMode = nr.Dhcp;
                        break;
                    case nr.Manual:
                        this.ntpMode = nr.Manual;
                        break;
                    default:
                        this.ntpMode = nr.Disabled
                    }
                    this.model.Server = null == t ? void 0 : t.Server
                }
                $postLink() {
                    this._unWatchFormValidity = this.$scope.$watch("NTPForm.$valid", (e => {
                        this._valid = e
                    }
                    ))
                }
                $onDestroy() {
                    Ke(this._unWatchFormValidity) && this._unWatchFormValidity()
                }
                getResults() {
                    const e = {
                        NTP: {
                            Mode: this.ntpMode
                        }
                    };
                    return this.ntpMode === nr.Manual && (e.NTP.Server = this.model.Server),
                    e
                }
            }
            ir.$inject = ["$scope"],
            (0,
            s.module)("ipconfigure.orchid.singularity").controller("CameraEditNtpFormController", ir).component("cameraEditNtpForm", {
                bindings: {
                    editDialog: "<"
                },
                controller: "CameraEditNtpFormController",
                controllerAs: "$ctrl",
                template: n(76719)
            });
            class ar {
                constructor(e) {
                    this.$scope = e,
                    this.selectedTz = void 0,
                    this.model = {
                        DaylightSavings: {
                            initialValue: void 0,
                            value: !1
                        },
                        PosixTZ: {
                            initialValue: "",
                            value: ""
                        }
                    },
                    this.unknownTz = {
                        posixTz: "Unknown",
                        ianaTz: "Unknown",
                        supportsDst: !1
                    },
                    this._valid = !0,
                    this._initiallyUnknownTZ = !1
                }
                get initiallyUnknownTZ() {
                    return this._initiallyUnknownTZ
                }
                get tzList() {
                    return this.editDialog.cameraTzInfo
                }
                get valid() {
                    return this._valid
                }
                get dstDisabled() {
                    return !!Ke(this.selectedTz) && !this.selectedTz.supportsDst
                }
                $onInit() {
                    this.msgs = L.messages.cameras,
                    this.camera = this.editDialog.camera,
                    this.editDialog.registerNtpTzForm(this);
                    const e = this.camera.configuration.TimeZone;
                    if (Ke(e) && ("string" == typeof e.DaylightSavings ? this.model.DaylightSavings = {
                        initialValue: "true" === e.DaylightSavings,
                        value: "true" === e.DaylightSavings
                    } : this.model.DaylightSavings = {
                        initialValue: void 0,
                        value: !1
                    },
                    Ke(e.PosixTZ))) {
                        let t, n = e.PosixTZ;
                        const i = this.findMappedTZ(n);
                        Ke(i) ? (n = i.ianaTz,
                        t = i.ianaTz,
                        this.selectedTz = i) : (t = this.unknownTz.ianaTz,
                        this.selectedTz = this.unknownTz,
                        this._initiallyUnknownTZ = !0),
                        this.model.PosixTZ = {
                            initialValue: n,
                            value: t
                        }
                    }
                }
                $postLink() {
                    this._unWatchFormValidity = this.$scope.$watch("TZForm.$valid", (e => {
                        this._valid = e
                    }
                    ))
                }
                $onDestroy() {
                    Ke(this._unWatchFormValidity) && this._unWatchFormValidity()
                }
                getResults() {
                    const e = {
                        TimeZone: {}
                    }
                      , {DaylightSavings: t, PosixTZ: n} = this.model;
                    if (Ke(t) && (e.TimeZone.DaylightSavings = JSON.stringify(t.value)),
                    Ke(n))
                        if (n.value === this.unknownTz.posixTz)
                            e.TimeZone.PosixTZ = this.model.PosixTZ.initialValue;
                        else {
                            const t = this.findMappedTZ(n.value);
                            e.TimeZone.PosixTZ = Ke(t) ? t.posixTz : n.initialValue
                        }
                    return e
                }
                findMappedTZ(e) {
                    return this.tzList.find((t => t.ianaTz === e || t.posixTz === e))
                }
                selectedTzChanged() {
                    Ke(this.selectedTz) && Ke(this.model.DaylightSavings) && Ke(this.model.PosixTZ) && (this.model.DaylightSavings.value = this.selectedTz.supportsDst,
                    this.model.PosixTZ.value = this.selectedTz.ianaTz)
                }
            }
            ar.$inject = ["$scope"],
            (0,
            s.module)("ipconfigure.orchid.singularity").controller("CameraEditTZFormController", ar).component("cameraEditTzForm", {
                bindings: {
                    editDialog: "<"
                },
                controller: "CameraEditTZFormController",
                controllerAs: "$ctrl",
                template: n(75977)
            });
            class rr {
                constructor(e) {
                    this.$scope = e,
                    this.tpMode = "AUTO",
                    this._valid = !0
                }
                get valid() {
                    return this._valid
                }
                $onInit() {
                    this.msgs = L.messages.cameras,
                    this.camera = this.editDialog.camera;
                    const e = this.camera.configuration.TransportProtocol;
                    Ke(e) && (this.tpMode = "string" == typeof e ? e : "AUTO"),
                    this.editDialog.registerNtpTzForm(this)
                }
                $postLink() {
                    this._unWatchFormValidity = this.$scope.$watch("TPForm.$valid", (e => {
                        this._valid = e
                    }
                    ))
                }
                $onDestroy() {
                    Ke(this._unWatchFormValidity) && this._unWatchFormValidity()
                }
                getResults() {
                    return {
                        TransportProtocol: this.tpMode
                    }
                }
                selectedTpChanged() {
                    this._valid = Ke(this.tpMode)
                }
            }
            rr.$inject = ["$scope"],
            (0,
            s.module)("ipconfigure.orchid.singularity").controller("CameraEditTpFormController", rr).component("cameraEditTpForm", {
                bindings: {
                    editDialog: "<"
                },
                controller: "CameraEditTpFormController",
                controllerAs: "$ctrl",
                template: n(176)
            });
            class sr {
                constructor(e, t, n, i, a, r) {
                    this.dialogFor = e,
                    this.camera = t,
                    this.cameraTzInfo = n,
                    this.orchid = i,
                    this.OrchidDataService = a,
                    this.$mdDialog = r,
                    this.error = void 0,
                    this._processing = !1
                }
                get processing() {
                    return this._processing
                }
                get valid() {
                    return !!this._form && this._form.valid
                }
                clearErrors() {
                    this.error = void 0,
                    this.errorFields = void 0
                }
                closeDialog(e) {
                    this.$mdDialog.hide(e)
                }
                cancel() {
                    this.$mdDialog.cancel()
                }
                updateCamera() {
                    this._processing = !0,
                    this.clearErrors(),
                    this.OrchidDataService.updateCamera(this.orchid, this.camera, {
                        configuration: Ke(this._form) ? Object.assign({}, this.camera.configuration, this._form.getResults()) : this.camera.configuration
                    }).then(( ({data: {camera: e}}) => {
                        this._processing = !1,
                        this.camera.configuration = e.configuration,
                        this.closeDialog(this.camera)
                    }
                    )).catch((e => {
                        var t, n, i;
                        this._processing = !1;
                        let a = null !== (n = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.reason) && void 0 !== n ? n : null === (i = null == e ? void 0 : e.data) || void 0 === i ? void 0 : i.message;
                        Ke(a) || (a = L.messages.errors.unexpectedErrorOccurred()),
                        this.error = a
                    }
                    ))
                }
                registerNtpTzForm(e) {
                    this._form = e
                }
            }
            sr.$inject = ["dialogFor", "camera", "cameraTzInfo", "orchid", "OrchidDataService", "$mdDialog"],
            (0,
            s.module)("ipconfigure.orchid.singularity").controller("CameraNtpTimezoneEditDialogController", sr);
            var or, cr = n(83610), lr = n(79878), dr = n(47753);
            let ur = class {
                constructor(e) {
                    this._http = e,
                    this._orchidSessionIdMap = {}
                }
                getSessionId$(e) {
                    var t;
                    return void 0 === this._orchidSessionIdMap[e] && (this._orchidSessionIdMap[e] = new P.X(""),
                    this._postOrchidSessionId(e).pipe((0,
                    He.U)((e => e.orchidSessionId)), (0,
                    lr.K)((t => (delete this._orchidSessionIdMap[e],
                    (0,
                    cr._)(t))))).subscribe(this._orchidSessionIdMap[e])),
                    null === (t = this._orchidSessionIdMap[e]) || void 0 === t ? void 0 : t.pipe((0,
                    dr.T)(1))
                }
                getSessionId(e) {
                    var t;
                    return null === (t = this._orchidSessionIdMap[e]) || void 0 === t ? void 0 : t.value
                }
                setSessionId(e, t) {
                    void 0 !== this._orchidSessionIdMap[e] ? this._orchidSessionIdMap[e].next(t) : this._orchidSessionIdMap[e] = new P.X(t)
                }
                hasSessionId(e) {
                    const t = this._orchidSessionIdMap[e];
                    return null != t
                }
                clearSessionIds() {
                    this._orchidSessionIdMap = {}
                }
                clearSessionId(e) {
                    delete this._orchidSessionIdMap[e]
                }
                _postOrchidSessionId(e) {
                    return this._http.post(`${w.baseUrl}/service/orchids/${e}/session/load`, null, {
                        params: {
                            fsid: this.getLocalSessionId()
                        }
                    })
                }
                getLocalSessionId() {
                    var e;
                    return null !== (e = window.localStorage.getItem(this._sessionIdKey)) && void 0 !== e ? e : ""
                }
                clearLocalSessionId() {
                    window.localStorage.removeItem(this._sessionIdKey)
                }
                storeLocalSessionId(e) {
                    window.localStorage.setItem(this._sessionIdKey, e)
                }
                generateSessionIdKey(e, t) {
                    const n = new URL(e).origin;
                    this._sessionIdKey = `${t} - ${n}`
                }
            }
            ;
            var mr, hr, pr;
            ur = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (or = void 0 !== lt.eN && lt.eN) ? or : Object])], ur);
            let gr = class {
                constructor(e, t, n) {
                    this._http = e,
                    this._orchidProxyService = t,
                    this._sessionIdService = n
                }
                createRequest(e) {
                    const t = {
                        url: e
                    };
                    return Object.assign(Object.assign({}, t), {
                        with: (...e) => {
                            const n = {
                                proxyService: this._orchidProxyService,
                                sessionIdService: this._sessionIdService
                            }
                              , i = e.reduce(( (e, t) => t(e, n)), t);
                            return Object.assign(Object.assign({}, i), {
                                get: () => this._http.get(i.url, {
                                    params: i.params,
                                    headers: i.headers,
                                    withCredentials: i.withCredentials
                                }),
                                post: e => this._http.post(i.url, e, {
                                    params: i.params,
                                    headers: i.headers,
                                    withCredentials: i.withCredentials
                                }),
                                put: e => this._http.put(i.url, e, {
                                    params: i.params,
                                    headers: i.headers,
                                    withCredentials: i.withCredentials
                                }),
                                patch: e => this._http.patch(i.url, e, {
                                    params: i.params,
                                    headers: i.headers,
                                    withCredentials: i.withCredentials
                                }),
                                delete: e => this._http.delete(i.url, {
                                    params: i.params,
                                    headers: i.headers,
                                    withCredentials: i.withCredentials,
                                    body: e
                                }),
                                head: () => this._http.head(i.url, {
                                    params: i.params,
                                    headers: i.headers,
                                    withCredentials: i.withCredentials
                                }),
                                toUrl: () => i.params ? i.url + "?" + new lt.LE({
                                    fromObject: i.params
                                }).toString() : i.url
                            })
                        }
                    })
                }
            }
            ;
            function fr(e) {
                return (t, {sessionIdService: n}) => {
                    const i = {};
                    let a;
                    if (w.isOrchid ? a = n.getLocalSessionId() : (i.OrchidId = e,
                    a = n.getSessionId(e)),
                    !a)
                        throw new Error("The Recorder session ID is undefined!");
                    return void 0 !== t.headers && void 0 !== t.headers.Authorization || (i.Authorization = `Bearer ${a}`),
                    Object.assign(Object.assign({}, t), {
                        headers: Object.assign(Object.assign({}, t.headers), i)
                    })
                }
            }
            function vr(e, t) {
                return (n, {proxyService: i, sessionIdService: a}) => {
                    if (t || (t = {}),
                    t.forceProxy) {
                        const t = new URL(n.url);
                        n.url = i.orchidUri(e, {
                            forceProxy: !0
                        }) + "/" + t.pathname.replace(/^\//, "") + t.search + t.hash
                    } else
                        n.url = i.applyProxy(e, n.url);
                    if (n.url.includes("service/orchid-proxy")) {
                        const e = a.getLocalSessionId();
                        if ("" === e)
                            throw new Error("Local session ID is undefined!");
                        n.headers = Object.assign(Object.assign({}, n.headers), {
                            Authorization: `Bearer ${e}`
                        })
                    }
                    return n
                }
            }
            var yr;
            gr = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(lt.eN)), (0,
            c.fM)(1, (0,
            i.Inject)(mt)), (0,
            c.fM)(2, (0,
            i.Inject)(ur)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (mr = void 0 !== lt.eN && lt.eN) ? mr : Object, "function" == typeof (hr = void 0 !== mt && mt) ? hr : Object, "function" == typeof (pr = void 0 !== ur && ur) ? pr : Object])], gr),
            o().module("ipconfigure.orchid.singularity").service("RequestBuilderService", (0,
            r.dV)(gr));
            let br = class {
                constructor(e) {
                    this._requestBuilder = e
                }
                registerCamera(e, t) {
                    return t ? this._requestBuilder.createRequest(`${t.discoverableOrchid.baseUrl}/service/cameras`).with(vr({
                        id: t.id,
                        uri: t.uri
                    }, {
                        forceProxy: !0
                    })).post(e).pipe((0,
                    pn.q)(1)) : this._requestBuilder.createRequest(`${w.baseUrl}/service/cameras`).with(fr()).post(e).pipe((0,
                    pn.q)(1))
                }
                updateCamera(e, t, n) {
                    return n ? this._requestBuilder.createRequest(`${n.discoverableOrchid.baseUrl}/service/cameras/${t}`).with(vr({
                        id: n.id,
                        uri: n.uri
                    }, {
                        forceProxy: !0
                    })).patch(e).pipe((0,
                    pn.q)(1)) : this._requestBuilder.createRequest(`${w.baseUrl}/service/cameras/${t}`).with(fr()).patch(e).pipe((0,
                    pn.q)(1))
                }
            }
            ;
            var Sr;
            br = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(gr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (yr = void 0 !== gr && gr) ? yr : Object])], br),
            function(e) {
                e.CAMERA_RECOVERY = "2.2.2",
                e.CAMERA_CONFIG_STATS_TABLE = "2.16.0",
                e.CAMERA_TZ_LIST = "21.6.0",
                e.CAMERA_STREAMS_DISK_USAGE = "21.9.0",
                e.SECONDARY_STREAMS = "21.12.0",
                e.EVENT_SUBSCRIPTIONS = "23.6.0",
                e.AUDIT_LOGGING = "23.12.0",
                e.THUMBNAIL_SEARCH = "24.3.0",
                e.MAX_RETENTION_CAP = "24.6.0",
                e.CAMERA_SIDE_MOTION_DETECTION = "24.6.0",
                e.CAMERA_DISABLEMENT = "24.6.0",
                e.TWO_WAY_AUDIO = "24.6.0",
                e.API_UI_LINK_UPDATE = "22.12.2",
                e.RESOURCE_TAGGING = "24.9.0",
                e.MOTION_REGIONS_OVERLAY = "24.9.0",
                e.CAMERA_CONNECTION_PREFERENCE = "24.9.0",
                e.BULK_TAGGING = "24.12.0"
            }(Sr || (Sr = {}));
            let Cr = class {
                _isDevBuild(e) {
                    return 0 === e.major
                }
                _parseOrchidVersion(e) {
                    const [t,n,i] = e.version.version.split(".");
                    return {
                        major: parseInt(t),
                        minor: parseInt(n),
                        hotfix: parseInt(i)
                    }
                }
                _getFeatureVersionRequirements(e) {
                    if ("string" != typeof e)
                        return e;
                    {
                        const [t,n,i] = e.split(".");
                        return {
                            major: parseInt(t),
                            minor: parseInt(n),
                            hotfix: parseInt(i)
                        }
                    }
                }
                isFeatureSupported(e, t) {
                    const n = this._parseOrchidVersion(e);
                    if (this._isDevBuild(n))
                        return !0;
                    const i = this._getFeatureVersionRequirements(t);
                    return n.major > i.major || (n.major === i.major && n.minor > i.minor || n.major === i.major && n.minor === i.minor && n.hotfix >= i.hotfix)
                }
            }
            ;
            Cr = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            })], Cr);
            var wr, Ir = n(83286), Tr = n(51313), Er = n(11954);
            !function(e) {
                e.GENERIC_ERROR = "generic-error",
                e.EMPTY_DATA = "empty-data",
                e.EMPTY_SEARCH = "empty-search",
                e.EMPTY_SEARCH_FILTERS = "empty-search-filters",
                e.CUSTOM_ERROR = "custom-error"
            }(wr || (wr = {}));
            let _r = class {
                constructor() {
                    this.title = "",
                    this.description = "",
                    this.icon = "",
                    this.type = wr.GENERIC_ERROR,
                    this.messages = L.messages.errorBanner,
                    this.bannerTitle = "",
                    this.bannerDescription = "",
                    this.bannerIcon = ""
                }
                ngOnInit() {
                    this.setBannerIcon(),
                    this.setBannerCopy()
                }
                setBannerIcon() {
                    switch (this.type) {
                    case wr.EMPTY_SEARCH:
                    case wr.EMPTY_SEARCH_FILTERS:
                        this.bannerIcon = zt.search;
                        break;
                    case wr.GENERIC_ERROR:
                        this.bannerIcon = zt.error;
                        break;
                    case wr.CUSTOM_ERROR:
                    default:
                        this.bannerIcon = this.icon
                    }
                }
                setBannerCopy() {
                    switch (this.type) {
                    case wr.EMPTY_SEARCH:
                    case wr.EMPTY_SEARCH_FILTERS:
                        this.bannerTitle = this.messages.noResultFound();
                        break;
                    case wr.GENERIC_ERROR:
                        this.bannerTitle = this.messages.somethingWentWrong();
                        break;
                    case wr.CUSTOM_ERROR:
                    default:
                        this.bannerTitle = this.title
                    }
                    switch (this.type) {
                    case wr.EMPTY_SEARCH:
                        this.bannerDescription = this.messages.tryUsingDifferentKeyword();
                        break;
                    case wr.EMPTY_SEARCH_FILTERS:
                        this.bannerDescription = this.messages.tryUsingDifferentKeywordOrFilterOption();
                        break;
                    case wr.GENERIC_ERROR:
                        this.bannerDescription = this.messages.pleaseTryAgain();
                        break;
                    case wr.CUSTOM_ERROR:
                    default:
                        this.bannerDescription = this.description
                    }
                }
            }
            ;
            var xr, Dr, Or, Ar, Rr, Pr, kr, Mr, Lr, Nr, Fr, Ur;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], _r.prototype, "title", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], _r.prototype, "description", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], _r.prototype, "icon", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], _r.prototype, "type", void 0),
            _r = (0,
            c.gn)([(0,
            i.Component)({
                selector: "error-banner",
                template: n(8070)
            })], _r),
            function(e) {
                e[e.LOADING = 0] = "LOADING",
                e[e.LOADED = 1] = "LOADED",
                e[e.ERROR = 2] = "ERROR"
            }(xr || (xr = {}));
            const $r = O("onvifBulkRegistrationComponent");
            var jr;
            !function(e) {
                e.HTTP = "http",
                e.HTTPS = "https"
            }(jr || (jr = {}));
            let Vr = class {
                constructor(e, t, n, a) {
                    this._dataService = e,
                    this._renewableService = t,
                    this._minimumVersionService = n,
                    this._cameraManagementService = a,
                    this.onClose = new i.EventEmitter,
                    this.ConnectionProtocol = jr,
                    this.InformationIcons = zt,
                    this.ActionsIcons = Ht,
                    this.ERROR_TYPE = wr,
                    this.ComponentState = xr,
                    this.componentState = xr.LOADING,
                    this.connectionPreference = jr.HTTP,
                    this._allowAlternateProtocolConnection = !1,
                    this._ignoreTlsCertification = !1,
                    this.cameraConnectionPreferenceIsSupported = !0,
                    this._destroy$ = new St.x,
                    this.onRegistrationStart = new i.EventEmitter,
                    this.onRegistrationEnd = new i.EventEmitter,
                    this.msgs = Object.assign(Object.assign(Object.assign(Object.assign({}, L.messages.cameras), L.messages.onvifBulkRegistration), L.messages.cameras.connectionPreference), L.messages.common),
                    this.formMsgs = Object.assign(Object.assign({}, L.messages.credentialsForm), {
                        errors: L.messages.errors
                    }),
                    this._discoverableCameras = [],
                    this._camerasForRegister = [],
                    this.noData = !1,
                    this.processing = !1,
                    this.processingRefresh = !1,
                    this.registrationStatus = {
                        show: !1,
                        errors: [],
                        progress: 0,
                        progressPercentage: 0,
                        total: 0,
                        complete: !1
                    },
                    this.allFilteredCamsChecked = !1,
                    this.someFilteredCamsChecked = !1,
                    this.totalCamerasSelected = 0,
                    this.totalFilteredCamerasSelected = 0,
                    this.pageSizeOptions = [30, 40, 50],
                    this.pageSize = 30,
                    this.filter = "",
                    this.displayedColumns = ["camera-status", "registered", "name", "ip-address", "registrationError"],
                    this.dataSource = new Ei.by;
                    const r = new p.qu;
                    this.credentialsForm = r.group({
                        username: new p.NI(""),
                        password: new p.NI("")
                    })
                }
                ngOnInit() {
                    w.isOrchid || (this.cameraConnectionPreferenceIsSupported = this._minimumVersionService.isFeatureSupported(this.orchid, Sr.CAMERA_CONNECTION_PREFERENCE))
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                set matPaginator(e) {
                    e && this.dataSource && (this.dataSource.paginator = e)
                }
                set matSort(e) {
                    e && this.dataSource && (this.sort = e,
                    this.dataSource.sort = this.sort)
                }
                ngAfterViewInit() {
                    this._getDiscoveredCameras(),
                    this.dataSource.data = this._discoverableCameras,
                    this.dataSource.sortingDataAccessor = this._sortingDataAccessor,
                    this.totalCamerasSelected = this.dataSource.data.filter((e => e.selected)).length,
                    this.totalFilteredCamerasSelected = this.dataSource.filteredData.filter((e => e.selected)).length,
                    this._sortDiscoveredCamerasList(this.dataSource.data)
                }
                _getDiscoveredCameras() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.componentState = xr.LOADING;
                        try {
                            const e = yield this._dataService.getDiscoverableCameras(this.orchid);
                            this._discoverableCameras = e.cameras,
                            this._discoverableCameras = this._discoverableCameras.map((e => Object.assign(Object.assign({}, e), {
                                name: decodeURI(e.name),
                                hardware: decodeURI(e.hardware),
                                selected: !1,
                                registered: !1,
                                registrationMessage: "",
                                status: "checkbox"
                            }))),
                            this.noData = 0 === this._discoverableCameras.length,
                            this._checkIfRegistered(this._discoverableCameras),
                            this.refreshTable(),
                            this._sortDiscoveredCamerasList(this.dataSource.data),
                            this.error = void 0,
                            this.componentState = xr.LOADED
                        } catch (e) {
                            this.componentState = xr.ERROR,
                            this.noData = !0,
                            $r.error(e)
                        }
                    }
                    ))
                }
                _checkIfRegistered(e) {
                    e.forEach((e => {
                        this.orchid.cameras.some((t => {
                            t.configuration.IPAddress === e.ip && (e.registered = !0)
                        }
                        ))
                    }
                    ))
                }
                refreshTable() {
                    this.dataSource.data = this._discoverableCameras,
                    this.updateNumCamsSelected()
                }
                refresh() {
                    !0 !== this.processingRefresh && (this.processingRefresh = !0,
                    this.componentState = xr.LOADING,
                    setTimeout(( () => {
                        this.dataSource.filter = "",
                        this.filter = "",
                        this.processingRefresh = !1,
                        this.allFilteredCamsChecked = !1,
                        this.totalCamerasSelected = 0,
                        this._getDiscoveredCameras(),
                        this.processing = !1,
                        this.registrationStatus.show = !1,
                        this.registrationStatus.complete = !1
                    }
                    ), 333))
                }
                _sortingDataAccessor(e, t) {
                    switch (t) {
                    case "name":
                        return e.name.toLocaleLowerCase();
                    case "registered":
                        return e.registered ? 0 : 1;
                    case "ip-address":
                        return e.ip.split(".").map((e => ("000" + e).slice(-3))).join(".");
                    case "registrationError":
                        return e.registrationMessage;
                    default:
                        return e[t]
                    }
                }
                firstPage() {
                    this.dataSource.paginator && this.dataSource.paginator.firstPage()
                }
                applyFilter(e) {
                    const t = e.target.value;
                    this.dataSource.filter = t.trim().toLowerCase(),
                    this.updateNumCamsSelected(),
                    this.firstPage()
                }
                updateNumCamsSelected() {
                    this.totalCamerasSelected = this.dataSource.data.filter((e => e.selected)).length,
                    this.totalFilteredCamerasSelected = this.dataSource.filteredData.filter((e => e.selected)).length,
                    this.someFilteredCamsChecked = this.totalFilteredCamerasSelected > 0 && this.totalFilteredCamerasSelected < this.dataSource.filteredData.length,
                    this.allFilteredCamsChecked = this.totalFilteredCamerasSelected === this.dataSource.filteredData.length
                }
                onBulkCheckboxChange(e) {
                    const t = e.checked
                      , n = e.source.indeterminate;
                    0 !== this.dataSource.data.length && (!1 === t || n ? (e.source.checked = !1,
                    this.dataSource.filteredData.forEach((e => {
                        e.selected = !1
                    }
                    ))) : this.dataSource.filteredData.forEach((e => {
                        this.connectionPreferenceIsNotSupported(e) || (e.selected = !0)
                    }
                    )),
                    this.updateNumCamsSelected())
                }
                onRowClick(e) {
                    !0 !== this.processing && (e.selected = !e.selected),
                    this.updateNumCamsSelected()
                }
                get isRegisterButtonDisabled() {
                    return !(!this.processing && !this.credentialsForm.invalid) || 0 === this.totalCamerasSelected
                }
                getUsernameErrorMessage() {
                    return this.credentialsForm.controls.username.hasError("required") ? L.messages.errors.username.usernameRequired() : ""
                }
                getPasswordErrorMessage() {
                    return this.credentialsForm.controls.password.hasError("required") ? L.messages.errors.password.passwordRequired() : ""
                }
                handleRegisterButtonClick() {
                    if (this.onRegistrationStart.emit(),
                    this.processing = !0,
                    this.dataSource.filter = "",
                    this.filter = "",
                    this.firstPage(),
                    this.registrationStatus.complete)
                        return this.retryFailedCameras();
                    this._registerCameras()
                }
                _registerCamera(e) {
                    const t = this._getCameraPOSTBody(e)
                      , n = w.isOrchid ? this._cameraManagementService.registerCamera(t) : this._cameraManagementService.registerCamera(t, this.orchid);
                    return this._getErrorHandlingRequest$(e, n)
                }
                _getCameraPOSTBody(e) {
                    const t = this.credentialsForm.value.username
                      , n = this.credentialsForm.value.password;
                    return {
                        driver: Q.ONVIF,
                        name: e.ip,
                        connection: {
                            verifySslCerts: this.cameraConnectionPreferenceIsSupported ? !this._ignoreTlsCertification : void 0,
                            uri: this.cameraConnectionPreferenceIsSupported ? this._getCameraConnectionUri(e) : e.url,
                            username: t,
                            password: n
                        }
                    }
                }
                _getCameraConnectionUri(e) {
                    const t = new URL(e.url);
                    if (t) {
                        if (this.connectionPreference === jr.HTTPS) {
                            if (this._allowAlternateProtocolConnection) {
                                return this.getSupportedProtocols(e).includes(jr.HTTPS) ? `${jr.HTTPS}://${t.host}${t.pathname}` : `${jr.HTTP}://${t.host}${t.pathname}`
                            }
                            return `${jr.HTTPS}://${t.host}${t.pathname}`
                        }
                        if (this.connectionPreference === jr.HTTP)
                            return `${jr.HTTP}://${t.host}${t.pathname}`
                    }
                    return e.url
                }
                _getErrorHandlingRequest$(e, t) {
                    return t.pipe((0,
                    pn.q)(1), (0,
                    sa.b)(( () => {
                        e.status = "success",
                        this.registrationStatus.progress += 1,
                        this.registrationStatus.progressPercentage = this.registrationStatus.progress / this.registrationStatus.total * 100,
                        e.registrationMessage = this.msgs.success()
                    }
                    )), (0,
                    lr.K)((t => (e.status = "failure",
                    $r.error(t),
                    t.error.code && t.error.reason ? e.registrationMessage = t.error.code + ": " + t.error.reason : e.registrationMessage = L.messages.errors.unexpectedErrorOccurred(),
                    this.registrationStatus.errors.push(e.registrationMessage),
                    this.registrationStatus.progress += 1,
                    this.registrationStatus.progressPercentage = this.registrationStatus.progress / this.registrationStatus.total * 100,
                    (0,
                    ze.of)(t)))), (0,
                    Ir.x)(( () => {
                        this.dataSource.data = this.dataSource.sortData(this._camerasForRegister, this.sort)
                    }
                    )))
                }
                _registerCameras() {
                    this.processing = !0,
                    this.processingRefresh = !0,
                    this.credentialsForm.controls.username.disable(),
                    this.credentialsForm.controls.password.disable(),
                    this.registrationStatus = {
                        show: !0,
                        errors: [],
                        progress: 0,
                        progressPercentage: 0,
                        total: 0,
                        complete: !1
                    },
                    this.allFilteredCamsChecked = !1,
                    this._camerasForRegister = this.dataSource.data.filter((e => e.selected)),
                    this.registrationStatus.total = this._camerasForRegister.length,
                    this.dataSource.data = this.dataSource.sortData(this._camerasForRegister, this.sort),
                    this.dataSource.data.forEach((e => {
                        e.registrationMessage = this.msgs.pending(),
                        e.status = "blank"
                    }
                    )),
                    this.totalCamerasSelected = 0,
                    (0,
                    Er.D)(this.dataSource.data).pipe((0,
                    Tr.b)((e => (e.status = "processing",
                    this._registerCamera(e)))), (0,
                    Ir.x)(( () => {
                        this.processing = !1,
                        this.processingRefresh = !1,
                        this.credentialsForm.controls.username.enable(),
                        this.credentialsForm.controls.password.enable(),
                        this.registrationStatus.complete = !0,
                        this._renewableService.refreshCameras(this.orchid),
                        0 === this.registrationStatus.errors.length && this.onClose.emit(),
                        this.totalCamerasSelected = this.registrationStatus.errors.length,
                        this.onRegistrationEnd.emit()
                    }
                    )), (0,
                    oa.R)(this._destroy$)).subscribe()
                }
                retryFailedCameras() {
                    this.registrationStatus.complete = !1,
                    this.dataSource.data.forEach((e => {
                        e.selected = !this.connectionPreferenceIsNotSupported(e) && "success" !== e.status
                    }
                    )),
                    this._registerCameras()
                }
                isPaginationVisible() {
                    const e = this.dataSource.filteredData.length;
                    return !(this.noData || e <= this.pageSizeOptions[0])
                }
                getSupportedProtocols(e) {
                    const t = [];
                    if (this.cameraConnectionPreferenceIsSupported && e.urls)
                        e.urls.forEach((e => {
                            const n = e.split(":").at(0);
                            n && !t.includes(n) && t.push(n)
                        }
                        ));
                    else {
                        const n = e.url.split(":").at(0);
                        n && t.push(n)
                    }
                    return t
                }
                _sortDiscoveredCamerasList(e) {
                    this.dataSource.data = e.sort(( (e, t) => {
                        const n = this.getSupportedProtocols(e)
                          , i = this.getSupportedProtocols(t);
                        if (!n.includes(this.connectionPreference) && i.includes(this.connectionPreference))
                            return 1;
                        if (n.includes(this.connectionPreference) && !i.includes(this.connectionPreference))
                            return -1;
                        if (n.includes(this.connectionPreference) && i.includes(this.connectionPreference)) {
                            if (n.length < i.length)
                                return -1;
                            if (n.length > i.length)
                                return 1
                        }
                        return 0
                    }
                    ))
                }
                handleConnectionPreferenceChange() {
                    this._allowAlternateProtocolConnection = !1,
                    this._ignoreTlsCertification = !1,
                    this.sort.sort({
                        id: "",
                        start: "asc",
                        disableClear: !1
                    }),
                    this.dataSource.data.forEach((e => {
                        this.registrationStatus.complete ? e.selected = !this.connectionPreferenceIsNotSupported(e) && "failure" === e.status : this.connectionPreferenceIsNotSupported(e) && (e.selected = !1)
                    }
                    )),
                    this._sortDiscoveredCamerasList(this.dataSource.data),
                    this.updateNumCamsSelected(),
                    this.firstPage()
                }
                connectionPreferenceIsNotSupported(e) {
                    return !!this.cameraConnectionPreferenceIsSupported && (!this._allowAlternateProtocolConnection && !this.getSupportedProtocols(e).includes(this.connectionPreference))
                }
                handleAlternateProtocolCheckboxChange(e) {
                    this._allowAlternateProtocolConnection = e.checked,
                    this.dataSource.filteredData.forEach((e => {
                        this.registrationStatus.complete ? e.selected = !this.connectionPreferenceIsNotSupported(e) && "failure" === e.status : this.connectionPreferenceIsNotSupported(e) && (e.selected = !1)
                    }
                    )),
                    this._sortDiscoveredCamerasList(this.dataSource.data),
                    this.updateNumCamsSelected(),
                    this.firstPage()
                }
                handleIgnoreTlsCertCheckboxChange(e) {
                    this._ignoreTlsCertification = e.checked
                }
                bulkCheckboxIsDisabled() {
                    return this.cameraConnectionPreferenceIsSupported ? 0 === this.dataSource.filteredData.filter((e => !this.connectionPreferenceIsNotSupported(e))).length : 0 === this.dataSource.filteredData.length
                }
            }
            ;
            var Gr, Br;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Vr.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (Dr = void 0 !== i.EventEmitter && i.EventEmitter) ? Dr : Object)], Vr.prototype, "onClose", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (Or = void 0 !== i.EventEmitter && i.EventEmitter) ? Or : Object)], Vr.prototype, "onRegistrationStart", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (Ar = void 0 !== i.EventEmitter && i.EventEmitter) ? Ar : Object)], Vr.prototype, "onRegistrationEnd", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW, {
                static: !1
            }), (0,
            c.w6)("design:type", "function" == typeof (Rr = void 0 !== pi.NW && pi.NW) ? Rr : Object), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Pr = void 0 !== pi.NW && pi.NW) ? Pr : Object])], Vr.prototype, "matPaginator", null),
            (0,
            c.gn)([(0,
            i.ViewChild)(Ii.YE, {
                static: !1
            }), (0,
            c.w6)("design:type", "function" == typeof (kr = void 0 !== Ii.YE && Ii.YE) ? kr : Object), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Mr = void 0 !== Ii.YE && Ii.YE) ? Mr : Object])], Vr.prototype, "matSort", null),
            Vr = (0,
            c.gn)([(0,
            i.Component)({
                selector: "onvif-bulk-registration",
                template: n(285)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pt)), (0,
            c.fM)(1, (0,
            i.Inject)(Gt)), (0,
            c.fM)(2, (0,
            i.Inject)(Cr)), (0,
            c.fM)(3, (0,
            i.Inject)(br)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Lr = pt) ? Lr : Object, "function" == typeof (Nr = Gt) ? Nr : Object, "function" == typeof (Fr = void 0 !== Cr && Cr) ? Fr : Object, "function" == typeof (Ur = void 0 !== br && br) ? Ur : Object])], Vr);
            let zr = class {
                constructor(e, t, n) {
                    var i, a;
                    this._cameraManagementService = e,
                    this._dialogData = t,
                    this._dialogRef = n,
                    this.ActionsIcons = Ht,
                    this.ConnectionProtocol = jr,
                    this.errorMessage = "",
                    this.processing = !1,
                    this._cameraConnectionUri = "",
                    this.ignoreTlsCerts = !1,
                    this.msgs = Object.assign(Object.assign(Object.assign(Object.assign({}, L.messages.cameras), L.messages.cameras.configurationProtocol), L.messages.cameras.connectionPreference), {
                        cancel: L.messages.common.cancel
                    }),
                    this._cameraConnectionUri = null !== (i = this._dialogData.camera.connectionUri) && void 0 !== i ? i : "",
                    this.ignoreTlsCerts = null !== (a = !this._dialogData.camera.verifySslCerts) && void 0 !== a && a,
                    this.selectedProtocol = this._cameraConnectionUri.split(":").at(0)
                }
                handleConfigProtocolChange(e) {
                    var t;
                    const n = null === (t = this._cameraConnectionUri) || void 0 === t ? void 0 : t.split(":").at(1);
                    n && (this._cameraConnectionUri = `${e.value}:${n}`)
                }
                close(e) {
                    this.processing || this._dialogRef.close(e)
                }
                handleErrorMessageClose() {
                    this.errorMessage = ""
                }
                saveConfigurationProtocol() {
                    this.errorMessage = "",
                    this.processing = !0;
                    const e = {
                        connection: {
                            verifySslCerts: !this.ignoreTlsCerts,
                            uri: this._cameraConnectionUri
                        }
                    };
                    (w.isOrchid ? this._cameraManagementService.updateCamera(e, this._dialogData.camera.id) : this._cameraManagementService.updateCamera(e, this._dialogData.camera.id, this._dialogData.orchid)).subscribe({
                        next: e => {
                            this.processing = !1,
                            this.close(!0)
                        }
                        ,
                        error: e => {
                            this.processing = !1,
                            this.errorMessage = e.error.reason
                        }
                    })
                }
            }
            ;
            var Hr, Wr, qr, Yr;
            (0,
            c.gn)([(0,
            i.HostListener)("keydown.enter"), (0,
            c.w6)("design:type", Function), (0,
            c.w6)("design:paramtypes", []), (0,
            c.w6)("design:returntype", void 0)], zr.prototype, "saveConfigurationProtocol", null),
            zr = (0,
            c.gn)([(0,
            i.Component)({
                selector: "camera-configuration-protocol-dialog",
                template: n(80781)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(br)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.so)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Gr = void 0 !== br && br) ? Gr : Object, Object, "function" == typeof (Br = void 0 !== hn.so && hn.so) ? Br : Object])], zr);
            let Xr = class {
                constructor(e, t, n, i, a) {
                    this._dialogData = e,
                    this._dialogRef = t,
                    this._formBuilder = n,
                    this._minimumVersionService = i,
                    this._cameraManagementService = a,
                    this.msgs = Object.assign(Object.assign(Object.assign(Object.assign({}, L.messages.cameras), L.messages.credentialsForm), L.messages.cameras.connectionPreference), L.messages.cameras.cameraManualAdd),
                    this.ActionsIcons = Ht,
                    this.recoverCameraForm = this._formBuilder.group({
                        discoveryUrl: new p.NI(this._dialogData.camera.connectionUri,[p.kI.required]),
                        username: new p.NI("",[p.kI.required]),
                        password: new p.NI("",[p.kI.required]),
                        ignoreTlsCerts: new p.NI(!this._dialogData.camera.verifySslCerts)
                    }),
                    this.cameraConnectionPreferenceIsSupported = !0,
                    this.showTlsIgnoreCheckbox = !1,
                    this._destroy$ = new St.x,
                    this.processing = !1,
                    this.errorMessage = "",
                    this.ignoreTlsCerts = !1
                }
                ngOnInit() {
                    var e, t, n, i;
                    if (w.isOrchid || (this.cameraConnectionPreferenceIsSupported = this._minimumVersionService.isFeatureSupported(this._dialogData.orchid, Sr.CAMERA_CONNECTION_PREFERENCE)),
                    this.cameraConnectionPreferenceIsSupported) {
                        const a = null === (e = this.recoverCameraForm.get("discoveryUrl")) || void 0 === e ? void 0 : e.value.split(":").at(0);
                        this.showTlsIgnoreCheckbox = a === jr.HTTPS,
                        this.ignoreTlsCerts = null !== (t = !this._dialogData.camera.verifySslCerts) && void 0 !== t && t,
                        null === (n = this.recoverCameraForm.get("discoveryUrl")) || void 0 === n || n.valueChanges.pipe((0,
                        oa.R)(this._destroy$)).subscribe({
                            next: e => {
                                var t;
                                const n = null === (t = e.split(":").at(0)) || void 0 === t ? void 0 : t.toLowerCase();
                                this.showTlsIgnoreCheckbox = !!n && n === jr.HTTPS
                            }
                        }),
                        null === (i = this.recoverCameraForm.get("ignoreTlsCerts")) || void 0 === i || i.valueChanges.pipe((0,
                        oa.R)(this._destroy$)).subscribe({
                            next: e => {
                                this.ignoreTlsCerts = e
                            }
                        })
                    }
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                close(e) {
                    this._dialogRef.close(e)
                }
                recoverCamera() {
                    var e, t, n, i, a, r;
                    this.errorMessage = "",
                    this.processing = !0;
                    const s = {
                        connection: {
                            verifySslCerts: this.cameraConnectionPreferenceIsSupported ? !this.ignoreTlsCerts : void 0,
                            uri: null !== (t = null === (e = this.recoverCameraForm.get("discoveryUrl")) || void 0 === e ? void 0 : e.value) && void 0 !== t ? t : "",
                            username: null !== (i = null === (n = this.recoverCameraForm.get("username")) || void 0 === n ? void 0 : n.value) && void 0 !== i ? i : "",
                            password: null !== (r = null === (a = this.recoverCameraForm.get("password")) || void 0 === a ? void 0 : a.value) && void 0 !== r ? r : ""
                        }
                    };
                    (w.isOrchid ? this._cameraManagementService.updateCamera(s, this._dialogData.camera.id) : this._cameraManagementService.updateCamera(s, this._dialogData.camera.id, this._dialogData.orchid)).subscribe({
                        next: e => {
                            this.processing = !1,
                            this.close(e)
                        }
                        ,
                        error: e => {
                            this.processing = !1,
                            this.errorMessage = e.error.reason
                        }
                    })
                }
                handleClosingError() {
                    this.errorMessage = ""
                }
            }
            ;
            function Kr(e, t, i, a, r, s, o, c, l, d, u, m) {
                var h = this;
                function p(e, t, i, a) {
                    var s, o = {
                        template: n(58496),
                        controller: "StreamDialogController as streamDialog",
                        parent: angular.element(document.body),
                        targetEvent: t,
                        clickOutsideToClose: !1,
                        escapeToClose: !1,
                        locals: {
                            orchid: h.orchid,
                            camera: h.cameraCopy,
                            originalStream: e
                        }
                    };
                    for (s in h.cameraCopy.capabilities.stream)
                        !0 === Object.prototype.hasOwnProperty.call(h.cameraCopy.capabilities.stream, s) && g(h.cameraCopy.capabilities.stream, s);
                    a || (a = function() {}
                    ),
                    r.show(o).then(i, a).finally((function() {
                        c.refreshCameras(h.orchid)
                    }
                    ))
                }
                function g(e, t) {
                    var n, i;
                    if (e.categoryArrays || (e.categoryArrays = {}),
                    !e.categoryArrays[t + "Array"] && e[t]) {
                        for (e.categoryArrays[t + "Array"] = Dt(e[t], !0),
                        n = 0; n < e.categoryArrays[t + "Array"].length; n += 1)
                            e.categoryArrays[t + "Array"][n].value && "string" != typeof e.categoryArrays[t + "Array"][n].value.type && (e.categoryArrays[t + "Array"].splice(n, 1),
                            n -= 1);
                        for (n = 0; n < e.categoryArrays[t + "Array"].length; n += 1)
                            if (e.categoryArrays[t + "Array"][n].value.capabilities)
                                for (i in e.categoryArrays[t + "Array"][n].value.capabilities)
                                    Object.prototype.hasOwnProperty.call(e.categoryArrays[t + "Array"][n].value.capabilities, i) && (e.categoryArrays[t + "Array"][n].value.capabilitiesArray || (e.categoryArrays[t + "Array"][n].value.capabilitiesArray = {}),
                                    e.categoryArrays[t + "Array"][n].value.capabilitiesArray[i] = Dt(e.categoryArrays[t + "Array"][n].value.capabilities[i], !1))
                    }
                }
                function f() {
                    h.camera.streams.forEach((function(e) {
                        v(e)
                    }
                    ))
                }
                function v(e) {
                    h.streamsMap[e.id] || (h.streamsMap[e.id] = {
                        id: e.id,
                        extras: {}
                    });
                    const t = {
                        isPrimary: h.camera.primaryStream.id === e.id,
                        isSecondary: !1,
                        isDisabled: !1,
                        isSecondaryRecording: !1,
                        isSecondaryProxy: !1
                    };
                    if (!t.isPrimary) {
                        const i = (n = e.id,
                        h.camera.secondaryStreams ? h.camera.secondaryStreams.find((function(e) {
                            return n === e.id
                        }
                        )) : void 0);
                        i && (t.isSecondary = !0,
                        i.recording ? t.isSecondaryRecording = !0 : t.isSecondaryProxy = !0)
                    }
                    var n;
                    t.isDisabled = !t.isPrimary && !t.isSecondary,
                    h.streamsMap[e.id].extras = t
                }
                async function y(e) {
                    await h.ActiveStreamStateService.pollStreamStatusAndUpdateActiveStreamsMap(e),
                    v(e)
                }
                function b() {
                    if (h.currentMotionStyle = void 0,
                    h.recovering = !1,
                    h.recoveringForced = !0,
                    h.selectedStream = void 0,
                    h.processingFusionCameraStreams = !1,
                    h.canRecoverCamera = h.isCameraRecoverable(),
                    h.failureCameraSettings = "",
                    h.failureStream = "",
                    h.connection = {
                        uri: "http://" + h.cameraCopy.configuration.IPAddress + "/onvif/device_service"
                    },
                    h.streamsMap = {},
                    h.camera.primaryStream && h.camera.primaryStream.recordingConfiguration) {
                        var e = h.camera.primaryStream.recordingConfiguration.bgseg;
                        h.motionMaskEnabled = e.motionMask && e.motionMask.href
                    }
                    if (h.hasTalkDown = !!h.camera.capabilities.camera.Talkdown,
                    h.hasTalkDown) {
                        h.talkDownEnabled = !0;
                        const e = h.camera.configuration;
                        e.Talkdown && "false" === e.Talkdown.enabled && (h.talkDownEnabled = !1)
                    }
                    void 0 !== h.camera.streams || w.isOrchid ? f() : (h.processingFusionCameraStreams = !0,
                    o.fetchCameraStreams(h.orchid, h.camera.id).then((function(e) {
                        h.camera.streams = e,
                        f(),
                        h.processingFusionCameraStreams = !1
                    }
                    )).catch((function(e) {
                        h.camera.streams = [],
                        h.processingFusionCameraStreams = !1
                    }
                    ))),
                    void 0 === h.cameraProcessing && (h.cameraProcessing = !1),
                    h.isPrimaryStreamDefined = !se(h.camera.primaryStream),
                    h.isPrimaryStreamDefined || (h.openStats = !1),
                    function() {
                        try {
                            h.currentMotionStyle = Va(h.camera.primaryStream)
                        } catch (e) {
                            h.currentMotionStyle = ja
                        }
                    }(),
                    S(h.camera.primaryStream),
                    h.refreshPrimaryStreamProxyUrl(),
                    g(h.cameraCopy.capabilities, "camera"),
                    h.camera.displayModel = h.camera.driver === Q.ONVIF ? h.camera.configuration.Manufacturer + " " + h.camera.configuration.Model.replace(h.camera.configuration.Manufacturer + " ", "") : h.msgs.unknownGenericRTSP(),
                    h.displayMacAddress = h.camera.configuration.MAC ? h.camera.configuration.MAC : h.msgs.unknownGenericRTSP(),
                    h.showMacAddressCopy = !!h.camera.configuration.MAC
                }
                function S(e) {
                    h.camera.primaryStream && e.configuration && (h.camera.driver === Q.ONVIF ? h.camera.primaryStream.rtsp = e.configuration.Resource : (e.configuration.General.Path = void 0 !== e.configuration.General.Path ? e.configuration.General.Path : "",
                    h.camera.primaryStream.rtsp = h.camera.configuration.BaseUri + e.configuration.General.Path))
                }
                h._matDialog = s,
                h.initialized = !1,
                h.ActiveStreamStateService = l,
                h.CameraDriverType = Q,
                h.cameraStats = [],
                h.numRowStats = 0,
                h.lastVideoWritten = "",
                h.metadataStats = [],
                h.noMetadataStats = !1,
                h.unavailableStat = "-",
                h.showStats = !0,
                h.disableSecondaryStreamFeature = !1,
                h.disableTable = !0,
                h.openStats = !1,
                h.supportsResourceTagging = !1,
                h.hasTalkDown = !1,
                h.talkDownEnabled = !1,
                h.motionMaskEnabled = !1,
                h.watches = [],
                h.supportsEditingNTP = function() {
                    return !re(h.camera.capabilities.camera.NTP)
                }
                ,
                h.supportsEditingTZ = function() {
                    return !re(h.camera.capabilities.camera.TimeZone)
                }
                ,
                h.supportsEditingTP = function() {
                    return !re(h.camera.capabilities.camera.TransportProtocol)
                }
                ,
                h.ntpDisplay = function() {
                    return re(h.camera.configuration.NTP) || "disabled" === h.camera.configuration.NTP.Mode ? h.msgs.disabled() : "dhcp" === h.camera.configuration.NTP.Mode ? h.msgs.usesNTPSettingsFromDHCPServer() : h.camera.configuration.NTP.Server
                }
                ,
                h.tzDisplay = function() {
                    if (re(h.camera.configuration.TimeZone))
                        return h.msgs.disabled();
                    let e;
                    return null !== h.cameraTzInfo && (e = h.cameraTzInfo.find((function(e) {
                        return e.posixTz === h.camera.configuration.TimeZone.PosixTZ
                    }
                    ))),
                    re(e) ? h.msgs.unknownTZ() : e.ianaTz
                }
                ,
                h.tpDisplay = function() {
                    return re(h.camera.configuration.TransportProtocol) ? h.camera.capabilities.camera.TransportProtocol.default : h.camera.configuration.TransportProtocol
                }
                ,
                h.cameraStatusTrans = function(e) {
                    if (h.cameraDisablementIsSupported && !h.camera.active)
                        return h.msgs.statuses.disabled();
                    if (re(e))
                        return "";
                    const t = h.msgs.statuses[e];
                    return re(t) ? e : t()
                }
                ,
                h.rtspProxyUrl = "",
                h.refreshPrimaryStreamProxyUrl = function() {
                    h.camera.primaryStream && h.camera.primaryStream.id && (h.rtspProxyUrl = o.rtspUrl(h.orchid, h.camera.primaryStream.id))
                }
                ,
                h.toggleStatsTable = function() {
                    h.openStats = !h.openStats
                }
                ,
                h.formatWindowSizeTime = function(e) {
                    return e >= 60 ? e / 60 + h.msgs.minutes() : e >= 0 ? e + h.msgs.seconds() : h.unavailableStat
                }
                ,
                h.formatPacketLoss = function(e, t) {
                    return void 0 !== t && e + t ? Math.round(t / (e + t) * 100) + "%" : h.unavailableStat
                }
                ,
                h.formatAverageBits = function(e) {
                    return e > 0 ? (new Ja).transform(e) : h.unavailableStat
                }
                ,
                h.formatAverageBitsTotal = function(e, t) {
                    let n = 0;
                    return void 0 === e && void 0 === t ? h.unavailableStat : (n = e ? t ? e + t : e : t,
                    n > 0 ? (new Ja).transform(n) : h.unavailableStat)
                }
                ,
                h.formatLastVideoWritten = function(e, t) {
                    return e && t ? (new tr).transform(e) + " - " + (new er).transform(t) : e && !t ? (new tr).transform(e) + " - " + h.msgs.na() : h.unavailableStat
                }
                ,
                h.openDewarpDialog = function(e) {
                    r.show({
                        controller: "DewarpConfigController as dewarpConfig",
                        template: n(67446),
                        parent: angular.element(document.body),
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        locals: {
                            camera: h.camera,
                            orchid: h.orchid
                        },
                        onComplete: function(e, t) {
                            e.dewarpConfig.init()
                        }
                    }).catch((function() {}
                    )).finally((function() {
                        c.refreshCameras(h.orchid)
                    }
                    ))
                }
                ,
                h.updateCameraTags = async function(e) {
                    e.orchidId = h.orchid.id,
                    c.replaceCamera(angular.copy(e)),
                    await c.refreshCameras(h.orchid),
                    b()
                }
                ,
                h.deleteCamera = function(e) {
                    var n = r.confirm().theme(d.getTheme()).targetEvent(e).content(h.msgs.deleteNamedCamera({
                        VALUE: h.camera.name
                    })).ok(h.msgs.dialogs.delete()).cancel(h.msgs.dialogs.cancel());
                    r.show(n).then((function() {
                        h.deleting = !0,
                        o.deleteCamera(h.orchid, h.camera).then((function() {
                            t.$emit("change-admin-include", "admin-camera-delete-confirm"),
                            h.configuredCameras.some((function(e, t) {
                                if (e.id === h.camera.id)
                                    return h.configuredCameras.splice(t, 1),
                                    !0
                            }
                            )),
                            delete h.camera,
                            h.deleting = !1,
                            c.refreshCameras(h.orchid),
                            h.callback()
                        }
                        ), (function(e) {
                            h.deleting = !1,
                            0 !== status && (i.error(e),
                            alert("cameras/" + h.camera.id + h.msgs.deleteFailed()))
                        }
                        ))
                    }
                    )).catch((function() {
                        return angular.noop()
                    }
                    ))
                }
                ,
                h.isCameraRecoverable = function() {
                    var e = !0;
                    w.isOrchid || (e = m.isFeatureSupported(h.orchid, Sr.CAMERA_RECOVERY));
                    var t = h.camera.driver === Q.ONVIF
                      , n = !h.cameraDisablementIsSupported || h.camera.active;
                    return e && t && n
                }
                ,
                h.recoverCamera = function(e) {
                    const t = {
                        panelClass: "recover-camera-dialog-panel",
                        disableClose: !0,
                        data: {
                            orchid: h.orchid,
                            camera: h.camera
                        }
                    };
                    this._matDialog.open(Xr, t).afterClosed().subscribe({
                        next: function(e) {
                            e && (e.instance = h.camera.instance,
                            c.replaceCamera(angular.copy(e)),
                            c.refreshCameras(h.orchid).then((function() {
                                b()
                            }
                            )))
                        }
                    })
                }
                ,
                h.disableCamera = function(e) {
                    e.stopPropagation();
                    var t = {
                        template: n(54970),
                        controller: ["$scope", "$mdDialog", function(e, t) {
                            e.msgs = h.msgs,
                            e.cameraName = h.camera.name,
                            e.disableCameraDialog = {},
                            e.cameraProcessing = !1,
                            e.cancel = function() {
                                t.cancel()
                            }
                            ,
                            e.ok = function() {
                                e.cameraProcessing = !0,
                                o.disableCamera(h.orchid, h.camera.id).then((function() {
                                    e.cameraProcessing = !1,
                                    t.hide()
                                }
                                ), (function(t) {
                                    e.cameraProcessing = !1,
                                    e.disableCameraDialog = {
                                        error: t.data ? t.data : {
                                            reason: h.msgs.error.somethingWentWrong()
                                        }
                                    }
                                }
                                ))
                            }
                        }
                        ],
                        parent: angular.element(document.body),
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        escapeToClose: !1,
                        locals: {
                            orchid: h.orchid,
                            camera: h.camera
                        }
                    };
                    r.show(t).then((function() {
                        c.refreshCameras(h.orchid),
                        b(),
                        h.openStats = !1,
                        h.disableTable = !0
                    }
                    ), (function() {}
                    ))
                }
                ,
                h.reactivateCamera = function(e) {
                    e.stopPropagation();
                    const t = h.orchid.cameras.filter((function(e) {
                        return e.active
                    }
                    )).length === h.orchid.discoverableOrchid.licenseSession.license.cameras;
                    var i = {
                        template: n(98094),
                        controller: ["$scope", "$mdDialog", function(e, n) {
                            e.msgs = h.msgs,
                            e.cameraName = h.camera.name,
                            e.reactivateCameraDialog = {},
                            e.canReactivateCamera = !t,
                            e.cameraProcessing = !1,
                            e.cancel = function() {
                                n.cancel()
                            }
                            ,
                            e.ok = function() {
                                e.cameraProcessing = !0,
                                o.activateCamera(h.orchid, h.camera.id).then((function() {
                                    e.cameraProcessing = !1,
                                    n.hide()
                                }
                                ), (function(t) {
                                    e.cameraProcessing = !1,
                                    e.reactivateCameraDialog = {
                                        error: t.data ? t.data : {
                                            reason: h.msgs.error.somethingWentWrong()
                                        }
                                    }
                                }
                                ))
                            }
                        }
                        ],
                        parent: angular.element(document.body),
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        escapeToClose: !1,
                        locals: {
                            orchid: h.orchid,
                            camera: h.camera
                        }
                    };
                    r.show(i).then((function() {
                        c.refreshCameras(h.orchid),
                        b(),
                        h.disableTable = !1
                    }
                    ), (function() {}
                    ))
                }
                ,
                h.openMotionDetectionDialog = function(e) {
                    r.show({
                        controller: "MotionDetectionConfigurationController as motionConfig",
                        template: n(46185),
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        locals: {
                            camera: h.camera,
                            orchid: h.orchid,
                            brushColor: u.getPrimaryColorHex()
                        }
                    }).catch((function() {}
                    )).finally((function() {
                        c.refreshCameras(h.orchid)
                    }
                    ))
                }
                ,
                h.editCamera = function(e) {
                    var t = {
                        template: n(42909),
                        controller: "EditCameraDialogController as editCameraDialog",
                        parent: angular.element(document.body),
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        escapeToClose: !1,
                        locals: {
                            orchid: h.orchid,
                            camera: h.camera
                        }
                    };
                    r.show(t).then((function(e) {
                        h.camera.name = e.name,
                        h.cameraCopy.name = e.name,
                        c.replaceCamera(h.camera),
                        c.refreshCameras(h.orchid),
                        b()
                    }
                    ), (function() {}
                    )).finally((function() {
                        c.refreshCameras(h.orchid)
                    }
                    ))
                }
                ,
                h.addStream = function(e) {
                    var t = !0 === Array.isArray(h.camera.streams) ? h.camera.streams.length : 0;
                    parseInt(h.camera.capabilities.camera.PossibleStreams, 10) <= t ? alert(h.msgs.cameraReachedMaximumNumStreams()) : p(void 0, e, (async function(e) {
                        h.camera.primaryStream ? (c.replaceCamera(h.camera),
                        await c.refreshCameras(h.orchid),
                        await y(e)) : (await c.refreshCameras(h.orchid),
                        await y(e))
                    }
                    ))
                }
                ,
                h.copyStream = function(e, t) {
                    t.stopPropagation();
                    var i = {
                        template: n(67764),
                        controller: "CopyStreamDialogController as copyStreamDialog",
                        parent: angular.element(document.body),
                        targetEvent: t,
                        clickOutsideToClose: !1,
                        escapeToClose: !1,
                        multiple: !0,
                        locals: {
                            orchid: h.orchid,
                            camera: h.camera,
                            stream: e
                        }
                    };
                    r.show(i).catch(angular.noop)
                }
                ,
                h.restartStream = async function(e, t) {
                    t.stopPropagation(),
                    h.streamsMap[e.id].processing = !0,
                    h.cameraProcessing = !0;
                    try {
                        await o.restartStream(h.orchid, h.camera, e)
                    } catch (e) {
                        i.debug(`${e.data.code}: ${e.data.reason}`),
                        alert(h.msgs.restartStreamFailed())
                    }
                    await y(e),
                    h.streamsMap[e.id].processing = !1,
                    h.cameraProcessing = !1
                }
                ,
                h.editStream = function(e, t) {
                    p(e, t, (async function(t) {
                        for (var n = 0; n < h.camera.streams.length; ++n)
                            h.camera.streams[n].id === t.id && (h.camera.streams.splice(n, 1, t),
                            h.camera.primaryStream.id === e.id && (h.camera.primaryStream.configuration = void 0),
                            c.replaceCamera(h.camera),
                            await c.refreshCameras(h.orchid),
                            await y(t))
                    }
                    ))
                }
                ,
                h.makeStreamDisabled = async function(e, t) {
                    let n;
                    t.stopPropagation(),
                    n = h.camera.secondaryStreams ? angular.copy(h.camera.secondaryStreams) : [],
                    h.streamsMap[e.id].processing = !0,
                    h.cameraProcessing = !0;
                    const a = n.map((function(e) {
                        return e.id
                    }
                    )).indexOf(e.id);
                    n.splice(a, 1);
                    try {
                        await o.updateCamera(h.orchid, h.camera, {
                            secondaryStreams: n
                        }),
                        c.replaceCamera(h.camera),
                        await c.refreshCameras(h.orchid),
                        await y(e),
                        h.streamsMap[e.id].processing = !1,
                        h.cameraProcessing = !1
                    } catch (t) {
                        h.streamsMap[e.id].processing = !1,
                        h.cameraProcessing = !1,
                        i.debug("error disabling stream, PATCH /service/cameras/" + h.camera.id, t),
                        alert(h.msgs.unableToMarkStreamAsDisabled())
                    }
                }
                ,
                h.makeStreamSecondary = async function(e, t) {
                    let n;
                    t.stopPropagation(),
                    n = h.camera.secondaryStreams ? angular.copy(h.camera.secondaryStreams) : [],
                    h.streamsMap[e.id].processing = !0,
                    h.cameraProcessing = !0,
                    n.push({
                        id: e.id,
                        recording: !0
                    });
                    try {
                        await o.updateCamera(h.orchid, h.camera, {
                            secondaryStreams: n
                        }),
                        c.replaceCamera(h.camera),
                        await c.refreshCameras(h.orchid),
                        await y(e),
                        h.streamsMap[e.id].processing = !1,
                        h.cameraProcessing = !1
                    } catch (t) {
                        h.streamsMap[e.id].processing = !1,
                        h.cameraProcessing = !1,
                        i.debug("error setting secondary stream, PATCH /service/cameras/" + h.camera.id, t),
                        alert(h.msgs.unableToMarkStreamAsSecondary())
                    }
                }
                ,
                h.makeStreamPrimary = async function(e, t) {
                    let n;
                    t.stopPropagation(),
                    h.camera.primaryStream ? (n = angular.copy(h.camera.primaryStream),
                    h.streamsMap[n.id].processing = !0) : h.camera.primaryStream = {},
                    h.streamsMap[e.id].processing = !0,
                    h.cameraProcessing = !0;
                    try {
                        await o.updateCamera(h.orchid, h.camera, {
                            primaryStream: {
                                id: e.id
                            }
                        }),
                        S(e),
                        h.refreshPrimaryStreamProxyUrl(),
                        c.replaceCamera(h.camera),
                        await c.refreshCameras(h.orchid),
                        await y(e),
                        await y(n),
                        h.streamsMap[e.id].processing = !1,
                        h.streamsMap[n.id].processing = !1,
                        h.cameraProcessing = !1
                    } catch (t) {
                        n && (h.streamsMap[n.id].processing = !1),
                        h.streamsMap[e.id].processing = !1,
                        h.cameraProcessing = !1,
                        i.debug("error, PATCH /service/cameras/" + h.camera.id, t),
                        alert(h.msgs.unableToMarkStreamAsPrimary())
                    }
                }
                ,
                h.deleteStream = function(e, t, n) {
                    n.stopPropagation(),
                    r.show(r.confirm().theme(d.getTheme()).content(h.msgs.deleteNamedStream({
                        VALUE: t.name
                    })).ok(h.msgs.dialogs.delete()).cancel(h.msgs.dialogs.cancel())).then((function() {
                        h.processingDeleteStream[t.id] = !0,
                        o.deleteStream(h.orchid, e, t).then((function(n) {
                            h.selectedStream && h.selectedStream.id === t.id && (h.selectedStream = void 0),
                            h.configuredCameras.some((function(n) {
                                if (n.id === e.id)
                                    return n.streams.some((function(e, i) {
                                        if (e.id === t.id)
                                            return n.streams.splice(i, 1),
                                            !0
                                    }
                                    )),
                                    !0
                            }
                            )),
                            angular.isDefined(n.data.primaryStream) ? h.camera.primaryStream.id === t.id && angular.copy(n.data.primaryStream, h.camera.primaryStream) : (h.camera.primaryStream = void 0,
                            c.replaceCamera(h.camera)),
                            e.streams.some((function(t) {
                                if (t.id === e.primaryStream.id)
                                    return S(t),
                                    !0
                            }
                            )),
                            c.replaceCamera(h.camera),
                            c.refreshCameras(h.orchid),
                            h.processingDeleteStream[t.id] = !1
                        }
                        ), (function(n) {
                            h.processingDeleteStream[t.id] = !1,
                            0 !== status && (i.error(n),
                            alert("cameras/" + e.id + "/streams/" + t.id + h.msgs.deleteFailed()))
                        }
                        ))
                    }
                    ), (function() {}
                    ))
                }
                ,
                h.cancelRecoverCamera = function() {
                    h.recovering = !1
                }
                ,
                h.getRecordingStyle = function(e) {
                    if (!e)
                        return h.msgs.unknownType();
                    try {
                        return h.streamsMap[e.id] && h.streamsMap[e.id].extras.isSecondary ? e.configuration.Video && "H264" !== e.configuration.Video.Encoder ? h.msgs.attention.secondaryStreamsConfiguredWithAVALUEEncoderWillNotBeAvailableForViewingOnTheStage({
                            VALUE: e.configuration.Video.Encoder
                        }) : h.streamsMap[e.id].extras.isSecondaryRecording ? `${h.msgs.secondary()}: ${h.msgs.recording()}` : `${h.msgs.secondary()}: ${h.msgs.proxy()}` : Za(e.recordingConfiguration).localizedName()
                    } catch (e) {
                        return h.msgs.unknownType()
                    }
                }
                ,
                h.updateStats = function() {
                    if (h.camera.primaryStream && h.ActiveStreamStateService.activeStreamsMap[h.camera.primaryStream.id] && h.ActiveStreamStateService.activeStreamsMap[h.camera.primaryStream.id].streamStatistics) {
                        h.cameraStats = [],
                        (!h.cameraDisablementIsSupported || h.cameraDisablementIsSupported && h.camera.active) && (h.disableTable = !1);
                        h.ActiveStreamStateService.activeStreamsMap[h.camera.primaryStream.id].streamStatistics.forEach((function(e) {
                            let t, n, i, a, r, s;
                            re(e.audio) ? t = n = i = void 0 : (t = e.audio.averageBitsPerSecond,
                            n = e.audio.packetsReceived,
                            i = e.audio.packetsLost),
                            re(e.video) ? a = r = s = void 0 : (a = e.video.packetsReceived,
                            r = e.video.packetsLost,
                            s = e.video.averageBitsPerSecond),
                            h.cameraStats.push({
                                windowSizeTime: h.formatWindowSizeTime(e.windowSizeSeconds),
                                packetLossVideo: h.formatPacketLoss(a, r),
                                packetLossAudio: h.formatPacketLoss(n, i),
                                averageBitsVideo: h.formatAverageBits(s),
                                averageBitsAudio: h.formatAverageBits(t),
                                averageBitsTotal: h.formatAverageBitsTotal(s, t)
                            })
                        }
                        ));
                        const e = h.ActiveStreamStateService.activeStreamsMap[h.camera.primaryStream.id].lastFinalizedArchiveBytes
                          , t = h.ActiveStreamStateService.activeStreamsMap[h.camera.primaryStream.id].lastArchiveWritten;
                        h.lastVideoWritten = h.formatLastVideoWritten(t, e),
                        h.updateMetadataStatistics(),
                        h.numRowStats = h.cameraStats.length
                    } else if (h.camera.primaryStream && h.streamsMap[h.camera.primaryStream.id] && h.streamsMap[h.camera.primaryStream.id].processing) {
                        let e = h.cameraStats.map((function(e) {
                            return e.windowSizeTime
                        }
                        ));
                        h.cameraStats = [];
                        for (let t = 0; t < h.numRowStats; t++)
                            h.cameraStats.push({
                                windowSizeTime: e[t],
                                packetLossVideo: h.formatPacketLoss(void 0, void 0),
                                packetLossAudio: h.formatPacketLoss(void 0, void 0),
                                averageBitsVideo: h.formatAverageBits(void 0),
                                averageBitsAudio: h.formatAverageBits(void 0),
                                averageBitsTotal: h.formatAverageBitsTotal(void 0, void 0)
                            });
                        h.lastVideoWritten = h.formatLastVideoWritten(void 0, void 0)
                    }
                }
                ,
                h.updateMetadataStatistics = function() {
                    const e = h.ActiveStreamStateService.activeStreamsMap[h.camera.primaryStream.id].metadataStatistics;
                    e ? (h.noMetadataStats = !1,
                    Object.keys(e).forEach((function(t, n) {
                        const i = h.msgs.metadataStatistics[t]()
                          , a = (new tr).transform(e[t]);
                        h.metadataStats.some((function(e) {
                            return e.name === i
                        }
                        )) ? h.metadataStats[n].timestamp = a : h.metadataStats.push({
                            name: i,
                            timestamp: a
                        })
                    }
                    ))) : (h.metadataStatistics = [],
                    h.noMetadataStats = !0)
                }
                ,
                h.showEditNtpOrTZDialog = function(e, t) {
                    (function(e, t) {
                        return e.show({
                            controller: "CameraNtpTimezoneEditDialogController",
                            controllerAs: "$ctrl",
                            bindToController: !0,
                            escapeToClose: !1,
                            locals: t,
                            template: n(42005),
                            targetEvent: t.targetEvent
                        })
                    }
                    )(r, {
                        dialogFor: e,
                        camera: h.camera,
                        orchid: h.orchid,
                        cameraTzInfo: h.cameraTzInfo,
                        targetEvent: t
                    }).then((function(e) {
                        re(e) ? c.refreshCameras(h.orchid) : (h.camera.configuration = e.configuration,
                        h.cameraCopy.configuration = e.configuration,
                        c.replaceCamera(e),
                        c.refreshCameras(h.orchid),
                        b())
                    }
                    )).catch((function() {}
                    ))
                }
                ,
                h.watches.push(t.$watch((function() {
                    return h.camera
                }
                ), (function() {
                    h.cameraCopy = angular.copy(h.camera),
                    b(),
                    h.updateStats()
                }
                )), t.$watch((function() {
                    return h.camera.primaryStream && h.ActiveStreamStateService.activeStreamsMap[h.camera.primaryStream.id] ? h.ActiveStreamStateService.activeStreamsMap[h.camera.primaryStream.id].timestamp : 0
                }
                ), (function() {
                    h.updateStats()
                }
                ))),
                h.resetCopy = function() {
                    h.cameraCopy = angular.copy(h.camera),
                    b()
                }
                ,
                h.canUpdateStream = function(e) {
                    let t = !0;
                    return h.cameraDisablementIsSupported && (t = h.camera.active),
                    h.cameraProcessing || h.processingDeleteStream[e.id] || t
                }
                ,
                h.isPrimaryStreamDewarped = function() {
                    if (h.camera.primaryStream) {
                        var e = "";
                        const t = h.camera.primaryStream.dewarpConfiguration;
                        return h.camera.primaryStream && t && Object.keys(t).length > 0 && (e = t.enable ? t.enable.toString().trim().toLowerCase() : ""),
                        "true" === e
                    }
                    return !1
                }
                ,
                h.getConfigurationProtocol = function() {
                    const e = h.camera.connectionUri.split(":").at(0);
                    return e || ""
                }
                ,
                h.editConfigurationProtocol = function() {
                    const e = {
                        panelClass: "camera-configuration-protocol-dialog-panel",
                        disableClose: !0,
                        data: {
                            orchid: h.orchid,
                            camera: h.camera
                        }
                    };
                    h._matDialog.open(zr, e).afterClosed().subscribe({
                        next: function(e) {
                            e && c.refreshCameras(h.orchid).then((function() {
                                b()
                            }
                            ))
                        }
                    })
                }
                ,
                h.openTalkPermissionDialog = function(e) {
                    e.stopPropagation();
                    var t = {
                        template: n(59845),
                        controller: ["$scope", "$mdDialog", function(e, t) {
                            e.msgs = h.msgs,
                            e.talkDownEnabled = h.talkDownEnabled,
                            e.cameraProcessing = h.cameraProcessing,
                            e.talkdownPermissionDialog = {},
                            e.cancel = function() {
                                t.cancel()
                            }
                            ,
                            e.ok = function() {
                                const n = {
                                    ...h.camera.configuration,
                                    Talkdown: {
                                        enabled: e.talkDownEnabled.toString()
                                    }
                                };
                                h.cameraProcessing = !0,
                                e.cameraProcessing = !0,
                                o.updateCamera(h.orchid, h.camera, {
                                    configuration: n
                                }).then((function() {
                                    h.camera.configuration = n,
                                    c.replaceCamera(h.camera),
                                    t.hide()
                                }
                                ), (function(t) {
                                    h.cameraProcessing = !1,
                                    e.cameraProcessing = !1,
                                    e.talkdownPermissionDialog = {
                                        error: t
                                    }
                                }
                                ))
                            }
                        }
                        ],
                        parent: angular.element(document.body),
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        escapeToClose: !1,
                        locals: {
                            orchid: h.orchid,
                            camera: h.camera
                        }
                    };
                    r.show(t).then((function() {
                        c.refreshCameras(h.orchid),
                        b(),
                        h.cameraProcessing = !1
                    }
                    ), (function() {}
                    ))
                }
                ,
                h.$onDestroy = function() {
                    h.clipboard.destroy(),
                    h.proxyClipboard.destroy(),
                    h.watches.forEach((function(e) {
                        e()
                    }
                    ))
                }
                ,
                h.$onInit = function() {
                    h.msgs = {
                        ...L.messages.cameras,
                        ...L.messages.cameras.configurationProtocol,
                        ...L.messages.bag,
                        dialogs: L.messages.dialogs,
                        statuses: L.messages.statuses,
                        bitrate: L.messages.statisticKeys.websocket.bitrate,
                        audio: L.messages.utilityService.audio,
                        na: L.messages.activation.na,
                        noStreamsConfigured: L.messages.utilityService.noStreamsConfigures,
                        error: L.messages.errorBanner
                    },
                    w.isOrchid ? h.supportsResourceTagging = !0 : h.supportsResourceTagging = m.isFeatureSupported(h.orchid, Sr.RESOURCE_TAGGING),
                    h.icons = {
                        ...Ht,
                        ...qt
                    },
                    h.initialized = !0,
                    h.processingDeleteStream = {},
                    h.failureCameraInformation = "",
                    h.failureCameraSettings = "",
                    h.failureStream = "",
                    h.refreshingPrimaryStreamStatus = !1,
                    h.clipboard = new (Oa())(".copy-to-clipboard"),
                    h.proxyClipboard = new (Oa())(".copy-proxy-to-clipboard"),
                    h.cameraDisablementIsSupported = !0,
                    h.cameraConnectionPreferenceIsSupported = !0,
                    w.isOrchid || (h.showStats = m.isFeatureSupported(h.orchid, Sr.CAMERA_CONFIG_STATS_TABLE),
                    h.disabledSecondaryStreamFeature = !m.isFeatureSupported(h.orchid, Sr.SECONDARY_STREAMS),
                    h.cameraDisablementIsSupported = m.isFeatureSupported(h.orchid, Sr.CAMERA_DISABLEMENT),
                    h.cameraConnectionPreferenceIsSupported = m.isFeatureSupported(h.orchid, Sr.CAMERA_CONNECTION_PREFERENCE)),
                    h.canRecoverCamera = h.isCameraRecoverable()
                }
            }
            function Zr(e, t) {
                const n = t ? L.messages.capabilityEnums[e] : L.messages.capabilities[e];
                return n ? n() : null
            }
            function Jr(e) {
                const t = Zr(e, !1);
                return null !== t ? t : e.replace(/([A-Z]+)/g, " $1").replace(/([A-Z][a-z])/g, " $1")
            }
            function Qr(e) {
                return {
                    restrict: "E",
                    scope: {
                        name: "=",
                        value: "=",
                        capability: "=",
                        readOnly: "="
                    },
                    link: function(t, n) {
                        var i = ""
                          , a = ""
                          , r = "";
                        switch (t.capabilityEnumTrans = function(e) {
                            const t = Zr(e, !0);
                            return t || e
                        }
                        ,
                        t.normalizeValue = function() {
                            var e = parseInt(t.value, 10);
                            angular.isUndefined(e) && (e = 0),
                            e > t.capability.max ? t.value = t.capability.max : e < t.capability.min && (t.value = t.capability.min)
                        }
                        ,
                        t.capability.type) {
                        case "string":
                            i += "<md-input-container md-no-float>",
                            i += '<label for="' + t.name + '">' + Jr(t.name) + "</label>",
                            i += '<input class="form-control" id="' + t.name + (t.readOnly ? " disabled " : "") + 'type="text" ng-model="value" />',
                            i += "</md-input-container>";
                            break;
                        case "ip_address":
                            i += "<md-input-container md-no-float>",
                            i += '<label for="' + t.name + '">' + Jr(t.name) + "</label>",
                            i += '<input class="form-control" id="' + t.name + '" type="text" ng-model="value" placeholder="0.0.0.0"' + (t.capability.readOnly || t.readOnly ? ' disabled="true" ' : "") + " />",
                            i += "</md-input-container>";
                            break;
                        case "int":
                        case "float":
                            t.value = parseInt(t.value, 10),
                            2147483647 === t.value && (t.value = 0),
                            t.capability.max = parseInt(t.capability.max, 10),
                            t.capability.min = parseInt(t.capability.min, 10),
                            1 === t.capability.min && "BitRate" === t.name && (t.capability.min = 0),
                            t.value = Math.max(t.value, t.capability.min),
                            t.value = Math.min(t.value, t.capability.max),
                            t.capability.hasOwnProperty("min") && t.capability.hasOwnProperty("max") ? (t.capability.min === t.capability.max ? (i += t.name,
                            a = ' disabled="true" ') : r = ' min="' + t.capability.min + '" max="' + t.capability.max + '" step="' + ("float" === t.capability.type ? "0.1" : "1") + '"',
                            t.readOnly && (a = " disabled "),
                            i += "<md-slider-container>",
                            i += "\t<md-input-container md-no-float>",
                            i += '\t\t<label class="slider-label" for="' + t.name + '">' + Jr(t.name) + "</label>",
                            i += '\t\t<input type="number" placeholder="" ' + r + 'style="height: 30px; margin-top: auto; padding-left: 0; text-align: right" flex id="' + t.name + '" class="form-control" ng-model="value" ' + a + ' ng-blur="normalizeValue()" />',
                            i += "\t</md-input-container>",
                            i += '\t<md-slider id="' + t.name + 'Slider" ng-model="value" flex ' + r + a + "></md-slider>",
                            i += "</md-slider-container>") : (i += "<md-input-container md-no-float>",
                            i += '\t<input id=" placeholder="" ' + t.name + '"' + (t.readOnly ? " disabled " : "") + 'class="form-control" type="number" ng-model="value" class="input-mini" />',
                            i += "</md-input-container>");
                            break;
                        case "enum":
                            t.capability.options.length > 0 && t.capability.options.indexOf(t.value) < 0 && (t.value = t.capability.options[t.capability.options.length - 1]),
                            i += "<md-input-container md-no-float>",
                            i += '<label for="' + t.name + '">' + Jr(t.name) + "</label>",
                            i += '<md-select class="form-control" id="' + t.name + '" ng-model="value" ng-disabled="::capability.options.length < 2 || ' + t.readOnly + '">',
                            i += '<md-option ng-value="option" ng-repeat="option in capability.options">{{ capabilityEnumTrans(option) }}</md-option>',
                            i += "</md-select>",
                            i += "</md-input-container>";
                            break;
                        case "bool":
                            i += "<md-input-container md-no-float>",
                            i += '<label class="checkbox-inline" style="font-weight: bold;">',
                            i += "<input " + (t.readOnly ? " disabled " : "") + 'type="checkbox" id="' + t.name + '" ng-model="value">',
                            i += t.name,
                            i += "</label>",
                            i += "</md-input-container>";
                            break;
                        default:
                            i += '<label for="' + t.name + '">' + Jr(t.name) + "</label>",
                            i += "[" + L.messages.cameras.unknownType() + ": " + t.capability.type + "]"
                        }
                        n.append(i),
                        e(n.contents())(t)
                    }
                }
            }
            function es(e) {
                return {
                    restrict: "E",
                    scope: {
                        streamId: "=",
                        driver: "=",
                        encoder: "=",
                        frameRate: "=",
                        capabilities: "=",
                        govLength: "=",
                        readOnly: "=",
                        mafrEnabled: "<"
                    },
                    template: n(28918),
                    link: function(t) {
                        var n = !1;
                        function i() {
                            !0 === n && (!0 === t.mafrEnabled ? t.govLength = parseInt(t.frameRate / t.nonMotionFrameRateValues[t.nonMotionFrameRateIndex], 10) : t.govLength = t.frameRate)
                        }
                        function a() {
                            var e, t = document.querySelector("#FrameRate"), n = document.querySelector("#GOVLength"), i = L.messages.cameras.theseValuesCanBeManipulatedMotionReduce();
                            null !== t && null !== n && null === t.parentNode.parentNode.parentNode.querySelector(".mr-reducer-notice") && ((e = document.createElement("div")).setAttribute("class", "mr-reducer-notice"),
                            e.textContent = i,
                            e.style.display = "none",
                            t.parentNode.parentNode.parentNode.appendChild(e),
                            (e = document.createElement("div")).setAttribute("class", "mr-reducer-notice"),
                            e.textContent = i,
                            e.style.display = "none",
                            n.parentNode.parentNode.parentNode.appendChild(e))
                        }
                        function r(e, t) {
                            e && (e.style.display = t)
                        }
                        function s() {
                            var e, n, i = document.querySelector("#FrameRate"), a = document.querySelector("#GOVLength"), s = document.querySelector("#FrameRateSlider"), o = document.querySelector("#GOVLengthSlider");
                            null !== i && null !== i.parentNode.parentNode.parentNode.querySelector("div.mr-reducer-notice") && (e = i.parentNode.parentNode.parentNode.querySelector("div.mr-reducer-notice"),
                            null !== a && (n = a.parentNode.parentNode.parentNode.querySelector("div.mr-reducer-notice")),
                            !0 === t.mafrEnabled && "H264" === t.encoder ? (r(e, "block"),
                            r(n, "block"),
                            r(a, "none"),
                            r(i, "none"),
                            r(o, "none"),
                            r(s, "none")) : (r(e, "none"),
                            r(n, "none"),
                            r(a, ""),
                            r(i, ""),
                            r(o, ""),
                            r(s, "")))
                        }
                        t.msgs = L.messages.cameras,
                        t.CameraDriverType = Q,
                        t.nonMotionFrameRateValues = [1, 2, 3],
                        t.nonMotionFrameRateIndex = 0,
                        t.$watch("streamId", (function() {
                            n = !1
                        }
                        )),
                        t.$watch("frameRate", (function(n, a) {
                            var r;
                            if ("string" == typeof a && (a = parseFloat(a)),
                            "string" == typeof n && (n = parseFloat(n)),
                            !1 === angular.isUndefined(t.frameRate)) {
                                for (t.nonMotionFrameRateIndex = 0,
                                t.nonMotionFrameRateValues = [],
                                r = t.frameRate; r >= 1; r -= 1)
                                    t.nonMotionFrameRateValues.push(t.frameRate / r);
                                0 === t.nonMotionFrameRateValues.length && (t.nonMotionFrameRateValues = [1]),
                                e((function() {
                                    t.nonMotionFrameRateIndex = function() {
                                        for (var e = t.frameRate / t.govLength, n = 0, i = Math.abs(e - t.nonMotionFrameRateValues[0]), a = 1; a < t.nonMotionFrameRateValues.length; ++a)
                                            Math.abs(e - t.nonMotionFrameRateValues[a]) < i && (n = a,
                                            i = Math.abs(e - t.nonMotionFrameRateValues[a]));
                                        return n
                                    }(),
                                    angular.isDefined(a) && (a !== n || angular.isUndefined(t.govLength)) && i()
                                }
                                ))
                            }
                        }
                        )),
                        t.$watch("nonMotionFrameRateIndex", (function(e, n) {
                            !0 === t.mafrEnabled && e !== n && i()
                        }
                        )),
                        t.$watch("streamId", (function() {
                            t.nonMotionFrameRateIndex = t.nonMotionFrameRateValues.indexOf(t.frameRate / t.govLength),
                            -1 === t.nonMotionFrameRateIndex && (t.nonMotionFrameRateIndex = 0,
                            !0 === t.mafrEnabled && (t.govLength = parseInt(t.frameRate / t.nonMotionFrameRateValues[t.nonMotionFrameRateIndex], 10))),
                            t.minFrameRate = 1,
                            t.maxFrameRate = 30,
                            t.capabilities && t.capabilities.stream && t.capabilities.stream.Video && t.capabilities.stream.Video.Encoder && t.capabilities.stream.Video.Encoder.capabilities && t.capabilities.stream.Video.Encoder.capabilities.H264 && t.capabilities.stream.Video.Encoder.capabilities.H264.FrameRate && t.capabilities.stream.Video.Encoder.capabilities.H264.FrameRate && (t.minFrameRate = t.capabilities.stream.Video.Encoder.capabilities.H264.FrameRate.min,
                            t.maxFrameRate = t.capabilities.stream.Video.Encoder.capabilities.H264.FrameRate.max),
                            n = !0,
                            e((function() {
                                a(),
                                e((function() {
                                    s()
                                }
                                ))
                            }
                            ))
                        }
                        )),
                        t.$watch("encoder", (function() {
                            a(),
                            s()
                        }
                        )),
                        t.$watch("mafrEnabled", (function(e, n) {
                            a(),
                            !0 === t.mafrEnabled && e !== n && (t.govLength = parseInt(t.frameRate / t.nonMotionFrameRateValues[t.nonMotionFrameRateIndex], 10)),
                            s()
                        }
                        ))
                    }
                }
            }
            function ts(e, t, n, i, a, r, s, c, l, d, u) {
                const m = O("StreamDialog");
                var h = this
                  , p = !1
                  , g = !1;
                if (h.brandAppName = r.brand.APP_NAME,
                h.orchid = c,
                h.camera = l,
                h.newStream = o().isUndefined(d),
                h.isSecondaryStream = !1,
                !1 === h.newStream && void 0 !== l.secondaryStreams) {
                    const e = l.secondaryStreams.find((function(e) {
                        return e.id === d.id
                    }
                    ));
                    h.isSecondaryStream = void 0 !== e,
                    h.isSecondaryStream && (h.isSecondaryStreamRecording = e.recording)
                }
                function f() {
                    !1 === p && (p = !0,
                    h.recordingStyle(Ka),
                    e.show(e.alert().theme(u.getTheme()).multiple(!0).clickOutsideToClose(!1).textContent(h.msgs.unableToDetermineRecordingStyle()).ok(h.msgs.ok())).finally((function() {
                        document.body.classList.add("md-dialog-is-showing")
                    }
                    )))
                }
                function v(e) {
                    let t = {};
                    for (let n in e)
                        e.hasOwnProperty(n) && (t[n] = e[n].default);
                    return t
                }
                function y(e, t) {
                    var n;
                    for (n in t)
                        if (!0 === t.hasOwnProperty(n) && (e[n] = t[n].default,
                        t[n].capabilities))
                            for (var i in t[n].capabilities)
                                y(e, t[n].capabilities[i])
                }
                function b() {
                    let t;
                    try {
                        t = Za(h.stream.recordingConfiguration),
                        h.motionStyleOptions = h.hasMetaCapabilities ? t.metaOptions : t.noMetaOptions
                    } catch (e) {
                        f()
                    }
                    try {
                        const e = Va(h.stream);
                        h.selectedMotionStyle = e.id,
                        h.selectedMotionStyle === Fa.CAMERA ? (t && !h.hasMetaCapabilities && (h.motionStyleOptions = t.metaOptions,
                        h.selectedMotionEvent = {
                            name: h.stream.recordingConfiguration.metadata.bgseg.topic,
                            data: h.stream.recordingConfiguration.metadata.bgseg.data
                        },
                        h.motionEvents = [[za(h.selectedMotionEvent.name), h.selectedMotionEvent]]),
                        function(e, t, n) {
                            let i = {};
                            if (t.Metadata && (i = Ha(t.Metadata.Mode.capabilities.On.TopicFilter, n)),
                            !Ba(e.recordingConfiguration, i))
                                throw Error(L.messages.cameras.invalidStreamConfig.invalidTopic());
                            if (!e.configuration.Metadata || "On" !== e.configuration.Metadata.Mode)
                                throw e.recordingConfiguration.metadata && (e.recordingConfiguration.metadata.bgseg.topic = ""),
                                Error(L.messages.cameras.invalidStreamConfig.modeMismatch());
                            if (!function(e) {
                                var t;
                                if (e.configuration && e.configuration.Metadata) {
                                    const n = e.configuration.Metadata.TopicFilter
                                      , i = null === (t = e.recordingConfiguration.metadata) || void 0 === t ? void 0 : t.bgseg.topic;
                                    if (0 !== n.length && i && !n.includes(i))
                                        return !1
                                }
                                return !0
                            }(e))
                                throw e.recordingConfiguration.metadata && (e.recordingConfiguration.metadata.bgseg.topic = ""),
                                Error(L.messages.cameras.invalidStreamConfig.topicFilterMismatch())
                        }(h.stream, h.camera.capabilities.stream, h.orchidInstance.recordingCapabilities.metadata.bgseg.data.type.options),
                        h.selectedMotionEvent = {
                            name: h.stream.recordingConfiguration.metadata.bgseg.topic,
                            data: h.stream.recordingConfiguration.metadata.bgseg.data
                        },
                        m("debug", "Metadata is configured on this stream")) : (m("debug", "Metadata is NOT configured on this stream"),
                        h.hasMetaCapabilities && (h.selectedMotionEvent = Object.values(h.availableEventOptions)[0]))
                    } catch (t) {
                        !1 === g && (g = !0,
                        h.selectedMotionStyle = ja.id,
                        e.show(e.alert().theme(u.getTheme()).multiple(!0).clickOutsideToClose(!1).textContent(h.msgs.unableToDetermineMotionStyle()).ok(h.msgs.ok())).finally((function() {
                            document.body.classList.add("md-dialog-is-showing")
                        }
                        )))
                    }
                }
                function S(e) {
                    h.stream.processing = !1,
                    o().isUndefined(e) || null === e ? h.error = h.msgs.noResponseFromOrchid() : o().isDefined(e.reason) ? h.error = e.reason : h.error = h.msgs.errors.unexpectedErrorOccurred()
                }
                h.RecordingStyles = Xa,
                h.RecordingStyleId = qa,
                h.RecordingStyleIds = Ya,
                h.MotionStyleId = Fa,
                h.MotionStyleIds = Ua,
                h.MotionStyles = $a,
                h._isOrchid = w.isOrchid,
                h.showLBM = !0,
                h._cameraDisablementIsSupported = !0,
                h.cameraIsDisabled = !1,
                h.hasMetaCapabilities = !1,
                h.selectedMotionStyle = "",
                h.motionStyleOptions = [],
                h.selectedMotionEvent = {},
                h.availableEventOptions = {},
                h.motionEvents = [],
                h.cameraSideMotionDetectionIsAvailable = !0,
                h._isOrchid || (h.cameraSideMotionDetectionIsAvailable = s.isFeatureSupported(h.orchid, Sr.CAMERA_SIDE_MOTION_DETECTION)),
                h.$onInit = function() {
                    h._isOrchid || (h._cameraDisablementIsSupported = s.isFeatureSupported(h.orchid, Sr.CAMERA_DISABLEMENT)),
                    h._cameraDisablementIsSupported ? h.cameraIsDisabled = !h.camera.active : h.cameraIsDisabled = !1,
                    h.msgs = {
                        ...L.messages.cameras,
                        ok: L.messages.dialogs.ok,
                        errors: L.messages.errors
                    },
                    h.buttonTitle = h.newStream ? h.msgs.addStream() : h.msgs.updateStream(),
                    n.getDiscoverableOrchid(h.orchid).then((function(e) {
                        h.orchidInstance = e.data,
                        h.orchidLoaded = !0,
                        h.camera.capabilities.stream.Metadata ? (m("debug", "Camera supports Metadata", h.camera),
                        h.hasMetaCapabilities = !0,
                        h.availableEventOptions = Ha(h.camera.capabilities.stream.Metadata.Mode.capabilities.On.TopicFilter, h.orchidInstance.recordingCapabilities.metadata.bgseg.data.type.options),
                        h.availableEventOptions && 0 === Object.keys(h.availableEventOptions).length ? (h.hasMetaCapabilities = !1,
                        m("info", "Camera has meta capabilities, but there are no available supported events")) : h.motionEvents = Object.entries(h.availableEventOptions)) : (m("debug", "Camera does NOT support Metadata", h.camera),
                        h.hasMetaCapabilities = !1),
                        !0 === h.newStream ? (h.stream = function() {
                            var e, t = {
                                configuration: {},
                                recordingConfiguration: {
                                    decode: {
                                        keyFramesOnly: !0
                                    }
                                },
                                dewarpConfiguration: {}
                            };
                            for (e in h.camera.capabilities.stream)
                                !0 === h.camera.capabilities.stream.hasOwnProperty(e) && (t.configuration[e] = {},
                                y(t.configuration[e], h.camera.capabilities.stream[e]));
                            for (e in t.recordingConfiguration.bgseg = {},
                            h.orchidInstance.recordingCapabilities.bgseg)
                                !0 === h.orchidInstance.recordingCapabilities.bgseg.hasOwnProperty(e) && (t.recordingConfiguration.bgseg[e] = h.orchidInstance.recordingCapabilities.bgseg[e].default);
                            for (e in t.recordingConfiguration.filesplit = {},
                            h.orchidInstance.recordingCapabilities.filesplit)
                                !0 === h.orchidInstance.recordingCapabilities.filesplit.hasOwnProperty(e) && (t.recordingConfiguration.filesplit[e] = h.orchidInstance.recordingCapabilities.filesplit[e].default);
                            let n;
                            for (e in t.recordingConfiguration.metadata = {
                                bgseg: {}
                            },
                            n = h.orchidInstance.recordingCapabilities.metadata ? h.orchidInstance.recordingCapabilities.metadata.bgseg : {},
                            n)
                                n.hasOwnProperty(e) && (n[e].hasOwnProperty("default") ? t.recordingConfiguration.metadata.bgseg[e] = n[e].default : t.recordingConfiguration.metadata.bgseg[e] = v(n[e]));
                            return t.recordingConfiguration.mode = h.orchidInstance.recordingCapabilities.mode.default,
                            t.recordingConfiguration.motionReducer = h.orchidInstance.recordingCapabilities.motionReducer.default,
                            t
                        }(),
                        m("debug", "Creating new stream with this configuration:", h.stream),
                        b()) : (h.stream = o().copy(d),
                        m("debug", "Editing stream preconfigured with this configuration:", h.stream),
                        b()),
                        h.camera.driver !== Q.ONVIF && (h.stream.configuration.General.Path = void 0 !== h.stream.configuration.General.Path ? h.stream.configuration.General.Path : ""),
                        h.streamRtspUrl = h.camera.driver === Q.ONVIF ? h.stream.configuration.Resource : h.camera.configuration.BaseUri + h.stream.configuration.General.Path,
                        h.rtspProxyUrl = n.rtspUrl(h.orchid, h.stream.id),
                        t((function() {
                            h.bodyIsReady = !0
                        }
                        )),
                        h._isOrchid || (h.showLBM = i.isLbmAvailable())
                    }
                    )),
                    a.getSmartSearchStatus(h.orchid).then((function(e) {
                        h.smartSearchNotAvailable = e.available
                    }
                    ))
                }
                ,
                h.submitButtonIsDisabled = function() {
                    return !0 !== h.bodyIsReady || h.$invalid || h.stream.processing || h.cameraIsDisabled
                }
                ,
                h.checkRecordingStyle = function(e) {
                    return !!h.stream && function(e, t) {
                        return Xa[t].test(e)
                    }(h.stream.recordingConfiguration, e)
                }
                ,
                h.recordingStyle = function(e) {
                    if (void 0 === e)
                        try {
                            return h.stream ? Za(h.stream.recordingConfiguration) : Ka
                        } catch (e) {
                            f()
                        }
                    else {
                        if (void 0 === h.stream)
                            return e;
                        try {
                            return h.motionStyleOptions = h.hasMetaCapabilities ? e.metaOptions : e.noMetaOptions,
                            h.selectedMotionStyle = ja.id,
                            Xa[e.id].updateRecordingConfiguration(h.stream.recordingConfiguration),
                            $a[h.selectedMotionStyle].updateMetaConfiguration(h.stream),
                            e
                        } catch (e) {
                            f()
                        }
                    }
                }
                ,
                h.motionStyle = function(e) {
                    if (void 0 === e)
                        return h.MotionStyles[h.selectedMotionStyle];
                    if (void 0 === h.stream)
                        return e;
                    if (h.selectedMotionStyle = e.id,
                    !h.hasMetaCapabilities) {
                        h.motionStyleOptions = h.recordingStyle().noMetaOptions;
                        o().element(document.querySelector("#motionStyleContainer"))[0].classList.remove("md-input-focused")
                    }
                    return $a[e.id].updateMetaConfiguration(h.stream, {
                        styleId: h.selectedMotionStyle,
                        topic: h.selectedMotionEvent.name,
                        data: h.selectedMotionEvent.data
                    }),
                    e
                }
                ,
                h.changeMotionEvent = function() {
                    $a[Fa.CAMERA].updateMetaConfiguration(h.stream, {
                        styleId: h.selectedMotionStyle,
                        topic: h.selectedMotionEvent.name,
                        data: h.selectedMotionEvent.data
                    })
                }
                ,
                h.addOrUpdateStream = async function() {
                    if (h.stream.processing = !0,
                    h.newStream)
                        n.addStream(h.orchid, h.camera, h.stream).then((function(t) {
                            e.hide(t.data.stream)
                        }
                        ), (function(e) {
                            S(e.data)
                        }
                        ));
                    else {
                        var t = o().copy(h.stream);
                        delete t.cameraExpanded;
                        try {
                            const i = await n.updateStream(h.orchid, h.camera, t);
                            e.hide(i.data.stream)
                        } catch (e) {
                            S(e.data)
                        }
                    }
                }
                ,
                h.audioIsTranscoded = function() {
                    switch (h.stream.configuration.Audio.Encoder) {
                    case "G711":
                        return !("64" === h.stream.configuration.Audio.BitRate && "8" === h.stream.configuration.Audio.SampleRate);
                    case "AAC":
                        return !0;
                    default:
                        return !1
                    }
                }
                ,
                h.showCamSideMotionSmartSearchWarning = function() {
                    return !h.isSecondaryStream && h.smartSearchNotAvailable && h.selectedMotionStyle === h.MotionStyleId.CAMERA && !h.cameraSideMotionDetectionIsAvailable
                }
                ,
                h.cancel = function() {
                    e.cancel()
                }
            }
            var ns, is, as, rs;
            Xr = (0,
            c.gn)([(0,
            i.Component)({
                selector: "recover-camera-dialog",
                template: n(94930)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(2, (0,
            i.Inject)(p.qu)), (0,
            c.fM)(3, (0,
            i.Inject)(Cr)), (0,
            c.fM)(4, (0,
            i.Inject)(br)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (Hr = void 0 !== hn.so && hn.so) ? Hr : Object, "function" == typeof (Wr = void 0 !== p.qu && p.qu) ? Wr : Object, "function" == typeof (qr = void 0 !== Cr && Cr) ? qr : Object, "function" == typeof (Yr = void 0 !== br && br) ? Yr : Object])], Xr),
            Kr.$inject = ["$rootScope", "$scope", "$log", "$timeout", "$mdDialog", "MatDialog", "OrchidDataService", "RenewableService", "ActiveStreamStateService", "UserSettingsService", "ThemeService", "MinimumVersionService"],
            angular.module("ipconfigure.orchid.singularity").controller("EditCameraController", Kr).directive("editCamera", (function() {
                return {
                    scope: {},
                    restrict: "E",
                    bindToController: {
                        orchid: "=",
                        camera: "=",
                        configuredCameras: "=",
                        callback: "&",
                        cameraTzInfo: "<"
                    },
                    controller: "EditCameraController",
                    controllerAs: "editCamera",
                    template: n(28816)
                }
            }
            )),
            angular.module("ipconfigure.orchid.singularity").controller("EditCameraDialogController", ["$mdDialog", "OrchidDataService", "orchid", "camera", function(e, t, n, i) {
                var a = this;
                a.orchid = n,
                a.camera = angular.copy(i),
                a.$onInit = function() {
                    a.msgs = L.messages.cameras
                }
                ,
                a.handleKeyDown = function(e) {
                    "Enter" === e.key && a.camera.name && a.updateCamera()
                }
                ,
                a.updateCamera = function() {
                    a.camera.processing = !0,
                    t.updateCamera(a.orchid, a.camera, {
                        name: a.camera.name
                    }).then((function(t) {
                        a.camera.processing = !1,
                        e.hide(t.data.camera)
                    }
                    ), (function(e) {
                        a.camera.processing = !1,
                        a.error = e.data && e.data.message ? e.data.message : L.messages.common.anUnexpectedErrorOccurred()
                    }
                    ))
                }
                ,
                a.cancel = function() {
                    e.cancel()
                }
            }
            ]).directive("editCameraDialog", (function() {
                return {
                    scope: {},
                    restrict: "E",
                    bindToController: {
                        orchid: "=",
                        camera: "="
                    },
                    controller: "EditCameraDialogController",
                    controllerAs: "editCameraDialog",
                    template: n(42909)
                }
            }
            )),
            Qr.$inject = ["$compile"],
            angular.module("ipconfigure.orchid.singularity").directive("dynamicInput", Qr),
            es.$inject = ["$timeout"],
            angular.module("ipconfigure.orchid.singularity").directive("motionReductionSupport", es),
            ts.$inject = ["$mdDialog", "$timeout", "OrchidDataService", "PlayerModeService", "TimelineEventService", "BrandService", "MinimumVersionService", "orchid", "camera", "originalStream", "UserSettingsService"],
            o().module("ipconfigure.orchid.singularity").controller("StreamDialogController", ts),
            angular.module("ipconfigure.orchid.singularity").controller("CopyStreamDialogController", ["$scope", "$q", "$mdDialog", "OrchidDataService", "RenewableService", "UtilityService", "MinimumVersionService", "orchid", "camera", "stream", function(e, t, n, i, a, r, s, o, c, l) {
                var d = this;
                d.PROXY_ONLY = qa.PROXY_ONLY,
                d.NO_MOTION = qa.CONTINUOUS_NO_MOTION,
                d.orchid = o,
                d.camera = c,
                d.camerasCopy = angular.copy(o.cameras.filter((function(e) {
                    return e.id !== d.camera.id && e.driver === Q.ONVIF
                }
                ))),
                d.cameraDisablementIsSupported = !0,
                d.originalStream = l,
                delete d.originalStream.cameraExpanded,
                d.originalStreamRecordingStyle = null;
                try {
                    d.originalStreamRecordingStyle = Za(d.originalStream.recordingConfiguration)
                } catch (e) {
                    !1 == !1 && (!0,
                    n.show(n.alert().multiple(!0).clickOutsideToClose(!0).textContent(d.msgs.unableToDetermineRecordingStyle()).ok(d.msgs.ok()))),
                    d.originalStreamRecordingStyle = Ka
                }
                try {
                    d.originalStreamMotionStyle = Va(d.originalStream, d.camera.capabilities.stream)
                } catch (e) {
                    d.originalStreamMotionStyle = ja
                }
                function u(e, t) {
                    var n, i, a = d.originalStream.configuration[t], s = e.primaryStream;
                    if (!se(e.primaryStream))
                        if (e.capabilities.stream[t] && e.capabilities.stream[t].Encoder && ((!0 === d.copyAllSettings || !0 === d.shouldCopyStreamSetting[t].Encoder) && "none" !== a.Encoder || !0 !== d.copyAllSettings && !0 !== d.shouldCopyStreamSetting[t].Encoder && "none" !== s.configuration[t].Encoder)) {
                            if (e.matchStream.configuration[t] = {},
                            n = e.capabilities.stream[t].Encoder.capabilities,
                            !0 !== d.copyAllSettings && !0 !== d.shouldCopyStreamSetting[t].Encoder)
                                i = n[s.configuration[t].Encoder],
                                e.matchStream.configuration[t].Encoder = s.configuration[t].Encoder;
                            else if (angular.isDefined(n[a.Encoder]))
                                i = n[a.Encoder],
                                e.matchStream.configuration[t].Encoder = a.Encoder;
                            else {
                                e.munged = !0;
                                let r = Object.keys(n)[0];
                                i = n[r],
                                e.matchStream.configuration[t].Encoder = r,
                                e.streamDiff[t] = {
                                    Encoder: {
                                        old: a.Encoder,
                                        new: r
                                    }
                                }
                            }
                            !0 !== d.copyAllSettings && !1 === d.shouldCopyStreamSetting[t].Quality && (e.matchStream.configuration[t].Quality = s.configuration[t].Quality),
                            angular.forEach(Object.keys(i), (function(n) {
                                var o = a[n]
                                  , c = o;
                                if (!0 === d.copyAllSettings || !0 === d.shouldCopyStreamSetting[t][n]) {
                                    if (angular.isUndefined(o) && (o = i[n].default),
                                    "int" === i[n].type)
                                        parseInt(o) > parseInt(i[n].max) ? o = i[n].max : parseInt(o) < parseInt(i[n].min) && (o = i[n].min);
                                    else if ("enum" === i[n].type && angular.isUndefined(r.find(i[n].options, (function(e) {
                                        return e === o
                                    }
                                    ))))
                                        if ("Resolution" === n) {
                                            var l, u = o.split("x"), m = u[0] * u[1], h = 9999999999, p = "";
                                            angular.forEach(i[n].options, (function(e) {
                                                u = e.split("x"),
                                                l = u[0] * u[1],
                                                Math.abs(m - l) < h && (h = Math.abs(m - l),
                                                p = e)
                                            }
                                            )),
                                            o = p
                                        } else
                                            o = i[n].default;
                                    c !== o && (e.munged = !0,
                                    angular.isUndefined(e.streamDiff[t]) && (e.streamDiff[t] = {}),
                                    e.streamDiff[t][n] = {
                                        old: c,
                                        new: o
                                    }),
                                    e.matchStream.configuration[t][n] = o
                                } else
                                    e.matchStream.configuration[t][n] = s.configuration[t][n]
                            }
                            ))
                        } else
                            e.matchStream.configuration[t] = {
                                Encoder: d.msgs.none()
                            },
                            "none" === a.Encoder || !0 !== d.copyAllSettings && !0 !== d.shouldCopyStreamSetting[t].Encoder || (e.munged = !0,
                            e.streamDiff[t] = {
                                Encoder: {
                                    old: a.Encoder,
                                    new: d.msgs.none()
                                }
                            })
                }
                function m() {
                    d.munged = 0;
                    var e = {}
                      , t = d.orchid.discoverableOrchid.recordingCapabilities.bgseg;
                    for (var n in t)
                        e[n] = t[n].default;
                    d.sourceMotionSettings = function(e) {
                        var t, n, i, a;
                        const r = Va(e);
                        return r.id === Fa.CAMERA ? {
                            styleId: r.id,
                            topic: null === (n = null === (t = e.recordingConfiguration.metadata) || void 0 === t ? void 0 : t.bgseg) || void 0 === n ? void 0 : n.topic,
                            data: null === (a = null === (i = e.recordingConfiguration.metadata) || void 0 === i ? void 0 : i.bgseg) || void 0 === a ? void 0 : a.data
                        } : {
                            styleId: r.id
                        }
                    }(d.originalStream, d.camera.capabilities.stream),
                    angular.forEach(d.camerasCopy, (function(t) {
                        if (t.matchStream = {
                            name: d.originalStream.name,
                            configuration: {},
                            recordingConfiguration: {
                                filesplit: {},
                                bgseg: e
                            },
                            dewarpConfiguration: {}
                        },
                        t.munged = !1,
                        t.streamDiff = {},
                        d.copyAllSettings || d.shouldCopyRecordingStyle) {
                            const e = d.originalStreamRecordingStyle.id;
                            Xa[e].updateRecordingConfiguration(t.matchStream.recordingConfiguration)
                        } else {
                            let e;
                            try {
                                let n = t.primaryStream;
                                e = n ? Za(n.recordingConfiguration) : Ka
                            } catch (t) {
                                e = Ka
                            }
                            Xa[e.id].updateRecordingConfiguration(t.matchStream.recordingConfiguration)
                        }
                        if (d.copyAllSettings || d.shouldCopyMotionStyle) {
                            let e;
                            if (d.sourceMotionSettings.styleId === Fa.CAMERA) {
                                const n = Ha(t.capabilities.stream.Metadata ? t.capabilities.stream.Metadata.Mode.capabilities.On.TopicFilter : [], d.orchid.discoverableOrchid.recordingCapabilities.metadata.bgseg.data.type.options);
                                Ba(d.originalStream.recordingConfiguration, n) ? e = d.sourceMotionSettings.styleId : (e = Fa.SERVER,
                                t.munged = !0,
                                t.streamDiff[d.msgs.recording()] = {
                                    [d.msgs.motionStyle()]: {
                                        old: $a[d.sourceMotionSettings.styleId].localizedName(),
                                        new: $a[Fa.SERVER].localizedName()
                                    }
                                })
                            } else
                                e = d.sourceMotionSettings.styleId;
                            $a[e].updateMetaConfiguration(t.matchStream, d.sourceMotionSettings)
                        }
                        se(t.primaryStream) || (t.matchStream.recordingConfiguration.decode = d.copyAllSettings || d.shouldCopyDecodeAllFrames ? d.originalStream.recordingConfiguration.decode : t.primaryStream.recordingConfiguration.decode),
                        u(t, "Video"),
                        se(t.primaryStream) || (d.copyAllSettings || d.shouldCopyStreamSetting.Video.Quality ? t.matchStream.configuration.Video.Quality = d.originalStream.configuration.Video.Quality : t.matchStream.configuration.Video.Quality = t.primaryStream.configuration.Video.Quality),
                        u(t, "Audio"),
                        t.munged && d.munged++
                    }
                    ))
                }
                function h(e) {
                    var t, n;
                    e.processing = !0,
                    e.primaryStream && Object.keys(e.primaryStream).length > 0 && d.makePrimary ? ((n = angular.copy(e.primaryStream)).name = e.matchStream.name,
                    n.configuration.Video = e.matchStream.configuration.Video,
                    n.configuration.Audio = e.matchStream.configuration.Audio,
                    n.configuration.Metadata = e.matchStream.configuration.Metadata,
                    n.recordingConfiguration = e.matchStream.recordingConfiguration,
                    n.recordingConfiguration.bgseg = e.primaryStream.recordingConfiguration.bgseg,
                    t = i.updateStream(d.orchid, e, n).then((function(t) {
                        e.processing = !1,
                        e.success = !0
                    }
                    ), (function(t) {
                        d.error = !0,
                        e.processing = !1,
                        e.error = t.data.reason
                    }
                    )),
                    d.promises.push(t)) : (t = i.addStream(d.orchid, e, e.matchStream).then((function(t) {
                        e.success = !0,
                        function(e) {
                            e.processing = !1,
                            a.replaceCamera(e)
                        }(e)
                    }
                    ), (function(t) {
                        e.processing = !1,
                        d.error = !0,
                        e.error = t.data.reason
                    }
                    )),
                    d.promises.push(t))
                }
                d.allCamerasSelected = !1,
                d.copyCount = 0,
                d.makePrimary = !0,
                d.munged = 0,
                d.hideMunged = !1,
                d.promises = [],
                d.copyAllSettings = !0,
                d.allStreamSettings = !0,
                d.showSettings = {},
                d.sectionSelected = {},
                d.shouldCopyStreamSetting = {
                    Video: {},
                    Audio: {}
                },
                d.translateFeatureId = function(e) {
                    if (re(e))
                        return "";
                    const t = d.msgs.copyStream.translateFeatureId({
                        VALUE: e
                    });
                    return "<DNT>" === t ? e : t
                }
                ,
                d.translateOnvifFieldId = function(e) {
                    if (re(e))
                        return "";
                    const t = L.messages.capabilities[e];
                    return re(t) ? e : t()
                }
                ,
                d.isEmpty = function(e) {
                    return 0 === Object.keys(e).length
                }
                ,
                d.selectCamera = function(e) {
                    d.processing || d.reviewMode || (e.needsCopy = !e.needsCopy,
                    d.copyCount += e.needsCopy ? 1 : -1)
                }
                ,
                d.selectAllCameras = function() {
                    d.allCamerasSelected = !d.allCamerasSelected,
                    d.copyCount = 0,
                    angular.forEach(d.camerasCopy, (function(e) {
                        e.needsCopy = d.allCamerasSelected
                    }
                    )),
                    d.copyCount += d.allCamerasSelected ? d.camerasCopy.length : 0
                }
                ,
                d.toggleAllStreamSettings = function() {
                    d.allStreamSettings = !d.allStreamSettings,
                    d.shouldCopyDecodeAllFrames = d.allStreamSettings,
                    d.shouldCopyRecordingStyle = d.allStreamSettings,
                    d.shouldCopyMotionStyle = d.allStreamSettings,
                    ["Video", "Audio"].forEach((function(e) {
                        d.sectionSelected[e] = d.allStreamSettings,
                        angular.forEach(Object.keys(d.originalStream.configuration[e]), (function(t) {
                            d.shouldCopyStreamSetting[e][t] = d.allStreamSettings
                        }
                        ))
                    }
                    ))
                }
                ,
                d.selectSection = function(e) {
                    d.sectionSelected[e] = !d.sectionSelected[e],
                    angular.forEach(Object.keys(d.originalStream.configuration[e]), (function(t) {
                        d.shouldCopyStreamSetting[e][t] = d.sectionSelected[e]
                    }
                    ))
                }
                ,
                d.fieldCount = function(e) {
                    return d.originalStream.configuration[e] ? Object.keys(d.originalStream.configuration[e]).length : 0
                }
                ,
                d.toggleShowSettings = function(e) {
                    d.showSettings[e] = !d.showSettings[e]
                }
                ,
                d.showCameraCopyOption = function(e) {
                    return d.cameraDisablementIsSupported ? !(e.munged && d.hideMunged) && !((d.processing || d.reviewMode) && !e.needsCopy) && e.active : !(e.munged && d.hideMunged || (d.processing || d.reviewMode) && !e.needsCopy)
                }
                ,
                d.copyStream = function() {
                    d.processing = !0;
                    for (var e = 0; e < d.camerasCopy.length; ++e)
                        !0 !== d.camerasCopy[e].needsCopy || !0 === d.camerasCopy[e].munged && !0 === d.hideMunged || h(d.camerasCopy[e]);
                    t.all(d.promises).then((function() {
                        a.refreshCameras(d.orchid),
                        d.processing = !1,
                        d.reviewMode = !0
                    }
                    ), (function() {
                        a.refreshCameras(d.orchid),
                        d.processing = !1,
                        d.reviewMode = !0
                    }
                    ))
                }
                ,
                d.copyCamerasAreAvailable = function() {
                    return d.cameraDisablementIsSupported ? d.camerasCopy.filter((function(e) {
                        return e.active
                    }
                    )).length >= 1 : d.camerasCopy.length >= 1
                }
                ,
                d.cancel = function() {
                    n.cancel()
                }
                ,
                d.$onInit = function() {
                    w.isOrchid || (d.cameraDisablementIsSupported = s.isFeatureSupported(d.orchid, Sr.CAMERA_DISABLEMENT)),
                    d.msgs = Object.assign({
                        ok: L.messages.dialogs.ok
                    }, L.messages.cameras),
                    m(),
                    d.toggleAllStreamSettings(),
                    e.$watch((function() {
                        return d.copyAllSettings
                    }
                    ), (function(e, t) {
                        angular.isDefined(t) && m()
                    }
                    )),
                    e.$watch((function() {
                        return d.shouldCopyDecodeAllFrames
                    }
                    ), (function(e, t) {
                        angular.isDefined(t) && m()
                    }
                    )),
                    e.$watch((function() {
                        return d.shouldCopyRecordingStyle
                    }
                    ), (function(e, t) {
                        angular.isDefined(t) && m()
                    }
                    )),
                    e.$watch((function() {
                        return d.shouldCopyMotionStyle
                    }
                    ), (function(e, t) {
                        angular.isDefined(t) && m()
                    }
                    )),
                    e.$watch((function() {
                        return d.shouldCopyStreamSetting
                    }
                    ), (function(e, t) {
                        angular.isDefined(t) && m()
                    }
                    ), !0)
                }
            }
            ]);
            let ss = ns = class {
                constructor(e, t, n, i) {
                    var a;
                    this._dialogData = e,
                    this._matDialogRef = t,
                    this._gamepadService = n,
                    this._playerOptionsFactory = i,
                    this.title = w.isOrchid ? this._dialogData.camera.name : `${this._dialogData.orchid.name}: ${this._dialogData.camera.name}`,
                    this.camera = this._dialogData.camera,
                    this.orchid = this._dialogData.orchid,
                    this.options = this._playerOptionsFactory.createPreviewPlayerOptions(),
                    this.streamId = se(this._dialogData.streamId) ? this._dialogData.streamId : null === (a = this._dialogData.camera.primaryStream) || void 0 === a ? void 0 : a.id,
                    this.close = this.close.bind(this)
                }
                close() {
                    this._gamepadService.stopListening(),
                    this._matDialogRef.close()
                }
                ngOnDestroy() {
                    this._gamepadService.stopListening();
                    document.querySelector(".cdk-overlay-container").removeAttribute("style")
                }
                ngOnInit() {
                    this._gamepadService.startListening();
                    document.querySelector(".cdk-overlay-container").style.zIndex = "80"
                }
                static show(e, t) {
                    e.open(ns, t)
                }
            }
            ;
            var os;
            ss = ns = (0,
            c.gn)([(0,
            i.Component)({
                selector: "stream-preview-dialog",
                template: n(48913)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(2, (0,
            i.Inject)(En)), (0,
            c.fM)(3, (0,
            i.Inject)(sn)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (is = void 0 !== hn.so && hn.so) ? is : Object, "function" == typeof (as = En) ? as : Object, "function" == typeof (rs = void 0 !== sn && sn) ? rs : Object])], ss);
            let cs = class {
                constructor(e, t) {
                    this._dialogData = e,
                    this._matDialogRef = t,
                    this.ActionsIcons = Ht,
                    this.ComponentState = xr,
                    this.msgs = L.messages.cameras,
                    this.componentState = xr.LOADING,
                    this.orchid = this._dialogData.orchid,
                    this.componentState = xr.LOADED
                }
                close() {
                    this._matDialogRef.close()
                }
                handleRegistrationStart() {
                    this.componentState = xr.LOADING
                }
                handleRegistrationEnd() {
                    this.componentState = xr.LOADED
                }
            }
            ;
            var ls;
            cs = (0,
            c.gn)([(0,
            i.Component)({
                selector: "camera-add-dialog",
                template: n(89201)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.so)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (os = void 0 !== hn.so && hn.so) ? os : Object])], cs),
            function(e) {
                e.TAG = "tag",
                e.RESOURCE_TAG = "resource_tag",
                e.SEARCH = "search",
                e.DATE = "date",
                e.TIME = "time",
                e.CAMERA = "camera",
                e.USER = "user",
                e.SERVER = "server",
                e.EVENT_TYPE = "event_subscription_type"
            }(ls || (ls = {}));
            let ds = class {
                constructor() {
                    this.onRemove = new i.EventEmitter,
                    this.isTagWithValue = !1,
                    this.icons = Object.assign(Object.assign({}, Ht), zt),
                    this.icon = ""
                }
                ngOnInit() {
                    Object.values(ls).includes(this.filter.type) && (this.setIcon(),
                    this.filter.type === ls.RESOURCE_TAG && this.filter.data.value && this.filter.data.value.length > 0 && (this.isTagWithValue = !0))
                }
                setIcon() {
                    switch (this.filter.type) {
                    case ls.SEARCH:
                        this.icon = this.icons.search;
                        break;
                    case ls.TAG:
                    case ls.RESOURCE_TAG:
                        this.icon = this.icons.tag;
                        break;
                    case ls.DATE:
                        this.icon = this.icons.date;
                        break;
                    case ls.TIME:
                        this.icon = this.icons.clock;
                        break;
                    case ls.CAMERA:
                        this.icon = this.icons.camera;
                        break;
                    case ls.USER:
                        this.icon = this.icons.user;
                        break;
                    case ls.SERVER:
                        this.icon = this.icons.servers.server;
                        break;
                    default:
                        this.icon = ""
                    }
                }
                handleRemove() {
                    this.onRemove.emit()
                }
            }
            ;
            function us(e, t) {
                if (0 === t.length)
                    return !0;
                if (t.length > 0 && 0 === e.length)
                    return !1;
                for (let n = 0; n < t.length; n++) {
                    const i = t[n];
                    if (e.findIndex((e => {
                        const t = i.data.label.toLowerCase() === e.key.toLowerCase();
                        return i.data.value && i.data.value.length > 0 ? null !== e.value && (t && i.data.value.toLowerCase() === e.value.toLowerCase()) : t
                    }
                    )) >= 0)
                        return !0
                }
                return !1
            }
            function ms(e, t) {
                return t.map((t => {
                    const n = e.some((e => e.type === ls.RESOURCE_TAG && e.data.label === t.key && e.data.value === t.value));
                    return {
                        type: ls.RESOURCE_TAG,
                        data: {
                            label: t.key,
                            value: t.value ? t.value : ""
                        },
                        value: n,
                        id: `${t.key}-${t.value}`
                    }
                }
                ))
            }
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], ds.prototype, "filter", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], ds.prototype, "onRemove", void 0),
            ds = (0,
            c.gn)([(0,
            i.Component)({
                selector: "filter-chip",
                template: n(60113)
            })], ds);
            const hs = 50;
            var ps, gs, fs, vs;
            !function(e) {
                e.SERVER = "server",
                e.CAMERA = "camera",
                e.EVENT_SUBSCRIPTION = "event subscription"
            }(ps || (ps = {})),
            function(e) {
                e.IN_PROGRESS = "in-progress",
                e.UNSUPPORTED = "unsupported",
                e.SUCCESS = "success",
                e.FAILED = "failed",
                e.DEFAULT = "default",
                e.CANCELED = "canceled",
                e.TIMED_OUT = "timed-out"
            }(gs || (gs = {})),
            function(e) {
                e.BUSY = "busy",
                e.IDLE = "idle"
            }(fs || (fs = {})),
            function(e) {
                e[e.IN_PROGRESS = L.messages.common.inProgress()] = "IN_PROGRESS",
                e[e.SUCCESS = L.messages.common.success()] = "SUCCESS",
                e[e.FAILED = L.messages.common.failed()] = "FAILED"
            }(vs || (vs = {}));
            function ys(e, t=!1) {
                const n = [];
                return e.forEach((e => {
                    var i;
                    const a = {
                        key: e.controls.key.value,
                        value: e.controls.value.value
                    };
                    "" === (null === (i = a.value) || void 0 === i ? void 0 : i.trim()) && (a.value = null),
                    a.key = a.key.toLocaleLowerCase(),
                    a.value && t && (a.value = a.value.toLocaleLowerCase()),
                    n.push(a)
                }
                )),
                n
            }
            function bs(e, t) {
                const n = []
                  , i = new Map;
                return e.forEach((e => {
                    var t;
                    i.has(e.orchidId) || i.set(e.orchidId, []),
                    null === (t = i.get(e.orchidId)) || void 0 === t || t.push(e.cameraId)
                }
                )),
                i.forEach(( (e, i) => {
                    var a;
                    const r = t.findOrchid(i)
                      , s = {
                        cameraRecords: [],
                        recorderName: null !== (a = null == r ? void 0 : r.name) && void 0 !== a ? a : "Unknown Recorder",
                        recorderUUID: i
                    };
                    e.forEach((e => {
                        var t;
                        const n = null == r ? void 0 : r.cameras.find((t => t.id === e));
                        s.cameraRecords.push({
                            name: null !== (t = null == n ? void 0 : n.name) && void 0 !== t ? t : "Unknown camera",
                            id: e
                        })
                    }
                    )),
                    n.push(s)
                }
                )),
                n
            }
            function Ss(e) {
                return "CAMERA_BULK_TAG_END" === e.eventType || "ORCHID_BULK_TAG_END" === e.eventType
            }
            function Cs(e) {
                return "CAMERA_BULK_TAG_START" === e.eventType || "ORCHID_BULK_TAG_START" === e.eventType
            }
            function ws(e) {
                switch (e.status) {
                case "200":
                    return gs.SUCCESS;
                case "410":
                    return gs.CANCELED;
                case "408":
                    return gs.TIMED_OUT;
                default:
                    return gs.FAILED
                }
            }
            Ds.$inject = ["$window", "$rootScope", "$scope", "$mdDialog", "MatDialog", "OrchidDataService", "RenewableService", "ResourceTaggingService", "ActiveStreamStateService", "UserSettingsService", "MinimumVersionService"];
            const Is = "disabled"
              , Ts = "online"
              , Es = "offline"
              , _s = {
                ...ls,
                STATUS: "Status"
            }
              , xs = {
                SINGLE_CHIP: "single_chip",
                LIST: "list"
            };
            function Ds(e, t, n, i, a, r, s, o, c, l, d) {
                var u = this;
                u.displayMode = xs.LIST,
                u.DISPLAY_MODE = xs,
                u.MIN_TAG_LIST_LENGTH = 2,
                u.camerasLoaded = !1,
                u.isOrchid = t.isOrchid,
                u._matDialog = a,
                u.camerasSelectedCount = 0,
                u.selectAll = !1,
                u.isExpanded = {},
                u.shouldDelete = {},
                u.watchers = [],
                u.renewableServiceMessagesSubscription = void 0,
                u.streamDetails = ee,
                u.ActiveStreamStateService = c,
                u.MinimumVersionService = d,
                u.ResourceTaggingService = o,
                u.cameraTzInfo = null,
                u.processingDeletedCameras = !1,
                u.paging = {
                    perPage: 10,
                    current: 0,
                    pageSizeOptions: [10, 20, 30, 40, 50],
                    pageCameraLimit: 10
                },
                u.filteredCameras = [],
                u.activeFilters = [],
                u.cameraStatusFilters = [],
                u.cameraTagFilters = [],
                u.cameraTagFilters = [],
                u.setDisplayMode = function(e) {
                    u.displayMode = e <= 576 ? xs.SINGLE_CHIP : xs.LIST
                }
                ;
                var m = function(e) {
                    u.setDisplayMode(e.srcElement.innerWidth)
                };
                u.pagingPages = function(e) {
                    return Math.ceil(e / u.paging.perPage)
                }
                ,
                u.getCameraStatus = function(e) {
                    return u.cameraDisablementIsSupported && !e.active ? Is : u.isRunning(e) ? Ts : Es
                }
                ,
                u.updateFilteredCameras = function(e) {
                    const t = null != e ? e : u.orchid.cameras;
                    if (0 === u.activeFilters.length)
                        u.filteredCameras = t;
                    else {
                        const e = u.activeFilters.filter((function(e) {
                            return e.type === _s.RESOURCE_TAG
                        }
                        ));
                        u.filteredCameras = t.filter((function(t) {
                            return function(e) {
                                const t = u.activeFilters.filter((function(e) {
                                    return e.type === _s.SEARCH
                                }
                                ));
                                if (0 === t.length)
                                    return !0;
                                const n = e.name.toLowerCase();
                                for (let e = 0; e < t.length; e++)
                                    if (n.includes(t[e].data.label.toLowerCase()))
                                        return !0;
                                return !1
                            }(t) && function(e) {
                                const t = u.activeFilters.filter((function(e) {
                                    return e.type === _s.STATUS
                                }
                                ));
                                if (0 === t.length)
                                    return !0;
                                const n = u.getCameraStatus(e);
                                for (let e = 0; e < t.length; e++)
                                    if (t[e].id === n)
                                        return !0;
                                return !1
                            }(t) && us(t.tags, e)
                        }
                        ))
                    }
                    let n = u.pagingPages(u.filteredCameras.length) - 1;
                    n < 0 && (n = 0),
                    n < u.paging.current && (u.paging.current = n)
                }
                ,
                u.updateCurrentPage = function(e) {
                    u.processingDeletedCameras || u.deselectAllSelectedCameras(),
                    u.paging.current !== e.pageIndex && (u.paging.current = e.pageIndex,
                    u.closeAllCameras()),
                    u.paging.perPage !== e.pageSize && (u.paging.perPage = e.pageSize)
                }
                ,
                u.handleSearchKeyUp = function(e) {
                    "Enter" !== e.key && 13 !== e.keyCode || u.handleSearchSubmit(e.target)
                }
                ,
                u.handleSearchSubmit = function(e) {
                    const t = e.value;
                    e.blur(),
                    e.value = "",
                    u.activeFilters.push({
                        type: _s.SEARCH,
                        data: {
                            label: t
                        },
                        value: !0,
                        id: t
                    }),
                    u.onFiltersChanged()
                }
                ,
                u.onFiltersChanged = function() {
                    u.processingDeletedCameras || u.deselectAllSelectedCameras(),
                    u.paging.current = 0,
                    u.closeAllCameras(),
                    u.updateFilteredCameras()
                }
                ,
                u.closeAllCameras = function() {
                    document.querySelectorAll(".camera-card.big-summer-blowout").forEach((function(e) {
                        e.classList.contains("expanded") && e.expandMe()
                    }
                    )),
                    angular.forEach(u.orchid.cameras, (function(e) {
                        u.isExpanded[e.id] && (u.isExpanded[e.id] = !1)
                    }
                    ))
                }
                ,
                u.deselectAllSelectedCameras = function() {
                    u.selectAll = !1,
                    u.camerasSelectedCount = 0,
                    u.shouldDelete && Object.keys(u.shouldDelete).forEach((function(e) {
                        u.shouldDelete[e] = !1
                    }
                    ))
                }
                ,
                u.createCamerasEnabledText = function() {
                    if (0 === u.orchid.cameras.length)
                        return "";
                    return `${u.orchid.cameras.filter((function(e) {
                        return !u.cameraDisablementIsSupported || e.active
                    }
                    )).length}/${u.orchid.discoverableOrchid.licenseSession.license.cameras} ${u.msgs.camerasEnabled()}`
                }
                ,
                u.createCamerasDisabledText = function() {
                    if (0 === u.orchid.cameras.length)
                        return "";
                    let e = u.orchid.cameras.filter((function(e) {
                        return !!u.cameraDisablementIsSupported && !e.active
                    }
                    )).length;
                    return 0 === e ? "" : `${u.msgs.VALUECamerasDisabled({
                        VALUE: e
                    })}`
                }
                ,
                u.getCameraStatusIconClass = function(e) {
                    switch (u.getCameraStatus(e)) {
                    case Is:
                        return `${qt.camera_disabled} disabled-camera-icon`;
                    case Ts:
                        return qt.camera_up;
                    default:
                        return qt.camera_down
                    }
                }
                ,
                u.isRunning = function(e) {
                    let n;
                    return e.primaryStream && (n = u.ActiveStreamStateService.activeStreamsMap[e.primaryStream.id] ? u.ActiveStreamStateService.activeStreamsMap[e.primaryStream.id].streamState : t.isOrchid ? e.primaryStream.status ? e.primaryStream.status.streamState : "unknown" : e.lastStreamState),
                    "running" === n
                }
                ,
                u.toggleSelected = function(e, t) {
                    var n;
                    angular.isUndefined(u.shouldDelete[e.id]) && (u.shouldDelete[e.id] = !1),
                    n = angular.isUndefined(t) ? !u.shouldDelete[e.id] : t,
                    u.shouldDelete[e.id] !== n && (u.shouldDelete[e.id] = n,
                    u.camerasSelectedCount += u.shouldDelete[e.id] ? 1 : -1)
                }
                ,
                u.selectAllChanged = function(e) {
                    const t = u.filteredCameras.sort((function(e, t) {
                        const n = Tt(e.name)
                          , i = Tt(t.name);
                        return n < i ? -1 : n > i ? 1 : void 0
                    }
                    ));
                    t.slice(u.paging.current * u.paging.perPage, (u.paging.current + 1) * u.paging.perPage).forEach((function(t) {
                        return u.toggleSelected(t, e)
                    }
                    ))
                }
                ,
                u.ipOrder = function(e) {
                    var t = 3
                      , n = 0;
                    return e.ip.split(".").forEach((function(e) {
                        n += Number(e) * Math.pow(1e3, t--)
                    }
                    )),
                    n
                }
                ,
                u.addCamera = function(e, t, n) {
                    const i = {
                        panelClass: "camera-add-dialog-panel",
                        disableClose: !0,
                        data: {
                            orchid: u.orchid
                        }
                    };
                    u._matDialog.open(cs, i)
                }
                ,
                u.previewStream = function(e, t) {
                    const n = {
                        panelClass: "custom-stream-preview-dialog-container",
                        data: {
                            camera: e,
                            orchid: u.orchid
                        }
                    };
                    se(e.primaryStream) || (n.streamId = e.primaryStream.id),
                    u._matDialog.open(ss, n)
                }
                ,
                u.deleteCameras = function() {
                    u.deleteErrors = [];
                    const e = u.msgs.dialogs;
                    i.show(i.confirm().theme(l.getTheme()).content(u.msgs.areYouSureDeleteCameras()).ok(e.delete()).cancel(e.cancel())).then((async function() {
                        u.processing = !0,
                        u.ready = !1,
                        u.processingDeletedCameras = !0,
                        await async function() {
                            const e = {
                                ...u.shouldDelete
                            };
                            for (var t = u.orchid.cameras.length - 1; t >= 0; --t) {
                                let n = u.orchid.cameras[t];
                                if (!0 === e[n.id]) {
                                    n.deleteProcessing = !0;
                                    try {
                                        await r.deleteCamera(u.orchid, n),
                                        u.orchid.cameras.splice(t, 1),
                                        0 !== u.camerasSelectedCount && u.camerasSelectedCount--;
                                        const e = u.filteredCameras.length;
                                        0 !== u.paging.current && u.paging.current >= e / u.paging.perPage && u.paging.current--
                                    } catch (e) {
                                        n.deleteProcessing = !1,
                                        u.deleteErrors.push(u.msgs.failedToRemoveNamedCamera({
                                            VALUE: n.name
                                        }))
                                    }
                                }
                            }
                        }(),
                        u.processingDeletedCameras = !1,
                        u.deselectAllSelectedCameras(),
                        s.refreshCameras(u.orchid)
                    }
                    )).catch((function() {
                        return angular.noop()
                    }
                    ))
                }
                ,
                u.$onDestroy = function() {
                    u.ActiveStreamStateService.stopPolling(),
                    u.watchers.forEach((function(e) {
                        e()
                    }
                    )),
                    void 0 !== u.renewableServiceMessagesSubscription && u.renewableServiceMessagesSubscription.unsubscribe(),
                    angular.element(e).off("resize", m)
                }
                ,
                u.$onInit = function() {
                    u.ActiveStreamStateService.startPolling(u.orchid),
                    u.camerasLoaded = !1,
                    u.cameraDisablementIsSupported = !0,
                    u.resourceTaggingIsSupported = !0,
                    u.cameraTimezoneListIsSupported = !0,
                    u.bulkTaggingIsSupported = !0,
                    u.msgs = {
                        ...L.messages.cameras,
                        dialogs: L.messages.dialogs,
                        search: L.messages.library.search,
                        common: L.messages.common,
                        tags: L.messages.resourceTagging
                    },
                    u._initializeFilters(),
                    Promise.all(u._getInitialRequests()).then((function(e) {
                        let[t,n] = e;
                        u.orchid.cameras = t,
                        u.cameraTimezoneListIsSupported && (u.cameraTzInfo = n),
                        u.resourceTaggingIsSupported && u.getAllTags(),
                        u.updateFilteredCameras()
                    }
                    )).finally((function() {
                        u.camerasLoaded = !0
                    }
                    )),
                    w.isOrchid ? u.watchers.push(n.$watch((function() {
                        return u.orchid.cameras
                    }
                    ), (function() {
                        u.getAllTags(),
                        u.updateFilteredCameras()
                    }
                    ))) : u._handleFusionSetup(),
                    u.setDisplayMode(e.innerWidth),
                    angular.element(e).on("resize", m)
                }
                ,
                u._initializeFilters = function() {
                    u.initialStatusFiltersData = [{
                        type: _s.STATUS,
                        typeLabel: u.msgs.status(),
                        data: {
                            label: u.msgs.online()
                        },
                        id: Ts,
                        value: !1
                    }, {
                        type: _s.STATUS,
                        typeLabel: u.msgs.status(),
                        data: {
                            label: u.msgs.offline()
                        },
                        id: Es,
                        value: !1
                    }, {
                        type: _s.STATUS,
                        typeLabel: u.msgs.status(),
                        data: {
                            label: u.msgs.disabled()
                        },
                        id: Is,
                        value: !1
                    }],
                    u.cameraStatusFilters = [...u.initialStatusFiltersData]
                }
                ,
                u._getInitialRequests = function() {
                    const e = [s.fetchCameras(u.orchid)];
                    return w.isOrchid ? e.push(r.fetchCamerasTZList(u.orchid)) : (u.resourceTaggingIsSupported = u.MinimumVersionService.isFeatureSupported(u.orchid, Sr.BULK_TAGGING),
                    u.cameraTimezoneListIsSupported = u.MinimumVersionService.isFeatureSupported(u.orchid, Sr.CAMERA_TZ_LIST),
                    u.cameraTimezoneListIsSupported && e.push(r.fetchCamerasTZList(u.orchid))),
                    e
                }
                ,
                u._handleFusionSetup = function() {
                    if (u.cameraDisablementIsSupported = u.MinimumVersionService.isFeatureSupported(u.orchid, Sr.CAMERA_DISABLEMENT),
                    u.cameraDisablementIsSupported || (u.cameraStatusFilters = u.initialStatusFiltersData.filter((function(e) {
                        return e.id !== Is
                    }
                    ))),
                    u.bulkTaggingIsSupported = u.MinimumVersionService.isFeatureSupported(u.orchid, Sr.BULK_TAGGING),
                    u.bulkTaggingIsSupported) {
                        const e = ["CAMERA_TAG_MODIFIED", "CAMERA_BULK_TAG_END"];
                        u.renewableServiceMessagesSubscription = s.messages$.pipe((0,
                        ra.h)((function(t) {
                            return e.includes(t.eventType)
                        }
                        ))).subscribe({
                            next: function() {
                                s.refreshCameras(u.orchid).then((function(e) {
                                    e.data.cameras && (u.orchid.cameras = e.data.cameras),
                                    u.getAllTags(),
                                    u.updateFilteredCameras()
                                }
                                ))
                            }
                        })
                    }
                }
                ,
                u.getAllTags = async function() {
                    const e = await (0,
                    dt.z)(u.ResourceTaggingService.fetchCameraTags({
                        id: u.orchid.id,
                        uri: u.orchid.uri
                    })).catch((function() {
                        return {
                            tags: []
                        }
                    }
                    ));
                    u.cameraTagFilters = ms(u.activeFilters, e.tags)
                }
                ,
                u.onAddFilter = function(e) {
                    u.activeFilters.push(e),
                    u.onFiltersChanged()
                }
                ,
                u.onRemoveFilter = function(e) {
                    const t = u.activeFilters.findIndex((function(t) {
                        return t.id === e.id
                    }
                    ));
                    u.removeFilter(t)
                }
                ,
                u.removeFilter = function(e) {
                    const t = this.activeFilters[e];
                    if (u.activeFilters.splice(e, 1),
                    t.type === _s.STATUS) {
                        const e = u.cameraStatusFilters;
                        for (let n = 0; n < u.cameraStatusFilters.length; n++)
                            t.id === u.cameraStatusFilters[n].id && (e[n].value = !1);
                        u.cameraStatusFilters = [...e]
                    }
                    if (t.type === _s.RESOURCE_TAG) {
                        const e = u.cameraTagFilters;
                        for (let n = 0; n < u.cameraTagFilters.length; n++)
                            t.id === u.cameraTagFilters[n].id && (e[n].value = !1);
                        u.cameraTagFilters = [...e]
                    }
                    u.onFiltersChanged()
                }
                ,
                u.removeAllFilters = function() {
                    u.activeFilters = [],
                    u.cameraStatusFilters.forEach((function(e) {
                        return e.value = !1
                    }
                    )),
                    u.cameraTagFilters.forEach((function(e) {
                        return e.value = !1
                    }
                    )),
                    u.onFiltersChanged()
                }
                ,
                n.sortingCameraNames = function(e) {
                    return Tt(e.name)
                }
            }
            function Os(e, t) {
                return {
                    restrict: "E",
                    scope: {
                        events: "=",
                        from: "=",
                        to: "=",
                        onPointClick: "&",
                        onPointDblclick: "&"
                    },
                    replace: !0,
                    template: "<div><svg></svg></div>",
                    link: function(e, n) {
                        var i, a, r, s, o, c, l, d = 0, u = 5, m = 15, h = 30, p = [];
                        function g() {
                            return Math.min(10, n[0].clientWidth / 30)
                        }
                        function f() {
                            return 3 === (d += 1) && (i = d3.time.scale().domain([e.from, e.to]).range([0, n[0].clientWidth - 100]),
                            a = d3.scale.linear().domain([0, c]).range([n[0].clientHeight - u - m, 0]),
                            r = d3.svg.axis().scale(i).orient("bottom").tickSize(1).ticks(Math.max(3, n[0].clientWidth / 100)).tickFormat((function(e) {
                                return function(e) {
                                    return 0 === e.getHours() && 0 === e.getMinutes() ? d3.time.format(L.formats.eventChart.date)(e) : d3.time.format(L.formats.eventChart.time)(e)
                                }(e)
                            }
                            )),
                            s = d3.svg.axis().scale(a).orient("left").ticks(Math.min(8, c - l + 1)).tickSize(-n[0].clientWidth),
                            (o = d3.select(n[0]).select("svg").attr("width", "100%").style("height", "100%").append("g").attr("transform", "translate(" + h + "," + u + ")").on("dblclick", (function() {
                                var t;
                                "rect" !== d3.event.target.tagName.toLowerCase() || null !== d3.event.target.getAttribute("class") && -1 !== d3.event.target.getAttribute("class").indexOf("filler") || ((t = d3.select(d3.event.target).data()[0].events).length > 1 && t[t.length - 1].when - t[0].when > 6e4 ? (e.from = new Date(t[0].when),
                                e.to = new Date(t[t.length - 1].when),
                                e.from.setMilliseconds(0),
                                e.from.setSeconds(0),
                                e.to.setMilliseconds(0),
                                e.to.getSeconds() > 0 && (e.to.setSeconds(0),
                                e.to.setMinutes(e.to.getMinutes() + 1)),
                                e.$apply(),
                                e.onPointDblclick()) : alert(L.messages.system.cannotZoomInFurther()))
                            }
                            )).on("click", (function() {
                                "rect" !== d3.event.target.tagName.toLowerCase() || null !== d3.event.target.getAttribute("class") && -1 !== d3.event.target.getAttribute("class").indexOf("filler") ? (o.select("g.points").selectAll("rect").style("fill", ""),
                                e.onPointClick({
                                    events: []
                                }),
                                e.$apply()) : (o.select("g.points").selectAll("rect").style("fill", ""),
                                d3.select(d3.event.target).style("fill", "red"),
                                e.onPointClick({
                                    events: d3.select(d3.event.target).data()[0].events
                                }),
                                e.$apply())
                            }
                            ))).append("rect").attr("class", "filler").attr("width", "100%").attr("height", "100%"),
                            o.append("g").attr("class", "x axis").attr("transform", "translate(0," + (n[0].clientHeight - u - m) + ")").call(r),
                            o.append("g").attr("class", "y axis").call(s),
                            o.append("g").attr("class", "points")),
                            d >= 3
                        }
                        function v() {
                            !0 === angular.isDefined(e.from) && !0 === angular.isDefined(e.to) && !0 === f() && (i.domain([e.from, e.to]),
                            y())
                        }
                        function y(e) {
                            var t = e ? 0 : 250
                              , c = o.select("g.points").selectAll("rect").data(p, (function(e) {
                                return e.x.getTime()
                            }
                            ));
                            c.exit().attr("class", "removed").transition().duration(t).attr("y", (function() {
                                return n[0].clientHeight - u - m
                            }
                            )).attr("height", 0).remove(),
                            c.enter().append("rect").attr("width", g()).attr("x", (function(e) {
                                return i(e.x) - g() / 2
                            }
                            )).attr("y", (function() {
                                return n[0].clientHeight - u - m
                            }
                            )).attr("height", 0),
                            o.select("g.points").selectAll("rect:not(.removed)").transition().delay(t).duration(t).attr("x", (function(e) {
                                return i(e.x) - g() / 2
                            }
                            )).attr("y", (function(e) {
                                return e.h = n[0].clientHeight - u - m - a(e.y),
                                a(e.y) - Math.abs(Math.max(10, e.h) - e.h)
                            }
                            )).attr("width", g()).attr("height", (function(e) {
                                return Math.max(10, e.h)
                            }
                            )),
                            o.selectAll("g .y.axis").transition().duration(t).call(s),
                            o.selectAll("g .x.axis").transition().duration(t).call(r)
                        }
                        const b = t.$on("resize", (function() {
                            i.range([0, n[0].clientWidth - 100]),
                            r.ticks(Math.max(3, n[0].clientWidth / 100)),
                            s.tickSize(-n[0].clientWidth),
                            y()
                        }
                        ));
                        e.$on("$destroy", (function() {
                            b()
                        }
                        )),
                        e.$watch("to", v),
                        e.$watch("from", v),
                        e.$watch("events", (function() {
                            var t, n, r, o, d, u = {};
                            if (p = [],
                            e.events.length > 0) {
                                for (t = e.from.getTime() + (i.invert(g() / 2 + 1).getTime() - i.invert(0).getTime()),
                                n = e.to.getTime(),
                                d = i.invert(g() + 5) - i.invert(0); t < n; ) {
                                    for (r = 0; r < e.events.length; r += 1)
                                        e.events[r].when >= t && e.events[r].when <= t + d && (u[t] || (u[t] = []),
                                        u[t].push(e.events[r]));
                                    t += d
                                }
                                for (o in u)
                                    u.hasOwnProperty(o) && p.push({
                                        x: new Date(parseInt(o, 10)),
                                        y: u[o].length,
                                        events: u[o]
                                    })
                            }
                            !0 === f() && (p.length > 0 ? (l = p.reduce((function(e, t) {
                                return e < t.y ? e : t.y
                            }
                            ), 1),
                            c = p.reduce((function(e, t) {
                                return e > t.y ? e : t.y
                            }
                            ), 0)) : (l = 1,
                            c = 1),
                            a.domain([0, c]),
                            s.ticks(Math.min(8, c - l + 1)),
                            y())
                        }
                        ))
                    }
                }
            }
            function As(e, t, n, i, a, r) {
                var s = this;
                function o() {
                    !1 === s.fetching && !0 === angular.isDefined(s.from) && !0 === angular.isDefined(s.to) && (s.fetching = !0,
                    a.generateReport(s.orchid, s.from.getTime(), s.to.getTime()).then((function(e) {
                        s.fetching = !1,
                        s.streams = [],
                        s.events = [],
                        s.selectedEvents = [],
                        e.data.cameras && e.data.cameras.forEach((function(e) {
                            e.streams.forEach((function(t) {
                                var n = angular.copy(t);
                                n.cameraName = e.name,
                                s.streams.push(n)
                            }
                            ))
                        }
                        )),
                        s.events = [],
                        e.data.orchidEvents && e.data.orchidEvents.forEach((function(e) {
                            s.events.push({
                                what: e.type + (e.message ? " - " + e.message : ""),
                                where: i.brand.APP_ID,
                                descriptiveWhere: i.brand.CHILD_APP_ID,
                                when: e.when
                            })
                        }
                        )),
                        e.data.streamEvents && e.data.streamEvents.forEach((function(e) {
                            if ("failover failed" === e.type)
                                e.message = "archive loss event";
                            s.events.push({
                                what: "stream-" + e.type + (e.message ? " - " + e.message : ""),
                                where: e.streamId,
                                when: e.when
                            })
                        }
                        ))
                    }
                    ), (function(e) {
                        s.fetching = !1,
                        s.streams = [],
                        s.events = [],
                        s.selectedEvents = [],
                        n.debug("An error occurred:", e)
                    }
                    )))
                }
                s.isOrchid = e.isOrchid,
                s.fetching = !1,
                s.from = new Date,
                s.to = new Date,
                s.from.setHours(0, 0, 0, 0),
                s.to.setHours(23, 59, 0, 0),
                s.streams = [],
                s.events = [],
                s.selectedEvents = [],
                s.pointClick = function(e) {
                    s.selectedEvents = e,
                    s.selectedEvents.forEach((function(e) {
                        !1 === e.hasOwnProperty("descriptiveWhere") && (e.descriptiveWhere = s.lookupWhere(e.where))
                    }
                    ))
                }
                ,
                s.pointDblClick = function() {
                    o()
                }
                ,
                s.lookupWhere = function(e) {
                    var t;
                    return "orchid" === e ? e : 0 === (t = s.streams.filter((function(t) {
                        if (t.streamId === e)
                            return !0
                    }
                    ))).length ? s.msgs.unknownCameraStream() : t[0].cameraName + " / " + t[0].name
                }
                ,
                s.showDateTimePicker = function(e) {
                    (0,
                    dt.z)(Pi(r, {
                        date: e ? s.to : s.from,
                        title: e ? s.msgs.to() : s.msgs.from(),
                        okText: s.msgs.go(),
                        hideSeconds: !0,
                        useOrchidTheme: !0
                    })).then((function(t) {
                        t && (e ? s.to = t : s.from = t,
                        o())
                    }
                    ))
                }
                ,
                t.sortingCameraNames = function(e) {
                    return Tt(e.cameraName)
                }
                ,
                s.$onInit = function() {
                    s.msgs = L.messages.system,
                    s.dateTimeFormat = L.formats.ipcDatePicker.noSeconds,
                    s.dateFormat = L.formats.systemStatus.date,
                    o()
                }
            }
            angular.module("ipconfigure.orchid.singularity").controller("CameraConfigController", Ds).directive("cameraConfig", (function() {
                return {
                    scope: {},
                    restrict: "E",
                    bindToController: {
                        orchid: "="
                    },
                    controller: "CameraConfigController",
                    controllerAs: "cameraConfig",
                    template: n(87592),
                    link: function(e, t, n, i) {
                        i.wrappedElement = t[0]
                    }
                }
            }
            )),
            Os.$inject = ["$window", "$rootScope"],
            angular.module("ipconfigure.orchid.singularity").directive("eventsChart", Os),
            As.$inject = ["$rootScope", "$scope", "$log", "BrandService", "OrchidDataService", "MatDialog"],
            angular.module("ipconfigure.orchid.singularity").controller("SystemReportController", As).directive("systemReport", (function() {
                return {
                    scope: {},
                    restrict: "E",
                    bindToController: {
                        orchid: "="
                    },
                    controller: "SystemReportController",
                    controllerAs: "systemReport",
                    template: n(59040)
                }
            }
            ));
            n(93609);
            const Rs = 864e5
              , Ps = 86400
              , ks = new Date(2e3,0,1);
            function Ms(e) {
                const t = new Date(e);
                return t.setUTCHours(23, 59, 59, 999),
                t.setUTCMonth(t.getMonth() + 1, 0),
                t.getTime()
            }
            function Ls(e) {
                const t = new Date(e);
                return t.setUTCDate(1),
                t.setUTCHours(0, 0, 0, 0),
                t.getTime()
            }
            function Ns(e) {
                const t = new Date(e);
                return t.setUTCHours(0, 0, 0, 0),
                t.getTime()
            }
            function Fs(e, t) {
                const n = new Date(t).getUTCHours()
                  , i = new Date(Ns(e));
                return i.setUTCHours(n),
                i
            }
            function Us(e) {
                return null !== e && e >= ks
            }
            function $s(e, t, n) {
                return e <= t && t <= n
            }
            function js(e, t) {
                const n = Math.pow(10, t);
                return Math.round((e + Number.EPSILON) * n) / n
            }
            var Vs;
            let Gs = class {
                constructor(e, t, n, i, a, r) {
                    this._cameras = e,
                    this._diskUsage = t,
                    this._cameraUsage24h = n,
                    this._cameraUsageFull = i,
                    this._orchid = a,
                    this._minimumVersionService = r,
                    this._cameraDisablementIsSupported = !0,
                    this._camStreamsDiskUsageIsSupported = !0,
                    w.isOrchid || (this._cameraDisablementIsSupported = this._minimumVersionService.isFeatureSupported(this._orchid, Sr.CAMERA_DISABLEMENT),
                    this._camStreamsDiskUsageIsSupported = this._minimumVersionService.isFeatureSupported(this._orchid, Sr.CAMERA_STREAMS_DISK_USAGE))
                }
                calculateRetentionData() {
                    const e = this._diskUsage.storage.capacity
                      , t = this._diskUsage.storage.unavailable
                      , n = this._diskUsage.cleanerThreshold + t
                      , i = e - n
                      , a = {
                        bytesFromDeletedCameras: 0,
                        bytesFromDeletedCamerasPercentage: 0,
                        bytesFromDeletedCamerasPiped: er.transform(0),
                        cameras: [],
                        cleanerThresholdPiped: er.transform(n),
                        estimatedStorageUsage: 0,
                        estimatedStorageUsagePercentage: 0,
                        maxUsagePiped: er.transform(i),
                        storageThreshold: n,
                        thresholdPercentage: 100 * n / e,
                        totalBytesEstimated: 0,
                        totalBytesEstimatedPercentage: 0,
                        unavailable: t,
                        unavailablePercentage: 100 * t / e,
                        unavailablePiped: er.transform(t),
                        freePiped: er.transform(this._diskUsage.storage.free)
                    };
                    this._cameras.forEach((t => {
                        var n, i, r;
                        if (!this._cameraUsage24h.some((e => t.id === e.camera.id))) {
                            let s = Ka;
                            if (t.primaryStream)
                                try {
                                    s = Za(t.primaryStream.recordingConfiguration)
                                } catch (e) {
                                    s = Ka
                                }
                            const o = this._cameraUsageFull.find((e => e.camera.id === t.id));
                            a.cameras.push({
                                bytesEstimated: 0,
                                bytesEstimatedPercentage: 0,
                                bytesEstimatedPerDay: 0,
                                bytesEstimatedPerDayPiped: er.transform(0),
                                bytesFromDeletedStreams: 0,
                                bytesRecorded: null !== (n = null == o ? void 0 : o.bytesRecorded) && void 0 !== n ? n : 0,
                                bytesRecordedPercentage: (null !== (i = null == o ? void 0 : o.bytesRecorded) && void 0 !== i ? i : 0) / e,
                                bytesRecordedPiped: er.transform(null !== (r = null == o ? void 0 : o.bytesRecorded) && void 0 !== r ? r : 0),
                                daysDesired: t.retention / Rs,
                                daysEstimated: 0,
                                daysRecorded: 0,
                                id: +t.id,
                                isNewCamera: !1,
                                isRecording: !1,
                                name: t.name,
                                override: t.retention > 0,
                                recordingStyle: s,
                                retentionSpanDays: 0,
                                secondsRecorded: 0,
                                streams: []
                            })
                        }
                    }
                    )),
                    this._cameraUsage24h.forEach((t => {
                        var n, i;
                        const r = this._cameras.find((e => t.camera.id === e.id));
                        if (r) {
                            let s, o = 0, c = Ka;
                            const l = this._cameraUsageFull.find((e => e.camera.id === t.camera.id));
                            if (this._camStreamsDiskUsageIsSupported && (s = l.streams.reduce(( (e, t) => e.secondsRecorded > t.secondsRecorded ? e : t))),
                            void 0 !== r.primaryStream) {
                                try {
                                    c = Za(r.primaryStream.recordingConfiguration)
                                } catch (e) {}
                                t.retentionSpanMilliseconds && (o = t.retentionSpanMilliseconds / Rs),
                                o = js(o, 2)
                            }
                            let d, u;
                            this._cameraDisablementIsSupported ? (d = c.group !== Wa.NON_RECORDING && null !== (n = r.active) && void 0 !== n && n,
                            u = void 0 !== r.secondaryStreams && r.secondaryStreams.some((e => e.recording)) && null !== (i = r.active) && void 0 !== i && i) : (d = c.group !== Wa.NON_RECORDING,
                            u = void 0 !== r.secondaryStreams && r.secondaryStreams.some((e => e.recording)));
                            const m = {
                                bytesEstimated: 0,
                                bytesEstimatedPerDay: 0,
                                bytesEstimatedPerDayPiped: er.transform(0),
                                bytesEstimatedPercentage: 0,
                                bytesFromDeletedStreams: 0,
                                bytesRecorded: l.bytesRecorded,
                                bytesRecordedPercentage: 100 * l.bytesRecorded / e,
                                bytesRecordedPiped: er.transform(l.bytesRecorded),
                                retentionSpanDays: o,
                                daysDesired: r.retention / Rs,
                                daysEstimated: 0,
                                daysRecorded: this._camStreamsDiskUsageIsSupported ? js(s.secondsRecorded / Ps, 2) : 0,
                                id: +r.id,
                                isNewCamera: 0 === t.secondsRecorded && t.numUnfinalizedArchives > 0,
                                isRecording: d || u,
                                name: r.name,
                                override: r.retention > 0,
                                recordingStyle: c,
                                secondsRecorded: t.secondsRecorded,
                                streams: []
                            };
                            let h = 0;
                            this._camStreamsDiskUsageIsSupported && t.streams.forEach((t => {
                                var n;
                                const i = r.streams.find((e => e.id === t.stream.id));
                                if (void 0 === i || i.id !== (null === (n = r.primaryStream) || void 0 === n ? void 0 : n.id) && !i.recordWhenSecondary)
                                    m.bytesFromDeletedStreams += t.bytesRecorded;
                                else {
                                    let n;
                                    try {
                                        n = Za(i.recordingConfiguration)
                                    } catch (e) {
                                        n = Ka
                                    }
                                    const a = n.group === Wa.NON_RECORDING || t.secondsRecorded <= 0 ? 0 : t.bytesRecorded * Ps / t.secondsRecorded;
                                    h += a;
                                    const r = l.streams.find((e => e.stream.id === t.stream.id))
                                      , s = {
                                        bytesEstimated: 0,
                                        bytesEstimatedPerDay: a,
                                        bytesEstimatedPerDayPiped: er.transform(a),
                                        bytesEstimatedPercentage: 0,
                                        bytesRecorded: r.bytesRecorded,
                                        bytesRecordedPercentage: 100 * r.bytesRecorded / e,
                                        bytesRecordedPiped: er.transform(r.bytesRecorded),
                                        daysDesired: 0,
                                        daysEstimated: 0,
                                        daysRecorded: r.secondsRecorded / Ps,
                                        id: i.id,
                                        override: !1,
                                        secondsRecorded: t.secondsRecorded
                                    };
                                    m.streams.push(s)
                                }
                            }
                            )),
                            m.bytesEstimatedPerDay = m.isRecording ? h : 0,
                            m.bytesEstimatedPerDayPiped = er.transform(m.bytesEstimatedPerDay),
                            a.cameras.push(m)
                        }
                    }
                    ));
                    const r = this._cameraUsageFull.filter((e => !this._cameras.some((t => t.id === e.camera.id)))).reduce(( (e, t) => e + t.bytesRecorded), 0);
                    return a.bytesFromDeletedCameras = r,
                    a.bytesFromDeletedCameras > 0 && (a.bytesFromDeletedCamerasPiped = er.transform(a.bytesFromDeletedCameras)),
                    a.bytesFromDeletedCamerasPercentage = 100 * a.bytesFromDeletedCameras / e,
                    a
                }
                calculateEstimatedRetentionData(e) {
                    let t = 0
                      , n = 0
                      , i = 0;
                    e.totalBytesEstimated = e.totalBytesEstimatedPercentage = 0,
                    e.cameras.forEach((e => {
                        !0 === e.override ? t += e.bytesEstimatedPerDay * e.daysDesired : n += e.bytesEstimatedPerDay
                    }
                    ));
                    const a = this._diskUsage.cleanerThreshold - t;
                    return n > 0 && a > 0 && (i = a / n),
                    e.cameras.forEach((t => {
                        var n;
                        !1 === t.isRecording || t.secondsRecorded <= 0 ? t.daysEstimated = 0 : !0 === t.override ? t.daysEstimated = null !== (n = t.daysDesired) && void 0 !== n ? n : 0 : t.daysEstimated = i,
                        t.bytesEstimated = t.bytesEstimatedPerDay * t.daysEstimated,
                        t.bytesEstimatedPercentage = 100 * t.bytesEstimated / this._diskUsage.storage.capacity,
                        e.totalBytesEstimated += t.bytesEstimated,
                        e.totalBytesEstimatedPercentage += t.bytesEstimatedPercentage,
                        t._daysEstimatedExact = t.daysEstimated,
                        t.daysEstimated = js(t.daysEstimated, 2)
                    }
                    )),
                    e.estimatedStorageUsage = e.totalBytesEstimated,
                    e.estimatedStorageUsagePercentage = 100 * (e.estimatedStorageUsage + e.unavailable) / this._diskUsage.storage.capacity,
                    e
                }
            }
            ;
            var Bs, zs, Hs;
            Gs = (0,
            c.gn)([(0,
            c.fM)(5, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", [Array, Object, Array, Array, Object, "function" == typeof (Vs = void 0 !== Cr && Cr) ? Vs : Object])], Gs);
            const Ws = O("ConfirmDialog");
            let qs = Bs = class {
                constructor(e, t, n) {
                    this.options = e,
                    this.matDialogRef = t,
                    this.injector = n,
                    this.isProcessing = !1,
                    this.msgs = L.messages.dialogs,
                    this.options.contentInput && (this.contentInputInjector = i.Injector.create({
                        providers: [{
                            provide: this.options.contentInput.injectionToken,
                            useValue: this.options.contentInput.data
                        }],
                        parent: this.injector
                    }))
                }
                cancel() {
                    this.matDialogRef.disableClose || this.matDialogRef.close(!1)
                }
                confirm() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        try {
                            this.matDialogRef.disableClose = !0,
                            this.isProcessing = !0,
                            this.options.confirmCallback && this.options.confirmCallback(),
                            this.options.confirmCallbackAsync && (yield this.options.confirmCallbackAsync()),
                            this.matDialogRef.close(!0)
                        } catch (e) {
                            (null == e ? void 0 : e.message) ? this.error = e.message : (this.error = this.options.customErrorText ? this.options.customErrorText : this.msgs.anUnexpectedErrorHasOccurred(),
                            Ws.error(e))
                        } finally {
                            this.isProcessing = !1,
                            this.matDialogRef.disableClose = !1
                        }
                    }
                    ))
                }
                onEsc() {
                    this.cancel()
                }
                static show(e, t) {
                    return e.open(Bs, t).afterClosed().pipe((0,
                    pn.q)(1))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.HostListener)("keydown.esc"), (0,
            c.w6)("design:type", Function), (0,
            c.w6)("design:paramtypes", []), (0,
            c.w6)("design:returntype", void 0)], qs.prototype, "onEsc", null),
            qs = Bs = (0,
            c.gn)([(0,
            i.Component)({
                selector: "sing-confirm-dialog",
                template: n(41402)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.so)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (zs = void 0 !== hn.so && hn.so) ? zs : Object, "function" == typeof (Hs = void 0 !== i.Injector && i.Injector) ? Hs : Object])], qs);
            const Ys = new i.InjectionToken("desired_retention_dialog_input");
            let Xs = class {
                constructor(e) {
                    this._data = e,
                    this.tableDataSource = new Ei.by(this._data),
                    this.msgs = Object.assign(Object.assign({}, L.messages.retentionPolicy), L.messages.timeUnitsPlural)
                }
                shouldShowTimeSpan(e) {
                    const t = e => Math.round(100 * e) / 100;
                    return t(e.daysDeletionTimeSpan) !== t(e.daysFootageToDelete)
                }
            }
            ;
            Xs = (0,
            c.gn)([(0,
            i.Component)({
                selector: "desired-retention-confirm-dialog",
                changeDetection: i.ChangeDetectionStrategy.OnPush,
                template: n(19343)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Ys)), (0,
            c.w6)("design:paramtypes", [Array])], Xs);
            var Ks = n(34978);
            Zs.$inject = ["$rootScope", "$scope", "$log", "$q", "OrchidDataService", "RenewableService", "BytesPipe", "MatDialog", "MinimumVersionService"];
            function Zs(e, t, n, i, a, r, s, o, c) {
                var l, d = this, u = [];
                d.RecordingStyleId = qa,
                d.hasMotionOnlyStreams = !1,
                d.isOrchid = e.isOrchid,
                d.bytesPipe = s,
                d.cameraDisablementIsSupported = !0,
                d.disabledCameraIcon = qt.camera_disabled,
                d.bulkUpdateResetter$ = new St.x,
                d.isRetentionBulkUpdaterDisabled = function() {
                    return d.retentionData.cameras.every((function(e) {
                        return !d.isCameraActive(e.id) || !e.isRecording
                    }
                    ))
                }
                ,
                d.getBorderClass = function(e) {
                    if (e > 0) {
                        if ((d.retentionData.cameras[e].id % 26 ? d.retentionData.cameras[e].id % 26 : 1) === (d.retentionData.cameras[e - 1].id % 26 ? d.retentionData.cameras[e - 1].id % 26 : 1))
                            return "needs-border"
                    }
                    return ""
                }
                ,
                d.retentionBulkUpdate = function(e, t, n) {
                    if (!e)
                        return;
                    const i = d.retentionData.cameras.filter((function(e) {
                        return d.isCameraActive(e.id) && e.isRecording
                    }
                    ));
                    i.length && (i.forEach((function(n) {
                        n.override = "custom" === e,
                        n.daysDesired = "custom" === e ? t : 0
                    }
                    )),
                    d.recalculateEstimates(),
                    n.$setDirty())
                }
                ,
                d.resetRetentionBulkUpdater = function() {
                    d.bulkUpdateResetter$.next()
                }
                ,
                d.setRetentionToAutomaticIfZero = function(e, t) {
                    0 === e.daysDesired && !0 === e.override && d.toggleRetentionOverride(e, t)
                }
                ,
                d.toggleRetentionOverride = function(e, t) {
                    e.override = !e.override,
                    !0 === e.override ? e.daysDesired = e._daysEstimatedExact ? function(e, t) {
                        const n = Math.pow(10, t);
                        return Math.trunc(e * n) / n
                    }(e._daysEstimatedExact, 2) : e.daysEstimated : e.daysDesired = 0,
                    d.recalculateEstimates(!0),
                    t.$setDirty()
                }
                ,
                d.revertChanges = function(e) {
                    d.retentionData = xt(d.retentionDataOriginal),
                    e.$setPristine(),
                    d.resetRetentionBulkUpdater()
                }
                ,
                d.recalculateEstimates = function(e) {
                    e && d.resetRetentionBulkUpdater(),
                    d.retentionData = d.retentionCalculator.calculateEstimatedRetentionData(d.retentionData)
                }
                ,
                d._calculateRetentionSpanDays = function(e) {
                    return a.fetchArchiveAt(0, e, d.orchid, 1).then((function(e) {
                        const t = e.data.archives.length > 0 ? e.data.archives[0].start : Date.now();
                        return js((Date.now() - t) / Rs, 1)
                    }
                    )).catch((function() {
                        return 0
                    }
                    ))
                }
                ,
                d.isCameraActive = function(e) {
                    const t = d.cameraObjectsReceived.find((function(t) {
                        return t.id === e
                    }
                    ));
                    return !d.cameraDisablementIsSupported || t.active
                }
                ,
                d.saveConfiguration = function(e) {
                    d.processingSave = !0;
                    const t = d.retentionData.cameras.filter((function(e) {
                        const t = d.retentionDataOriginal.cameras.find((function(t) {
                            return t.id === e.id
                        }
                        ));
                        return t && t.daysDesired !== e.daysDesired
                    }
                    )).map((function(e) {
                        return {
                            id: e.id,
                            retention: !0 === e.override ? e.daysDesired * Ps * 1e3 : 0
                        }
                    }
                    ))
                      , n = w.isOrchid || c.isFeatureSupported(d.orchid, Sr.MAX_RETENTION_CAP) ? (0,
                    Be.P)((function() {
                        return a.doRetentionUpdateDryRun(d.orchid, {
                            cameras: t
                        })
                    }
                    )).pipe((0,
                    lr.K)((function(e) {
                        throw d.processingSave = !1,
                        d.processingSaveFailed = !0,
                        d.processingSaveFailedMessage = d.msgs.unexpectedErrorWhenSavingRetention(),
                        e
                    }
                    )), (0,
                    Ks.w)((function(e) {
                        if (d.processingSave = !1,
                        !e || !e.cameras.some((function(e) {
                            return e.retention.playTimeBeingDeletedMs > 0
                        }
                        )))
                            return (0,
                            ze.of)(null);
                        const t = e.cameras.filter((function(e) {
                            return e.retention.playTimeBeingDeletedMs > 0
                        }
                        )).map((function(e) {
                            const t = d.retentionData.cameras.find((function(t) {
                                return t.id === e.id
                            }
                            ))
                              , n = d.retentionDataOriginal.cameras.find((function(t) {
                                return t.id === e.id
                            }
                            ))
                              , i = e.retention;
                            return {
                                cameraName: t.name,
                                oldRetention: n.daysDesired,
                                newRetention: t.daysDesired,
                                daysFootageToDelete: i.playTimeBeingDeletedMs / 864e5,
                                daysDeletionTimeSpan: i.timeSpanBeingDeletedMs / 864e5
                            }
                        }
                        ));
                        return qs.show(o, {
                            maxWidth: "min(80vw, 800px)",
                            disableClose: !0,
                            data: {
                                confirmText: d.msgs.update(),
                                cancelText: d.msgs.cancel(),
                                content: Xs,
                                contentInput: {
                                    injectionToken: Ys,
                                    data: t
                                }
                            }
                        }).pipe((0,
                        ra.h)((function(e) {
                            return e
                        }
                        )))
                    }
                    ))) : (0,
                    ze.of)(null);
                    n.subscribe((function() {
                        d.processingSave = !0;
                        const n = t.map((function(e, t) {
                            return a.updateCamera(d.orchid, e).then((function() {
                                return d.retentionData.cameras[t].retention = e.retention
                            }
                            ))
                        }
                        ));
                        i.all(n).then((function() {
                            d.processingSave = !1,
                            d.processingSaveFailed = !1,
                            d.processingSaveFailedMessage = "",
                            e.$setPristine(),
                            d.retentionDataOriginal = xt(d.retentionData),
                            r.refreshCameras(d.orchid)
                        }
                        )).catch((function(e) {
                            d.processingSave = !1,
                            d.processingSaveFailed = !0,
                            d.processingSaveFailedMessage = d.msgs.unexpectedErrorWhenSavingRetention(),
                            Array.isArray(e) && e.length > 0 && e[0].data ? d.processingSaveFailedMessage += ": " + e[0].data.reason : d.processingSaveFailedMessage += "."
                        }
                        ))
                    }
                    ))
                }
                ,
                d.$onInit = function() {
                    d.isOrchid || (d.cameraDisablementIsSupported = c.isFeatureSupported(d.orchid, Sr.CAMERA_DISABLEMENT)),
                    d.msgs = {
                        ...L.messages.retentionPolicy,
                        ...L.messages.storageUnits,
                        ...L.messages.common,
                        errors: L.messages.errors,
                        slashDay: L.messages.slashDay
                    },
                    d.processing = !0,
                    d.processingFailed = !1,
                    d.processingFailedMessage = "",
                    d.processingSave = !1,
                    d.processingSaveFailed = !1,
                    d.processingSaveFailedMessage = "",
                    d.cameraObjectsReceived = [],
                    u.push(r.fetchCameras(d.orchid)),
                    u.push(a.getDiskUtilization(d.orchid)),
                    u.push(a.getRetention(d.orchid, Date.now() - 864e5, Date.now())),
                    u.push(a.getRetention(d.orchid, 0, Date.now())),
                    i.all(u).then((function(e) {
                        if (!0 === d.destroyed)
                            return Promise.reject();
                        d.cameraObjectsReceived = e[0],
                        e[2].data.cameras.forEach((function(e) {
                            void 0 !== e.primaryStream && void 0 === e.primaryStream.retentionSpanMilliseconds && (e.retentionSpanMilliseconds = d._calculateRetentionSpanDays(e.primaryStream.id))
                        }
                        )),
                        d.retentionCalculator = new Gs(e[0],e[1].data,e[2].data.cameras,e[3].data.cameras,d.orchid,c),
                        d.retentionData = d.retentionCalculator.calculateRetentionData(),
                        d.retentionData = d.retentionCalculator.calculateEstimatedRetentionData(d.retentionData),
                        d.retentionData.cameras.filter((function(e) {
                            return e.recordingStyle.id === d.RecordingStyleId.MOTION_ONLY
                        }
                        )).length > 0 && (d.hasMotionOnlyStreams = !0)
                    }
                    )).then((function() {
                        if (!0 === d.destroyed)
                            return Promise.reject();
                        d.retentionDataOriginal = xt(d.retentionData),
                        d.processing = !1
                    }
                    )).catch((function(e) {
                        !0 !== d.destroyed && (d.processing = !1,
                        d.processingFailed = !0,
                        "string" == typeof e ? d.processingFailedMessage = e : e && e.data && "string" == typeof e.data.reason ? d.processingFailedMessage = e.data.reason : d.processingFailedMessage = d.msgs.errors.unknownErrorOccurred(),
                        n.error("init error", e))
                    }
                    ))
                }
                ,
                d.$onDestroy = function() {
                    d.destroyed = !0,
                    l()
                }
                ,
                t.sortingCameraNames = function(e) {
                    return Tt(e.name)
                }
                ,
                l = t.$watch((function() {
                    return d.orchid.cameras.length
                }
                ), (function(e, t) {
                    t && t !== e && d.$onInit()
                }
                ))
            }
            angular.module("ipconfigure.orchid.singularity").controller("RetentionPolicyController", Zs).directive("retentionPolicy", (function() {
                return {
                    scope: {},
                    restrict: "E",
                    bindToController: {
                        orchid: "="
                    },
                    controller: "RetentionPolicyController",
                    controllerAs: "retentionPolicy",
                    template: n(62532)
                }
            }
            ));
            n(96895);
            function Js(e, t, n, i, a, r, s, o) {
                var c = this;
                c.bulkAction = !1,
                c.user = s,
                c.isFusion = o,
                c.orchid = r,
                c.showBulkAction = !c.isFusion && !e.isOrchid,
                c.confirm = function(e) {
                    s.error = void 0,
                    c.bulkAction ? t.hide({
                        user: c.user,
                        bulk: !0
                    }) : s.processing = i.deleteUser(c.orchid, s).then((function() {
                        a.getAuthenticationData().username === s.username ? n.location.reload() : t.hide({
                            user: s,
                            bulk: !1
                        })
                    }
                    )).catch((function(e) {
                        s.processing = !1,
                        e.data && e.data.reason ? s.error = e.data.reason : s.error = c.msgs.anErrorOccurredWhileDeleteUser()
                    }
                    ))
                }
                ,
                c.cancel = function() {
                    s.error = void 0,
                    t.cancel()
                }
                ,
                c.$onInit = function() {
                    c.msgs = L.messages.userManager
                }
            }
            function Qs(e, t, n) {
                var i = this;
                i.searchText = "",
                i.querySearch = function(e) {
                    var t = i.masterList.filter(i.createFilterFor(e)).sort((function(e, t) {
                        return e._lowerName.toLowerCase() < t._lowerName.toLowerCase() ? -1 : e._lowerName.toLowerCase() > t._lowerName.toLowerCase() ? 1 : 0
                    }
                    ));
                    return n.notify(),
                    t
                }
                ,
                i.createFilterFor = function(e) {
                    var t = angular.lowercase(e);
                    return function(n) {
                        if (angular.isUndefined(n._lowerName) && (n._lowerName = angular.lowercase(n[i.nameField])),
                        0 === e.length || n._lowerName.indexOf(t) > -1)
                            return !i.items.some((function(e) {
                                return e.id === n.id
                            }
                            ))
                    }
                }
                ,
                i.transformChip = function(e) {
                    return angular.isObject(e) ? e : {
                        name: e,
                        type: "new"
                    }
                }
                ,
                i.$onInit = function() {
                    i.msgs = L.messages.chips,
                    i.ngDisabled || (i.uniqueSelector = "autocomplete---" + t.v4(),
                    e((function() {
                        document.getElementById(i.uniqueSelector).addEventListener("blur", (function() {
                            e((function() {
                                if (i.searchText.length > 0) {
                                    var e = i.querySearch(i.searchText);
                                    1 === e.length ? (i.errorMessage = "",
                                    i.items.push(i.transformChip(e[0])),
                                    i.searchText = "") : 0 === e.length ? i.errorMessage = i.msgs.yourSearchDidNotMatchAnyResults() : i.errorMessage = i.msgs.pleaseChooseAnOptionFromTheMenu()
                                } else
                                    i.errorMessage = ""
                            }
                            ))
                        }
                        ))
                    }
                    )))
                }
            }
            o().module("ipconfigure.orchid.singularity").controller("OrchidUserDialogController", ["$rootScope", "$mdDialog", "BrandService", "OrchidDataService", "AuthenticationService", "orchid", "user", "roleTransHelper", function(e, t, n, i, a, r, s, c) {
                var l = this
                  , d = a.getAuthenticationData();
                l._destroy$ = new St.x,
                l.msgs = {},
                l.formMsgs = {},
                l.$onInit = function() {
                    l.msgs = {
                        ...L.messages.userManager,
                        errors: L.messages.errors
                    },
                    l.formMsgs = L.messages.credentialsForm,
                    l.title = l.newUser ? l.msgs.newUserFor({
                        VALUE: l.orchidName
                    }) : l.msgs.usernameFrom({
                        USERNAME: l.user.username,
                        FROM: l.orchidName
                    }),
                    l.titleShort = l.newUser ? l.msgs.newUserForShort() : l.title,
                    l.buttonTitle = l.newUser ? l.msgs.addUser() : l.msgs.updateUser()
                }
                ,
                l.$onDestroy = function() {
                    l._destroy$.next(),
                    l._destroy$.complete()
                }
                ,
                l.newUser = o().isUndefined(s) || o().isDefined(s) && o().isUndefined(s.id),
                l.bulkCreate = !1,
                l.bulkUpdate = !1,
                l.isOrchid = e.isOrchid,
                l.isSelf = !1 !== e.isOrchid && !l.newUser && d.username === s.username,
                l.roleTransHelper = c,
                l.newUser ? o().isUndefined(s) ? l.user = {
                    role: "Manager"
                } : l.user = {
                    role: s.role,
                    processing: s.processing,
                    selected: s.selected,
                    username: s.username
                } : (l.user = o().copy(s),
                l.user.isAdmin = "admin" === s.username);
                function u(e) {
                    l.user.processing = !1,
                    o().isUndefined(e) || null === e ? l.error = l.msgs.errors.noResponseReturnedFrom({
                        VALUE: n.brand.APP_NAME
                    }) : o().isDefined(e.reason) ? l.error = e.reason : l.error = l.msgs.errors.unexpectedErrorOccurred()
                }
                l.user.password = "",
                l.user.confirmPassword = "",
                l.orchidName = !0 === e.isOrchid ? n.brand.APP_NAME : r.name,
                l.addOrUpdateUser = function() {
                    "" === l.user.password && (l.user.password = null,
                    l.user.passwordConfirm = null),
                    l.newUser ? (l.user.processing = !0,
                    l.bulkCreate ? t.hide({
                        user: l.user,
                        bulk: !0
                    }) : i.addUser(r, l.user).then((function(e) {
                        t.hide({
                            user: e.data,
                            bulk: !1
                        })
                    }
                    ), (function(e) {
                        u(e.data)
                    }
                    ))) : l.bulkUpdate ? t.hide({
                        user: l.user,
                        bulk: !0
                    }) : (l.user.processing = !0,
                    i.updateUser(r, l.user).then((function(n) {
                        !0 === l.isSelf && e.$broadcast("logout"),
                        t.hide({
                            user: n.data,
                            bulk: !1
                        })
                    }
                    ), (function(e) {
                        u(e.data)
                    }
                    )))
                }
                ,
                l.cancel = function() {
                    t.cancel()
                }
            }
            ]),
            angular.module("ipconfigure.orchid.singularity").controller("OrchidUserBulkDeleteConfirmDialogController", ["$mdDialog", "$q", "OrchidDataService", "CrossOrchidDataService", "user", "roleTransHelper", function(e, t, n, i, a, r) {
                var s, o = this;
                o.orchidUsers = [],
                o.promises = [],
                o.user = a,
                o.ready = !1,
                o.processing = !1,
                o.roleTransHelper = r,
                (s = i.findByName({
                    match: a.username
                }, o.orchidUsers)).parent.then((function() {
                    t.all(s.child).finally((function() {
                        o.ready = !0,
                        o.orchidUsers.forEach((function(e) {
                            e.apply = !0
                        }
                        ))
                    }
                    ))
                }
                ), (function() {}
                )),
                o.rowClass = function(e) {
                    var t = "";
                    return e.error ? t = "error-row" : e.noUser ? t = "noop-row" : e.apply || (t = "no-apply-row"),
                    t
                }
                ,
                o.actionText = function(e) {
                    return e.error ? o.msgs.noActionCannotQueryServer() : e.noUser ? o.msgs.noActionUserDoesNotExist() : o.msgs.userWillBeRemoved()
                }
                ,
                o.accept = function() {
                    o.processing = !0,
                    o.promises = [],
                    o.orchidUsers.forEach((function(e) {
                        angular.isUndefined(e.user) || !0 === e.apply && o.promises.push(n.deleteUser(e.orchid, e.user))
                    }
                    )),
                    t.all(o.promises).then((function() {
                        e.hide()
                    }
                    ), (function(t) {
                        var n = o.msgs.anErrorOccurredWhileProcessingBulkDelete();
                        e.hide(),
                        -1 === t.status ? angular.isDefined(t.config.url) ? n += `\n\n${o.msgs.unableToConnedToServer({
                            SERVER: t.config.url
                        })}` : n += `\n\n${o.msgs.connectionAborted()}` : t.statusText.length > 0 && (n += "\n\n" + t.status + ": " + t.statusText),
                        alert(n)
                    }
                    ))
                }
                ,
                o.cancel = function() {
                    e.cancel()
                }
                ,
                o.$onInit = function() {
                    o.msgs = L.messages.userManager
                }
            }
            ]),
            Js.$inject = ["$rootScope", "$mdDialog", "$window", "OrchidDataService", "AuthenticationService", "orchid", "user", "isFusion"],
            angular.module("ipconfigure.orchid.singularity").controller("OrchidUserDeleteDialogController", Js),
            Qs.$inject = ["$timeout", "uuid", "AutocompleteRepairService"],
            angular.module("ipconfigure.orchid.singularity").controller("autocompleteChipsController", Qs).directive("autocompleteChips", (function() {
                return {
                    restrict: "E",
                    bindToController: {
                        items: "=",
                        masterList: "=",
                        ngDisabled: "=?",
                        placeholder: "@",
                        nameField: "@",
                        changeCallback: "&?"
                    },
                    controller: "autocompleteChipsController as autocompleteChips",
                    template: function(e, t) {
                        return '<md-chips                    ng-model="autocompleteChips.items"                    md-autocomplete-snap                    md-transform-chip="autocompleteChips.transformChip($chip)"                    md-require-match="true"                    ng-change="autocompleteChips.changeCallback()"                    ng-class="{ \'disabled\': autocompleteChips.ngDisabled }"                     readonly="autocompleteChips.ngDisabled"                >                    <md-autocomplete                        md-input-id="{{autocompleteChips.uniqueSelector}}"                        md-menu-class="{{autocompleteChips.uniqueSelector}}"                        md-selected-item="autocompleteChips.selectedItem"                        md-search-text="autocompleteChips.searchText"                        md-items="item in autocompleteChips.querySearch(autocompleteChips.searchText)"                        md-item-text="item[autocompleteChips.nameField]"                        md-min-length="0"                        md-no-cache="true"                        md-dropdown-position="bottom"                        md-menu-class="autocomplete-matches"                        placeholder="' + t.placeholder + '">                        <span md-highlight-text="autocompleteChips.searchText" md-highlight-flags="gi">{{item[autocompleteChips.nameField]}}</span>                    </md-autocomplete>                    <md-chip-template>                        <span>                            <strong>{{$chip[autocompleteChips.nameField]}}</strong>                        </span>                    </md-chip-template>                </md-chips>                <div class="autocomplete-validation-text" ng-if="autocompleteChips.errorMessage">                    {{autocompleteChips.errorMessage}}                </div>'
                    }
                }
            }
            )),
            o().module("ipconfigure.orchid.singularity").controller("SingularityUserDialogController", ["$mdDialog", "BrandService", "DataService", "AuthenticationService", "user", "groups", function(e, t, n, i, a, r) {
                var s = this;
                s.groups = r,
                s.msgs = {
                    ...L.messages.userManager,
                    ...L.messages.dialogs
                },
                s.formMsgs = L.messages.credentialsForm,
                s.newUser = o().isUndefined(a),
                s.newUser ? (s.user = {
                    groups: [],
                    isEnabled: !0,
                    role: "Viewer"
                },
                s.isCurrentUser = !1) : (s.user = o().copy(a),
                s.user.isAdmin = "admin" === a.username,
                s.isCurrentUser = i.getAuthenticationData().username === a.username);
                s.showGoogleAuthEmailInfoTip = void 0 !== i.getAuthenticationProviders().find((function(e) {
                    return e.type.toLowerCase() === De.GOOGLE_OAUTH
                }
                )),
                s.user.password = "",
                s.user.confirmPassword = "",
                s.title = s.newUser ? s.msgs.newUserFor({
                    VALUE: t.brand.APP_NAME
                }) : s.msgs.usernameFrom({
                    USERNAME: s.user.username,
                    FROM: t.brand.APP_NAME
                }),
                s.buttonTitle = s.newUser ? s.msgs.addUser() : s.msgs.updateUser(),
                s.addOrUpdateUser = function() {
                    "" === s.user.password && (s.user.password = void 0,
                    s.user.passwordConfirm = void 0),
                    s.processing = !0,
                    s.newUser ? n.addUser(s.user).then((function(t) {
                        e.hide({
                            user: t.data
                        })
                    }
                    ), (function(e) {
                        s.processing = !1,
                        e.data && e.data.reason ? s.error = e.data.reason : s.error = s.msgs.anUnexpectedErrorHasOccurred()
                    }
                    )) : n.updateUser(s.user).then((function(t) {
                        e.hide({
                            user: t
                        })
                    }
                    ), (function(e) {
                        s.processing = !1,
                        e && e.reason ? s.error = e.reason : s.error = s.msgs.anUnexpectedErrorHasOccurred()
                    }
                    ))
                }
                ,
                s.cancel = function() {
                    e.cancel()
                }
            }
            ]),
            angular.module("ipconfigure.orchid.singularity").controller("OrchidBulkActionConfirmController", ["$mdDialog", "$q", "OrchidDataService", "CrossOrchidDataService", "originalUser", "newUser", "bulkCreate", "roleTransHelper", function(e, t, n, i, a, r, s, o) {
                var c, l = this, d = a && a.username !== r.username ? {
                    match: a.username,
                    avoid: r.username
                } : {
                    match: r.username
                };
                l.siblingUpdates = [],
                l.promises = [],
                l.user = r,
                l.ready = !1,
                l.processing = !1,
                l.bulkCreate = s,
                l.roleTransHelper = o,
                (c = i.findByName(d, l.siblingUpdates)).parent.then((function() {
                    t.all(c.child).finally((function() {
                        l.ready = !0,
                        l.siblingUpdates.forEach((function(e) {
                            e.apply = !0
                        }
                        ))
                    }
                    ))
                }
                ), (function() {}
                )),
                l.sortOrder = function() {
                    return l.bulkCreate ? ["error", "noUser", "orchid.name"] : ["-noUser", "-error", "orchid.name"]
                }
                ,
                l.rowClass = function(e) {
                    var t = "";
                    return e.error || e.avoid ? t = "error-row" : !l.bulkCreate && angular.isUndefined(e.user) ? t = "noop-row" : e.apply || (t = "no-apply-row"),
                    t
                }
                ,
                l.actionText = function(e) {
                    return e.error ? l.msgs.noActionCannotQueryServer() : e.avoid ? `${l.msgs.userWithSameNameExists()} "${e.user.username}"` : e.noUser ? l.bulkCreate ? l.msgs.userWillBeAdded() : l.msgs.noActionUserDoesNotExist() : l.msgs.userWillBeUpdated()
                }
                ,
                l.accept = function() {
                    l.promises = [],
                    l.processing = !0,
                    l.siblingUpdates.forEach((function(e) {
                        if (!e.error && !e.avoid && e.apply)
                            if (angular.isDefined(e.user)) {
                                var t = e.orchid
                                  , i = e.user
                                  , a = angular.copy(l.user);
                                a.id = i.id,
                                a.href = i.href,
                                l.promises.push(n.updateUser(t, a))
                            } else
                                l.bulkCreate && l.promises.push(n.addUser(e.orchid, l.user))
                    }
                    )),
                    t.all(l.promises).then((function() {
                        e.hide()
                    }
                    ), (function(t) {
                        var n = l.msgs.anErrorOccurredWhileProcessingBulkDelete();
                        e.hide(),
                        -1 === t.status ? angular.isDefined(t.config.url) ? n += `\n\n${l.msgs.unableToConnedToServer({
                            SERVER: t.config.url
                        })}` : n += `\n\n${l.msgs.connectionAborted()}` : t.statusText.length > 0 && (n += "\n\n" + t.status + ": " + t.statusText),
                        alert(n)
                    }
                    ))
                }
                ,
                l.cancel = function() {
                    e.cancel()
                }
                ,
                l.$onInit = function() {
                    l.msgs = L.messages.userManager
                }
            }
            ]);
            let eo = function() {
                function e(t, n, i, a, r, s, o, c, l, d, u, m) {
                    (0,
                    S.Z)(this, e),
                    this.$mdDialog = t,
                    this.$scope = n,
                    this.$rootScope = i,
                    this.$timeout = a,
                    this.BrandService = r,
                    this.DataService = s,
                    this.FusionDataService = o,
                    this.OrchidDataService = c,
                    this.AuthenticationService = l,
                    this.AutocompleteRepairService = d,
                    this.UserSettingsService = u,
                    this.Router = m,
                    this.isFusion = !1,
                    this.hideUri = this.isFusion || i.isOrchid,
                    this.isSingle = i.isOrchid,
                    this.users = [],
                    this.title = this.BrandService.APP_NAME,
                    this.loading = !0,
                    this.paging = {
                        perPage: 16,
                        pageSizeOptions: [16, 32, 48, 64, 80],
                        current: 0,
                        paginatorLimit: 16
                    },
                    this.filters = {
                        searchNames: []
                    },
                    this.failedReason = "",
                    this.promise = null,
                    this.noUsersMessageKeys = {
                        Exist: "existence",
                        Matches: "matches"
                    },
                    this.roles = ["Administrator", "Manager", "Viewer", "Live Viewer"]
                }
                return (0,
                b.Z)(e, [{
                    key: "filteredUsers",
                    get: function() {
                        const e = this.users;
                        if (0 === this.filters.searchNames.length)
                            return e;
                        const t = this.filters.searchNames;
                        return e.filter((function(e) {
                            const n = e.username.toLowerCase();
                            for (let e = 0; e < t.length; e++)
                                if (n.includes(t[e].toLowerCase()))
                                    return !0;
                            return !1
                        }
                        ))
                    }
                }, {
                    key: "displayedUsersPerPage",
                    get: function() {
                        return this.paging.perPage
                    }
                }, {
                    key: "noUsersOrSearchDidNotMatchSwitchKey",
                    get: function() {
                        return this.users && 0 !== this.users.length ? this.noUsersMessageKeys.Matches : this.noUsersMessageKeys.Exist
                    }
                }, {
                    key: "$onInit",
                    value: function() {
                        var e = this;
                        this.msgs = {
                            ...L.messages.userManager,
                            search: L.messages.dashboard.search,
                            dialogs: L.messages.dialogs
                        },
                        this.roleToTrans = {
                            Administrator: this.msgs.administrator(),
                            Manager: this.msgs.manager(),
                            Viewer: this.msgs.viewer(),
                            "Live Viewer": this.msgs.liveViewer()
                        },
                        this.roleTransHelper = {
                            roles: this.roles,
                            roleToTrans: this.roleToTrans,
                            translatedRole(e) {
                                return this.roleToTrans[e] || e
                            }
                        },
                        this.isFusion = void 0 === this.orchid,
                        this.title = this.isFusion || this.$rootScope.isOrchid ? this.BrandService.brand.APP_NAME : this.orchid.name,
                        this.isFusion ? this.promise = this.FusionDataService.fetchUsers() : this.promise = this.OrchidDataService.fetchUsers(this.orchid),
                        this.promise.then((function(t) {
                            !0 === e.isFusion && o().forEach(t, (function(t) {
                                e.generateGroupList(t)
                            }
                            )),
                            e.users = t,
                            e.loading = !1
                        }
                        ), (function(t) {
                            e.failedReason = e.msgs.failedToLoadUsers(),
                            e.processing = !1,
                            e.promise.$$state.status = 1,
                            e.loading = !1
                        }
                        ))
                    }
                }, {
                    key: "onPageChange",
                    value: function(e) {
                        this.paging.current = e.pageIndex,
                        this.paging.perPage = e.pageSize
                    }
                }, {
                    key: "onFiltersChanged",
                    value: function() {
                        var e = this;
                        this.$timeout((function() {
                            e.paging.current = 0
                        }
                        ))
                    }
                }, {
                    key: "getStartFromIndex",
                    value: function() {
                        return this.paging.current * this.paging.perPage
                    }
                }, {
                    key: "pagingPages",
                    value: function(e) {
                        return Math.ceil(e / this.paging.perPage)
                    }
                }, {
                    key: "pageRange",
                    value: function(e) {
                        const t = this.getStartFromIndex() + 1
                          , n = Math.min(t + this.paging.perPage - 1, (Array.isArray(e) ? e : this.users).length);
                        return t === n ? `${t}` : (t > n && (this.paging.current = this.paging.current - 1 < 0 ? this.paging.current : this.paging.current - 1),
                        `${t}-${n}`)
                    }
                }, {
                    key: "openContextMenu",
                    value: function(e, t, n) {
                        e.processing ? n.stopPropagation() : t.open(n)
                    }
                }, {
                    key: "addUser",
                    value: function(e, t) {
                        var n = this;
                        this.openUserDialog(o().isDefined(t) ? t : void 0, e, (function(t) {
                            t.bulk ? n.openBulkUpdateDialog(t.user, e, !0) : o().isDefined(t.user) && (n.generateGroupList(t.user),
                            n.users.push(t.user))
                        }
                        ), (function() {}
                        ))
                    }
                }, {
                    key: "modifyUser",
                    value: function(e, t) {
                        var n = this;
                        e.stopPropagation(),
                        t.selected = !0,
                        t.processing || this.openUserDialog(t, e, (function(i) {
                            i.bulk && n.openBulkUpdateDialog(i.user, e, !1),
                            o().isDefined(i.user) && (n.generateGroupList(i.user),
                            o().copy(i.user, t))
                        }
                        ), (function() {
                            t.selected = !1
                        }
                        ))
                    }
                }, {
                    key: "openBulkUpdateDialog",
                    value: function(e, t, i) {
                        var a = this;
                        e.selected = !1;
                        var r = {
                            template: n(24476),
                            clickOutsideToClose: !1,
                            escapeToClose: !1,
                            parent: o().element(document.body),
                            controller: "OrchidBulkActionConfirmController as orchidBulkActionConfirm",
                            targetEvent: t,
                            locals: {
                                originalUser: i ? void 0 : e,
                                newUser: e,
                                bulkCreate: i,
                                roleTransHelper: this.roleTransHelper
                            }
                        };
                        this.$mdDialog.show(r).then((function() {
                            const e = a.Router.url;
                            a.Router.navigateByUrl("/", {
                                skipLocationChange: !0
                            }).then((function() {
                                return a.Router.navigateByUrl(e)
                            }
                            ))
                        }
                        ), (function() {
                            i ? (e.processing = !1,
                            a.addUser(t, e)) : (e.selected = !1,
                            a.modifyUser(t, e))
                        }
                        ))
                    }
                }, {
                    key: "deleteUser",
                    value: function(e, t) {
                        var i = this;
                        let a;
                        e.stopPropagation(),
                        a = this.isFusion ? this.deleteSingularityUser(e, t) : this.deleteOrchidUser(e, t),
                        a.then((function(t) {
                            if (t.bulk) {
                                var a = {
                                    template: n(60298),
                                    controller: "OrchidUserBulkDeleteConfirmDialogController as orchidUserBulkDeleteConfirmDialog",
                                    parent: o().element(document.body),
                                    clickOutsideToClose: !1,
                                    escapeToClose: !1,
                                    targetEvent: e,
                                    locals: {
                                        user: t.user,
                                        roleTransHelper: i.roleTransHelper
                                    }
                                };
                                i.$mdDialog.show(a).then((function() {
                                    i.removeUser(t.user)
                                }
                                )).catch((function() {}
                                ))
                            } else
                                i.removeUser(t.user)
                        }
                        ), (function(e) {}
                        ))
                    }
                }, {
                    key: "removeUser",
                    value: function(e) {
                        o().isDefined(e) && this.users.includes(e) && this.users.splice(this.users.indexOf(e), 1)
                    }
                }, {
                    key: "isCurrentUser",
                    value: function(e) {
                        return this.AuthenticationService.getAuthenticationData().username === e.username
                    }
                }, {
                    key: "generateGroupList",
                    value: function(e) {
                        !0 === this.isFusion && (e.groupList = e.groups.map((function(e) {
                            return e.name
                        }
                        )).join(", "))
                    }
                }, {
                    key: "deleteOrchidUser",
                    value: function(e, t) {
                        return this.$mdDialog.show({
                            template: n(37996),
                            controller: "OrchidUserDeleteDialogController as orchidUserDeleteDialog",
                            parent: o().element(document.body),
                            targetEvent: e,
                            clickOutsideToClose: !1,
                            escapeToClose: !1,
                            locals: {
                                user: t,
                                orchid: this.orchid,
                                isFusion: this.isFusion,
                                roleTransHelper: this.roleTransHelper
                            }
                        })
                    }
                }, {
                    key: "openUserDialog",
                    value: function(e, t, i, a) {
                        const r = {
                            template: this.isFusion ? n(87794) : n(15426),
                            controller: this.isFusion ? "SingularityUserDialogController as singularityUserDialog" : "OrchidUserDialogController as orchidUserDialog",
                            onComplete: this.isFusion ? this.AutocompleteRepairService.handleDialog : void 0,
                            parent: o().element(document.body),
                            targetEvent: t,
                            clickOutsideToClose: !1,
                            escapeToClose: !1,
                            locals: {
                                user: e,
                                orchid: this.orchid,
                                groups: this.groups,
                                roleTransHelper: this.roleTransHelper
                            }
                        };
                        this.$mdDialog.show(r).then(i, a)
                    }
                }, {
                    key: "deleteSingularityUser",
                    value: function(e, t) {
                        var n = this;
                        const i = function() {
                            return delete t.processing,
                            {
                                user: t
                            }
                        };
                        return this.$mdDialog.show(this.$mdDialog.confirm().theme(this.UserSettingsService.getTheme()).content(this.msgs.deleteWhichUser({
                            VALUE: t.username
                        })).ok(this.msgs.deleteUser()).cancel(this.msgs.dialogs.cancel())).then((function() {
                            const e = n.DataService.deleteUser(t);
                            return t.processing = e,
                            e.then(i).catch((function(e) {
                                let a = n.msgs.failedToDeleteUser({
                                    VALUE: t.username
                                });
                                e.data.reason && (a = e.data.reason),
                                n.$mdDialog.show(n.$mdDialog.alert().content(a).ok(n.msgs.dialogs.ok())),
                                i()
                            }
                            ))
                        }
                        ))
                    }
                }, {
                    key: "getDeleteIcon",
                    value: function(e) {
                        if (!e)
                            return "";
                        return !this.isFusion && "admin" === e.username || this.isFusion && e.superUser ? "fa-solid fa-lock" : "fa-regular fa-trash-can"
                    }
                }]),
                e
            }();
            function to(e) {}
            eo.$inject = ["$mdDialog", "$scope", "$rootScope", "$timeout", "BrandService", "DataService", "FusionDataService", "OrchidDataService", "AuthenticationService", "AutocompleteRepairService", "UserSettingsService", "Router"],
            o().module("ipconfigure.orchid.singularity").controller("UserManagerListController", eo).component("userManagerList", {
                bindings: {
                    orchid: "=",
                    groups: "="
                },
                controller: "UserManagerListController",
                controllerAs: "userManagerList",
                template: n(32243)
            }),
            angular.module("ipconfigure.orchid.singularity").controller("OrchidAdminController", ["DataService", to]).directive("orchidAdmin", (function() {
                return {
                    scope: {},
                    restrict: "E",
                    bindToController: {
                        component: "@",
                        orchids: "=",
                        route: "="
                    },
                    controller: "OrchidAdminController",
                    controllerAs: "orchidAdmin",
                    template: n(98737)
                }
            }
            )),
            to.$inject = ["DataService"];
            const no = {
                HEALTHY: "healthy",
                EXPIRING: "expiring",
                OFFLINE: "offline",
                UNSUPPORTED: "unsupported",
                DEGRADED: "degraded",
                CONTROLLEDSHUTDOWN: "controlled shutdown",
                PENDINGSHUTDOWN: "pending shutdown"
            }
              , io = {
                ORCHID: "orchid",
                OFFLINE: "offline",
                UNSUPPORTED: "unsupported",
                CONTROLLEDSHUTDOWN: "controlled shutdown"
            }
              , ao = {
                HEALTHY: {
                    id: no.HEALTHY,
                    severity: 0,
                    content: io.ORCHID,
                    iconStyle: "fa-regular fa-server",
                    displayText: L.messages.dashboard.serverIsAvailable(),
                    generateCameraStatus: function(e) {
                        return L.messages.dashboard.camerasOnline({
                            VALUE: `${e.camerasOnline}/${e.camerasAvailable}`
                        })
                    }
                },
                EXPIRING: {
                    id: no.EXPIRING,
                    severity: 1,
                    content: io.ORCHID,
                    iconStyle: "fa-regular fa-clock warn-color",
                    displayText: L.messages.dashboard.licenseExpiration(),
                    generateCameraStatus: function(e) {
                        return L.messages.dashboard.camerasOnline({
                            VALUE: `${e.camerasOnline}/${e.camerasAvailable}`
                        })
                    }
                },
                OFFLINE: {
                    id: no.OFFLINE,
                    severity: 2,
                    content: io.OFFLINE,
                    iconStyle: "fa-solid fa-circle-down warn-color",
                    displayText: L.messages.dashboard.serverIsUnavailable(),
                    generateCameraStatus: function(e) {
                        return L.messages.dashboard.camerasOnline({
                            VALUE: "?/?"
                        })
                    }
                },
                UNSUPPORTED: {
                    id: no.UNSUPPORTED,
                    severity: 3,
                    content: io.UNSUPPORTED,
                    iconStyle: "fa-regular fa-server warn-color",
                    displayText: L.messages.dashboard.serverIsUnsupported(),
                    generateCameraStatus: function(e) {
                        return L.messages.dashboard.camerasOnline({
                            VALUE: "?/?"
                        })
                    }
                },
                DEGRADED: {
                    id: no.DEGRADED,
                    severity: 4,
                    content: io.ORCHID,
                    iconStyle: "fa-triangle-exclamation",
                    displayText: L.messages.dashboard.serverIsDegraded(),
                    generateCameraStatus: function(e) {
                        return L.messages.dashboard.camerasOnline({
                            VALUE: `${e.camerasOnline}/${e.camerasAvailable}`
                        })
                    }
                },
                PENDINGSHUTDOWN: {
                    id: no.PENDINGSHUTDOWN,
                    severity: 5,
                    content: io.ORCHID,
                    iconStyle: "fa-regular fa-server warn-color",
                    displayText: L.messages.dashboard.confirmRequired(),
                    generateCameraStatus: function(e) {
                        return L.messages.dashboard.camerasOnline({
                            VALUE: `${e.camerasOnline}/${e.camerasAvailable}`
                        })
                    }
                },
                CONTROLLEDSHUTDOWN: {
                    id: no.CONTROLLEDSHUTDOWN,
                    severity: 6,
                    content: io.CONTROLLEDSHUTDOWN,
                    iconStyle: "fa-solid fa-circle-down warn-color",
                    displayText: L.messages.dashboard.serverIsUnavailable(),
                    generateCameraStatus: function(e) {
                        return L.messages.dashboard.camerasOnline({
                            VALUE: "?/?"
                        })
                    }
                }
            }
              , ro = /^https?:\/\//i
              , so = /^[^@]+@[^@]+$/
              , oo = /^[a-zA-Z0-9_]*$/;
            const co = {
                applyHeaders: function(e) {
                    return t => Object.assign(Object.assign({}, t), {
                        headers: Object.assign(Object.assign({}, t.headers), e)
                    })
                },
                applySearchParams: function(e) {
                    return t => Object.assign(Object.assign({}, t), {
                        params: Object.assign(Object.assign({}, t.params), e)
                    })
                },
                cacheBust: function(e) {
                    return t => Object.assign(Object.assign({}, t), {
                        params: Object.assign(Object.assign({}, t.params), {
                            "cache-bust": null != e ? e : Date.now()
                        })
                    })
                },
                withCredentials: function(e) {
                    return t => Object.assign(Object.assign({}, t), {
                        withCredentials: null == e || e
                    })
                }
            };
            const lo = Object.assign(Object.assign({}, co), {
                appendFsidToURL: function() {
                    return (e, {sessionIdService: t}) => {
                        const n = t.getLocalSessionId();
                        if (!n)
                            throw new Error("The local session ID is undefined!");
                        return Object.assign(Object.assign({}, e), {
                            params: Object.assign(Object.assign({}, e.params), {
                                fsid: n
                            })
                        })
                    }
                },
                authorizeFusion: function() {
                    return (e, {sessionIdService: t}) => {
                        const n = t.getLocalSessionId();
                        if (!n)
                            throw new Error("The local session ID is undefined!");
                        return Object.assign(Object.assign({}, e), {
                            headers: Object.assign(Object.assign({}, e.headers), {
                                Authorization: `Bearer ${n}`
                            })
                        })
                    }
                }
            });
            var uo;
            let mo = class {
                constructor(e) {
                    this._requestBuilder = e
                }
                recoverRecorder(e, t) {
                    return this._requestBuilder.createRequest(w.baseUrl + "/service/orchids/" + e.id).with(lo.authorizeFusion()).patch(t)
                }
            }
            ;
            var ho, po, go, fo, vo;
            mo = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(gr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (uo = void 0 !== gr && gr) ? uo : Object])], mo);
            let yo = ho = class {
                constructor(e, t, n, i) {
                    this._formBuilder = e,
                    this.dialogData = t,
                    this._dialogRef = n,
                    this._recorderManagerService = i,
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.recorderRecovery.dialogs), L.messages.common), {
                        aValidHttpOrHttpsUrlIsRequired: L.messages.dashboard.aValidHttpOrHttpsUrlIsRequired,
                        unknownErrorOccurred: L.messages.errors.unknownErrorOccurred
                    }),
                    this.processing = !1,
                    this.errorMessage = "",
                    this.recoveryForm = this._formBuilder.group({
                        url: [this.dialogData.recorder.uri, [p.kI.required, p.kI.pattern(ro)]],
                        username: ["", [p.kI.required]],
                        password: ["", [p.kI.required]]
                    }),
                    this.stepIndex = 0,
                    this.oldCameras = [],
                    this.newCameras = [],
                    this.mappedCameraIds = [],
                    this.numCamsMapped = 0,
                    this.showNumCamsMsg = !1,
                    this.numCamsMsg = "",
                    this.mappingSummary = {
                        allCameras: [],
                        camerasToDelete: [],
                        camerasToMigrate: [],
                        camerasToAdd: []
                    },
                    this._destroy$ = new St.x
                }
                get urlFormControl() {
                    return this.recoveryForm.get("url")
                }
                get usernameFormControl() {
                    return this.recoveryForm.get("username")
                }
                get passwordFormControl() {
                    return this.recoveryForm.get("password")
                }
                get countCamerasToRemove() {
                    return this.oldCameras.length - this.mappedCameraIds.length
                }
                get countCamerasToMigrate() {
                    return this.mappedCameraIds.length
                }
                get countCamerasToAdd() {
                    return this.newCameras.length - this.mappedCameraIds.length
                }
                ngOnInit() {
                    this._dialogRef.keydownEvents().pipe((0,
                    oa.R)(this._destroy$)).subscribe((e => {
                        switch (e.key) {
                        case "Escape":
                            this.processing || this._dialogRef.close(void 0);
                            break;
                        case "Enter":
                            !this.processing && 0 === this.stepIndex && this.recoveryForm.valid && this.recoverRecorder()
                        }
                    }
                    ))
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                nextStep() {
                    this.stepIndex++,
                    this._stepper.next()
                }
                previousStep() {
                    0 !== this.oldCameras.length && 0 !== this.newCameras.length || this.stepIndex !== this._stepper.steps.length - 1 ? (this.stepIndex--,
                    this._stepper.previous()) : (this.stepIndex = 0,
                    this._stepper.selected = this._stepper.steps.first)
                }
                recoverRecorder() {
                    this.processing = !0,
                    (0,
                    dt.z)(this._recorderManagerService.recoverRecorder({
                        id: this.dialogData.recorder.id,
                        uri: this.dialogData.recorder.uri
                    }, {
                        name: this.dialogData.recorder.name,
                        password: this.passwordFormControl.value,
                        uri: this.urlFormControl.value,
                        username: this.usernameFormControl.value,
                        cameraMapping: void 0
                    })).then((e => {
                        this._dialogRef.close(e)
                    }
                    )).catch((e => {
                        var t;
                        409 === e.status ? (this.newRecorderSummary = {
                            recorderName: this.dialogData.recorder.name,
                            recorderURL: this.urlFormControl.value,
                            recorderCameraCount: e.error.newServer.cameras ? e.error.newServer.cameras.length : 0
                        },
                        this.currentRecorderSummary = {
                            recorderName: this.dialogData.recorder.name,
                            recorderURL: this.dialogData.recorder.uri,
                            recorderCameraCount: e.error.oldServer.cameras ? e.error.oldServer.cameras.length : 0
                        },
                        e.error.newServer.cameras ? (e.error.newServer.cameras.sort(( (e, t) => Tt(e.name).localeCompare(Tt(t.name)))),
                        this.newCameras = xt(e.error.newServer.cameras)) : this.newCameras = [],
                        this.mappedCameraIds = [],
                        e.error.oldServer.cameras ? (e.error.oldServer.cameras.sort(( (e, t) => Tt(e.name).localeCompare(Tt(t.name)))).map((e => Object.assign(Object.assign({}, e), {
                            mappedCameraId: void 0
                        }))),
                        this.oldCameras = xt(e.error.oldServer.cameras)) : this.oldCameras = [],
                        this.errorMessage = "",
                        this.generateMappingSummary(),
                        0 === this.oldCameras.length || 0 === this.newCameras.length ? (this.stepIndex = this._stepper.steps.length - 1,
                        this._stepper.selected = this._stepper.steps.last) : this.nextStep()) : this.errorMessage = null !== (t = e.error.reason) && void 0 !== t ? t : this.msgs.unknownErrorOccurred()
                    }
                    )).finally(( () => {
                        this.processing = !1
                    }
                    ))
                }
                recoverRecorderWithMappings() {
                    this.processing = !0,
                    (0,
                    dt.z)(this._recorderManagerService.recoverRecorder({
                        id: this.dialogData.recorder.id,
                        uri: this.dialogData.recorder.uri
                    }, {
                        name: this.dialogData.recorder.name,
                        password: this.passwordFormControl.value,
                        uri: this.urlFormControl.value,
                        username: this.usernameFormControl.value,
                        cameraMapping: this._generateCameraMappings()
                    })).then((e => {
                        this._dialogRef.close(e)
                    }
                    )).catch((e => {
                        var t;
                        this.errorMessage = null !== (t = e.error.reason) && void 0 !== t ? t : this.msgs.unknownErrorOccurred()
                    }
                    )).finally(( () => {
                        this.processing = !1
                    }
                    ))
                }
                static show(e, t) {
                    return e.open(ho, {
                        data: t,
                        panelClass: "recorder-recovery-dialog-custom-panel-class",
                        disableClose: !0
                    }).afterClosed().pipe((0,
                    pn.q)(1))
                }
                _generateCameraMappings() {
                    const e = [];
                    return this.oldCameras.forEach((t => {
                        t.mappedCameraId && e.push({
                            newCameraId: t.mappedCameraId,
                            oldCameraId: t.id
                        })
                    }
                    )),
                    e
                }
                generateMappingSummary() {
                    this.mappingSummary = {
                        allCameras: [],
                        camerasToMigrate: [],
                        camerasToAdd: [],
                        camerasToDelete: []
                    },
                    this.mappingSummary.camerasToAdd = this.newCameras.filter((e => !this.mappedCameraIds.includes(e.id))),
                    this.oldCameras.forEach((e => {
                        e.mappedCameraId ? this.mappingSummary.camerasToMigrate.push(e) : this.mappingSummary.camerasToDelete.push(e)
                    }
                    )),
                    this.mappingSummary.allCameras = [...this.oldCameras, ...this.newCameras],
                    this.mappingSummary = xt(this.mappingSummary)
                }
            }
            ;
            var bo, So, Co, wo, Io;
            (0,
            c.gn)([(0,
            i.ViewChild)("stepper"), (0,
            c.w6)("design:type", "function" == typeof (po = void 0 !== Ti.Vq && Ti.Vq) ? po : Object)], yo.prototype, "_stepper", void 0),
            yo = ho = (0,
            c.gn)([(0,
            i.Component)({
                selector: "recorder-recovery-dialog",
                template: n(74694)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(p.qu)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(3, (0,
            i.Inject)(mo)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (go = void 0 !== p.qu && p.qu) ? go : Object, Object, "function" == typeof (fo = void 0 !== hn.so && hn.so) ? fo : Object, "function" == typeof (vo = void 0 !== mo && mo) ? vo : Object])], yo);
            let To = bo = class {
                constructor(e, t, n, i) {
                    this._matDialogRef = e,
                    this._fusionDataService = t,
                    this._authService = n,
                    this._cdr = i,
                    this.msgs = L.messages.dashboard,
                    this.error = void 0,
                    this.showError = !1,
                    this.formGroup = new p.cw({}),
                    this.processing = !1,
                    this.showManagementGroups = !1,
                    this._permGroupsValid = !1;
                    const a = this._authService.getAuthenticationData();
                    this.showManagementGroups = a.isRecorderRegistrar()
                }
                ngOnInit() {
                    this.formGroup = this._initFormGroup()
                }
                static show(e) {
                    return e.open(bo, {
                        maxHeight: "100vh",
                        panelClass: "recorder-registration-dialog-panel",
                        disableClose: !0
                    }).afterClosed().pipe((0,
                    pn.q)(1))
                }
                cancel() {
                    this._matDialogRef.close(!1)
                }
                dismissMe() {
                    this.showError = !1
                }
                _initFormGroup() {
                    return new p.cw({
                        name: new p.NI(void 0,[p.kI.required]),
                        uri: new p.NI([]),
                        username: new p.NI([]),
                        password: new p.NI([]),
                        groupIds: new p.NI(void 0,this._createPermGroupValidator())
                    })
                }
                _createPermGroupValidator() {
                    return e => e.value ? this._permGroupsValid ? null : {
                        required: !0
                    } : !0 === this.showManagementGroups ? {
                        required: !0
                    } : null
                }
                register() {
                    if (this.formGroup.invalid)
                        return;
                    this.processing = !0;
                    const {name: e, uri: t, username: n, password: i, groupIds: a} = this.formGroup.value
                      , r = {
                        name: e,
                        uri: t,
                        username: n,
                        password: i
                    };
                    a && (r.groupIds = a),
                    this._fusionDataService.addOrchid(r).then((e => {
                        this.processing = !1,
                        this._matDialogRef.close(e.data)
                    }
                    ), (e => {
                        this.processing = !1,
                        e.data && e.data.reason ? this.error = e.data.reason : this.error = this.msgs.anUnexpectedErrorHasOccurred(),
                        this.showError = !0,
                        this._cdr.detectChanges()
                    }
                    ))
                }
                handlePermGroupsSelectionChange(e) {
                    this._permGroupsValid = e.valid,
                    this.formGroup.controls.groupIds.setValue(e.value),
                    this._cdr.detectChanges()
                }
            }
            ;
            var Eo, _o, xo, Do, Oo;
            To = bo = (0,
            c.gn)([(0,
            i.Component)({
                selector: "recorder-registration-dialog",
                template: n(74962),
                changeDetection: i.ChangeDetectionStrategy.OnPush
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(1, (0,
            i.Inject)(Qe)), (0,
            c.fM)(2, (0,
            i.Inject)(xe)), (0,
            c.fM)(3, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (So = void 0 !== hn.so && hn.so) ? So : Object, "function" == typeof (Co = Qe) ? Co : Object, "function" == typeof (wo = void 0 !== xe && xe) ? wo : Object, "function" == typeof (Io = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? Io : Object])], To);
            let Ao = Eo = class {
                constructor(e, t, n, i, a) {
                    this._matDialogRef = e,
                    this.data = t,
                    this._fusionDataService = n,
                    this._authService = i,
                    this._cdr = a,
                    this.msgs = L.messages.dashboard,
                    this.formMsgs = L.messages.credentialsForm,
                    this.error = void 0,
                    this.showError = !1,
                    this.formGroup = new p.cw({}),
                    this.processing = !1,
                    this.showManagementGroups = !1,
                    this.recorderName = "",
                    this._permGroupsValid = !1,
                    this._unsubscribe$ = new St.x;
                    const r = this._authService.getAuthenticationData();
                    this.showManagementGroups = r.isRecorderRegistrar(),
                    this.recorder = t.recorder,
                    this.recorderName = this.recorder.name
                }
                ngOnInit() {
                    this.formGroup = this._initFormGroup()
                }
                ngOnDestroy() {
                    this._unsubscribe$.next(),
                    this._unsubscribe$.complete()
                }
                static show(e, t) {
                    return e.open(Eo, {
                        maxHeight: "100vh",
                        panelClass: "recorder-edit-dialog-panel",
                        disableClose: !0,
                        data: {
                            recorder: t
                        }
                    }).afterClosed().pipe((0,
                    pn.q)(1))
                }
                cancel() {
                    this._matDialogRef.close(!1)
                }
                dismissMe() {
                    this.showError = !1
                }
                _initFormGroup() {
                    const e = this.recorder.name || void 0;
                    this.recorder.uri;
                    return new p.cw({
                        name: new p.NI(e,[p.kI.required, p.kI.pattern(/\S+/)]),
                        groupIds: new p.NI(void 0,this._createPermGroupValidator())
                    })
                }
                _createPermGroupValidator() {
                    return e => e.value ? this._permGroupsValid ? null : {
                        required: !0
                    } : !0 === this.showManagementGroups ? {
                        required: !0
                    } : null
                }
                update() {
                    if (this.formGroup.invalid)
                        return;
                    this.processing = !0;
                    const {name: e, uri: t, username: n, password: i} = this.formGroup.value
                      , a = {
                        id: this.recorder.id,
                        name: e
                    };
                    !0 === this.showManagementGroups && (a.groupIds = this.formGroup.controls.groupIds.value),
                    this._fusionDataService.updateOrchid(a).then((e => {
                        this.processing = !1,
                        this._matDialogRef.close(e.data)
                    }
                    ), (e => {
                        this.processing = !1,
                        e.data.reason ? this.error = e.data.reason : this.error = this.msgs.anUnexpectedErrorHasOccurred(),
                        this.showError = !0,
                        this._cdr.detectChanges()
                    }
                    ))
                }
                handlePermGroupsSelectionChange(e) {
                    this._permGroupsValid = e.valid,
                    this.formGroup.controls.groupIds.setValue(e.value),
                    this._cdr.detectChanges()
                }
            }
            ;
            Ao = Eo = (0,
            c.gn)([(0,
            i.Component)({
                selector: "recorder-edit-dialog",
                template: n(52467),
                changeDetection: i.ChangeDetectionStrategy.OnPush
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(2, (0,
            i.Inject)(Qe)), (0,
            c.fM)(3, (0,
            i.Inject)(xe)), (0,
            c.fM)(4, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (_o = void 0 !== hn.so && hn.so) ? _o : Object, Object, "function" == typeof (xo = Qe) ? xo : Object, "function" == typeof (Do = void 0 !== xe && xe) ? Do : Object, "function" == typeof (Oo = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? Oo : Object])], Ao),
            Lo.$inject = ["$scope", "$timeout", "$mdDialog", "MatDialog", "DataService", "RenewableService", "FusionConfigService", "TimeService", "SessionIdService", "UserSettingsService", "MinimumVersionService", "AuthenticationService", "ManagedRecordersService", "Router"];
            const Ro = O("Dashboard")
              , Po = 6048e5
              , ko = 2
              , Mo = 10;
            function Lo(e, t, n, i, a, r, s, o, c, l, d, u, m, h) {
                var p = this;
                function g(e) {
                    return "degraded" === e.discoverableOrchid.licenseSession.state.status ? ao.DEGRADED : !0 !== e.isCompatibleVersion ? ao.UNSUPPORTED : !0 !== e.isAvailable ? ao.OFFLINE : p.orchidData[e.id] && p.orchidData[e.id].license && p.orchidData[e.id].license.weeksLeft && p.orchidData[e.id].license.weeksLeft <= 4 ? ao.EXPIRING : ao.HEALTHY
                }
                function f() {
                    p.userManagerMsgs = L.messages.userManager,
                    p.msgs = {
                        ...L.messages.dashboard,
                        ...L.messages.dialogs,
                        advancedSettings: L.messages.navigation.advancedSettings,
                        dialogs: L.messages.dialogs,
                        manageTags: L.messages.resourceTagging.manageTags
                    },
                    p.icons = {
                        ...zt
                    };
                    const e = s.getConfigPostAuth();
                    return p.minOrchidVersion = e.minimumOrchidVersion,
                    r.orchidsPromise().then((function() {
                        p.orchidsLoading = !1,
                        angular.forEach(p.orchids, (function(e) {
                            v(e)
                        }
                        ))
                    }
                    ))
                }
                function v(e) {
                    if (angular.isUndefined(p.orchidData[e.id])) {
                        const t = !p.doFetchManaged;
                        p.orchidData[e.id] = {
                            expanded: !1,
                            currentTab: y(e),
                            license: {},
                            fetchingSessionId: !1,
                            managed: t
                        },
                        p.doFetchManaged && m.isManaged(e.id).pipe((0,
                        oa.R)(p.unsubscribe$)).subscribe((function(t) {
                            p.orchidData[e.id] && (p.orchidData[e.id].managed = t)
                        }
                        ))
                    }
                    !function(e) {
                        e.discoverableOrchid.licenseSession.license.activationTimeRange && o.getOrchidTimeOffsetPromise(e.id).then((function(t) {
                            const n = Date.now() - t
                              , i = e.discoverableOrchid.licenseSession.license.activationTimeRange.stop - n;
                            p.orchidData[e.id].license.weeksLeft = i / Po,
                            p.orchidData[e.id].license.expiresOn = new Date(e.discoverableOrchid.licenseSession.license.activationTimeRange.stop).toString()
                        }
                        ))
                    }(e)
                }
                function y(e) {
                    return g(e).id === no.DEGRADED ? 5 : 0
                }
                function b(e) {
                    return c.hasSessionId(e)
                }
                function S(e, t, i) {
                    i = !!i,
                    t.processing = a.deleteOrchid(t, i).then((function() {}
                    ), (function(a) {
                        var r = n.confirm().theme(l.getTheme()).title(p.msgs.unregisteringFailed({
                            VALUE: t.name
                        })).htmlContent(p.msgs.unregisteringFailedReason({
                            VALUE: a.data.reason
                        })).targetEvent(e).ok(p.msgs.unregisterChildApp()).cancel(p.msgs.dialogs.cancel());
                        t.processing = void 0,
                        !1 === i ? n.show(r).then((function() {
                            S(e, t, !0)
                        }
                        )) : alert(p.msgs.alertUnregisterFailed({
                            VALUE: t.name
                        }))
                    }
                    ))
                }
                p._matDialog = i,
                p._router = h,
                p.authData = u.getAuthenticationData(),
                p.isAdmin = p.authData.isAdministrator(),
                p.isRecorderAdmin = p.authData.isRecorderAdministrator(),
                p.isRecorderRegistrar = p.authData.isRecorderRegistrar(),
                p.canManageAllRecorders = p.authData.canManageAllRecorders(),
                p.managedRecorders = {},
                p.doFetchManaged = p.isRecorderAdmin && !p.canManageAllRecorders,
                p.unsubscribe$ = new St.x(!1),
                p.userIsAdminOrRegistrar = p.isAdmin || p.isRecorderRegistrar,
                p.showEditButton = p.isAdmin || p.isRecorderAdmin,
                p.showDeleteButton = p.isAdmin || p.isRecorderRegistrar,
                p.brand = w.brand,
                p.ServerStateId = no,
                p.DashboardOrchidContentType = io,
                p.orchidData = {},
                p.orchidsLoading = !0,
                p.filters = {
                    searchNames: [],
                    sortBy: "name"
                },
                p.paging = {
                    perPage: 10,
                    current: 0,
                    pageSizeOptions: [10, 20, 30, 40, 50],
                    paginatorLimit: 10,
                    closeAllOrchids: function() {
                        angular.forEach(p.orchids, (function(e) {
                            p.orchidData[e.id] && (p.orchidData[e.id].expanded = !1)
                        }
                        ))
                    }
                },
                p.sessionError = {},
                p.noUsersMessageKeys = {
                    Exist: "existence",
                    MatchSearch: "matches"
                },
                Object.defineProperty(this, "noServersOrSearchDidNotMatchSwitchKey", {
                    get() {
                        return this.orchids && 0 !== this.orchids.length && 0 !== this.filters.searchNames.length ? this.noUsersMessageKeys.MatchSearch : this.noUsersMessageKeys.Exist
                    }
                }),
                p.registerOrchid = function(e) {
                    To.show(p._matDialog)
                }
                ,
                p.refreshOrchid = function(e, t) {
                    e.stopPropagation(),
                    p.orchidData[t.id].refreshing = !0,
                    a.purgeOrchid(t).then((function(e) {
                        angular.merge(t, e.data),
                        p.orchidData[t.id].refreshing = !1
                    }
                    ), (function() {
                        p.orchidData[t.id].refreshing = !1
                    }
                    ))
                }
                ,
                p.editOrchid = function(e, t) {
                    e.stopPropagation(),
                    Ao.show(p._matDialog, t)
                }
                ,
                p.recoverRecorder = function(e, t) {
                    e.stopPropagation(),
                    yo.show(i, {
                        recorder: t
                    })
                }
                ,
                p.deleteOrchid = function(e, t) {
                    e.stopPropagation(),
                    n.show(n.confirm().theme(l.getTheme()).content(p.msgs.deleteOrchidDialogContent({
                        VALUE: t.name
                    })).ok(p.msgs.unregister()).cancel(p.msgs.dialogs.cancel())).then((function() {
                        S(e, t, !1)
                    }
                    ), (function() {}
                    ))
                }
                ,
                p.pagingPages = function(e) {
                    return Math.ceil(e / p.paging.perPage)
                }
                ,
                p.pageRange = function(e) {
                    const t = p.getStartFromIndex() + 1
                      , n = Math.min(t + p.paging.perPage - 1, (Array.isArray(e) ? e : p.orchids).length);
                    return t === n ? `${t}` : `${t}-${n}`
                }
                ,
                p.onPageChange = function(e) {
                    p.paging.current = e.pageIndex,
                    p.paging.perPage = e.pageSize
                }
                ,
                p.getStartFromIndex = function() {
                    return p.paging.current * p.paging.perPage
                }
                ,
                p.filtersChanged = function(e) {
                    t((function() {
                        !0 !== e && (p.paging.current = 0)
                    }
                    ))
                }
                ,
                p.getOrchidState = g,
                p.calculateCamerasOnlinePercentage = function(e) {
                    return !0 !== e.isAvailable || 0 === e.camerasAvailable ? 0 : e.camerasOnline / e.camerasAvailable * 100
                }
                ,
                p.orchidComparator = function(e, t) {
                    if ("object" !== e.type || "object" !== t.type)
                        return 0;
                    var n = e.value
                      , i = t.value;
                    if ("version" === p.filters.sortBy)
                        try {
                            var a = function(e, t) {
                                if (le(e),
                                le(t),
                                e.major > t.major)
                                    return 1;
                                if (e.major < t.major)
                                    return -1;
                                if (e.minor > t.minor)
                                    return 1;
                                if (e.minor < t.minor)
                                    return -1;
                                let n = parseInt(e.patch, 10)
                                  , i = parseInt(t.patch, 10);
                                return isNaN(n) && isNaN(i) ? e.patch.localeCompare(t.patch) : isNaN(n) || isNaN(i) ? isNaN(n) ? -1 : 1 : n > i ? 1 : n < i ? -1 : 0
                            }(n.version, i.version);
                            if (0 !== a)
                                return a
                        } catch (e) {
                            Ro("error", `Failed to compare versions: ${e.message}`)
                        }
                    else if ("health" === p.filters.sortBy) {
                        var r = p.getOrchidState(n)
                          , s = p.getOrchidState(i)
                          , o = r.severity
                          , c = s.severity;
                        if (o > c)
                            return -1;
                        if (o < c)
                            return 1;
                        if (r.id === no.OFFLINE && s.id === no.OFFLINE && o === c) {
                            if (n.lastAvailable > i.lastAvailable)
                                return 1;
                            if (n.lastAvailable < i.lastAvailable)
                                return -1
                        }
                        var l = n.camerasAvailable - n.camerasOnline
                          , d = i.camerasAvailable - i.camerasOnline;
                        if (l > d)
                            return -1;
                        if (l < d)
                            return 1
                    }
                    return n.name.localeCompare(i.name)
                }
                ,
                p.getOfflineSince = function(e) {
                    if (this.getOrchidState(e) !== ao.OFFLINE)
                        return;
                    if (e.lastAvailable > Date.now())
                        return;
                    return t = e.lastAvailable,
                    R()(t).fromNow(!0);
                    var t
                }
                ,
                p.getSessionId = function(e) {
                    var t = this;
                    e.isAvailable && (b(e.id) || (p.orchidData[e.id].fetchingSessionId = !0,
                    c.getSessionId$(e.id).subscribe((function() {
                        return p.orchidData[e.id].fetchingSessionId = !1
                    }
                    ), (function() {
                        p.sessionError = {
                            message: t.msgs.noSessionExistsForVALUE({
                                VALUE: e.name
                            })
                        },
                        p.orchidData[e.id].fetchingSessionId = !1
                    }
                    ))))
                }
                ,
                p.hasSessionId = b,
                p.advancedSettingsCompatibleOrchid = function(e) {
                    return 0 === e.version.major || !1 !== e.isCompatibleVersion && (e.version.major > ko || e.version.major === ko && e.version.minor >= Mo)
                }
                ,
                p.auditLogsCompatibleOrchid = function(e) {
                    return d.isFeatureSupported(e, Sr.AUDIT_LOGGING)
                }
                ,
                e.$on("orchidChanged", (function(t, n) {
                    var i, a, r;
                    !0 === n.defunct ? (p.orchidData[n.id] = void 0,
                    m.clearOrchid(n.id),
                    i = p.orchids.length,
                    a = p.paging.perPage,
                    r = Math.ceil(i / a),
                    p.paging.current + 1 > r && p.paging.current > 0 && p.paging.current--) : (v(n),
                    e.$digest()),
                    p.filtersChanged(!0)
                }
                )),
                e.$on("orchidAdded", (function(e, t) {
                    v(t),
                    p.filtersChanged(!0)
                }
                )),
                e.$on("advancedRecover", (function(e, t) {
                    p.doFetchManaged && f()
                }
                )),
                p.$onInit = function() {
                    f()
                }
                ,
                p.$onDestroy = function() {
                    p.unsubscribe$.next(!0),
                    p.unsubscribe$.complete()
                }
                ,
                p.manageTags = function() {
                    p._router.navigateByUrl("/orchids/tags")
                }
            }
            angular.module("ipconfigure.orchid.singularity").controller("DashboardController", Lo).directive("dashboard", (function() {
                return {
                    restrict: "E",
                    bindToController: {
                        orchids: "=",
                        cameras: "=",
                        route: "="
                    },
                    scope: {},
                    controller: "DashboardController as dashboard",
                    template: n(89976)
                }
            }
            ));
            n(45002),
            n(59822),
            n(39734);
            n.p;
            function No(e, t, n, i) {
                var a = this;
                a.$onInit = function() {
                    a.msgs = {
                        ...L.messages.cameraGroups,
                        thereAreNoCamerasAssociatedWithThisServer: L.messages.library.thereAreNoCamerasAssociatedWithThisServer
                    }
                }
                ,
                a.showOrchidCameras = {},
                a.expanded = {},
                a.selectedOrchids = {},
                a._matDialog = i,
                a.GROUP_SIZE_THRESHOLD = 50,
                e.$on("cameraChanged", (function(e, t) {
                    t.defunct && angular.isDefined(a.selected[a.makeCameraKey(t.orchidId, t.id)]) && a.toggleSelected(t)
                }
                )),
                a.previewStream = function(e, t) {
                    const i = {
                        panelClass: "custom-stream-preview-dialog-container",
                        data: {
                            camera: e,
                            orchid: n.findOrchid(e.orchidId),
                            streamId: e.primaryStream.id
                        }
                    };
                    a._matDialog.open(ss, i)
                }
                ,
                a.toggleSelectAll = function(e, t) {
                    t.stopPropagation(),
                    angular.isUndefined(a.selectedOrchids[e]) ? (angular.forEach(a.cameraMap[e].cameras, (function(e) {
                        a.selected[a.makeCameraKey(e.orchidId, e.id)] = e
                    }
                    )),
                    a.selectedOrchids[e] = {}) : (angular.forEach(a.cameraMap[e].cameras, (function(e) {
                        delete a.selected[a.makeCameraKey(e.orchidId, e.id)]
                    }
                    )),
                    delete a.selectedOrchids[e])
                }
                ,
                a.toggleSelected = function(e) {
                    angular.isUndefined(a.selected[a.makeCameraKey(e.orchidId, e.id)]) ? (a.selected[a.makeCameraKey(e.orchidId, e.id)] = e,
                    Object.keys(a.selected).filter((function(t) {
                        return t.indexOf(e.orchidId) > -1
                    }
                    )).length === a.cameraMap[e.orchidId].cameras.length && (a.selectedOrchids[e.orchidId] = {})) : (delete a.selected[a.makeCameraKey(e.orchidId, e.id)],
                    delete a.selectedOrchids[e.orchidId])
                }
                ,
                a.makeCameraKey = function(e, t) {
                    return e + "-" + t
                }
                ,
                e.sortingCameraNames = function(e) {
                    return Tt(e.name)
                }
            }
            No.$inject = ["$scope", "$mdDialog", "RenewableService", "MatDialog"],
            angular.module("ipconfigure.orchid.singularity").directive("cameraGroupCameras", [function() {
                return {
                    restrict: "E",
                    template: n(93053),
                    scope: {},
                    bindToController: {
                        cameraMap: "=",
                        selectable: "@?",
                        collapse: "=?",
                        selected: "=?"
                    },
                    controller: ["$scope", "$mdDialog", "RenewableService", "MatDialog", No],
                    controllerAs: "cameraGroupCameras"
                }
            }
            ]),
            angular.module("ipconfigure.orchid.singularity").directive("cameraGroupCard", (function() {
                return {
                    restrict: "E",
                    template: n(51414)
                }
            }
            ));
            n(38559),
            n(69473);
            n.p;
            function Fo(e, t, n, i, a, r, s, o) {
                var c = this;
                function l(e, t, n) {
                    for (var i = 0; i < n.length; ++i)
                        if (t.id === n[i].id && t.orchidId === n[i].orchidId)
                            return;
                    e.push(t)
                }
                c.msgs = L.messages.chips,
                c.imageUrl = function(e, t) {
                    return i.cameraPreviewUrl(e.orchidId, e.id, "chip", !0, t)
                }
                ,
                c.cameraIsEnabled = function(e) {
                    let t = s.findOrchid(e.orchidId);
                    return !r.isFeatureSupported(t, Sr.CAMERA_DISABLEMENT) || e.active
                }
                ,
                c.transformChip = function(e) {
                    return e.orchidId ? e : e.id
                }
                ,
                c.orchidChips = {
                    searchText: "",
                    querySearch: function(t) {
                        var n = e.orchids.filter(c.orchidChips.createFilterFor(t));
                        return a.notify(),
                        n
                    },
                    createFilterFor: function(e) {
                        var t = angular.lowercase(e);
                        return function(n) {
                            angular.isUndefined(n._orchidLowerName) && (n._orchidLowerName = angular.lowercase(n.name) + " all cameras",
                            n._searchName = n._orchidLowerName);
                            for (var i = 0; i < c.orchids.length; ++i)
                                if (n.id === c.orchids[i])
                                    return !1;
                            return 0 === e.length || n._orchidLowerName.indexOf(t) > -1
                        }
                    }
                },
                c.cameraChips = {
                    searchText: "",
                    querySearch: function(e) {
                        var t = c.cameraChips.searchResults(e);
                        return a.notify(),
                        t
                    },
                    searchResults: function(t) {
                        var n = angular.lowercase(t)
                          , i = [];
                        return e.orchids.forEach((function(e) {
                            e.cameras.forEach((function(a) {
                                !0 !== c.fullOrchids[a.orchidId] && (angular.isUndefined(a._lowerName) && (a._lowerName = angular.lowercase(a.name),
                                a._orchidLowerName = angular.lowercase(e.name),
                                a._searchName = a._orchidLowerName + a._lowerName),
                                (0 === t.length || a._lowerName.indexOf(n) > -1 || a._orchidLowerName.indexOf(n) > -1) && l(i, a, c.cameras))
                            }
                            ))
                        }
                        )),
                        i
                    }
                },
                c.deviceChips = {
                    searchText: "",
                    querySearch: function(e) {
                        var t = c.orchidChips.querySearch(e).concat(c.cameraChips.querySearch(e)).sort((function(e, t) {
                            return Et(e._orchidLowerName, e._searchName) < Et(t._orchidLowerName, t._searchName) ? -1 : Et(e._orchidLowerName, e._searchName) > Et(t._orchidLowerName, t._searchName) ? 1 : 0
                        }
                        ));
                        return a.notify(),
                        t
                    }
                },
                c.devices = [],
                c.devices = c.orchids.concat(c.cameras),
                c.uuid = o.v4(),
                n((function() {
                    document.getElementById("autocomplete---" + c.uuid).addEventListener("blur", (function() {
                        n((function() {
                            if (c.deviceChips.searchText.length > 0) {
                                var e = c.deviceChips.querySearch(c.deviceChips.searchText);
                                1 === e.length ? (c.deviceChips.errorMessage = "",
                                c.devices.push(c.transformChip(e[0])),
                                c.deviceChips.searchText = "") : 0 === e.length ? c.deviceChips.errorMessage = c.msgs.yourSearchDidNotMatchAnyResults() : c.deviceChips.errorMessage = c.msgs.pleaseChooseAnOptionFromTheMenu()
                            } else
                                c.deviceChips.errorMessage = ""
                        }
                        ))
                    }
                    ))
                }
                )),
                t.$watch((function() {
                    return c.devices.length
                }
                ), (function(e, t) {
                    var i = []
                      , a = [];
                    c.deviceChips.errorMessage = "",
                    c.fullOrchids = {},
                    angular.forEach(c.devices, (function(e) {
                        "object" == typeof e && angular.isDefined(e.orchidId) ? i.push(Object.assign({}, e)) : (a.push(e),
                        c.fullOrchids[e] = !0)
                    }
                    )),
                    c.orchids = a,
                    c.cameras = i,
                    c.devicesUpdatedCallback && n((function() {
                        c.devicesUpdatedCallback()
                    }
                    ))
                }
                ))
            }
            var Uo, $o, jo;
            Fo.$inject = ["$rootScope", "$scope", "$timeout", "DataService", "AutocompleteRepairService", "MinimumVersionService", "RenewableService", "uuid"],
            angular.module("ipconfigure.orchid.singularity").controller("AutocompleteOrchidsAndCamerasChipsController", Fo).directive("autocompleteOrchidsAndCamerasChips", (function() {
                return {
                    restrict: "E",
                    bindToController: {
                        orchids: "=",
                        cameras: "=",
                        devicesUpdatedCallback: "<"
                    },
                    scope: {},
                    controller: "AutocompleteOrchidsAndCamerasChipsController as AutocompleteOrchidsAndCamerasChips",
                    template: function(e, t) {
                        return '<md-chips ng-model="AutocompleteOrchidsAndCamerasChips.devices" md-autocomplete-snap md-transform-chip="AutocompleteOrchidsAndCamerasChips.transformChip($chip)" md-require-match="true">                    <md-autocomplete                        md-input-id="autocomplete---{{AutocompleteOrchidsAndCamerasChips.uuid}}"                        md-menu-class="autocomplete---{{AutocompleteOrchidsAndCamerasChips.uuid}} stacked-autocomplete"                        md-selected-item="AutocompleteOrchidsAndCamerasChips.deviceChips.selectedItem"                        md-search-text="AutocompleteOrchidsAndCamerasChips.deviceChips.searchText"                        md-items="device in AutocompleteOrchidsAndCamerasChips.deviceChips.querySearch(AutocompleteOrchidsAndCamerasChips.deviceChips.searchText)"                        md-item-text="device.name"                        md-min-length="0"                        md-no-cache="true"                        md-require-match="true"                        md-dropdown-position="bottom"                        placeholder="' + L.messages.chips.searchPlaceholder() + '">                        <span ng-if="!device.orchidId" class="img-autocomplete-hint" style="padding-top: 4px">                            <span class="preview-image-container orchid-image">                                <img class="preview-image orchid-logo" src="images/logo_small_white.png">                            </span>                            <div style="padding-top: 1px">                                <div>                                    <span class="autocomplete-text orchid-text" md-highlight-text="AutocompleteOrchidsAndCamerasChips.deviceChips.searchText" md-highlight-flags="gi">                                        {{device.name}}                                    </span>                                </div>                                <div>                                    <span class="autocomplete-text sub-thing" md-highlight-text="AutocompleteOrchidsAndCamerasChips.deviceChips.searchText" md-highlight-flags="gi">                                        ' + L.messages.chips.allCameras() + '                                    </span>                                </div>                            </div>                        </span>                        <span ng-if="device.orchidId" class="img-autocomplete-hint" style="padding-top: 4px">                            <span class="preview-image-container">                                <i ng-if="!AutocompleteOrchidsAndCamerasChips.cameraIsEnabled(device)" class="disabled-camera-icon fa-solid fa-video-slash"></i>                                <img ng-if="AutocompleteOrchidsAndCamerasChips.cameraIsEnabled(device)" class="preview-image" ng-src="{{AutocompleteOrchidsAndCamerasChips.imageUrl(device, true)}}" onerror="this.src=\'images/borked.png\'">                            </span>                            <div style="padding-top: 1px">                                <div>                                    <span class="autocomplete-text" md-highlight-text="AutocompleteOrchidsAndCamerasChips.deviceChips.searchText" md-highlight-flags="gi">                                        {{$root.orchids[$root.orcDict[device.orchidId].index].name}}                                    </span>                                </div>                                <div>                                    <span class="autocomplete-text sub-thing" md-highlight-text="AutocompleteOrchidsAndCamerasChips.deviceChips.searchText" md-highlight-flags="gi">                                        {{device.name}}                                    </span>                                </div>                            </div>                        </span>                    </md-autocomplete>                    <md-chip-template>                        <span ng-if="!$chip.orchidId" class="img-chip-display">                            <span class="preview-image-container orchid-image">                                <img class="preview-image orchid-logo" src="images/logo_small_white.png">                            </span>                            <span class="chip-text">                                <div><strong>                                    {{$root.orchids[$root.orcDict[$chip].index].name}}                                </strong></div>                                <div class="sub-thing">' + L.messages.chips.allCameras() + '</div>                            </span>                        </span>                        <span ng-if="$chip.orchidId" class="img-chip-display">                            <span class="preview-image-container">                                <img ng-if="AutocompleteOrchidsAndCamerasChips.cameraIsEnabled($chip)" class="preview-image" ng-src="{{AutocompleteOrchidsAndCamerasChips.imageUrl($chip, true)}}" onerror="this.src=\'images/borked.png\'">                                <i ng-if="!AutocompleteOrchidsAndCamerasChips.cameraIsEnabled($chip)" class="disabled-camera-icon fa-solid fa-video-slash"></i>                            </span>                            <span class="chip-text">                                <div>                                    {{$root.orchids[$root.orcDict[$chip.orchidId].index].name}}                                </div>                                <div class="sub-thing">                                    {{$root.orchids[$root.orcDict[$chip.orchidId].index].cameras[$root.orcDict[$chip.orchidId].cameras[$chip.id]].name}}                                </div>                            </span>                        </span>                    </md-chip-template>                </md-chips>                <div class="autocomplete-validation-text" ng-if="AutocompleteOrchidsAndCamerasChips.deviceChips.errorMessage">                    {{AutocompleteOrchidsAndCamerasChips.deviceChips.errorMessage}}                </div>'
                    }
                }
            }
            )),
            angular.module("ipconfigure.orchid.singularity").controller("CameraGroupDialogController", ["$mdDialog", "FusionDataService", "group", "parentGroup", "rootGroup", "RenewableService", function(e, t, n, i, a, r) {
                var s = this;
                s.group = n,
                s.parentGroup = i,
                s.rootGroup = a,
                s.msgs = L.messages.cameraGroups,
                s.messages = L.messages.cameras.cameraPicker,
                s.data,
                s.camera,
                s.loaded = !1,
                s.serversSelected = 0,
                s.camerasSelected = 0,
                s.totalSelected = 0,
                s.totalDataList = [],
                s.orchids = [],
                s.cameras = [],
                s.editing = !1,
                s.cancel = function() {
                    e.cancel()
                }
                ,
                s.onSelectedServersChange = function(e) {
                    s.serversSelected = e
                }
                ,
                s.onSelectedCamerasChange = function(e) {
                    s.camerasSelected = e
                }
                ,
                s.onTotalDataListChange = function(e) {
                    s.totalDataList = e,
                    s.orchids = s.totalDataList[0],
                    s.cameras = s.totalDataList[1],
                    s.totalSelected = s.serversSelected + s.camerasSelected
                }
                ,
                s.addOrUpdateGroup = function() {
                    var i = angular.copy(s.shadowGroup);
                    i.groups = void 0,
                    s.processing = !0,
                    i.parentId = s.parentGroup.id,
                    i.orchids = s.orchids;
                    const a = Object.fromEntries(i.cameras.map((function(e) {
                        return [`${e.id}${e.orchidId}`, e]
                    }
                    )))
                      , r = s.cameras.map((function(e) {
                        return a[`${e.id}${e.orchidId}`] || e
                    }
                    ));
                    i.cameras = r,
                    n.isNew ? t.addCameraGroup(i).then((function(t) {
                        e.hide(t.data)
                    }
                    ), (function(e) {
                        s.processing = !1,
                        s.error = angular.isDefined(e) && angular.isDefined(e.data) && angular.isDefined(e.data.reason) ? e.data.reason : s.msgs.anUnexpectedErrorHasOccurred()
                    }
                    )) : t.updateCameraGroup(i).then((function(t) {
                        e.hide(t.data)
                    }
                    ), (function(e) {
                        s.processing = !1,
                        s.error = angular.isDefined(e) && angular.isDefined(e.data) && angular.isDefined(e.data.reason) ? e.data.reason : s.msgs.anUnexpectedErrorHasOccurred()
                    }
                    ))
                }
                ,
                s.$onInit = function() {
                    s.msgs = L.messages.cameraGroups,
                    s.messages = L.messages.cameras.cameraPicker,
                    s.shadowGroup = angular.copy(s.group),
                    r.orchidsPromise().then((function(e) {
                        s.data = e
                    }
                    )).finally((function() {
                        s.loaded = !0
                    }
                    )),
                    s.saveText = s.group.isNew ? s.msgs.addGroup() : s.msgs.updateGroup(),
                    s.title = s.group.isNew ? s.msgs.newCameraGroup() : s.msgs.editCameraGroup(),
                    s.totalSelected = 0,
                    s.totalDataList = [],
                    (s.shadowGroup.cameras.length > 0 || s.shadowGroup.orchids.length > 0) && (s.editing = !0)
                }
            }
            ]);
            const Vo = O("PromptForFileDialog");
            let Go = Uo = class {
                constructor(e, t) {
                    this.options = e,
                    this.matDialogRef = t,
                    this.lines = [],
                    this.msgs = {},
                    this.files = [],
                    this.styleClasses = {},
                    this.isProcessing = !1,
                    this.options.styleClass && (this.styleClasses[this.options.styleClass] = !0),
                    Array.isArray(e.message) ? this.lines = e.message : void 0 !== e.message && (this.lines = [e.message])
                }
                ngOnInit() {
                    this.msgs = L.messages.dialogs
                }
                ok() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        try {
                            this.isProcessing = !0,
                            this.matDialogRef.disableClose = !0,
                            this.options.okCallback && this.options.okCallback([...this.files], this.callbackInterface),
                            this.options.okCallbackAsync && (yield this.options.okCallbackAsync([...this.files], this.callbackInterface)),
                            this.matDialogRef.close(this.files)
                        } catch (e) {
                            (null == e ? void 0 : e.message) ? this.error = e.message : (this.error = this.msgs.anUnexpectedErrorHasOccurred(),
                            Vo.error(e))
                        } finally {
                            this.isProcessing = !1,
                            this.matDialogRef.disableClose = !1
                        }
                    }
                    ))
                }
                get callbackInterface() {
                    return {
                        clear: this.clear.bind(this)
                    }
                }
                clear() {
                    this.files = [],
                    this.fileInput.nativeElement.value = ""
                }
                close() {
                    this.matDialogRef.disableClose || this.matDialogRef.close([])
                }
                onChange(e) {
                    const t = e.target;
                    null !== t.files && (this.files = Array.from(t.files))
                }
                static show(e, t) {
                    const n = {
                        data: t
                    };
                    return e.open(Uo, n).afterClosed().pipe((0,
                    pn.q)(1))
                }
                onEsc() {
                    this.close()
                }
                get disableOk() {
                    return 0 === this.files.length || !!this.isProcessing
                }
                clearErrors() {
                    this.error = void 0
                }
                get accept() {
                    return this.options.accept.join(", ")
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.ViewChild)("FileInput"), (0,
            c.w6)("design:type", "function" == typeof ($o = void 0 !== i.ElementRef && i.ElementRef) ? $o : Object)], Go.prototype, "fileInput", void 0),
            (0,
            c.gn)([(0,
            i.HostListener)("keydown.esc"), (0,
            c.w6)("design:type", Function), (0,
            c.w6)("design:paramtypes", []), (0,
            c.w6)("design:returntype", void 0)], Go.prototype, "onEsc", null),
            Go = Uo = (0,
            c.gn)([(0,
            i.Component)({
                selector: "file-prompt-dialog",
                template: n(10748)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.so)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (jo = void 0 !== hn.so && hn.so) ? jo : Object])], Go);
            var Bo, zo, Ho, Wo, qo, Yo, Xo, Ko, Zo, Jo = n(35673);
            !function(e) {
                e.FULLYEXPANDED = "FullyExpanded",
                e.PARTIALLYEXPANDED = "PartiallyExpanded",
                e.HIDDEN = "Hidden"
            }(Ko || (Ko = {})),
            function(e) {
                e[e.CAMERA = 0] = "CAMERA",
                e[e.SERVER = 1] = "SERVER"
            }(Zo || (Zo = {}));
            const Qo = O("MapConfigurationComponent")
              , ec = ["image/png", "image/jpeg"];
            let tc = Bo = class {
                constructor(e, t, n, i, a, r) {
                    this.options = e,
                    this._window = t,
                    this._matDialogRef = n,
                    this._matDialog = i,
                    this._dataService = a,
                    this._renewableService = r,
                    this.msgs = Object.assign(Object.assign({}, L.messages.dialogs), L.messages.mapConfiguration),
                    this.unmappedBagItems = [],
                    this.mappedCameras$ = new St.x,
                    this.processing = !1,
                    this.previewImagePixelWidth = 700,
                    this.selectedCameraItem = null,
                    this.drawerOpened = !nt,
                    this.cameraHandleState = Ko.HIDDEN,
                    this._cameraGroup = e.cameraGroup,
                    this.shadowCameraGroup = xt(e.cameraGroup)
                }
                get CameraHandleState() {
                    return Ko
                }
                get BagItemType() {
                    return Zo
                }
                get isMobile() {
                    return nt
                }
                static show(e, t) {
                    return e.open(Bo, {
                        data: t,
                        panelClass: "map-configuration-panel",
                        disableClose: !0
                    }).afterClosed()
                }
                ngOnInit() {
                    this._assembleBagItems()
                }
                ngAfterViewInit() {
                    let e, t;
                    const n = () => {
                        void 0 !== e && (e.unsubscribe(),
                        e = void 0),
                        void 0 !== t && (t.unsubscribe(),
                        t = void 0)
                    }
                    ;
                    this._droppedSubscription = this.unMappedListed.dropped.subscribe(n),
                    this._enteredSubscription = this.unMappedListed.entered.subscribe(n),
                    this._exitedSubscription = this.unMappedListed.exited.subscribe((i => {
                        let a;
                        e = i.item.moved.subscribe((e => {
                            a = e
                        }
                        )),
                        t = i.item.dropped.subscribe((e => {
                            var t;
                            const i = this._window.document.elementFromPoint(e.dropPoint.x, e.dropPoint.y);
                            if ("CANVAS" === (null == i ? void 0 : i.nodeName) && (null === (t = i.parentElement) || void 0 === t ? void 0 : t.classList.contains("ol-layer")) || "DIV" === (null == i ? void 0 : i.nodeName) && i.classList.contains("ol-layer")) {
                                const t = e.item.data;
                                if (t) {
                                    const e = t.data;
                                    e.mapPosition = {
                                        theta: 0,
                                        x: 0,
                                        y: 0
                                    },
                                    this.mappedCameras$.next(Object.assign(Object.assign({}, e), {
                                        event: a.event
                                    }))
                                }
                                const n = this.unmappedBagItems.findIndex((e => e === t));
                                this.unmappedBagItems.splice(n, 1)
                            }
                            n()
                        }
                        ))
                    }
                    )),
                    this.shadowCameraGroup.cameras.filter((e => null !== e.mapPosition)).forEach((e => this.mappedCameras$.next(e)))
                }
                ngOnDestroy() {
                    var e, t, n;
                    null === (e = this._droppedSubscription) || void 0 === e || e.unsubscribe(),
                    null === (t = this._enteredSubscription) || void 0 === t || t.unsubscribe(),
                    null === (n = this._exitedSubscription) || void 0 === n || n.unsubscribe(),
                    this._matDialog.closeAll()
                }
                promptForMapFile() {
                    Go.show(this._matDialog, {
                        accept: ec,
                        allowMultipleFiles: !1,
                        title: this.msgs.selectTheMapImage(),
                        message: null !== this._cameraGroup.mapConfiguration ? this.msgs.thisWillReplaceTheExistingMapImageThisActionCannotBeUndone() : void 0,
                        okText: this.msgs.ok(),
                        cancelText: this.msgs.cancel(),
                        okCallbackAsync: e => this.uploadFile(e[0])
                    })
                }
                promptToDeleteMap() {
                    qs.show(this._matDialog, {
                        data: {
                            cancelText: this.msgs.cancel(),
                            confirmText: this.msgs.delete(),
                            message: this.msgs.areYouSureYouWantToDeleteThisMapImageThisActionCannotBeUndone(),
                            confirmCallbackAsync: () => (0,
                            c.mG)(this, void 0, void 0, (function*() {
                                try {
                                    this.processing = !0,
                                    yield this._dataService.deleteGroupMapImageById(this.shadowCameraGroup.id),
                                    this._cameraGroup = yield this._dataService.fetchCameraGroupById(this.shadowCameraGroup.id),
                                    this.shadowCameraGroup = xt(this._cameraGroup),
                                    this._assembleBagItems()
                                } catch (e) {
                                    const t = e.reason ? e.reason : this.msgs.theMapCouldNotBeDeleted();
                                    throw new Error(t)
                                } finally {
                                    this.selectedCameraItem = null,
                                    this.processing = !1
                                }
                            }
                            ))
                        }
                    })
                }
                promptToRemoveCamera(e) {
                    e.stopPropagation(),
                    qs.show(this._matDialog, {
                        data: {
                            cancelText: this.msgs.cancel(),
                            confirmText: this.msgs.delete(),
                            message: this.msgs.areYouSureYouWantToRemoveTheSelectedCameraFromTheMap(),
                            confirmCallback: () => this.removeCameraFromMap()
                        }
                    })
                }
                _toCameraBagItem(e) {
                    var t, n, i;
                    const a = this._renewableService.findOrchid(e.orchidId)
                      , r = this._renewableService.findCamera(e.orchidId, e.id)
                      , s = {
                        isDewarp: !1,
                        isPTZ: !1
                    }
                      , o = null === (t = r.capabilities) || void 0 === t ? void 0 : t.camera.PTZ
                      , c = null === (i = null === (n = r.primaryStream) || void 0 === n ? void 0 : n.dewarpConfiguration) || void 0 === i ? void 0 : i.enable;
                    return !0 !== c && "true" !== c || (s.isDewarp = !0),
                    !o || "true" !== o.pan && "true" !== o.tilt && "true" !== o.zoom || (s.isPTZ = !0),
                    {
                        type: Zo.CAMERA,
                        name: r.name,
                        active: r.active,
                        details: ee(r),
                        cameraId: e.id,
                        orchidId: e.orchidId,
                        orchid: a.name,
                        data: e,
                        cameraType: s
                    }
                }
                _assembleBagItems() {
                    this.unmappedBagItems = [],
                    this.shadowCameraGroup.cameras.filter((e => null === e.mapPosition)).map((e => this._toCameraBagItem(e))).forEach((e => this.unmappedBagItems.push(e))),
                    this.shadowCameraGroup.orchids.map((e => {
                        const t = this._renewableService.findOrchid(e);
                        return {
                            type: Zo.SERVER,
                            name: t.name,
                            details: this.msgs.serversCanNotBePlacedOnAMap(),
                            orchidId: t.id
                        }
                    }
                    )).forEach((e => this.unmappedBagItems.push(e))),
                    this.unmappedBagItems.sort(( (e, t) => Tt(e.name).localeCompare(Tt(t.name))))
                }
                uploadFile(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (!e)
                            throw new Error("No file specified");
                        try {
                            this.processing = !0,
                            yield this._dataService.putGroupMapImageById(this.shadowCameraGroup.id, e);
                            const t = yield this._dataService.fetchCameraGroupById(this.shadowCameraGroup.id);
                            this._cameraGroup.mapConfiguration = t.mapConfiguration,
                            this.shadowCameraGroup.mapConfiguration = t.mapConfiguration,
                            setTimeout(( () => {
                                this.shadowCameraGroup.cameras.filter((e => null !== e.mapPosition)).forEach((e => {
                                    this.mappedCameras$.next(e)
                                }
                                ))
                            }
                            ))
                        } catch (e) {
                            throw e.data && e.data.reason ? new Error(e.data.reason) : e
                        } finally {
                            this.selectedCameraItem = null,
                            this.processing = !1
                        }
                    }
                    ))
                }
                addCameraToMap(e) {
                    if (null === this.shadowCameraGroup.mapConfiguration)
                        return;
                    const t = e.data;
                    t && (t.mapPosition = {
                        theta: 0,
                        x: 0,
                        y: 0
                    },
                    this.mappedCameras$.next(t));
                    const n = this.unmappedBagItems.findIndex((t => t === e));
                    this.unmappedBagItems.splice(n, 1)
                }
                toggleShowCamerasInBag(e) {
                    this.shadowCameraGroup.hideCamerasInBag = !e.checked
                }
                displayCameraDetails(e) {
                    var t, n, i;
                    void 0 === e ? this.cameraHandleState = Ko.HIDDEN : (this.cameraHandleState === Ko.HIDDEN && (this.cameraHandleState = Ko.PARTIALLYEXPANDED),
                    this.selectedCameraItem = {
                        cameraName: null === (t = this._renewableService.findCamera(e.orchidId, e.id)) || void 0 === t ? void 0 : t.name,
                        orchidName: null === (n = this._renewableService.findOrchid(e.orchidId)) || void 0 === n ? void 0 : n.name,
                        cameraId: e.id,
                        orchidId: e.orchidId,
                        active: null === (i = this._renewableService.findCamera(e.orchidId, e.id)) || void 0 === i ? void 0 : i.active
                    })
                }
                changeCameraHandleState() {
                    this.cameraHandleState = this.cameraHandleState === Ko.PARTIALLYEXPANDED ? Ko.FULLYEXPANDED : Ko.PARTIALLYEXPANDED
                }
                removeCameraFromMap() {
                    if (null === this.selectedCameraItem)
                        return;
                    const e = this.shadowCameraGroup.cameras.find((e => {
                        var t, n;
                        return e.id === (null === (t = this.selectedCameraItem) || void 0 === t ? void 0 : t.cameraId) && e.orchidId === (null === (n = this.selectedCameraItem) || void 0 === n ? void 0 : n.orchidId)
                    }
                    ));
                    null !== e && (e.mapPosition = null),
                    this.mappedCameras$.next(e),
                    this.unmappedBagItems.push(this._toCameraBagItem(e)),
                    this.unmappedBagItems.sort(( (e, t) => Tt(e.name).localeCompare(Tt(t.name)))),
                    this.selectedCameraItem = null
                }
                confirm() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.processing = !0,
                        this.shadowCameraGroup.cameras.forEach((e => {
                            e.mapPosition && (e.mapPosition.x = Math.max(Math.min(e.mapPosition.x, 1), -1),
                            e.mapPosition.y = Math.max(Math.min(e.mapPosition.y, 1), -1))
                        }
                        ));
                        try {
                            yield this._dataService.updateCameraGroup(this.shadowCameraGroup),
                            this._matDialogRef.close()
                        } catch (e) {
                            this.errors = e.reason ? e.reason : this.msgs.theCameraPositionsCouldNotBeSaved(),
                            Qo.error(e)
                        } finally {
                            this.processing = !1
                        }
                    }
                    ))
                }
                cancel() {
                    if (this.processing)
                        return;
                    JSON.stringify(this._cameraGroup) !== JSON.stringify(this.shadowCameraGroup) ? qs.show(this._matDialog, {
                        data: {
                            cancelText: this.msgs.cancel(),
                            confirmText: this.msgs.ok(),
                            message: this.msgs.loseUnsavedChanges()
                        }
                    }).subscribe((e => {
                        void 0 !== e && !1 === e || this._matDialogRef.close()
                    }
                    )) : this._matDialogRef.close()
                }
                setError(e) {
                    null != e && "" !== e.trim() ? this.errors = e : delete this.errors
                }
            }
            ;
            var nc, ic, ac;
            (0,
            c.gn)([(0,
            i.ViewChild)("unmappedContainer"), (0,
            c.w6)("design:type", "function" == typeof (zo = void 0 !== h.Wj && h.Wj) ? zo : Object)], tc.prototype, "unMappedListed", void 0),
            tc = Bo = (0,
            c.gn)([(0,
            i.Component)({
                selector: "map-configuration",
                template: n(36481),
                animations: [(0,
                Jo.X$)("transitionCameraCard", [(0,
                Jo.SB)(Ko.HIDDEN, (0,
                Jo.oB)({
                    transform: "translateY(100%)"
                })), (0,
                Jo.SB)(Ko.PARTIALLYEXPANDED, (0,
                Jo.oB)({
                    transform: "translateY(calc(100% - 56px))"
                })), (0,
                Jo.SB)(Ko.FULLYEXPANDED, (0,
                Jo.oB)({
                    transform: "translateY(0%)"
                })), (0,
                Jo.eR)(`${Ko.HIDDEN} => ${Ko.PARTIALLYEXPANDED}`, [(0,
                Jo.jt)(".3s ease-in-out", (0,
                Jo.oB)({
                    transform: "translateY(calc(100% - 56px))"
                }))]), (0,
                Jo.eR)(`${Ko.PARTIALLYEXPANDED} => ${Ko.HIDDEN}`, [(0,
                Jo.jt)(".3s ease-in-out", (0,
                Jo.oB)({
                    transform: "translateY(100%)"
                }))]), (0,
                Jo.eR)(`${Ko.PARTIALLYEXPANDED} => ${Ko.FULLYEXPANDED}`, [(0,
                Jo.jt)(".3s ease-in-out", (0,
                Jo.oB)({
                    transform: "translateY(0%)"
                }))]), (0,
                Jo.eR)(`${Ko.FULLYEXPANDED} => ${Ko.PARTIALLYEXPANDED}`, [(0,
                Jo.jt)(".3s ease-in-out", (0,
                Jo.oB)({
                    transform: "translateY(calc(100% - 56px))"
                }))]), (0,
                Jo.eR)(`${Ko.FULLYEXPANDED} => ${Ko.HIDDEN}`, [(0,
                Jo.jt)(".3s ease-in-out", (0,
                Jo.oB)({
                    transform: "translateY(100%)"
                }))])]), (0,
                Jo.X$)("transitionDrawerToggle", [(0,
                Jo.SB)("true", (0,
                Jo.oB)({
                    transform: "translateX(240px)"
                })), (0,
                Jo.SB)("false", (0,
                Jo.oB)({
                    transform: "translateX(0px)"
                })), (0,
                Jo.eR)("false => true", [(0,
                Jo.jt)(".35s ease", (0,
                Jo.oB)({
                    transform: "translateX(240px)"
                }))]), (0,
                Jo.eR)("true => false", [(0,
                Jo.jt)(".35s ease", (0,
                Jo.oB)({
                    transform: "translateX(0px)"
                }))])]), (0,
                Jo.X$)("transitionDrawer", [(0,
                Jo.SB)("true", (0,
                Jo.oB)({
                    transform: "translateX(0px)"
                })), (0,
                Jo.SB)("false", (0,
                Jo.oB)({
                    transform: "translateX(-240px)"
                })), (0,
                Jo.eR)("false => true", [(0,
                Jo.jt)(".35s ease", (0,
                Jo.oB)({
                    transform: "translateX(0px)"
                }))]), (0,
                Jo.eR)("true => false", [(0,
                Jo.jt)(".35s ease", (0,
                Jo.oB)({
                    transform: "translateX(-240px)"
                }))])])]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(Window)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(3, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(4, (0,
            i.Inject)(Qe)), (0,
            c.fM)(5, (0,
            i.Inject)(Gt)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (Ho = "undefined" != typeof Window && Window) ? Ho : Object, "function" == typeof (Wo = void 0 !== hn.so && hn.so) ? Wo : Object, "function" == typeof (qo = void 0 !== hn.uw && hn.uw) ? qo : Object, "function" == typeof (Yo = Qe) ? Yo : Object, "function" == typeof (Xo = Gt) ? Xo : Object])], tc);
            const rc = O("MoveCameraGroupDialog");
            let sc = nc = class {
                constructor(e, t, n) {
                    this._fusionDataService = e,
                    this.dialogData = t,
                    this._matDialogRef = n,
                    this.msgs = L.messages.cameraGroups,
                    this.processing = !1,
                    this.error = void 0,
                    this.flatGroups = []
                }
                static show(e, t) {
                    const n = {
                        data: t
                    };
                    return e.open(nc, n).afterClosed().pipe((0,
                    pn.q)(1))
                }
                close() {
                    this._matDialogRef.close(void 0)
                }
                _flattenGroup(e, t, n, i) {
                    const a = i.concat([e.name]);
                    if (e.id !== n.id) {
                        const i = {
                            groupId: e.id,
                            groupPath: a.join(" > ")
                        };
                        t.push(i),
                        this.dialogData.parentGroup.id === e.id && (this.selectedItem = i),
                        e.groups.forEach((e => {
                            this._flattenGroup(e, t, n, a)
                        }
                        ))
                    }
                }
                moveGroup() {
                    this.processing = !0,
                    this._groupCopy.groups = [],
                    this._groupCopy.parentId = void 0 !== this.selectedItem ? this.selectedItem.groupId : this.dialogData.rootGroup.id,
                    this._fusionDataService.updateCameraGroup(this._groupCopy).then((e => {
                        this._matDialogRef.close(e.data)
                    }
                    )).catch((e => {
                        this.processing = !1,
                        this.error = e.data && e.data.reason ? e.data.reason : this.msgs.anUnexpectedErrorHasOccurred(),
                        rc.error(`Failed to move camera group: ${this.error}`)
                    }
                    ))
                }
                ngOnInit() {
                    this._groupCopy = xt(this.dialogData.group),
                    this.flatGroups.push({
                        groupId: this.dialogData.rootGroup.id,
                        groupPath: this.msgs.noneTopLevelGroup()
                    }),
                    this.dialogData.parentGroup.id === this.dialogData.rootGroup.id && (this.selectedItem = this.flatGroups[0]),
                    this.dialogData.rootGroup.groups.forEach((e => {
                        this._flattenGroup(e, this.flatGroups, this.dialogData.group, [])
                    }
                    ))
                }
            }
            ;
            sc = nc = (0,
            c.gn)([(0,
            i.Component)({
                selector: "move-camera-group-dialog",
                template: n(96062)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Qe)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.so)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (ic = Qe) ? ic : Object, Object, "function" == typeof (ac = void 0 !== hn.so && hn.so) ? ac : Object])], sc);
            let oc = function() {
                function e(t, n, i, a, r, s, o, c, l) {
                    (0,
                    S.Z)(this, e),
                    this.$rootScope = t,
                    this.$scope = n,
                    this.$timeout = i,
                    this.$mdDialog = a,
                    this.RenewableService = s,
                    this.AutocompleteRepairService = o,
                    this.FusionDataService = c,
                    this._matDialog = l,
                    this.orchidsList = "",
                    this.camerasList = "",
                    this.showAllCameras = !1,
                    this.moving = !1,
                    this.uuid = r.v4(),
                    this.childCameraCounts = {},
                    this.breadCrumbs = [],
                    this.orchidCameraMap = {},
                    this.listenersUnWatchers = [],
                    this.GROUP_SIZE_THRESHOLD = 50
                }
                return (0,
                b.Z)(e, [{
                    key: "$onInit",
                    value: function() {
                        var e = this;
                        this.msgs = {
                            ...L.messages.cameraGroups,
                            totalCameras: L.messages.cameras.cameraPicker.totalCameras,
                            totalServers: L.messages.cameras.cameraPicker.totalServers
                        },
                        this.RenewableService.orchidsPromise().then((function() {
                            e.init()
                        }
                        ))
                    }
                }, {
                    key: "$onDestroy",
                    value: function() {
                        this.listenersUnWatchers.forEach((function(e) {
                            e()
                        }
                        ))
                    }
                }, {
                    key: "init",
                    value: function() {
                        var e = this;
                        this.currentGroup = this.group,
                        this.group.contentCount = this.tallyServersAndCamerasInGroup(this.group),
                        this.parentPath || (this.parentPath = []),
                        this.path = angular.copy(this.parentPath),
                        this.group && this.path.push(this.group),
                        this.parentGroup = this.parentPath.length > 0 ? this.parentPath[this.parentPath.length - 1] : this.rootGroup,
                        0 === this.parentPath.length && this.listenersUnWatchers.push(this.$rootScope.$on("enter-group", (function(t, n) {
                            n[0].id === e.group.id && (e.breadCrumbs = n,
                            e.currentGroup = n[n.length])
                        }
                        ))),
                        this.group && (!1 === this._isRoot(this.parentGroup) && this.expanded && this.listenersUnWatchers.push(this.$scope.$watch((function() {
                            return e.expanded[e.parentGroup.id]
                        }
                        ), (function(t, n) {
                            !1 === t && (e.expanded[e.group.id] = !1)
                        }
                        ))),
                        this.listenersUnWatchers.push(this.$scope.$on("rebuild-groups", (function() {
                            e.buildLists()
                        }
                        )))),
                        this.buildLists()
                    }
                }, {
                    key: "cameraCountExceedsThreshold",
                    get: function() {
                        return this.group.cameras.length + this.group.orchids.length > this.GROUP_SIZE_THRESHOLD
                    }
                }, {
                    key: "tallyServersAndCamerasInGroup",
                    value: function(e) {
                        var t = this;
                        let n = {
                            servers: 0,
                            cameras: 0
                        };
                        return e.orchids && (n.servers += e.orchids.length),
                        e.cameras && (n.cameras += e.cameras.length),
                        e.groups && e.groups.forEach((function(e) {
                            let i = t.tallyServersAndCamerasInGroup(e);
                            n.servers += i.servers,
                            n.cameras += i.cameras
                        }
                        )),
                        n
                    }
                }, {
                    key: "openGroupDialog",
                    value: function(e, t) {
                        const i = {
                            template: n(37446),
                            controller: "CameraGroupDialogController as groupDialog",
                            parent: angular.element(document.body),
                            targetEvent: t,
                            clickOutsideToClose: !1,
                            escapeToClose: !1,
                            onComplete: this.AutocompleteRepairService.handleDialog,
                            locals: {
                                group: e,
                                parentGroup: e.isNew ? this.group : this.parentGroup,
                                rootGroup: this.rootGroup
                            }
                        };
                        return this.$mdDialog.show(i)
                    }
                }, {
                    key: "buildLists",
                    value: function() {
                        var e = this;
                        this.orchidCameraMap = {},
                        this.group && (angular.forEach(this.group.orchids, (function(t) {
                            e.orchidCameraMap[t] = {
                                cameras: [],
                                all: !0
                            }
                        }
                        )),
                        angular.forEach(this.group.cameras, (function(t) {
                            e.orchidCameraMap[t.orchidId] || (e.orchidCameraMap[t.orchidId] = {
                                cameras: []
                            }),
                            !0 !== e.orchidCameraMap[t.orchidId].all && e.orchidCameraMap[t.orchidId].cameras.push(e.RenewableService.findCamera(t.orchidId, t.id))
                        }
                        )))
                    }
                }, {
                    key: "findSourceGroup",
                    value: function(e) {
                        const t = e.dataTransfer.getData("group-uuid");
                        return angular.element(document.getElementById("group-" + t)).scope()
                    }
                }, {
                    key: "findGroup",
                    value: function(e, t) {
                        let n;
                        if (e.id === t)
                            return e;
                        for (let i = 0; i < e.groups.length; ++i)
                            if (n = this.findGroup(e.groups[i], t),
                            n)
                                return n
                    }
                }, {
                    key: "newGroup",
                    value: function(e) {
                        this.openGroupDialog({
                            isNew: !0,
                            cameras: [],
                            orchids: [],
                            groups: []
                        }, e).then((function(e) {}
                        ), (function(e) {}
                        ))
                    }
                }, {
                    key: "editMap",
                    value: function() {
                        const e = {
                            ...this.group,
                            groups: void 0
                        };
                        tc.show(this._matDialog, {
                            cameraGroup: e
                        })
                    }
                }, {
                    key: "editGroup",
                    value: function(e) {
                        this.openGroupDialog(this.group, e).then((function(e) {}
                        ), (function(e) {}
                        ))
                    }
                }, {
                    key: "moveGroup",
                    value: function(e) {
                        var t = this;
                        let n = {
                            group: this.group,
                            parentGroup: this.group.isNew ? this.group : this.parentGroup,
                            rootGroup: this.rootGroup
                        };
                        sc.show(this._matDialog, n).subscribe((function(e) {
                            if (void 0 !== e) {
                                let n;
                                if (e.parentId === t.parentGroup.id) {
                                    n = t.parentGroup,
                                    e.groups = t.group.groups;
                                    for (let t = 0; t < n.groups.length; ++t)
                                        if (n.groups[t].id === e.id) {
                                            n.groups[t] = e;
                                            break
                                        }
                                } else
                                    t.expanded[t.group.id] = !1,
                                    e.groups = t.group.groups,
                                    n = t.findGroup(t.rootGroup, e.parentId),
                                    n.groups.push(e),
                                    t.$timeout((function() {
                                        t.removeNode()
                                    }
                                    ))
                            }
                        }
                        ), (function() {}
                        ))
                    }
                }, {
                    key: "removeNode",
                    value: function() {
                        for (let e = 0; e < this.parentGroup.groups.length; ++e)
                            this.parentGroup.groups[e].id === this.group.id && this.parentGroup.groups.splice(e, 1)
                    }
                }, {
                    key: "destroySelf",
                    value: function(e) {
                        const t = {
                            data: {
                                message: this.msgs.deleteGroupAndAllOfItsChildren({
                                    VALUE: this.group.name
                                }),
                                confirmText: this.msgs.deleteGroup(),
                                cancelText: this.msgs.cancel(),
                                confirmCallbackAsync: async function() {
                                    try {
                                        await this.FusionDataService.deleteCameraGroup(this.group.id),
                                        this.removeNode()
                                    } catch (e) {
                                        const t = re(e.data) || re(e.data.reason) ? this.msgs.anErrorOccurredWhileAttemptingToDeleteTheGroup() : e.data.reason;
                                        throw new Error(t)
                                    }
                                }
                                .bind(this)
                            }
                        };
                        qs.show(this._matDialog, t)
                    }
                }, {
                    key: "enterGroup",
                    value: function(e, t) {
                        this.$rootScope.$broadcast("enter-group", this.path)
                    }
                }, {
                    key: "toggle",
                    value: function() {
                        this.expanded[this.group.id] = !this.expanded[this.group.id]
                    }
                }, {
                    key: "_isRoot",
                    value: function(e) {
                        return "980554ba-04f7-4e49-b1f6-1f2892a7ddea" === e.id
                    }
                }]),
                e
            }();
            oc.$inject = ["$rootScope", "$scope", "$timeout", "$mdDialog", "uuid", "RenewableService", "AutocompleteRepairService", "FusionDataService", "MatDialog"],
            angular.module("ipconfigure.orchid.singularity").controller("CameraGroupViewController", oc).component("cameraGroupView", {
                template: n(94185),
                bindings: {
                    rootGroup: "=",
                    group: "=",
                    parentPath: "=?",
                    features: "=",
                    isRoot: "@",
                    lastGroup: "=",
                    expanded: "=?",
                    display: "@"
                },
                controller: "CameraGroupViewController",
                controllerAs: "cameraGroup"
            });
            let cc = class {
                setPreAuthentication(e) {
                    this._preAuthAbout = e
                }
                setPostAuthentication(e) {
                    return this._postAuthAbout = e,
                    this._postAuthAbout
                }
                getConfigPreAuth() {
                    if (void 0 === this._preAuthAbout)
                        throw new Error("The pre-authenticated about info has not been fetched because the preInit method as not been called yet.");
                    return this._preAuthAbout
                }
                getConfigPostAuth() {
                    if (void 0 === this._postAuthAbout)
                        throw new Error("The authenticated about info has not been fetched because the user has not signed in or the setPostAuthentication method as not been called yet.");
                    return this._postAuthAbout
                }
                updateConfigPostAuth(e) {
                    if (void 0 === this._postAuthAbout)
                        throw new Error("The authenticated about info has not been fetched because the user has not signed in or the setPostAuthentication method as not been called yet.");
                    this._postAuthAbout.config = e
                }
                clearPostAuthConfig() {
                    this._postAuthAbout = void 0
                }
            }
            ;
            var lc, dc, uc, mc;
            cc = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            })], cc);
            let hc = lc = class {
                constructor(e, t, n) {
                    this._fusionDataService = e,
                    this._fusionConfigService = t,
                    this._matDialogRef = n,
                    this.msgs = Object.assign(Object.assign({}, L.messages.cameraGroups), {
                        update: L.messages.dialogs.update
                    }),
                    this.processing = !1
                }
                cancel() {
                    this._matDialogRef.close(!1)
                }
                updateCameraGroupSettings() {
                    this.processing = !0,
                    this._fusionDataService.updateServerConfig({
                        "groups.orchids.show": this.showOrchids
                    }).then(( () => {
                        this._matDialogRef.close(!0)
                    }
                    ), (e => {
                        this.processing = !1,
                        e && e.reason ? this.error = e.reason : this.error = this.msgs.anUnexpectedErrorHasOccurred()
                    }
                    ))
                }
                static show(e, t) {
                    return e.open(lc, t).afterClosed().pipe((0,
                    pn.q)(1))
                }
                ngOnInit() {
                    try {
                        this.showOrchids = this._fusionConfigService.getConfigPostAuth().config["groups.orchids.show"]
                    } catch (e) {
                        this.showOrchids = void 0,
                        this.error = this.msgs.anUnexpectedErrorHasOccurred()
                    }
                }
            }
            ;
            hc = lc = (0,
            c.gn)([(0,
            i.Component)({
                selector: "camera-group-settings-dialog",
                template: n(70595)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Qe)), (0,
            c.fM)(1, (0,
            i.Inject)(cc)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.so)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (dc = Qe) ? dc : Object, "function" == typeof (uc = void 0 !== cc && cc) ? uc : Object, "function" == typeof (mc = void 0 !== hn.so && hn.so) ? mc : Object])], hc);
            var pc, gc, fc, vc, yc = n(37174);
            let bc = pc = class {
                constructor(e, t, n) {
                    this._matDialogRef = e,
                    this.data = t,
                    this._fusionDataService = n,
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.cameraGroups), L.messages.dialogs), L.messages.cameras.cameraPicker),
                    this.processing = !1,
                    this.loading = !0,
                    this.showError = !1,
                    this.allGroups = [],
                    this.orchids = [],
                    this.ungroupedOrchids = [],
                    this.totalCameras = 0,
                    this.totalServers = 0,
                    this.hasChild = (e, t) => t.expandable,
                    this._transformer = (e, t) => ({
                        expandable: !!e.children && e.children.length > 0,
                        name: e.name,
                        level: t,
                        id: e.id,
                        selected: !1
                    }),
                    this.groups = [...t.groups],
                    this.ungroupedOrchids = [...t.ungroupedOrchids],
                    this.treeControl = new yc.C2((e => e.level),(e => e.expandable)),
                    this.treeFlattener = new Oi.JZ(this._transformer,(e => e.level),(e => e.expandable),(e => e.children)),
                    this.dataSource = new Oi.kc(this.treeControl,this.treeFlattener)
                }
                ngOnInit() {
                    this._getGroups(void 0, this.data.groups),
                    this.formGroup = this._initAndGetForm(),
                    this.loading = !1,
                    this.dataSource.data = this.allGroups
                }
                scrollToNode(e) {
                    var t;
                    e && (this._groupNameSelect._keyManager.setActiveItem(0),
                    null === (t = document.getElementById(this._groupNameSelect.value)) || void 0 === t || t.scrollIntoView({
                        behavior: "smooth",
                        block: "center",
                        inline: "nearest"
                    }))
                }
                static show(e, t, n) {
                    return e.open(pc, {
                        maxHeight: "100vh",
                        panelClass: "ungrouped-cameras-dialog-panel",
                        disableClose: !0,
                        data: {
                            ungroupedOrchids: t,
                            groups: n
                        }
                    }).afterClosed().pipe((0,
                    pn.q)(1))
                }
                _getGroups(e, t) {
                    t.sort(( (e, t) => e.name.toLowerCase().localeCompare(t.name.toLowerCase()))),
                    t.forEach((t => {
                        const n = {
                            id: t.id,
                            name: t.name,
                            children: []
                        };
                        t.groups.length > 0 && this._getGroups(n.children, t.groups),
                        e ? e && e.push(n) : this.allGroups.push(n)
                    }
                    ))
                }
                _initAndGetForm() {
                    return new p.cw({
                        groupId: new p.NI(void 0,[p.kI.required]),
                        orchids: new p.NI([]),
                        cameras: new p.NI([])
                    })
                }
                updateCamerasAndServers(e) {
                    this.formGroup.controls.orchids.setValue(e[0]),
                    this.formGroup.controls.cameras.setValue(e[1]),
                    this.totalServers = e[0].length,
                    this.totalCameras = e[1].length
                }
                _findGroup(e, t) {
                    t.forEach((t => {
                        t.id === e ? this.groupToUpdate = t : t.groups.length > 0 && this._findGroup(e, t.groups)
                    }
                    ))
                }
                addToGroup() {
                    const e = this.formGroup.value;
                    this.processing = !0,
                    this._findGroup(e.groupId, this.groups),
                    e.orchids.forEach((e => {
                        this.groupToUpdate.orchids.push(e)
                    }
                    )),
                    e.cameras.forEach((e => {
                        this.groupToUpdate.cameras.push(e)
                    }
                    )),
                    this.groupToUpdate.orchids.forEach((e => {
                        this.groupToUpdate.cameras = this.groupToUpdate.cameras.filter((t => t.orchidId !== e))
                    }
                    )),
                    this._fusionDataService.updateCameraGroup(this.groupToUpdate).then(( () => {
                        this._matDialogRef.close(!0)
                    }
                    )).catch((e => {
                        var t;
                        this.error = (null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.reason) || this.msgs.anUnexpectedErrorHasOccurred(),
                        this.showError = !0,
                        this.processing = !1
                    }
                    ))
                }
                cancel() {
                    this._matDialogRef.close(!1)
                }
                dismissMe() {
                    this.showError = !1
                }
            }
            ;
            function Sc(e, t) {
                let n;
                return n = e.map((e => {
                    const t = {
                        id: e.id,
                        name: e.name,
                        version: e.version,
                        cameras: e.cameras.map((e => ({
                            id: e.id,
                            name: e.name,
                            active: e.active
                        }))),
                        camerasAvailable: e.camerasAvailable
                    };
                    return JSON.parse(JSON.stringify(t))
                }
                )),
                n = wc(t, n),
                n = Cc(t, n),
                n = n.filter((e => {
                    if (e.cameras.length > 0 || 0 === e.camerasAvailable)
                        return e
                }
                )),
                n
            }
            function Cc(e, t) {
                return e.forEach((e => {
                    e.orchids.length > 0 && e.orchids.forEach((e => {
                        const n = t.findIndex((t => t.id === e));
                        -1 !== n && t.splice(n, 1)
                    }
                    )),
                    e.groups.length > 0 && Cc(e.groups, t)
                }
                )),
                t
            }
            function wc(e, t) {
                return e.forEach((e => {
                    e.cameras.length > 0 && e.cameras.forEach((e => {
                        const n = t.find((t => t.id === e.orchidId));
                        if (n) {
                            const t = n.cameras.findIndex((t => t.id === e.id));
                            -1 !== t && n.cameras.splice(t, 1)
                        }
                    }
                    )),
                    e.groups.length > 0 && wc(e.groups, t)
                }
                )),
                t
            }
            (0,
            c.gn)([(0,
            i.ViewChild)("groupNameSelect"), (0,
            c.w6)("design:type", "function" == typeof (gc = void 0 !== yi.gD && yi.gD) ? gc : Object)], bc.prototype, "_groupNameSelect", void 0),
            bc = pc = (0,
            c.gn)([(0,
            i.Component)({
                selector: "ungrouped-cameras-dialog",
                template: n(81723)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(2, (0,
            i.Inject)(Qe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (fc = void 0 !== hn.so && hn.so) ? fc : Object, Object, "function" == typeof (vc = Qe) ? vc : Object])], bc);
            let Ic = function() {
                function e(t, n, i, a, r, s, o, c) {
                    (0,
                    S.Z)(this, e),
                    this.$rootScope = t,
                    this.$scope = n,
                    this.$timeout = i,
                    this.$mdDialog = a,
                    this.RenewableService = r,
                    this.FusionDataService = s,
                    this.BlowoutUtilityService = o,
                    this._matDialog = c,
                    this.groupsLoaded = !1,
                    this.expanded = {},
                    this.ungroupedCameras = {},
                    this.ungroupedOrchids = [],
                    this.rootGroup = {},
                    this.orchids = [],
                    this.listeners = [],
                    this.paging = {
                        perPage: 16,
                        current: 0,
                        pageSizeOptions: [16, 32, 48, 64],
                        paginatorLimit: 16,
                        resetExpandedState: !0
                    },
                    this.filters = {
                        searchNames: []
                    },
                    this.ungroupedCameraCount = -1,
                    this.showUngroupedCameras = !1,
                    this.loading = !0,
                    this.failedLoading = !1,
                    this.logger = O("CameraGroupConfigController"),
                    this.noCameraGroupsMessageKeys = {
                        Exist: "existence",
                        Matches: "matches"
                    }
                }
                return (0,
                b.Z)(e, [{
                    key: "numberOfRootGroups",
                    get: function() {
                        return Array.isArray(this.rootGroup.groups) ? this.rootGroup.groups.length : 0
                    }
                }, {
                    key: "filteredGroups",
                    get: function() {
                        if (0 === this.filters.searchNames.length)
                            return this.rootGroup.groups;
                        const e = this.filters.searchNames;
                        return this.rootGroup.groups.filter((function(t) {
                            for (let n = 0; n < e.length; n++)
                                if (t.name.toLowerCase().includes(e[n].toLowerCase()))
                                    return !0;
                            return !1
                        }
                        ))
                    }
                }, {
                    key: "noGroupsOrSearchDidNotMatchSwitchKey",
                    get: function() {
                        return this.rootGroup.groups && 0 !== this.rootGroup.groups.length ? this.noCameraGroupsMessageKeys.Matches : this.noCameraGroupsMessageKeys.Exist
                    }
                }, {
                    key: "$onInit",
                    value: function() {
                        var e = this;
                        this.msgs = Object.assign({
                            name: L.messages.dashboard.name,
                            search: L.messages.dashboard.search
                        }, L.messages.cameraGroups),
                        this.listeners.push(this.$rootScope.$on("orchidChanged", (function(t, n) {
                            n.defunct && (e.purgeOrchid(e.rootGroup, n),
                            e.findUngroupedCameras(e.rootGroup),
                            e.$timeout((function() {
                                e.$scope.$broadcast("rebuild-groups")
                            }
                            )))
                        }
                        )), this.$rootScope.$on("cameraChanged", (function(t, n) {
                            n.defunct && (e.purgeCamera(e.rootGroup, n),
                            e.findUngroupedCameras(e.rootGroup),
                            e.$timeout((function() {
                                e.$scope.$broadcast("rebuild-groups")
                            }
                            )))
                        }
                        )), this.$rootScope.$on("cameraGroupsModified", (function(t, n) {
                            e.onCameraGroupsModified().catch((function(t) {
                                e.logger.error("failed to updated camera groups after receiving the cameraGroupsModified event", t)
                            }
                            ))
                        }
                        )), this.$scope.$on("cameraChanged", (function() {
                            return e.findUngroupedCameras()
                        }
                        ))),
                        this.RenewableService.orchidsPromise().then((function(t) {
                            e.orchids = t,
                            e.FusionDataService.fetchCameraGroups().then((function(t) {
                                e.rootGroup = t.data,
                                e.findUngroupedCameras()
                            }
                            )).catch((function(t) {
                                e.logger.error("failed to fetch the camera groups", t),
                                e.loading = !1,
                                e.failedLoading = !0
                            }
                            )).finally((function() {
                                e.groupsLoaded = !0,
                                e.loading = !1
                            }
                            ))
                        }
                        )).catch((function(t) {
                            e.loading = !1,
                            e.failedLoading = !0
                        }
                        ))
                    }
                }, {
                    key: "$onDestroy",
                    value: function() {
                        angular.forEach(this.listeners, (function(e) {
                            e()
                        }
                        ))
                    }
                }, {
                    key: "onPageChange",
                    value: function(e) {
                        var t = this;
                        this.paging.resetExpandedState && Object.keys(this.expanded).forEach((function(e) {
                            t.expanded[e] && (t.expanded[e] = !1)
                        }
                        )),
                        this.paging.current = e.pageIndex,
                        this.paging.perPage = e.pageSize
                    }
                }, {
                    key: "onFiltersChanged",
                    value: function() {
                        var e = this;
                        this.$timeout((function() {
                            e.BlowoutUtilityService.collapseExpandedElement(),
                            e.paging.current = 0
                        }
                        ))
                    }
                }, {
                    key: "onCameraGroupsModified",
                    value: async function() {
                        let e, t;
                        this.loading = !0;
                        const n = await this.FusionDataService.fetchCameraGroups().catch(de);
                        if (void 0 === n)
                            return this.logger.error("failed to fetch camera groups onCameraGroupsModified"),
                            void (this.loading = !1);
                        this.loading = !1;
                        const i = this.paging.current;
                        this.paging.resetExpandedState = !1,
                        this.rootGroup = {},
                        await this.$timeout(de, 300),
                        this.rootGroup = n.data,
                        this.findUngroupedCameras(),
                        await this.$timeout(de, 100),
                        this.paging.current !== i && (this.paging.current = i,
                        await this.$timeout(de, 100));
                        for (let n = 0; n < this.rootGroup.groups.length; ++n)
                            if (!0 === this.expanded[this.rootGroup.groups[n].id]) {
                                e = this.rootGroup.groups[n],
                                t = document.getElementById(`${e.id}-row`),
                                t && !t.classList.contains("expanded") && t.expandMe();
                                break
                            }
                        this.paging.resetExpandedState = !0
                    }
                }, {
                    key: "purgeOrchid",
                    value: function(e, t) {
                        var n = this;
                        e.orchids = e.orchids.filter((function(e) {
                            return t.id !== e
                        }
                        )),
                        e.cameras = e.cameras.filter((function(e) {
                            return t.id !== e.orchidId
                        }
                        )),
                        angular.forEach(e.groups, (function(e) {
                            n.purgeOrchid(e, t)
                        }
                        ))
                    }
                }, {
                    key: "purgeCamera",
                    value: function(e, t) {
                        var n = this;
                        e.cameras = e.cameras.filter((function(e) {
                            return !(e.orchidId === t.orchidId && e.id === t.id)
                        }
                        )),
                        angular.forEach(e.groups, (function(e) {
                            n.purgeCamera(e, t)
                        }
                        ))
                    }
                }, {
                    key: "getStartFromIndex",
                    value: function() {
                        return this.paging.current * this.paging.perPage
                    }
                }, {
                    key: "pagingPages",
                    value: function(e) {
                        return Math.ceil(e / this.paging.perPage)
                    }
                }, {
                    key: "pageRange",
                    value: function(e) {
                        const t = this.getStartFromIndex() + 1
                          , n = Math.min(t + this.paging.perPage - 1, (Array.isArray(e) ? e : this.rootGroup.groups ? this.rootGroup.groups : []).length);
                        return t === n ? `${t}` : (t > n && (this.paging.current = this.paging.current - 1 < 0 ? this.paging.current : this.paging.current - 1),
                        `${t}-${n}`)
                    }
                }, {
                    key: "openSettingsDialog",
                    value: function(e) {
                        return hc.show(this._matDialog, {
                            disableClose: !0
                        })
                    }
                }, {
                    key: "openUngroupedDialog",
                    value: function(e) {
                        return bc.show(this._matDialog, this.ungroupedOrchids, this.rootGroup.groups)
                    }
                }, {
                    key: "toggleUngroupedCameras",
                    value: function() {
                        this.showUngroupedCameras = !this.showUngroupedCameras
                    }
                }, {
                    key: "findUngroupedCameras",
                    value: function() {
                        var e = this;
                        this.ungroupedCameraCount = 0,
                        this.ungroupedOrchids = Sc(this.orchids, this.rootGroup.groups),
                        this.ungroupedOrchids.forEach((function(t) {
                            e.ungroupedCameraCount += t.cameras.length
                        }
                        ))
                    }
                }]),
                e
            }();
            var Tc, Ec, _c;
            Ic.$inject = ["$rootScope", "$scope", "$timeout", "$mdDialog", "RenewableService", "FusionDataService", "BigSummerBlowoutUtilityService", "MatDialog"],
            angular.module("ipconfigure.orchid.singularity").controller("CameraGroupConfigController", Ic).component("cameraGroupConfig", {
                template: n(67624),
                controller: "CameraGroupConfigController",
                controllerAs: "cameraGroupConfig"
            });
            let xc = Tc = class {
                constructor(e, t) {
                    this._matDialogRef = e,
                    this._authService = t,
                    this.msgs = L.messages.notifications,
                    this.email = new p.NI("",[p.kI.required, p.kI.email])
                }
                get getEmail() {
                    return this.email.value
                }
                cancel() {
                    this._matDialogRef.close()
                }
                ok() {
                    this.recipient = this.getEmail,
                    this._matDialogRef.close(this.recipient)
                }
                static show(e) {
                    return e.open(Tc).afterClosed().pipe((0,
                    pn.q)(1))
                }
                ngOnInit() {
                    this.recipient = this._authService.getAuthenticationData().email,
                    this.email.setValue(this.recipient)
                }
            }
            ;
            function Dc(e, t, n, i, a) {
                var r = this;
                r.smtpServer = i ? angular.copy(i) : {
                    new: !0,
                    name: "",
                    server: "",
                    username: "",
                    password: "",
                    advanced: {}
                },
                r._matDialog = a,
                r.testSmtpSettings = function(e) {
                    xc.show(r._matDialog).subscribe((function(e) {
                        if (e) {
                            var t = angular.copy(r.smtpServer);
                            t.recipient = e,
                            t.advanced = r.advancedSettings,
                            r.processingTest = !0,
                            r.testSuccessful = !1,
                            r.error = void 0,
                            n.testSmtpServer(t).then((function() {
                                r.testSuccessful = !0
                            }
                            )).catch((function(e) {
                                e.data && e.data.reason ? r.error = e.data.reason : r.error = r.msgs.anUnexpectedErrorHasOccurred()
                            }
                            )).finally((function() {
                                r.processingTest = !1
                            }
                            ))
                        }
                    }
                    ))
                }
                ,
                r.addAdvancedSetting = function() {
                    r.newSettingKey && r.newSettingValue && r.newSettingKey.length > 0 && r.newSettingValue.length > 0 && (r.advancedSettings[r.newSettingKey] = r.newSettingValue,
                    r.newSettingKey = "",
                    r.newSettingValue = "",
                    e[0].getElementById("key-field").focus())
                }
                ,
                r.removeAdvancedSetting = function(e) {
                    delete r.advancedSettings[e]
                }
                ,
                r.saveSmtpServer = function() {
                    var e;
                    r.processing = !0,
                    r.smtpServer.advanced = r.advancedSettings,
                    !0 === r.smtpServer.new ? e = n.newSmtpServer : (e = n.updateSmtpServer,
                    "" === r.smtpServer.password && (r.smtpServer.password = null)),
                    e(r.smtpServer).then((function() {
                        t.hide(r.smtpServer)
                    }
                    )).catch((function(e) {
                        r.processing = !1,
                        e.data && e.data.reason ? r.error = e.data.reason : r.error = r.msgs.anUnexpectedErrorHasOccurred()
                    }
                    ))
                }
                ,
                r.cancel = function() {
                    t.cancel()
                }
                ,
                r.$onInit = function() {
                    r.msgs = {
                        ...L.messages.notifications,
                        ...L.messages.dialogs
                    },
                    r.formMsgs = L.messages.credentialsForm,
                    Object.keys(r.smtpServer.advanced).length ? (r.advancedSettings = r.smtpServer.advanced,
                    r.showAdvanced = !0) : (r.advancedSettings = {},
                    r.showAdvanced = !1)
                }
            }
            function Oc(e, t, n) {
                const i = n[e.id];
                t[e.id] = i,
                void 0 !== i && i.groups.forEach((e => {
                    void 0 === t[e.id] && Oc(n[e.id], t, n)
                }
                ))
            }
            function Ac(e, t) {
                const n = [];
                return Object.keys(e).forEach((i => {
                    void 0 !== e[i] && e[i].users.forEach((e => {
                        void 0 === n.find((t => t.id === e.id)) && (void 0 !== t && i === t.id || n.push(e))
                    }
                    ))
                }
                )),
                n
            }
            function Rc(e, t) {
                if (e === t)
                    return !0;
                if (e instanceof Date && t instanceof Date)
                    return e.getTime() === t.getTime();
                if (!e || !t || "object" != typeof e && "object" != typeof t)
                    return e === t;
                const n = Object.keys(e);
                return n.length === Object.keys(t).length && n.every((n => Rc(e[n], t[n])))
            }
            function Pc(e, t) {
                return !!Rc(e, t) || e.every((e => t.some((t => kt(t, e)))))
            }
            function kc(e) {
                const t = {};
                return e.forEach((e => t[e.id] = e)),
                t
            }
            function Mc(e, t, n) {
                return e.slice(n * t, (n + 1) * t)
            }
            function Lc(e, t, n) {
                const i = kc(n)
                  , a = {}
                  , r = [];
                return t.forEach((e => a[e.id] = e.emailAddress)),
                e.forEach((e => {
                    const t = {};
                    Oc(e, t, i);
                    0 === Ac(t).filter((e => !ne(a[e.id]))).length && r.push(e.name)
                }
                )),
                r
            }
            function Nc(e) {
                return {
                    type: e,
                    new: !0,
                    include: {
                        orchids: [],
                        cameras: []
                    },
                    exclude: {
                        orchids: [],
                        cameras: []
                    },
                    configuration: "io_error" === e || "server_error" === e ? {
                        all: !0,
                        throttle: 300
                    } : {
                        all: !0,
                        threshold: 300,
                        refractory: 300
                    }
                }
            }
            function Fc(e, t, n, i, a, r) {
                var s = this;
                s.notification = n,
                s.hasDigest = void 0,
                s.users = i,
                s.groups = a,
                s.smtpServers = r,
                s.actionsExpanded = {},
                s.usersWithoutEmails = [],
                s.groupsWithoutEmails = [],
                s.setup = function() {
                    var e = angular.copy(s.notification);
                    s.shadowNotification = e,
                    s.shadowNotification.new && (s.newTrigger("camera_state"),
                    s.newTrigger("device_state"),
                    s.newTrigger("server_error"),
                    s.newAction())
                }
                ,
                s.newTrigger = function(e) {
                    s.shadowNotification.conditions.push(Nc(e))
                }
                ,
                s.removeTrigger = function(e) {
                    s.shadowNotification.conditions.splice(e, 1)
                }
                ,
                s.newAction = function() {
                    var e = "";
                    s.smtpServers.length >= 1 && (e = s.smtpServers[0].id),
                    s.shadowNotification.actions.push({
                        new: !0,
                        type: "email",
                        configuration: {
                            subject: "",
                            from: "",
                            recipients: []
                        },
                        smtpServerId: e,
                        users: [],
                        groups: []
                    })
                }
                ,
                s.removeAction = function(e) {
                    s.shadowNotification.actions.splice(e, 1),
                    s.checkDigest()
                }
                ,
                s.checkDigest = function() {
                    for (var e = 0; e < s.shadowNotification.actions.length; ++e)
                        if ("email_digest" === s.shadowNotification.actions[e].type)
                            return void (s.hasDigest = !0);
                    s.hasDigest = !1
                }
                ,
                s.saveNotification = function() {
                    var n;
                    !0 === s.shadowNotification.new ? (n = t.newNotification,
                    s.shadowNotification.id = void 0) : n = t.updateNotification,
                    angular.forEach(s.shadowNotification.conditions, (function(e) {
                        e.configuration.all ? (e.include.orchids = [],
                        e.include.cameras = []) : (e.exclude.orchids = [],
                        e.exclude.cameras = [])
                    }
                    ));
                    for (var i = 0; i < s.shadowNotification.actions.length; i++)
                        "email" === s.shadowNotification.actions[i].type ? s.shadowNotification.actions[i].configuration.subject = s.shadowNotification.name : "email_digest" === s.shadowNotification.actions[i].type && (s.shadowNotification.actions[i].configuration.subject = s.shadowNotification.name + " Digest");
                    s.processing = !0,
                    n(s.shadowNotification).then((function(t) {
                        e.hide(t.data)
                    }
                    )).catch((function(e) {
                        e.data ? s.error = e.data.reason : s.error = s.msgs.anUnexpectedErrorHasOccurred(),
                        s.processing = !1
                    }
                    ))
                }
                ,
                s.cancel = function() {
                    e.cancel()
                }
                ,
                s.$onInit = function() {
                    s.msgs = {
                        ...L.messages.notifications,
                        ...L.messages.dialogs
                    },
                    s.shadowNotification = {},
                    s.setup(),
                    s.title = !0 === s.shadowNotification.new ? s.msgs.newSystemAlert() : s.msgs.editNamedThing({
                        VALUE: s.notification.name
                    }),
                    s.checkDigest()
                }
            }
            function Uc(e, t, n) {
                var i = this
                  , a = new RegExp(so);
                const r = n("date");
                i.customSeparatorKeys = [13, 188, 186, 32],
                i.formatDate = function(e) {
                    return r(e, "H:mm")
                }
                ,
                i.remove = function() {
                    i.removeAction(i.index)
                }
                ,
                i.onUsersChanged = function() {
                    i.usersWithoutEmails = i.action.users.filter((function(e) {
                        return Object.keys(e).includes("emailAddress") ? ne(e.emailAddress) : Object.keys(e).includes("emailaddress") ? ne(e.emailaddress) : !Object.keys(e).includes("emailAddress") && !Object.keys(e).includes("emailaddress")
                    }
                    )).map((function(e) {
                        return e.username
                    }
                    ))
                }
                ,
                i.onGroupsChanged = function() {
                    e((function() {
                        var e, t;
                        e = {},
                        t = {},
                        t = kc(i.groups),
                        angular.forEach(i.action.groups, (function(n) {
                            Oc(n, e, t)
                        }
                        )),
                        i.groupies = Ac(e).map((function(e) {
                            return e.username
                        }
                        )).sort().join(", "),
                        i.groupsWithoutEmails = Lc(i.action.groups, i.users, i.groups)
                    }
                    ))
                }
                ,
                i.validEmail = function(e) {
                    return a.exec(e)
                }
                ,
                i.validateEmailChip = function(e) {
                    return i.validEmail(e) ? e : null
                }
                ,
                i.digestAt = function(e) {
                    e && (i.action.configuration.digestAt = R()(e).format(R().HTML5_FMT.TIME));
                    var t = i.action.configuration.digestAt.split(":");
                    return R().tz({
                        hours: t[0],
                        minutes: t[1]
                    }, i.action.configuration.timeZone).toDate().getTime()
                }
                ,
                i.$onInit = function() {
                    i.msgs = L.messages.notifications,
                    i.action.new && (i.expanded = !0,
                    i.action.configuration.oneEmailPerCondition = !1),
                    !i.action.new && i.action.configuration.digestAt && i.action.configuration.timeZone || (i.action.configuration.digestAt = R()({
                        hours: "16"
                    }).format(R().HTML5_FMT.TIME)),
                    i.action.configuration.timeZone = R().tz.guess(),
                    i.localTimezone = R().tz(new Date, R().tz.guess()).format("z"),
                    i.action.smtpServerId || (i.action.smtpServerId = ""),
                    i.action.configuration.from || (i.action.configuration.from = "noreply@example.com"),
                    t.$watch((function() {
                        return i.action.type
                    }
                    ), (function(e, t) {
                        e && t && e !== t && i.updateDigest()
                    }
                    )),
                    i.onUsersChanged(),
                    i.onGroupsChanged(),
                    i.static || e((function() {
                        i.addEmailChipsOnBlur()
                    }
                    ))
                }
            }
            function $c(e, t, n) {
                var i = this;
                i.uniqueSelector = "autocomplete---" + t.v4(),
                i.searchText = "",
                i.querySearch = function(t) {
                    var a = e.orchids.filter(i.createFilterFor(t)).map((function(e) {
                        return e.id
                    }
                    ));
                    return n.notify(),
                    a
                }
                ,
                i.createFilterFor = function(e) {
                    var t = angular.lowercase(e);
                    return function(n) {
                        if (angular.isUndefined(n._lowerName) && (n._lowerName = angular.lowercase(n.name)),
                        angular.isUndefined(e) || 0 === e.length || n._lowerName.indexOf(t) > -1)
                            return !i.orchids.some((function(e) {
                                return e === n.id
                            }
                            ))
                    }
                }
                ,
                i.transformChip = function(e) {
                    return e[i.id]
                }
            }
            function jc(e, t, n, i) {
                var a = this;
                a.scopeId = t.$id,
                a.transformChip = function(e) {
                    return angular.isObject(e) ? e : {
                        name: e,
                        type: "new"
                    }
                }
                ,
                a.imageUrl = function(e) {
                    return n.cameraPreviewUrl(e.orchidId, e.id, "chip")
                }
                ,
                a.buildOrchidDisplay = function() {
                    var e, t = {};
                    i.orchidsPromise().then((function() {
                        if (angular.isDefined(a.ruleDevices.cameras))
                            for (let n = 0; n < a.ruleDevices.cameras.length; ++n)
                                e = i.findCamera(a.ruleDevices.cameras[n].orchidId, a.ruleDevices.cameras[n].id),
                                angular.isUndefined(t[i.findOrchid(e.orchidId).name]) ? t[i.findOrchid(e.orchidId).name] = e.name : t[i.findOrchid(e.orchidId).name] += ", " + e.name;
                        for (var n = 0; n < a.ruleDevices.orchids.length; ++n)
                            t[i.findOrchid(a.ruleDevices.orchids[n]).name] = a.msgs.allCameras();
                        a.cameraList = t
                    }
                    ))
                }
                ,
                a.$onInit = function() {
                    a.msgs = L.messages.notifications,
                    a.devices = [],
                    a.orchids = e.orchids,
                    a.verb = `${"add" === a.type ? a.msgs.only() : a.msgs.excluding()} `,
                    a.devices = a.ruleDevices.orchids.concat(a.ruleDevices.cameras),
                    a.buildOrchidDisplay()
                }
            }
            function Vc(e, t, n) {
                var i = this
                  , a = [];
                function r(e, t) {
                    if (e && t && e !== t) {
                        var n = Nc(e);
                        angular.forEach(["include", "exclude", "configuration"], (function(e) {
                            i.rule[e] = n[e]
                        }
                        )),
                        o()
                    }
                }
                function s(e) {
                    var n, a = {};
                    for (let r = 0; r < i.rule[e].cameras.length; ++r)
                        n = t.findCamera(i.rule[e].cameras[r].orchidId, i.rule[e].cameras[r].id),
                        n && (angular.isUndefined(a[t.findOrchid(n.orchidId).name]) ? a[t.findOrchid(n.orchidId).name] = n.name : a[t.findOrchid(n.orchidId).name] += ", " + n.name);
                    for (var r = 0; r < i.rule[e].orchids.length; ++r)
                        a[t.findOrchid(i.rule[e].orchids[r]).name] = i.msgs.allCameras();
                    return a
                }
                function o() {
                    var e = {}
                      , n = {};
                    "camera_state" === i.rule.type ? (e = s("include"),
                    n = s("exclude")) : (e.list = i.rule.include.orchids.map((function(e) {
                        return t.findOrchid(e).name
                    }
                    )).join(", "),
                    n.list = i.rule.exclude.orchids.map((function(e) {
                        return t.findOrchid(e).name
                    }
                    )).join(", ")),
                    i.includeList = e,
                    i.excludeList = n
                }
                i.includeList = {},
                i.excludeList = {},
                i.remove = function() {
                    i.removeTrigger(i.index)
                }
                ,
                i.selectInputText = function(e) {
                    var t = e.target;
                    n.isMobileSafari() ? t.setSelectionRange(0, 99999) : t.select()
                }
                ,
                i.thresholdMinutes = function(e) {
                    return arguments.length && (i.rule.configuration.threshold = null === e ? null : 60 * e),
                    null === i.rule.configuration.threshold ? null : i.rule.configuration.threshold / 60
                }
                ,
                i.refractoryMinutes = function(e) {
                    return arguments.length && (i.rule.configuration.refractory = null === e ? null : 60 * e),
                    null === i.rule.configuration.refractory ? null : i.rule.configuration.refractory / 60
                }
                ,
                i.throttleMinutes = function(e) {
                    return arguments.length && (i.rule.configuration.throttle = null === e ? null : 60 * e),
                    null === i.rule.configuration.throttle ? null : i.rule.configuration.throttle / 60
                }
                ,
                i.$onInit = function() {
                    i.msgs = L.messages.notifications,
                    i.deviceLabels = {
                        camera_state: i.msgs.camera(),
                        device_state: i.msgs.server(),
                        server_error: i.msgs.server(),
                        io_error: i.msgs.server()
                    },
                    i.rule.new && (i.expanded = !0),
                    a.push(e.$watch((function() {
                        return i.rule.type
                    }
                    ), r)),
                    "camera_state" === i.rule.type && (a.push(e.$watch((function() {
                        return i.rule.include.cameras.length
                    }
                    ), o)),
                    a.push(e.$watch((function() {
                        return i.rule.exclude.cameras.length
                    }
                    ), o))),
                    a.push(e.$watch((function() {
                        return i.rule.include.orchids.length
                    }
                    ), o)),
                    a.push(e.$watch((function() {
                        return i.rule.exclude.orchids.length
                    }
                    ), o)),
                    o(),
                    e.$on("rebuild-triggers", (function() {
                        o()
                    }
                    ))
                }
            }
            function Gc(e, t, i, a, r, s, o, c, l, d, u, m) {
                var h = this;
                function p(e, t) {
                    var i = {
                        template: n(11210),
                        controller: "SmtpDialogController as smtpDialog",
                        parent: angular.element(o.body),
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        escapeToClose: !1,
                        locals: {
                            smtpServer: t
                        }
                    };
                    return a.show(i)
                }
                function g(e) {
                    for (var t = h.smtpServers.length - 1; t > -1; --t)
                        if (h.smtpServers[t].id === e.id) {
                            h.smtpServers.splice(t, 1);
                            break
                        }
                    angular.forEach(h.notifications, (function(t) {
                        angular.forEach(t.actions, (function(t) {
                            t.smtpServerId === e.id && (t.smtpServerId = "")
                        }
                        ))
                    }
                    ))
                }
                function f(e, t) {
                    var i = {
                        template: n(19907),
                        controller: "NotificationsDialogController as notificationsDialog",
                        parent: angular.element(o.body),
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        escapeToClose: !1,
                        onComplete: u.handleDialog,
                        locals: {
                            notification: t,
                            users: h.users,
                            groups: h.groups,
                            smtpServers: h.smtpServers
                        }
                    };
                    return a.show(i)
                }
                function v(e) {
                    h.notificationError[e.id] = [],
                    function(e, t) {
                        var n = !0
                          , i = !0
                          , a = !0
                          , r = !0;
                        angular.forEach(e.actions, (function(e) {
                            var t = e.smtpServerId && e.smtpServerId.length > 0;
                            n && t && (n = !1),
                            (i || a) && (null !== e.users && e.users.length > 0 && e.users.filter((function(e) {
                                return ne(e.emailaddress)
                            }
                            )).map((function(e) {
                                return e.username
                            }
                            )).length !== e.users.length && (i = !1,
                            t && (a = !1)),
                            null !== e.groups && e.groups.length > 0 && Lc(e.groups, h.users, h.groups).length !== e.groups.length && (i = !1,
                            t && (a = !1)),
                            e.configuration.recipients.length > 0 && (i = !1,
                            t && (a = !1)))
                        }
                        )),
                        e.conditions && 0 !== e.conditions.length || t.push(h.msgs.noTriggersHaveBeenCreated()),
                        e.actions && 0 !== e.actions.length || t.push(h.msgs.noActionsHaveBeenCreated()),
                        n && t.push(h.msgs.noActionSpecifiesAnSmtpServer()),
                        i && t.push(h.msgs.noActionSpecifiesARecipientWithAnEmailAddress()),
                        a && t.push(h.msgs.noActionSpecifiesBothAnSmtpServerAndARecipientWithAnEmailAddress());
                        for (var s = 0; s < e.conditions.length; ++s)
                            if (e.conditions[s].configuration.all || e.conditions[s].include.orchids && e.conditions[s].include.orchids.length > 0 || e.conditions[s].include.cameras && e.conditions[s].include.cameras.length > 0) {
                                r = !1;
                                break
                            }
                        r && t.push(h.msgs.triggersSpecifyNoValidTargets())
                    }(e, h.notificationError[e.id])
                }
                h.listeners = [],
                h.expanded = {},
                h.processing = {},
                h.groupies = {},
                h.notificationError = {},
                h.smtpServers = [],
                h.loadingGroups = !0,
                h.loadingNotifications = !0,
                h.notificationsSubscription,
                h.addSmtpServer = function(e) {
                    p(e)
                }
                ,
                h.editSmtpServer = function(e, t) {
                    e.stopPropagation(),
                    p(e, t)
                }
                ,
                h.deleteSmtpServer = function(e, t) {
                    e.stopPropagation(),
                    a.show(a.confirm().theme(m.getTheme()).content(h.msgs.areYouSureYouWantToDeleteThisSmtpServer()).ok(h.msgs.delete()).cancel(h.msgs.cancel())).then((function() {
                        c.deleteSmtpServer(t).then((function() {
                            g(t)
                        }
                        )).catch((function(e) {
                            s.error(e)
                        }
                        ))
                    }
                    ), (function() {}
                    ))
                }
                ,
                h.addNotification = function(e) {
                    f(e, {
                        new: !0,
                        dirty: !0,
                        name: "",
                        description: "",
                        isEnabled: !0,
                        actions: [],
                        conditions: []
                    })
                }
                ,
                h.editNotification = function(e, t) {
                    f(e, t)
                }
                ,
                h.deleteNotification = function(e, t) {
                    a.show(a.confirm().theme(m.getTheme()).content(h.msgs.areYouSureYouWantToDelete({
                        VALUE: t.name
                    })).ok(h.msgs.delete()).cancel(h.msgs.cancel())).then((function() {
                        c.deleteNotification(t).then((function() {}
                        )).catch((function(e) {
                            s.error(e)
                        }
                        ))
                    }
                    ), (function() {}
                    ))
                }
                ,
                h.$onInit = function() {
                    h.loading = !0,
                    h.msgs = L.messages.notifications,
                    h.smtpServersPromise = c.fetchSmtpServers().then((function(e) {
                        h.smtpServers = e.data
                    }
                    )),
                    h.notifications = [],
                    h.groupsPromise = c.fetchGroups().then((function(e) {
                        h.groups = e.data,
                        h.loadingGroups = !1
                    }
                    )),
                    h.usersPromise = c.fetchUsers().then((function(e) {
                        h.users = e
                    }
                    )),
                    h.orchidsPromise = d.orchidsPromise(),
                    h.thingsAreLoading = i.all([h.orchidsPromise, h.smtpServersPromise, h.groupsPromise, h.usersPromise]).then((function() {
                        h.notificationsSubscription = l.getNotifications().subscribe((function(e) {
                            h.notifications = e.filter((function(e) {
                                return !(1 === e.conditions.length && e.conditions[0].type === W.MOTION_ALERT_CONDITION)
                            }
                            )),
                            angular.forEach(h.notifications, (function(e) {
                                v(e)
                            }
                            )),
                            h.loadingNotifications = !1
                        }
                        ), (function(e) {
                            s.error("error", e),
                            h.error = h.msgs.failedToLoadSystemAlerts(),
                            h.loadingNotifications = !1
                        }
                        )),
                        h.loading = !1
                    }
                    )).catch((function(e) {
                        s.error(e),
                        h.loading = !1,
                        h.loadingNotifications = !1,
                        h.error = h.msgs.failedToLoadSystemAlerts()
                    }
                    )),
                    h.listeners.push(e.$on("orchidChanged", (function(e, n) {
                        r((function() {
                            t.$broadcast("rebuild-triggers")
                        }
                        ))
                    }
                    ))),
                    h.listeners.push(e.$on("cameraChanged", (function(e, n) {
                        r((function() {
                            t.$broadcast("rebuild-triggers")
                        }
                        ))
                    }
                    ))),
                    h.listeners.push(e.$on("smtpServerAdded", (function(e, t) {
                        !function(e) {
                            r((function() {
                                h.smtpServers.push(e)
                            }
                            ))
                        }(t)
                    }
                    ))),
                    h.listeners.push(e.$on("smtpServerModified", (function(e, t) {
                        !function(e) {
                            for (let t = h.smtpServers.length - 1; t > -1; --t)
                                if (h.smtpServers[t].id === e.id) {
                                    r((function() {
                                        h.smtpServers[t] = e
                                    }
                                    ));
                                    break
                                }
                        }(t)
                    }
                    ))),
                    h.listeners.push(e.$on("smtpServerRemoved", (function(e, t) {
                        g(t)
                    }
                    ))),
                    t.$on("$destroy", (function() {
                        angular.forEach(h.listeners, (function(e) {
                            e()
                        }
                        ))
                    }
                    ))
                }
                ,
                h.$onDestroy = function() {
                    h.notificationsSubscription && h.notificationsSubscription.unsubscribe()
                }
            }
            function Bc(e, t, i, a, r) {
                var s = this;
                s.loading = !0,
                s.$onInit = function() {
                    s.msgs = L.messages.custom
                }
                ,
                a.getPluginsPromise().then((function() {
                    var n = a.findPlugin(s.plugin, s.extension);
                    n ? (s.supportInfo = n,
                    "frame" === n.extension.type ? r.testPlugin(n).then((function(t) {
                        s.pluginSrc = e.trustAsResourceUrl(t.config.url)
                    }
                    )).catch((function(e) {
                        s.error = s.msgs.theExtensionIsNotAvailable({
                            VALUE: n.extension.name
                        }),
                        s.loading = !1,
                        t.error("failed to load " + n.name + "/" + n.extension.name, e.status)
                    }
                    )) : (s.error = s.msgs.theTypeOfAppIsNotSupported({
                        NAME: n.name,
                        ENAME: n.extension.name,
                        TYPE: n.extension.type
                    }),
                    s.loading = !1)) : (s.error = s.msgs.thePluginCouldNotBeFound({
                        PLUGIN: s.plugin,
                        EXTENSION: s.extension
                    }),
                    s.loading = !1,
                    t.error("failed to find " + s.plugin + "/" + s.extension))
                }
                )),
                s.showSupportLinks = function(e) {
                    var t = {
                        template: n(76492),
                        controller: "CustomSupportDialogController as customSupportDialog",
                        parent: angular.element(document.body),
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        escapeToClose: !1,
                        locals: {
                            supportInfo: s.supportInfo
                        }
                    };
                    i.show(t)
                }
            }
            xc = Tc = (0,
            c.gn)([(0,
            i.Component)({
                selector: "TestEmail",
                template: n(59831)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(1, (0,
            i.Inject)(xe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Ec = void 0 !== hn.so && hn.so) ? Ec : Object, "function" == typeof (_c = void 0 !== xe && xe) ? _c : Object])], xc),
            Dc.$inject = ["$document", "$mdDialog", "FusionDataService", "smtpServer", "MatDialog"],
            angular.module("ipconfigure.orchid.singularity").controller("SmtpDialogController", Dc),
            Fc.$inject = ["$mdDialog", "FusionDataService", "notification", "users", "groups", "smtpServers"],
            angular.module("ipconfigure.orchid.singularity").controller("NotificationsDialogController", Fc),
            Uc.$inject = ["$timeout", "$scope", "$filter"],
            angular.module("ipconfigure.orchid.singularity").controller("NotificationActionController", Uc).directive("notificationAction", [function() {
                return {
                    restrict: "E",
                    template: n(20106),
                    controller: "NotificationActionController as notificationAction",
                    scope: {},
                    bindToController: {
                        removeAction: "=",
                        action: "=",
                        updateDigest: "=",
                        digestExists: "=",
                        users: "=",
                        groups: "=",
                        smtpServers: "=",
                        index: "=",
                        static: "@?"
                    },
                    link: function(e, t, n, i) {
                        var a = t[0];
                        i.addEmailChipsOnBlur = function() {
                            var e = a.getElementsByClassName("notification-action-emails")[0]
                              , t = angular.element(e).controller("mdChips");
                            e.getElementsByTagName("INPUT")[0].addEventListener("blur", (function() {
                                i.validEmail(t.chipBuffer) && (t.appendChip(t.chipBuffer),
                                t.chipBuffer = "")
                            }
                            ))
                        }
                    }
                }
            }
            ]),
            $c.$inject = ["$rootScope", "uuid", "AutocompleteRepairService"],
            angular.module("ipconfigure.orchid.singularity").controller("AutocompleteOrchidChipsController", $c).directive("autocompleteOrchidChips", (function() {
                return {
                    restrict: "E",
                    bindToController: {
                        orchids: "=",
                        placeholder: "@",
                        nameField: "@"
                    },
                    scope: {},
                    controller: "AutocompleteOrchidChipsController as AutocompleteOrchidChips",
                    template: function(e, t) {
                        return '<md-chips ng-model="AutocompleteOrchidChips.orchids" md-autocomplete-snap md-transform-chip="AutocompleteOrchidChips.transformChip($chip)" md-require-match="true">                    <md-autocomplete                        md-input-id="{{AutocompleteOrchidChips.uniqueSelector}}"                        md-menu-class="{{AutocompleteOrchidChips.uniqueSelector}}"                        md-selected-item="AutocompleteOrchidChips.selectedItem"                        md-search-text="AutocompleteOrchidChips.searchText"                        md-items="item in AutocompleteOrchidChips.querySearch(AutocompleteOrchidChips.searchText)"                        md-item-text="$root.orchids[$root.orcDict[item].index].name"                        md-min-length="0"                        md-no-cache="true"                        md-dropdown-position="bottom"                        md-menu-class="autocomplete-matches"                        placeholder="' + L.messages.chips.searchPlaceholder() + '">                        <span md-highlight-flags="i" md-highlight-text="AutocompleteOrchidChips.searchText">{{$root.orchids[$root.orcDict[item].index].name}}</span>                    </md-autocomplete>                    <md-chip-template>                        <span>                            <strong>{{$root.orchids[$root.orcDict[$chip].index].name}}</strong>                        </span>                    </md-chip-template>                </md-chips>'
                    }
                }
            }
            )),
            jc.$inject = ["$rootScope", "$scope", "DataService", "RenewableService"],
            angular.module("ipconfigure.orchid.singularity").controller("DeviceFormController", jc).directive("deviceForm", [function() {
                return {
                    restrict: "E",
                    template: n(23169),
                    controller: "DeviceFormController as deviceForm",
                    scope: {},
                    bindToController: {
                        ruleDevices: "=",
                        device: "=",
                        type: "@"
                    }
                }
            }
            ]),
            Vc.$inject = ["$scope", "RenewableService", "BrowserInfoService"],
            angular.module("ipconfigure.orchid.singularity").controller("NotificationTriggerController", Vc).directive("notificationTrigger", [function() {
                return {
                    restrict: "E",
                    template: n(27623),
                    controller: "NotificationTriggerController as notificationTrigger",
                    scope: {},
                    bindToController: {
                        removeTrigger: "=",
                        rule: "=",
                        index: "=",
                        static: "@?"
                    }
                }
            }
            ]),
            Gc.$inject = ["$rootScope", "$scope", "$q", "$mdDialog", "$timeout", "$log", "$document", "FusionDataService", "NotificationsService", "RenewableService", "AutocompleteRepairService", "UserSettingsService"],
            angular.module("ipconfigure.orchid.singularity").controller("NotificationSettingsController", Gc).directive("notificationSettings", (function() {
                return {
                    restrict: "E",
                    bindToController: {
                        orchids: "="
                    },
                    scope: {},
                    controller: "NotificationSettingsController",
                    controllerAs: "notificationSettings",
                    template: n(14536)
                }
            }
            )),
            angular.module("ipconfigure.orchid.singularity").controller("CustomSupportDialogController", ["$mdDialog", "supportInfo", function(e, t) {
                var n = this;
                n.supportInfo = t,
                n.$onInit = function() {
                    n.msgs = L.messages.custom
                }
                ,
                n.close = function() {
                    e.hide()
                }
            }
            ]),
            Bc.$inject = ["$sce", "$log", "$mdDialog", "PluginService", "FusionDataService"],
            angular.module("ipconfigure.orchid.singularity").controller("CustomController", Bc).directive("custom", (function() {
                return {
                    restrict: "E",
                    bindToController: {
                        plugin: "@",
                        extension: "@"
                    },
                    scope: {},
                    template: n(23166),
                    controller: "CustomController as custom",
                    link: function(e, t, n, i) {
                        angular.element(t[0].querySelector("iframe")).on("load", (function(t) {
                            i.loading = !1,
                            e.$digest()
                        }
                        ))
                    }
                }
            }
            ));
            var zc = n(1843)
              , Hc = n.n(zc)
              , Wc = n(40632)
              , qc = n.n(Wc)
              , Yc = n(16150)
              , Xc = n.n(Yc);
            const Kc = {
                hybrid: {
                    50: "#f2d9df",
                    100: "#e6c1cb",
                    200: "#e2a2b3",
                    300: "#d46c88",
                    400: "#eb245a",
                    500: "#e11a50",
                    600: "#d71046",
                    700: "#ad103a",
                    800: "#9b0c32",
                    900: "#770926",
                    A100: "#ff4278",
                    A200: "#ff386e",
                    A400: "#eb245a",
                    A700: "#cd063c",
                    contrastDefaultColor: "light",
                    contrastDarkColors: "A700",
                    contrastStrongLightColors: "A400"
                }
            };
            angular.module("ipconfigure.orchid.singularity").config(["$mdThemingProvider", function(e) {
                var t = [Hc(), qc(), Xc(), Kc]
                  , n = e.extendPalette("deep-orange", {
                    100: "#ffd3ba",
                    500: "#df5a30",
                    600: "#bf4822",
                    contrastingDefaultColor: "#fff"
                })
                  , i = e.extendPalette("deep-orange", {
                    100: "#9f5228",
                    500: "#df5a30",
                    600: "#bf4822",
                    contrastingDefaultColor: "#fff"
                });
                e.definePalette("warn-palette", n),
                e.definePalette("warn-dark-palette", i),
                e.definePalette("dark-surface-palette", {
                    50: "#fafafa",
                    100: "#f5f5f5",
                    200: "#eeeeee",
                    300: "#e0e0e0",
                    400: "#bdbdbd",
                    500: "#9e9e9e",
                    600: "#757575",
                    700: "#616161",
                    800: "#424242",
                    900: "#212121",
                    A100: "#ffffff",
                    A200: "#eeeeee",
                    A400: "#bdbdbd",
                    A700: "#303030"
                }),
                t.map((function(t) {
                    for (const n in t) {
                        if ("defaultDarkMode" === n)
                            return;
                        e.definePalette(n, t[n]),
                        e.theme(n).primaryPalette(n, {
                            default: "500"
                        }).accentPalette(n, {
                            default: "A400",
                            "hue-1": "A700"
                        }).backgroundPalette("grey", {
                            default: "100"
                        }).warnPalette("warn-palette"),
                        Object.keys(t).includes("defaultDarkMode") && e.theme(n).dark(),
                        e.theme(n + "-dark").primaryPalette(n, {
                            default: "500"
                        }).accentPalette(n, {
                            default: "A400",
                            "hue-1": "A700"
                        }).backgroundPalette("dark-surface-palette", {
                            default: "A700"
                        }).warnPalette("warn-dark-palette").dark()
                    }
                }
                ))
            }
            ]);
            var Zc = n(84373)
              , Jc = n.n(Zc);
            function Qc(e, t, n) {
                let i = (n.max - n.min) / (t.max - t.min);
                return i * e + (n.min - i * t.min)
            }
            function el(e, t) {
                let n, i = this, a = e[0];
                function r() {
                    n[0].getContext("2d").clearRect(0, 0, n[0].width, n[0].height)
                }
                function s(e, t, i, a) {
                    var r = n[0].getContext("2d");
                    r.save(),
                    r.beginPath(),
                    r.arc(e, t, i, 0, 2 * Math.PI, !0),
                    r.fillStyle = a,
                    r.fill(),
                    r.strokeStyle = "black",
                    r.stroke(),
                    r.closePath(),
                    r.restore()
                }
                function o(e, t, i, a, r, s) {
                    if (0 !== i) {
                        var o = n[0].getContext("2d");
                        o.save(),
                        o.fillStyle = r,
                        o.strokeStyle = s,
                        o.beginPath(),
                        o.translate(e, t),
                        o.rotate(-a),
                        o.moveTo(20 + i, -5),
                        o.lineTo(20 + i, -10),
                        o.lineTo(20 + i + 15, 0),
                        o.lineTo(20 + i, 9),
                        o.lineTo(20 + i, 4),
                        o.lineTo(20, 4),
                        o.lineTo(20, -5),
                        o.lineTo(20 + i, -5),
                        o.stroke(),
                        o.fill(),
                        o.closePath(),
                        o.restore()
                    }
                }
                function c() {
                    let e = n[0].getBoundingClientRect()
                      , t = e.width / 2
                      , a = e.height / 2;
                    r();
                    for (var c = 0; c < 4; c++)
                        o(t, a, 15, c * (Math.PI / 2), i.fillStyle, i.strokeStyle);
                    s(t, a, 10, i.fillStyle, i.strokeStyle)
                }
                function l() {
                    n[0].width = a.offsetWidth,
                    n[0].height = a.offsetHeight,
                    c()
                }
                i.$onInit = function() {
                    n = angular.element(e[0].querySelector("canvas")),
                    t.$watch((function() {
                        return a.offsetHeight + a.offsetWidth
                    }
                    ), (function() {
                        l()
                    }
                    )),
                    l()
                }
                ,
                i.$onChanges = function(e) {
                    e.arrowCoordinates && (e.arrowCoordinates.isFirstChange() || (i.arrowCoordinates = e.arrowCoordinates.currentValue,
                    angular.isUndefined(e.arrowCoordinates.currentValue) ? c() : function(e) {
                        let t, a, c = n[0].getBoundingClientRect(), l = c.width / 2, d = c.height / 2;
                        if ("mouse" === e.source) {
                            let n = e.x - c.left
                              , i = e.y - c.top;
                            t = Math.sqrt(Math.pow(n - l, 2) + Math.pow(i - d, 2)) - 50,
                            a = Math.atan2(n - l, i - d) - Math.PI / 2
                        } else {
                            if ("gamepad" !== e.source)
                                return;
                            var u = Math.sqrt(Math.pow(e.x, 2) + Math.pow(e.y, 2));
                            t = (u > 1 ? 1 : u) * c.height / 2 - 50,
                            a = Math.atan2(e.x, -1 * e.y) + 3 * Math.PI / 2
                        }
                        r(),
                        o(l, d, t * (t > 0), a, i.fillStyle, i.strokeStyle),
                        s(l, d, 10, i.fillStyle, i.strokeStyle)
                    }(e.arrowCoordinates.currentValue)))
                }
            }
            function tl(e, t, n) {
                let i = this
                  , a = t.parent()
                  , r = t[0].querySelector(".ripple");
                i.$onInit = function() {
                    e.$watch("$ctrl.position", (function(e) {
                        e && function(e) {
                            let t = a[0].getBoundingClientRect()
                              , s = 25
                              , o = e.x - t.left - s
                              , c = e.y - t.top - s;
                            angular.element(r).css({
                                top: c + "px",
                                left: o + "px"
                            }).addClass("ripple-effect"),
                            n((function() {
                                angular.element(r).removeClass("ripple-effect"),
                                i.position = void 0
                            }
                            ), 400)
                        }(e)
                    }
                    ), !0)
                }
            }
            function nl(e, t, n, i, a) {
                let r, s, o, c, l, d, u = this, m = !1;
                const h = O("PtzController");
                function p() {
                    !0 === u.initialized && (u.panable || u.tiltable ? function() {
                        !0 !== u.hasPanTiltListeners && (s.on("mousedown touchstart", T),
                        a.on("gamepadaxismove", C));
                        u.hasPanTiltListeners = !0
                    }() : g(),
                    u.zoomable ? function() {
                        !0 !== u.hasZoomListeners && (o.on("mousedown touchstart", y),
                        c.on("mousedown touchstart", b),
                        s.on("wheel", w));
                        u.hasZoomListeners = !0
                    }() : f())
                }
                function g() {
                    !0 === u.hasPanTiltListeners && (s.off("mousedown touchstart", T),
                    s.off("mouseup mouseleave touchend", x),
                    s.off("mousemove touchmove", _),
                    s.off("mouseup touchend", E),
                    a.off("gamepadaxismove", C)),
                    u.hasPanTiltListeners = !1
                }
                function f() {
                    !0 === u.hasZoomListeners && (o.off("mouseout mouseup", S),
                    c.off("mouseout mouseup", S),
                    o.off("mousedown touchstart", y),
                    c.off("mousedown touchstart", b),
                    s.off("wheel", w)),
                    u.hasZoomListeners = !1
                }
                function v(e, t) {
                    A(t, 0, 0, e, "continuous")
                }
                function y(e) {
                    o.on("mouseout mouseup touchend", S),
                    e.preventDefault(),
                    e.stopPropagation(),
                    v(1, e.type)
                }
                function b(e) {
                    c.on("mouseout mouseup touchend", S),
                    e.preventDefault(),
                    e.stopPropagation(),
                    v(-1, e.type)
                }
                function S(e) {
                    o.off("mouseout mouseup", S),
                    c.off("mouseout mouseup", S),
                    e.preventDefault(),
                    e.stopPropagation(),
                    v(0, e.type)
                }
                function C(e) {
                    !0 !== s.ptzingViaMouse && !0 !== s.zoomViaMouse && (Math.abs(e.x) <= .1 && Math.abs(e.y) <= .1 && Math.abs(e.z) <= .1 ? x() : (A(e.type, e.x, e.y, e.z, "continuous"),
                    u.arrowCoordinates = {
                        x: e.x,
                        y: e.y,
                        source: "gamepad"
                    }))
                }
                function w(e) {
                    e.preventDefault(),
                    e.stopPropagation(),
                    t.cancel(s.wheelTimeout),
                    s.wheelTimeout = t((function() {
                        t.cancel(s.wheelCounterTimeout),
                        v(0, e.type)
                    }
                    ), 350);
                    var n = -1 * e.deltaY;
                    v(.625 * n / Math.abs(n), e.type)
                }
                function I(e, t, i) {
                    n.cancel(r),
                    r = n((function() {
                        !function(e, t, i) {
                            k("fakeContinuous", {
                                x: e,
                                y: t,
                                z: i,
                                type: "relative"
                            }).catch((function(e) {
                                M(e),
                                d = !1,
                                n.cancel(r)
                            }
                            ))
                        }(e, t, i)
                    }
                    ), 10)
                }
                function T(e) {
                    e.preventDefault(),
                    e.stopPropagation(),
                    u._ptzing ? u._ptzing = !1 : (u._ptzing = !0,
                    m ? (s.promise = t((function() {
                        s.off("mouseup touchend", E),
                        s.on("mouseup mouseleave touchend", x),
                        s.on("mousemove touchmove", _),
                        _(e)
                    }
                    ), 200),
                    s.on("mouseup touchend", E)) : (s.on("mouseup mouseleave touchend", x),
                    s.on("mousemove touchmove", _),
                    _(e)))
                }
                function E(e) {
                    t.cancel(s.promise),
                    e.preventDefault(),
                    s.off("mouseup touchend", E),
                    D(e.changedTouches ? e.changedTouches[0] : e, "relativeFOV"),
                    delete u.arrowCoordinates,
                    u._ptzing = !1
                }
                function _(e) {
                    e.preventDefault(),
                    e.stopPropagation(),
                    s.ptzingViaMouse = !0,
                    D(e.changedTouches ? e.changedTouches[0] : e, "continuous")
                }
                function x() {
                    s.off("mouseup mouseleave touchend", x),
                    s.off("mousemove touchmove", _),
                    delete u.arrowCoordinates,
                    s.ptzingViaMouse = !1,
                    s.zoomViaMouse = !1,
                    u._ptzing = !1,
                    !0 === l ? n.cancel(r) : A("stop", 0, 0, 0, "continuous")
                }
                function D(e, t) {
                    var n = s[0].getBoundingClientRect();
                    let i, a = e.clientX - n.left, r = e.clientY - n.top;
                    u.arrowCoordinates = {
                        x: e.clientX,
                        y: e.clientY,
                        source: "mouse"
                    },
                    "relativeFOV" === t ? (i = function(e, t, n) {
                        let i = function(e, t) {
                            let n;
                            if (t > e.width / e.height) {
                                let i = {
                                    width: e.width,
                                    height: e.width / t
                                };
                                n = {
                                    x: 0,
                                    y: (e.height - i.height) / 2,
                                    width: i.width,
                                    height: i.height
                                }
                            } else {
                                let i = {
                                    width: e.height * t,
                                    height: e.height
                                };
                                n = {
                                    x: (e.width - i.width) / 2,
                                    y: 0,
                                    width: i.width,
                                    height: i.height
                                }
                            }
                            return n
                        }(e, t)
                          , a = {
                            x: Qc(n.x, {
                                min: i.x,
                                max: i.x + i.width
                            }, {
                                min: -1,
                                max: 1
                            }),
                            y: Qc(n.y, {
                                min: i.y,
                                max: i.y + i.height
                            }, {
                                min: 1,
                                max: -1
                            })
                        };
                        return a.x > 1 || a.x < -1 || a.y > 1 || a.y < -1 ? null : a
                    }(n, u.resolution.width / u.resolution.height, {
                        x: a,
                        y: r
                    }),
                    null !== i && (u.position = {
                        x: e.clientX,
                        y: e.clientY
                    })) : i = function(e, t) {
                        let n = {
                            x: Qc(t.x, {
                                min: 0,
                                max: e.width
                            }, {
                                min: -1,
                                max: 1
                            }),
                            y: Qc(t.y, {
                                min: 0,
                                max: e.height
                            }, {
                                min: 1,
                                max: -1
                            })
                        };
                        return n.x > 1 && (n.x = 1),
                        n.x < -1 && (n.x = -1),
                        n.y > 1 && (n.y = 1),
                        n.y < -1 && (n.y = -1),
                        n
                    }(n, {
                        x: a,
                        y: r
                    }),
                    null !== i && A(e.type, i.x, i.y, 0, t)
                }
                function A(e, t, n, i, a) {
                    !0 === l && "continuous" === a ? I(t, n, i) : k(e, {
                        x: t,
                        y: n,
                        z: i,
                        type: a
                    }).catch(M)
                }
                u.hasPanTiltListeners = !1,
                u.hasZoomListeners = !1,
                u.$onInit = function() {
                    s = e,
                    o = angular.element(s[0].querySelector(".ptz-zoom-in")),
                    c = angular.element(s[0].querySelector(".ptz-zoom-out")),
                    u.arrowsFillStyle = u.controlColor,
                    u.initialized = !0,
                    p()
                }
                ,
                u.$onChanges = function(e) {
                    if (e.capabilities && e.capabilities.currentValue) {
                        var t = e.capabilities.currentValue;
                        u.panable = "true" === t.pan,
                        u.tiltable = "true" === t.tilt,
                        u.zoomable = "true" === t.zoom,
                        m = "true" === t.relativeFOV
                    }
                    if (e.quirks && e.quirks.currentValue) {
                        var n = e.quirks.currentValue;
                        if (n["zoom-override"]) {
                            var i = n["zoom-override"];
                            u.zoomable = "true" === i
                        }
                        l = "true" === n["force-relative-ptz"]
                    }
                    e.resolution && e.resolution.currentValue && (u.aspectRatio = e.resolution.currentValue.width / e.resolution.currentValue.height,
                    u.resolution = e.resolution.currentValue),
                    p()
                }
                ,
                u.$onDestroy = function() {
                    g(),
                    f()
                }
                ,
                u.lastCommand = null,
                u.nextCommand = null;
                const R = new Set(["relative", "relativeFOV"]);
                function P(e, t) {
                    if (re(t))
                        return !0;
                    if (re(u.lastCommand) || R.has(t.type))
                        return !1;
                    const n = u.lastCommand.eventType === e && u.lastCommand.command.x === t.x && u.lastCommand.command.y === t.y && u.lastCommand.command.z === t.z && u.lastCommand.command.type === t.type;
                    return n && h.debug(`We have a duplicate command. event type = ${e},  command =`, t, " last command = ", u.lastCommand),
                    n
                }
                async function k(e, t) {
                    if (d)
                        P(e, t) ? h.debug(`ptz processing and we have a duplicate command: event type = ${e}, command = `, t, " last command = ", u.lastCommand) : u.nextCommand = {
                            eventType: e,
                            command: t
                        };
                    else {
                        if (P(e, t))
                            return;
                        d = !0;
                        let n = t;
                        re(u.nextCommand) || (n = u.nextCommand.command,
                        u.nextCommand = {
                            eventType: e,
                            command: t
                        }),
                        u.lastCommand = {
                            eventType: e,
                            command: n
                        };
                        try {
                            await i.ptz(u.orchid, u.camera, n)
                        } catch (e) {
                            M(e)
                        }
                        if (d = !1,
                        !re(u.nextCommand)) {
                            const e = u.nextCommand;
                            return u.nextCommand = null,
                            k(e.eventType, e.command)
                        }
                    }
                }
                function M(e) {
                    if (re(e))
                        return;
                    const t = e instanceof Error;
                    h.error("PTZ command failed" + (t ? " due to unexpected error: " : ": "), t ? e : e.data.reason)
                }
            }
            angular.module("ipconfigure.orchid.singularity").component("panTiltArrows", {
                controller: el,
                controllerAs: "ctrl",
                bindings: {
                    arrowCoordinates: "<",
                    fillStyle: "<"
                },
                template: "<canvas></canvas>"
            }),
            el.$inject = ["$element", "$scope"],
            angular.module("ipconfigure.orchid.singularity").component("ripple", {
                controller: tl,
                template: '<span class="ripple"></span>',
                bindToController: !0,
                bindings: {
                    position: "<"
                }
            }),
            tl.$inject = ["$scope", "$element", "$timeout"],
            angular.module("ipconfigure.orchid.singularity").component("panTiltZoom", {
                controller: nl,
                controllerAs: "ptz",
                bindings: {
                    orchid: "<",
                    camera: "<",
                    capabilities: "<",
                    quirks: "<",
                    resolution: "<",
                    controlColor: "<"
                },
                template: Jc()
            }),
            nl.$inject = ["$element", "$timeout", "$interval", "OrchidDataService", "GamepadService"];
            var il = n(20220)
              , al = n.n(il);
            function rl(e, t, n, i, a) {
                var r = this;
                r.orchid = n,
                r.camera = i,
                r.preset = a,
                r.savePreset = function() {
                    r.processing = !0,
                    t.addPtzPreset(r.orchid, r.camera, a).then((function(t) {
                        e.hide(t)
                    }
                    ), (function(e) {
                        r.error = r.msgs.errorCreatingPreset({
                            VALUE: e.data.reason
                        })
                    }
                    )).finally((function() {
                        r.processing = !1
                    }
                    ))
                }
                ,
                r.cancel = function() {
                    e.cancel()
                }
                ,
                r.$onInit = function() {
                    r.msgs = L.messages.player,
                    r.dialogTitle = r.msgs.newPreset(),
                    r.saveText = r.msgs.savePreset()
                }
            }
            angular.module("ipconfigure.orchid.singularity").controller("PtzPresetsDialogController", rl).directive("ptzPresetsDialog", (function() {
                return {
                    scope: {},
                    restrict: "E",
                    bindToController: {
                        preset: "="
                    },
                    controller: "PtzPresetsDialogController",
                    controllerAs: "ptzPresetsDialog",
                    template: al()
                }
            }
            )),
            rl.$inject = ["$mdDialog", "OrchidDataService", "orchid", "camera", "preset"];
            var sl = n(30816)
              , ol = n.n(sl);
            angular.module("ipconfigure.orchid.singularity").controller("PtzPresetsController", ["MatDialog", "$mdDialog", "$timeout", "$log", "OrchidDataService", "UserSettingsService", function(e, t, i, a, r, s) {
                var o = this;
                o.adding = !1,
                o.editing = !1,
                o.moving = !1,
                o._matDialog = e;
                let c = N(o.camera);
                function l(e, i) {
                    t.show({
                        template: n(20220),
                        controller: rl,
                        controllerAs: "ptzPresetsDialog",
                        parent: angular.element(document.body),
                        targetEvent: e,
                        multiple: !0,
                        locals: {
                            orchid: o.orchid,
                            camera: o.camera,
                            preset: angular.copy(i)
                        }
                    }).then((function(e) {
                        o.camera.features.ptzPresets.push(e.data)
                    }
                    )).catch((function() {}
                    ))
                }
                o.maxPtzPresets = c ? c.maxPresets : 10,
                o.$onInit = function() {
                    o.msgs = L.messages.player
                }
                ,
                o.selectPtzPreset = function(e) {
                    o.moving = !0,
                    r.ptzPreset(o.orchid, o.camera, e).then((function() {}
                    )).catch((function(t) {
                        a.error("Error PTZ-ing to preset " + e.name + ": " + t.data.reason)
                    }
                    )).finally((function() {
                        i((function() {
                            o.moving = !1
                        }
                        ), 1e3)
                    }
                    ))
                }
                ,
                o.newPtzPreset = function(e) {
                    l(e, {
                        isNew: !0,
                        name: ""
                    })
                }
                ,
                o.updatePtzPreset = function(e) {
                    r.updatePtzPreset(e)
                }
                ,
                o.renamePtzPreset = function(e, t) {
                    l(e, t)
                }
                ,
                o.removePtzPreset = function(e) {
                    const t = e.name && e.name.length > 0 ? e.name : `${o.msgs.preset()} ${e.token}`
                      , n = {
                        disableClose: !0,
                        panelClass: "remove-preset-confirm-dialog",
                        data: {
                            confirmText: L.messages.dialogs.delete(),
                            cancelText: L.messages.dialogs.cancel(),
                            message: `${o.msgs.deletePreset()} "${t}"?`,
                            confirmCallbackAsync: async function() {
                                try {
                                    o.editing = !0,
                                    await r.removePtzPreset(o.orchid, o.camera, e);
                                    for (var t = 0; t < o.camera.features.ptzPresets.length; t++)
                                        if (e.token === o.camera.features.ptzPresets[t].token) {
                                            o.camera.features.ptzPresets.splice(t, 1);
                                            break
                                        }
                                } catch (t) {
                                    throw a.error(`Error deleting preset ${e.name}`),
                                    new Error
                                }
                            }
                        }
                    };
                    qs.show(o._matDialog, n).pipe((0,
                    Ir.x)((function() {
                        o.editing = !1
                    }
                    ))).subscribe()
                }
            }
            ]).directive("ptzPresets", [function() {
                return {
                    restrict: "E",
                    template: ol(),
                    bindToController: {
                        orchid: "=",
                        camera: "=",
                        viewOnly: "="
                    },
                    controller: "PtzPresetsController as ptzPresetsContainer"
                }
            }
            ]);
            let cl = function() {
                function e() {
                    (0,
                    S.Z)(this, e)
                }
                return (0,
                b.Z)(e, [{
                    key: "$onInit",
                    value: function() {
                        this.keys = this.value ? Object.keys(this.value) : []
                    }
                }, {
                    key: "$onChanges",
                    value: function(e) {
                        e.value && (this.keys = e.value.currentValue ? Object.keys(e.value.currentValue) : [])
                    }
                }, {
                    key: "isArray",
                    value: function(e) {
                        return angular.isArray(e)
                    }
                }, {
                    key: "isObject",
                    value: function(e) {
                        return angular.isObject(e) && !angular.isArray(e)
                    }
                }], [{
                    key: "template",
                    get: function() {
                        return n(70791)
                    }
                }, {
                    key: "controller",
                    get: function() {
                        return [e]
                    }
                }, {
                    key: "bindings",
                    get: function() {
                        return {
                            value: "<",
                            expandAll: "<"
                        }
                    }
                }]),
                e
            }();
            angular.module("ipconfigure.orchid.singularity").component("statsForNerds", cl);
            var ll = n(78900)
              , dl = n.n(ll)
              , ul = n(19602)
              , ml = n.n(ul);
            function hl(e, t) {
                var n = this;
                n.showLBM = !0,
                w.isOrchid || (n.showLBM = t.isLbmAvailable()),
                n.close = function() {
                    e.cancel()
                }
                ,
                n.dismiss = function() {
                    e.hide("dismiss")
                }
                ,
                n.reloadLowBandwidth = function() {
                    e.hide("reload")
                }
                ,
                n.$onInit = function() {
                    n.msgs = {
                        ...L.messages.player,
                        ok: L.messages.dialogs.ok
                    }
                }
            }
            angular.module("ipconfigure.orchid.singularity").controller("BandWidthExplainDialogController", hl),
            hl.$inject = ["$mdDialog", "PlayerModeService"];
            let pl = function() {
                function e(t, n, i, a) {
                    (0,
                    S.Z)(this, e),
                    this._$scope = t,
                    this._$mdDialog = n,
                    this._$timeout = i,
                    this._PubSub = a,
                    this.showWarning = !1,
                    this.suppressBandwidthWarning = !1
                }
                return (0,
                b.Z)(e, [{
                    key: "$onInit",
                    value: function() {
                        var e = this;
                        this.msgs = L.messages.player,
                        this.suppressBandwidthWarningSubscription = this._PubSub.subscribe("suppress-bandwidth-warning", (function() {
                            e.showWarning = !1,
                            e.suppressBandwidthWarning = !0,
                            e._$timeout.cancel(e._packetLossTimer)
                        }
                        )),
                        this._$scope.$on("show-bandwidth-warning", (function() {
                            e.showWarning = !0,
                            e._$timeout.cancel(e._packetLossTimer),
                            e._packetLossTimer = e._$timeout((function() {
                                e.showWarning = !1,
                                e._$timeout.cancel(e._packetLossTimer)
                            }
                            ), e.hideAfter)
                        }
                        ))
                    }
                }, {
                    key: "$onDestroy",
                    value: function() {
                        this._$timeout.cancel(this._packetLossTimer),
                        this._PubSub.unsubscribe(this.suppressBandwidthWarningSubscription)
                    }
                }, {
                    key: "showBandwidthExplanation",
                    value: function(e) {
                        var t = this;
                        this._$mdDialog.show({
                            template: ml(),
                            controller: hl,
                            controllerAs: "bandwidthExplain",
                            parent: angular.element(document.body),
                            targetEvent: e,
                            clickOutsideToClose: !0,
                            flex: 100
                        }).then((function(e) {
                            switch (e) {
                            case "dismiss":
                                t.showWarning = !1,
                                t._PubSub.publish("suppress-bandwidth-warning");
                                break;
                            case "reload":
                                t.showWarning = !1,
                                t._$scope.$emit("toggle-player-mode")
                            }
                        }
                        )).catch((function() {}
                        ))
                    }
                }]),
                e
            }();
            pl.$inject = ["$scope", "$mdDialog", "$timeout", "PubSub"],
            pl.template = dl(),
            pl.controller = pl,
            pl.bindings = {
                hideAfter: "<"
            },
            angular.module("ipconfigure.orchid.singularity").component("slowNetworkAlert", pl);
            var gl = n(93324)
              , fl = n.n(gl);
            let vl = function() {
                function e() {
                    (0,
                    S.Z)(this, e)
                }
                return (0,
                b.Z)(e, [{
                    key: "formatDuration",
                    value: function(e) {
                        let t = this._normalize(e);
                        return this._duration(t)
                    }
                }, {
                    key: "formatDurationHumanized",
                    value: function(e) {
                        let t = this._normalize(e);
                        for (var n, i = Math.abs(t), a = [], r = 864e5, s = [{
                            key: "day",
                            value: 24,
                            msValue: 864e5
                        }, {
                            key: "hour",
                            value: 60,
                            msValue: 36e5
                        }, {
                            key: "minute",
                            value: 60,
                            msValue: 6e4
                        }, {
                            key: "second",
                            value: 1e3,
                            msValue: 1e3
                        }]; s.length > 0; )
                            n = s.shift(),
                            i >= r && (a.push(this._pluralize(Math.floor(i / r), n.key)),
                            i -= Math.floor(i / r) * n.msValue),
                            r /= n.value;
                        return 0 === a.length ? "0 ".concat(L.messages.timeUnitsPlural.second({
                            VALUE: 0
                        })) : a.join(", ").replace(/(,)([^,]*)$/, `${L.messages.commaAnd()}$2`)
                    }
                }, {
                    key: "_normalize",
                    value: function(e) {
                        var t = parseInt(e, 10);
                        return (!0 === isNaN(t) || t < 0) && (t = 0),
                        t
                    }
                }, {
                    key: "_pluralize",
                    value: function(e, t) {
                        return e + " " + L.messages.timeUnitsPlural[t]({
                            VALUE: e
                        })
                    }
                }, {
                    key: "_duration",
                    value: function(e) {
                        var t = Math.abs(e)
                          , n = Math.floor(t / 1e3 % 60)
                          , i = Math.floor(t / 6e4 % 60);
                        return (Math.floor(t / 36e5 % 24) + 24 * Math.floor(t / 864e5) + ":" + ("0" + i).slice(-2) + ":" + ("0" + n).slice(-2)).replace(/^00:/, "").replace(/.000$/, "")
                    }
                }]),
                e
            }()
              , yl = class {
                transform(e, t) {
                    const n = new vl;
                    return t ? n.formatDurationHumanized(e) : n.formatDuration(e)
                }
                static transform(e, t) {
                    const n = new vl;
                    return t ? n.formatDurationHumanized(e) : n.formatDuration(e)
                }
            }
            ;
            yl = (0,
            c.gn)([(0,
            i.Pipe)({
                name: "timeDuration"
            })], yl);
            let bl = function() {
                function e() {
                    (0,
                    S.Z)(this, e)
                }
                return (0,
                b.Z)(e, [{
                    key: "$onInit",
                    value: function() {
                        this.msgs = L.messages.player
                    }
                }, {
                    key: "videoStartsIn",
                    value: function() {
                        return this.msgs.videoStartsIn({
                            TIME: yl.transform(this.timeRemaining - 500)
                        })
                    }
                }], [{
                    key: "template",
                    get: function() {
                        return fl()
                    }
                }, {
                    key: "controller",
                    get: function() {
                        return e
                    }
                }, {
                    key: "bindings",
                    get: function() {
                        return {
                            timeRemaining: "<",
                            percentComplete: "<"
                        }
                    }
                }]),
                e
            }();
            angular.module("ipconfigure.orchid.singularity").component("countdown", bl);
            n(25438);
            let Sl = (0,
            b.Z)((function e(t, n, i) {
                (0,
                S.Z)(this, e),
                this.x = t,
                this.y = n,
                this.scale = i
            }
            ));
            const Cl = [1, 1.1, 1.21, 1.33, 1.46, 1.61, 1.77, 1.94, 2.14, 2.35, 2.59, 2.85, 3.13, 3.45, 3.79, 4.17, 4.59, 5.05, 5.55, 6.11, 6.72, 7.4, 8.14, 8.95, 9.85, 10.83, 11.91, 13.11, 14.42, 15.86, 17.45, 19.19, 20];
            let wl = function() {
                function e(t, n) {
                    (0,
                    S.Z)(this, e),
                    this._scaleIndex = Cl.findIndex((function(e) {
                        return t.scale === e
                    }
                    )),
                    this._size = n,
                    this._position = t,
                    this._updatePosition()
                }
                return (0,
                b.Z)(e, [{
                    key: "move",
                    value: function(e) {
                        return this._position.x += e.x,
                        this._position.y += e.y,
                        this.getPosition()
                    }
                }, {
                    key: "zoom",
                    value: function(e, t, n) {
                        if (void 0 === t.x || void 0 === t.y)
                            throw new Error("Invalid cursor position value");
                        let i = (t.x - this._position.x) / this._position.scale
                          , a = (t.y - this._position.y) / this._position.scale;
                        return "mouse" === n ? (e > 0 && this._scaleIndex < Cl.length - 1 ? this._scaleIndex++ : e < 0 && this._scaleIndex > 0 && this._scaleIndex--,
                        this._position.scale = Cl[this._scaleIndex]) : (this._position.scale += .1 * e * this._position.scale,
                        this._position.scale = Math.max(1, Math.min(20, this._position.scale))),
                        this._position.x = -i * this._position.scale + t.x,
                        this._position.y = -a * this._position.scale + t.y,
                        this.getPosition()
                    }
                }, {
                    key: "getPosition",
                    value: function() {
                        return this._updatePosition()
                    }
                }, {
                    key: "_updatePosition",
                    value: function() {
                        let e = this._position.scale - 1;
                        this._position.x > 0 ? this._position.x = 0 : this._position.x + this._size.width * this._position.scale < this._size.width && (this._position.x = -this._size.width * e),
                        this._position.y > 0 ? this._position.y = 0 : this._position.y + this._size.height * this._position.scale < this._size.height && (this._position.y = -this._size.height * e);
                        let t = e / 2
                          , n = this._position.x + this._size.width * t
                          , i = this._position.y + this._size.height * t;
                        return new Sl(n,i,this._position.scale)
                    }
                }]),
                e
            }()
              , Il = function() {
                function e() {
                    (0,
                    S.Z)(this, e)
                }
                return (0,
                b.Z)(e, [{
                    key: "create",
                    value: function(e, t) {
                        return new wl(e,t)
                    }
                }]),
                e
            }();
            angular.module("ipconfigure.orchid.singularity").service("DigitalPtzCalculatorFactory", Il);
            let Tl = function() {
                function e(t, n, i, a) {
                    var r = this;
                    (0,
                    S.Z)(this, e),
                    this._$scope = t,
                    this._$element = n,
                    this._$document = i,
                    this._calculatorFactory = a,
                    this._bindEventListeners(),
                    this._zoomContainer = this._$element[0],
                    this._baselinePositionData(),
                    this._addEventListeners(),
                    this._$scope.$watch((function() {
                        return r.target
                    }
                    ), (function() {
                        r._baselinePositionData(),
                        r._applyPosition(r._calculator.getPosition())
                    }
                    )),
                    this._$scope.$watch((function() {
                        return `${r.position.scale}`
                    }
                    ), (function() {
                        r._baselinePositionData(),
                        r._applyPosition(r._calculator.getPosition())
                    }
                    )),
                    this._$scope.$on("$destroy", (function() {
                        r._removeEventListeners()
                    }
                    ))
                }
                return (0,
                b.Z)(e, [{
                    key: "_addEventListeners",
                    value: function() {
                        var e = this;
                        this._$scope.$on("resize.stage", (function() {
                            e._baselinePositionData(),
                            e._applyPosition(e._calculator.getPosition())
                        }
                        )),
                        this._zoomContainer.addEventListener("wheel", this._performZoom, {
                            passive: !1
                        }),
                        this._zoomContainer.addEventListener("mousedown", this._onMouseDown),
                        this._zoomContainer.addEventListener("touchstart", this._onTouchStart, {
                            passive: !1
                        }),
                        this._zoomContainer.addEventListener("touchmove", this._onTouchMove, {
                            passive: !1
                        }),
                        this._zoomContainer.addEventListener("touchend", this._onTouchEnd, {
                            passive: !1
                        })
                    }
                }, {
                    key: "_bindEventListeners",
                    value: function() {
                        this._performZoom = this._performZoom.bind(this),
                        this._onMouseDown = this._onMouseDown.bind(this),
                        this._onTouchStart = this._onTouchStart.bind(this),
                        this._onTouchMove = this._onTouchMove.bind(this),
                        this._onTouchEnd = this._onTouchEnd.bind(this),
                        this._onDrag = this._onDrag.bind(this),
                        this._onDrop = this._onDrop.bind(this)
                    }
                }, {
                    key: "_removeEventListeners",
                    value: function() {
                        this._zoomContainer.removeEventListener("wheel", this._performZoom),
                        this._zoomContainer.removeEventListener("mousedown", this._onMouseDown),
                        this._zoomContainer.removeEventListener("touchstart", this._onTouchStart),
                        this._zoomContainer.removeEventListener("touchmove", this._onTouchMove),
                        this._zoomContainer.removeEventListener("touchend", this._onTouchEnd)
                    }
                }, {
                    key: "_applyPosition",
                    value: function(e) {
                        let t = this._zoomContainer.querySelector(this.target);
                        t.style["transform-origin"] = "center center",
                        t.style.transform = `translate(${e.x}px, ${e.y}px) scale(${e.scale},${e.scale})`
                    }
                }, {
                    key: "_performZoom",
                    value: function(e) {
                        e.preventDefault();
                        let t, n, i = this._zoomContainer.getBoundingClientRect(), a = {
                            x: e.pageX - i.left + this._$document[0].body.scrollLeft,
                            y: e.pageY - i.top + this._$document[0].body.scrollTop
                        };
                        "[object TouchEvent]" === e.type ? (t = -1 * e.deltaY,
                        n = "touch") : (t = e.deltaY > 0 ? -1 : 1,
                        n = "mouse");
                        let r = this._calculator.zoom(t, a, n);
                        this._applyPosition(r)
                    }
                }, {
                    key: "_onMouseDown",
                    value: function(e) {
                        this.position.scale > 1 && (e.preventDefault(),
                        e.stopPropagation(),
                        this._lastMouseEvent = e,
                        this._$document.on("mousemove", this._onDrag),
                        this._$document.on("mouseup", this._onDrop))
                    }
                }, {
                    key: "_onDrag",
                    value: function(e) {
                        e.preventDefault();
                        let t = this._calculator.move({
                            x: e.pageX - this._lastMouseEvent.pageX,
                            y: e.pageY - this._lastMouseEvent.pageY
                        });
                        this._lastMouseEvent = e,
                        this._applyPosition(t)
                    }
                }, {
                    key: "_onDrop",
                    value: function() {
                        this._$document.off("mousemove", this._onDrag),
                        this._$document.off("mouseup", this._onDrop)
                    }
                }, {
                    key: "_calculateDistance",
                    value: function(e) {
                        return Math.hypot(e.touches[0].pageX - e.touches[1].pageX, e.touches[0].pageY - e.touches[1].pageY)
                    }
                }, {
                    key: "_onTouchStart",
                    value: function(e) {
                        2 === e.touches.length ? (this._pinching = !0,
                        this._lastPinchDistance = this._calculateDistance(e)) : (this.position.scale > 1 && e.target.classList.add("undraggable"),
                        this._lastTouchEvent = e)
                    }
                }, {
                    key: "_onTouchMove",
                    value: function(e) {
                        if (e.preventDefault(),
                        e.stopPropagation(),
                        this._pinching) {
                            let t = this._calculateDistance(e)
                              , n = new Event(e);
                            n.deltaY = (this._lastPinchDistance - t) / 8,
                            n.pageX = (e.touches[0].pageX + e.touches[1].pageX) / 2,
                            n.pageY = (e.touches[0].pageY + e.touches[1].pageY) / 2,
                            this._performZoom(n),
                            this._lastPinchDistance = t
                        } else if (this.position.scale > 1) {
                            let t = this._calculator.move({
                                x: e.touches[0].pageX - this._lastTouchEvent.touches[0].pageX,
                                y: e.touches[0].pageY - this._lastTouchEvent.touches[0].pageY
                            });
                            this._applyPosition(t),
                            this._lastTouchEvent = e
                        }
                    }
                }, {
                    key: "_onTouchEnd",
                    value: function(e) {
                        e.target.classList.remove("undraggable"),
                        this._pinching = !1,
                        delete this._lastPinchDistance
                    }
                }, {
                    key: "_baselinePositionData",
                    value: function() {
                        this._size && this._size.width > 0 && this._size.height > 0 && (this.position.x *= this._zoomContainer.offsetWidth / this._size.width,
                        this.position.y *= this._zoomContainer.offsetHeight / this._size.height),
                        this._size = {
                            width: this._zoomContainer.offsetWidth,
                            height: this._zoomContainer.offsetHeight
                        },
                        this._calculator = this._calculatorFactory.create(this.position, this._size)
                    }
                }], [{
                    key: "directiveFactory",
                    value: function() {
                        return {
                            restrict: "A",
                            controller: e,
                            bindToController: !0,
                            scope: {
                                position: "=",
                                target: "="
                            }
                        }
                    }
                }]),
                e
            }();
            Tl.$inject = ["$scope", "$element", "$document", "DigitalPtzCalculatorFactory"],
            angular.module("ipconfigure.orchid.singularity").directive("digitalPtz", Tl.directiveFactory);
            let El = function() {
                function e(t, n) {
                    (0,
                    S.Z)(this, e);
                    let i = n.subscribe(t.onMessage, t.call);
                    t.$on("$destroy", (function() {
                        n.unsubscribe(i)
                    }
                    ))
                }
                return (0,
                b.Z)(e, null, [{
                    key: "directiveFactory",
                    value: function() {
                        return {
                            restrict: "E",
                            controller: e,
                            scope: {
                                onMessage: "@",
                                call: "<"
                            }
                        }
                    }
                }]),
                e
            }();
            El.$inject = ["$scope", "PubSub"],
            angular.module("ipconfigure.orchid.singularity").directive("pubSubSubscription", El.directiveFactory);
            let _l = function() {
                function e(t, n, i) {
                    var a = this;
                    (0,
                    S.Z)(this, e),
                    this._target = n[0],
                    this._parent = this._target.parentNode,
                    this._$interval = i,
                    this._aspectRatioInterval = this._$interval(this._ensureAspectRatio.bind(this), 100),
                    t.$on("$destroy", (function() {
                        a._$interval.cancel(a._aspectRatioInterval)
                    }
                    ))
                }
                return (0,
                b.Z)(e, [{
                    key: "_ensureAspectRatio",
                    value: function() {
                        if (this._target.classList.contains("ng-hide"))
                            return;
                        let e, t = parseFloat(this._target.getAttribute("ensure-aspect-ratio")), n = this._parent.offsetWidth / this._parent.offsetHeight;
                        e = n === t ? t > 1 ? "height" : "width" : n >= t ? "height" : "width",
                        this._target.style["width" === e ? "height" : "width"] = "",
                        this._target.style[e] = "100%"
                    }
                }], [{
                    key: "directiveFactory",
                    value: function() {
                        return {
                            restrict: "A",
                            controller: e,
                            bindToController: !0
                        }
                    }
                }]),
                e
            }();
            _l.$inject = ["$scope", "$element", "$interval"],
            angular.module("ipconfigure.orchid.singularity").directive("ensureAspectRatio", _l.directiveFactory);
            var xl = n(65809);
            angular.module("ipconfigure.orchid.singularity").service("fisheyeFactory", (function() {
                var e = this
                  , t = 0;
                const n = nt ? 8 : 16;
                function i(i) {
                    if (e.dewarpCameraLimitReached)
                        throw new Error(L.messages.player.dewarpLimit({
                            VALUE: n
                        }));
                    var a = i ? new xl.Fisheye2Perspective : new xl.Fisheye2Equirectangular;
                    return t++,
                    a
                }
                e.createPerspective = function() {
                    return i(!0)
                }
                ,
                e.createEquirectangular = function() {
                    return i(!1)
                }
                ,
                e.release = function(e) {
                    e && null !== e && (e instanceof xl.Fisheye2Equirectangular ? e.unload() : (e.destructor(),
                    e.scene.remove(e.collisionSphere),
                    e.scene.remove(e.local)),
                    e.scene.remove(e.camera),
                    e.renderer.forceContextLoss(),
                    e.renderer.dispose(),
                    e.renderer.context = null,
                    e.renderer.domElement = null,
                    e.renderer = null,
                    e.canvas = null,
                    e.source = null,
                    e.textctx = null,
                    --t < 0 && (t = 0))
                }
                ,
                Object.defineProperty(e, "dewarpCameraLimitReached", {
                    configurable: !1,
                    get: () => t >= n
                })
            }
            )),
            Ol.$inject = ["$element", "fisheyeFactory"],
            angular.module("ipconfigure.orchid.singularity").component("cameraDewarper", {
                controller: Ol,
                controllerAs: "cameraDewarper",
                bindings: {
                    mode: "<",
                    dewarpConfig: "<",
                    isInteractive: "<",
                    source: "<",
                    onError: "&"
                }
            });
            const Dl = O("CameraDewarperController");
            function Ol(e, t) {
                var n, i = document.getElementsByTagName("body")[0], a = e[0], r = null, s = !1, o = {}, c = null, l = !1, d = this;
                function u() {
                    var e = a.offsetWidth
                      , t = a.offsetHeight;
                    1 === d.mode ? r.canvasSize = {
                        width: e,
                        height: t
                    } : e > t && t * c.panoramaAspectRatio < e ? (r.width = t * c.panoramaAspectRatio,
                    r.height = t) : (r.width = e,
                    r.height = e / c.panoramaAspectRatio),
                    isNaN(o.width) || isNaN(o.height) || (r.fisheyeRegion = {
                        centerX: o.width / 2,
                        centerY: o.height / 2,
                        radius: Math.min(o.width, o.height) / 2
                    }),
                    r.resize(),
                    r.render()
                }
                function m(e) {
                    var t, n;
                    null !== r && (l || (l = !0,
                    a.innerHTML = "",
                    a.append(r.canvas)),
                    r.src !== e.target ? (r.src && null !== r.src && 1 === d.mode && (t = {
                        pan: r.yawDegrees,
                        tilt: r.pitchDegrees,
                        zoom: r.zoom
                    }),
                    o = e.resolution,
                    r.src = e.target,
                    n = t,
                    null !== c ? null !== r && (r.orientation = c.orientation,
                    1 === d.mode ? (r.setSphereScale(1 / c.perspectiveDepth, 1 / c.perspectiveDepth, 1),
                    n ? (r.cameraPoseDegrees = {
                        pitch: n.tilt,
                        yaw: n.pan
                    },
                    r.zoom = n.zoom) : (r.cameraPoseDegrees = {
                        pitch: c.defaultPerspectiveView.tilt,
                        yaw: c.defaultPerspectiveView.pan
                    },
                    r.zoom = c.defaultPerspectiveView.zoom)) : 2 === d.mode && (r.shiftDegrees = c.panoramaShift),
                    u()) : Dl("error", "Invalid dewarp configuration set!")) : (o = e.resolution,
                    u()))
                }
                function h() {
                    a.removeEventListener("mousedown", p),
                    a.removeEventListener("wheel", v),
                    a.removeEventListener("touchstart", b)
                }
                function p(e) {
                    I(e),
                    i.classList.add("cursor-grab");
                    const t = r.canvas.getBoundingClientRect();
                    r.drag("start", e.clientX - t.left, e.clientY - t.top),
                    T(),
                    document.addEventListener("mousemove", g),
                    document.addEventListener("mouseup", f)
                }
                function g(e) {
                    const t = r.canvas.getBoundingClientRect();
                    r.drag("move", e.clientX - t.left, e.clientY - t.top)
                }
                function f() {
                    i.classList.remove("cursor-grab"),
                    T()
                }
                function v(e) {
                    y(e.deltaY > 0 ? -.05 : .05)
                }
                function y(e) {
                    if (0 !== e) {
                        var t = r.zoom + e;
                        isNaN(t) || (r.zoom = t > 10 ? 10 : t < .1 ? .1 : t,
                        r.render())
                    }
                }
                function b(e) {
                    if (I(e),
                    2 === e.touches.length)
                        s = !0,
                        n = C(e);
                    else {
                        const t = r.canvas.getBoundingClientRect();
                        r.drag("start", e.touches[0].clientX - t.left, e.touches[0].clientY - t.top)
                    }
                    E(),
                    document.addEventListener("touchmove", S),
                    document.addEventListener("touchend", w)
                }
                function S(e) {
                    if (s) {
                        var t = C(e);
                        y(.01 * (t - n)),
                        n = t
                    } else {
                        const t = r.canvas.getBoundingClientRect();
                        r.drag("move", e.touches[0].clientX - t.left, e.touches[0].clientY - t.top)
                    }
                }
                function C(e) {
                    return Math.hypot(e.touches[0].clientX - e.touches[1].clientX, e.touches[0].clientY - e.touches[1].clientY)
                }
                function w() {
                    s = !1,
                    E()
                }
                function I(e) {
                    e.stopPropagation(),
                    nt || e.preventDefault()
                }
                function T() {
                    document.removeEventListener("mousemove", g),
                    document.removeEventListener("mouseup", f)
                }
                function E() {
                    document.removeEventListener("touchmove", S),
                    document.removeEventListener("touchend", w)
                }
                d.$onInit = function() {}
                ,
                d.$onChanges = function(e) {
                    e.source && d.source && d.source.on("videoframe", m),
                    c = te(d.dewarpConfig),
                    e.mode && function(e) {
                        if (1 !== e && 2 !== e)
                            return;
                        if (null === c)
                            return void Dl("error", "Invalid dewarp configuration. Cannot enter dewarp mode.");
                        1 === e ? function() {
                            try {
                                t.release(r),
                                r = t.createPerspective()
                            } catch (e) {
                                return d.onError({
                                    error: t.dewarpCameraLimitReached ? e.message : L.messages.player.dewarpIncompatibleError()
                                }),
                                void Dl("error", "enablePerspectiveMode error:", e)
                            }
                            l = !1,
                            d.isInteractive && (a.classList.add("cursor-grab"),
                            a.addEventListener("mousedown", p),
                            a.addEventListener("wheel", v),
                            a.addEventListener("touchstart", b))
                        }() : function() {
                            try {
                                t.release(r),
                                r = t.createEquirectangular()
                            } catch (e) {
                                return d.onError({
                                    error: t.dewarpCameraLimitReached ? e.message : L.messages.player.dewarpIncompatibleError()
                                }),
                                void Dl("error", "enableEquirectangularMode error:", e)
                            }
                            l = !1,
                            d.isInteractive && (T(),
                            E(),
                            h(),
                            a.classList.remove("cursor-grab"),
                            i.classList.remove("cursor-grab"))
                        }();
                        if (d.source) {
                            var n = d.source.getVideoFrame();
                            null !== n && m(n)
                        }
                    }(e.mode.currentValue)
                }
                ,
                d.$onDestroy = function() {
                    T(),
                    E(),
                    h(),
                    d.source && d.source.off("videoframe", m),
                    t.release(r)
                }
            }
            const Al = O("PlayingSource");
            class Rl extends Error {
                constructor(e, ...t) {
                    super(...t),
                    this.isRecoverable = e
                }
            }
            const Pl = "connecting"
              , kl = "idle"
              , Ml = "paused"
              , Ll = "playing"
              , Nl = "error"
              , Fl = "resize"
              , Ul = "statechange"
              , $l = "stats"
              , jl = "videoframe"
              , Vl = "packetloss"
              , Gl = "track"
              , Bl = "motionregions";
            class zl {
                constructor(e, t, n) {
                    this._currentState = kl,
                    this._stopPromise = Promise.resolve(),
                    this._stopPromisePending = !1,
                    this._playPromise = Promise.resolve(),
                    this._playPromisePending = !1,
                    this._playRequestUpdatable = !1,
                    this._playDeadlineTimer = null,
                    this.targetElementType = n,
                    this._eventManager = e,
                    this._timeoutMs = t || 1e4,
                    this._currentState = kl,
                    this._currentPlayRequest = null,
                    this._nextPlayRequest = null,
                    this._nextPlayPromise = Promise.resolve(),
                    this._stopPromise = Promise.resolve(),
                    this._stopPromisePending = !1,
                    this._playPromise = Promise.resolve(),
                    this._playPromisePending = !1,
                    this._playRequestUpdatable = !1,
                    this._playDeadlineTimer = null
                }
                play(e, t, n) {
                    if (Al("debug", `Play - ${e} : ${t} : ${n}`),
                    this._changeState(Pl),
                    this._playPromisePending)
                        return this._updatePendingPlayRequest(e, t, n);
                    this._currentPlayRequest = {
                        time: e,
                        rate: t,
                        waitThres: n
                    },
                    this._playPromisePending = !0,
                    this._playRequestUpdatable = !0;
                    const i = this._stop();
                    return null == i && Al("warn", "no preplay promise"),
                    i.then(( () => {
                        this._playRequestUpdatable = !1,
                        this._playDeadlineTimer = setTimeout(this._finalPlayingCheck.bind(this), this._timeoutMs)
                    }
                    )),
                    this._playPromise = this._createPlayPromise(i).then(( () => (this._checkPlayCancel(),
                    this._changeState(Ll),
                    this._currentPlayRequest))).catch((e => {
                        let t;
                        throw e instanceof Rl ? (t = e,
                        t.message = L.messages.errors.playFailure({
                            VALUE: e.message
                        })) : (Al("error", "Received an unexpected error : " + e),
                        t = new Rl(!0,L.messages.errors.playFailure({
                            VALUE: e.message
                        }))),
                        null !== this._currentPlayRequest && this._notifyError(t),
                        t
                    }
                    )).finally(( () => {
                        this._playPromisePending = !1,
                        this._playRequestUpdatable = !1,
                        null !== this._playDeadlineTimer && (clearTimeout(this._playDeadlineTimer),
                        this._playDeadlineTimer)
                    }
                    )),
                    this._checkedPlayPromise(this._playPromise, e, t, n)
                }
                getVideoFrame() {
                    return this._currentState === Ml || this._currentState === Ll ? this._getVideoFrame() : null
                }
                stop() {
                    return Al("debug", "Stop"),
                    this._changeState(Ml),
                    this._cancelPlayRequest(),
                    null !== this._nextPlayRequest && (this._nextPlayRequest = void 0),
                    this._stop()
                }
                pause() {
                    this._changeState(Ml),
                    this._pause()
                }
                isAdaptive() {
                    throw new Error("NOT IMPLEMENTED!!")
                }
                setContainerSize(e) {
                    throw new Error("NOT IMPLEMENTED!!")
                }
                on(e, t) {
                    this._eventManager.on(e, t)
                }
                off(e, t) {
                    this._eventManager.off(e, t)
                }
                clear() {
                    this._clear()
                }
                setVolume(e) {
                    throw new Error("NOT IMPLEMENTED!!")
                }
                _getVideoFrame() {
                    throw new Error("NOT IMPLEMENTED!!")
                }
                replaceAudioInputTrack(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        throw new Error("NOT IMPLEMENTED!!")
                    }
                    ))
                }
                _updatePendingPlayRequest(e, t, n) {
                    return this._playRequestUpdatable ? (Al("debug", "Already have a play request pending. Update the play request"),
                    this._currentPlayRequest = {
                        time: e,
                        rate: t,
                        waitThres: n
                    },
                    this._checkedPlayPromise(this._playPromise, e, t, n)) : (this._cancelPlayRequest(),
                    null !== this._nextPlayRequest ? (Al("debug", "Update the next play"),
                    this._nextPlayRequest = {
                        time: e,
                        rate: t,
                        waitThres: n
                    },
                    this._checkedPlayPromise(this._nextPlayPromise, e, t, n)) : (Al("debug", "Set up next play promise"),
                    this._nextPlayRequest = {
                        time: e,
                        rate: t,
                        waitThres: n
                    },
                    this._nextPlayPromise = this._playPromise.catch(( () => {}
                    )).finally(( () => {
                        if (null !== this._nextPlayRequest && void 0 !== this._nextPlayRequest) {
                            Al("debug", "Calling the next play");
                            const e = this._nextPlayRequest.time
                              , t = this._nextPlayRequest.rate
                              , n = this._nextPlayRequest.waitThres;
                            return Al("debug", "next play: set next request to null"),
                            this._nextPlayRequest = null,
                            this.play(e, t, n)
                        }
                        Al("debug", "next play was cancelled"),
                        this._nextPlayRequest = null
                    }
                    )),
                    this._checkedPlayPromise(this._nextPlayPromise, e, t, n)))
                }
                _stop() {
                    return !0 === this._stopPromisePending || (this._stopPromisePending = !0,
                    this._stopPromise = this._createStopPromise(this._playPromise.catch(( () => {}
                    ))).finally(( () => {
                        this._stopPromisePending = !1
                    }
                    ))),
                    this._stopPromise
                }
                _changeState(e) {
                    e === this._currentState && this._currentState !== Pl || (this._currentState = e,
                    this._notifyStateChange(this._currentState))
                }
                _finalPlayingCheck() {
                    this._currentState !== Ll && this._notifyError(new Rl(!0,L.messages.errors.timedOutWaitingForStreamToPlay()))
                }
                _createStopPromise(e) {
                    throw new Error("NOT IMPLEMENTED!!")
                }
                _createPlayPromise(e) {
                    throw new Error("NOT IMPLEMENTED!!")
                }
                _pause() {
                    throw new Error("NOT IMPLEMENTED!!")
                }
                _clear() {
                    throw new Error("NOT IMPLEMENTED!!")
                }
                _notifyError(e) {
                    Al("error", "Notify error : " + e.message),
                    this.stop();
                    const t = {
                        isRecoverable: e.isRecoverable,
                        mediaType: e.mediaType,
                        message: e.message,
                        name: e.name
                    };
                    this._eventManager.trigger(Nl, t)
                }
                _notifyResize(e) {
                    this._eventManager.trigger(Fl, e)
                }
                _notifyStateChange(e) {
                    this._eventManager.trigger(Ul, e)
                }
                _notifyStats(e) {
                    this._eventManager.trigger($l, e)
                }
                _notifyRegions(e) {
                    this._eventManager.trigger(Bl, e)
                }
                _notifyTrack(e) {
                    this._eventManager.trigger(Gl, e)
                }
                _notifyVideoFrame(e) {
                    this._eventManager.trigger(jl, e)
                }
                _notifyPacketLoss(e) {
                    this._currentState === Ll && this._eventManager.trigger(Vl, e)
                }
                _checkPlayCancel() {
                    if (null === this._currentPlayRequest)
                        throw new Rl(!0,L.messages.errors.playRequestCancelled())
                }
                _cancelPlayRequest() {
                    this._currentPlayRequest = null
                }
                _checkedPlayPromise(e, t, n, i) {
                    return e.then(( () => {
                        if (null === this._currentPlayRequest)
                            throw new Rl(!0,L.messages.errors.playFailure({
                                VALUE: L.messages.errors.playRequestCancelled()
                            }));
                        if (this._currentPlayRequest.time !== t || this._currentPlayRequest.rate !== n || this._currentPlayRequest.waitThres !== i)
                            throw new Rl(!0,L.messages.errors.playFailure({
                                VALUE: L.messages.errors.playRequestUpdatedError()
                            }))
                    }
                    ))
                }
            }
            let Hl = function() {
                function e(t) {
                    (0,
                    S.Z)(this, e),
                    this._translatedStatKeys = Object.keys(L.messages.statisticKeys.player).reduce((function(e, t) {
                        return e[t] = L.messages.statisticKeys.player[t](),
                        e
                    }
                    ), {}),
                    this._stats = {
                        [this._translatedStatKeys.cameraDriver]: t.driver,
                        [this._translatedStatKeys.cameraMake]: t.configuration.Manufacturer ? t.configuration.Manufacturer : this._translatedStatKeys.unknown,
                        [this._translatedStatKeys.cameraModel]: t.configuration.Model ? t.configuration.Model : this._translatedStatKeys.unknown,
                        [this._translatedStatKeys.cameraMacAddress]: t.configuration.MAC ? t.configuration.MAC : this._translatedStatKeys.unknown,
                        [this._translatedStatKeys.upTime]: "0:00:00"
                    },
                    this._startTime = Date.now()
                }
                return (0,
                b.Z)(e, [{
                    key: "generateStats",
                    value: function() {
                        return this._stats[this._translatedStatKeys.upTime] = (new vl).formatDuration(Date.now() - this._startTime),
                        this._stats
                    }
                }, {
                    key: "reset",
                    value: function() {
                        this._startTime = Date.now()
                    }
                }]),
                e
            }();
            function Wl(e) {
                return Object.keys(e).reduce(( (t, n) => {
                    try {
                        t[n] = e[n]()
                    } catch (e) {}
                    return t
                }
                ), {})
            }
            let ql = function() {
                function e(t, n) {
                    (0,
                    S.Z)(this, e),
                    this.translatedStatKeys = Wl(L.messages.statisticKeys.player),
                    this.playerError = "",
                    this._stats = {
                        [this.translatedStatKeys.playerId]: t,
                        [this.translatedStatKeys.mode]: void 0,
                        [this.translatedStatKeys.streamId]: n,
                        [this.translatedStatKeys.timeToPlay]: void 0,
                        [this.translatedStatKeys.playbackTime]: void 0
                    }
                }
                return (0,
                b.Z)(e, [{
                    key: "updateStreamId",
                    value: function(e) {
                        this._stats[this.translatedStatKeys.streamId] = e
                    }
                }, {
                    key: "updatePlayerTypeStats",
                    value: function(e) {
                        this._stats[this.translatedStatKeys.mode] = e
                    }
                }, {
                    key: "updatePlayTimeStats",
                    value: function(e) {
                        this._stats[this.translatedStatKeys.timeToPlay] = Date.now() - e
                    }
                }, {
                    key: "updatePlaybackTime",
                    value: function(e) {
                        this._stats[this.translatedStatKeys.playbackTime] = e
                    }
                }, {
                    key: "generateStats",
                    value: function() {
                        return {
                            [this.translatedStatKeys.general]: this._stats
                        }
                    }
                }, {
                    key: "reset",
                    value: function() {
                        this.playerError = ""
                    }
                }]),
                e
            }();
            n(53659);
            var Yl, Xl = n(54181), Kl = n(26625), Zl = n(42965), Jl = n(16697), Ql = n(1545);
            class ed {
                constructor(e, t) {
                    this._orchid = e,
                    this._orchidDataService = t
                }
                getEvents(e, t, n, i, a, r, s, o, c) {
                    let l;
                    return void 0 === n && (n = 1e3),
                    l = "eventtime" !== r || s ? -n : n,
                    this._orchidDataService.fetchEvents(this._orchid, e, t, l, a, i, o, c)
                }
                getSubscriptions() {
                    return this._orchidDataService.fetchEventSubscriptions(this._orchid)
                }
                getCategories() {
                    return this._orchidDataService.fetchEventCategories(this._orchid)
                }
                getCameraTopics() {
                    return this._orchidDataService.fetchOnvifCameraTopics(this._orchid)
                }
                putSubscription(e, t) {
                    return this._orchidDataService.putEventSubscription(this._orchid, e, t)
                }
                deleteSubscription(e) {
                    return this._orchidDataService.deleteEventSubscription(this._orchid, e)
                }
                postEventSubscription(e) {
                    return this._orchidDataService.postEventSubscription(this._orchid, e)
                }
                postEvent(e) {
                    return this._orchidDataService.postEvent(this._orchid, e)
                }
            }
            let td = class {
                constructor(e) {
                    this._orchidDataService = e
                }
                create(e) {
                    return new ed(e,this._orchidDataService)
                }
            }
            ;
            var nd, id, ad;
            td = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Yl = pt) ? Yl : Object])], td);
            const rd = O("eventsTable.component");
            var sd;
            !function(e) {
                e[e.Loading = 0] = "Loading",
                e[e.Loaded = 1] = "Loaded",
                e[e.Failed = 2] = "Failed"
            }(sd || (sd = {}));
            let od = class {
                constructor(e) {
                    this._orchidEventsServiceFactory = e,
                    this.msgs = {},
                    this.displayedColumns = ["name", "category", "camera", "eventtime", "active"],
                    this.filterOptions = {
                        categoryIds: [],
                        range: {
                            from: void 0,
                            to: Date.now()
                        },
                        isDateRange: !1,
                        eventNameSearchTerms: [],
                        cameraNameSearchTerms: [],
                        eventStateFilters: [],
                        subscriptionIds: []
                    },
                    this.events = [],
                    this.sort = {
                        active: "eventtime",
                        direction: "desc"
                    },
                    this.pageSize = 1e3,
                    this.currentOffset = 0,
                    this.state = sd.Loading,
                    this.handleEventSelect = new i.EventEmitter,
                    this._subscriptionsMap = {}
                }
                get ComponentState() {
                    return sd
                }
                ngOnChanges(e) {
                    var t, n;
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        (null === (t = e.subscriptions) || void 0 === t ? void 0 : t.currentValue) && !1 === (null === (n = e.subscriptions) || void 0 === n ? void 0 : n.firstChange) && this.setSubscriptionsMap(),
                        this.orchids && Object.keys(this._subscriptionsMap).length > 0 && (this.currentOffset = 0,
                        this.events = [],
                        e.orchids && !e.orchids.firstChange && (this.filterOptions = {
                            cameraNameSearchTerms: [],
                            categoryIds: [],
                            eventNameSearchTerms: [],
                            eventStateFilters: [],
                            isDateRange: !1,
                            range: {
                                from: void 0,
                                to: Date.now()
                            },
                            subscriptionIds: []
                        }),
                        yield this._getOrchidEvents(),
                        this.top())
                    }
                    ))
                }
                ngOnInit() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.msgs = Object.assign({}, L.messages.events),
                        this.orchids && this.subscriptions && (this.setSubscriptionsMap(),
                        yield this.refresh())
                    }
                    ))
                }
                _getOrchidEvents() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (!this.orchids || !this.subscriptions)
                            return;
                        this.state = sd.Loading;
                        const e = this.orchids.map((e => {
                            var t, n;
                            if ((this.filterOptions.eventNameSearchTerms.length > 0 || this.filterOptions.cameraNameSearchTerms.length > 0) && 0 === this.filterOptions.subscriptionIds.length)
                                return Promise.resolve([]);
                            return this._orchidEventsServiceFactory.create(e).getEvents(null === (t = this.filterOptions.range) || void 0 === t ? void 0 : t.from, null === (n = this.filterOptions.range) || void 0 === n ? void 0 : n.to, this.pageSize, this.filterOptions.categoryIds, this.currentOffset, this.sort.active, "desc" === this.sort.direction, this.filterOptions.eventStateFilters, this.filterOptions.subscriptionIds)
                        }
                        ));
                        return Promise.all(e).then((e => {
                            const t = e.flat().map((e => {
                                const t = this._subscriptionsMap[e.subscriptionId.toString()];
                                return {
                                    active: e.active,
                                    eventId: e.id,
                                    subscriptionId: t.id,
                                    name: t.name,
                                    category: t.category,
                                    source: t.source,
                                    cameras: t.cameras,
                                    cameraNames: t.cameras.map((e => e.name)),
                                    selectedCamera: t.cameras.length > 0 ? t.cameras[0] : null,
                                    eventTime: e.eventTime,
                                    details: e.message,
                                    type: t.type
                                }
                            }
                            ));
                            this.events = [...this.events, ...t],
                            this.events.length > 0 && this.onRowClick(this.events[0]),
                            this.state = sd.Loaded
                        }
                        )).catch((e => {
                            var t;
                            rd.error(e),
                            this.events = [],
                            this.state = sd.Failed,
                            this.errorMessage = (null === (t = e.data) || void 0 === t ? void 0 : t.reason) || this.msgs.failedToFetchEvents()
                        }
                        )).finally(( () => {
                            0 === this.events.length && this.onRowClick(null)
                        }
                        ))
                    }
                    ))
                }
                more() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.currentOffset += this.pageSize,
                        yield this._getOrchidEvents()
                    }
                    ))
                }
                refresh() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.filterOptions.range.to = Date.now(),
                        this.currentOffset = 0,
                        this.events = [],
                        yield this._getOrchidEvents(),
                        this.top()
                    }
                    ))
                }
                applySort(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.sort = e,
                        this.currentOffset = 0,
                        this.events = [],
                        yield this._getOrchidEvents(),
                        this.top()
                    }
                    ))
                }
                top() {
                    var e, t;
                    0 !== this.events.length && (null === (t = null === (e = this.table) || void 0 === e ? void 0 : e.nativeElement) || void 0 === t || t.scrollIntoView(),
                    this.onRowClick(this.events[0]))
                }
                onRowClick(e) {
                    this.selectedEvent = e,
                    this.handleEventSelect.emit(e)
                }
                setSubscriptionsMap() {
                    this._subscriptionsMap = this.subscriptions.reduce(( (e, t) => (e[t.id.toString()] = t,
                    e)), {})
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], od.prototype, "subscriptions", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], od.prototype, "orchids", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], od.prototype, "filterOptions", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (nd = void 0 !== i.EventEmitter && i.EventEmitter) ? nd : Object)], od.prototype, "handleEventSelect", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("table", {
                read: i.ElementRef
            }), (0,
            c.w6)("design:type", "function" == typeof (id = void 0 !== i.ElementRef && i.ElementRef) ? id : Object)], od.prototype, "table", void 0),
            od = (0,
            c.gn)([(0,
            i.Component)({
                selector: "events-table",
                template: n(76241)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(td)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (ad = void 0 !== td && td) ? ad : Object])], od);
            const cd = Object.assign({
                1: "radar fa",
                2: "person-to-door fa",
                3: "clock fa",
                4: "cash-register fa",
                5: "volume-up fa",
                6: "ptz fa-kit",
                7: "temperature-high fa",
                8: "id-badge fa",
                9: "users fa",
                10: "car fa",
                11: "suitcase fa",
                12: "person-walking fa",
                13: "wrench fa",
                14: "video-camera fa",
                15: "lightbulb fa-regular",
                16: "paw fa"
            }, {
                1001: "circle-1 fa",
                1002: "circle-2 fa",
                1003: "circle-3 fa",
                1004: "circle-4 fa",
                1005: "circle-5 fa",
                1006: "circle-6 fa",
                1007: "circle-7 fa",
                1008: "circle-8 fa",
                1009: "circle-9 fa",
                1010: "circle-0 fa"
            });
            function ld(e) {
                return e.sort(( (e, t) => w.isOrchid ? e.translatedName.localeCompare(t.translatedName, void 0, {
                    numeric: !0
                }) : e.name.localeCompare(t.name, void 0, {
                    numeric: !0
                })))
            }
            var dd, ud, md, hd, pd, gd, fd, vd, yd, bd, Sd;
            !function(e) {
                e.THUMBNAIL_SEARCH_CLOSE = "thumbnail-search-close",
                e.THUMBNAIL_SEARCH_OPEN = "thumbnail-search-open",
                e.DETAILS_PANEL_OPEN = "details-panel-open",
                e.DETAILS_PANEL_CLOSE = "details-panel-close",
                e.CONTROL_OPEN = "control-expander-open",
                e.GET_PANEL_STATUS = "get-panel-status"
            }(Sd || (Sd = {}));
            let Cd = class {
                constructor(e, t, n, i, a) {
                    this._authService = e,
                    this._renewableService = t,
                    this._sessionIdService = n,
                    this._utilityService = i,
                    this._orchidEventsServiceFactory = a,
                    this.msgs = {},
                    this.displayedColumns = ["name", "category", "camera", "receivetime"],
                    this.orchid = null,
                    this.orchids = [],
                    this.categories = [],
                    this.subscriptionsData = [],
                    this.isOrchid = w.isOrchid,
                    this.ready = !1,
                    this.selectedEvent = null,
                    this.subscriptions = [],
                    this.orchidDataReady = !1,
                    this._camerasMap = {},
                    this._categoriesMap = {},
                    this.firstViewing = !0,
                    this.pageReady = !1,
                    this.pageUnavailable = !1,
                    this.iFrameReady = !1,
                    this.isAdmin = this._authService.getAuthenticationData().isAdministrator(),
                    this.draggingSizer = !1,
                    this.currentOffset = 0,
                    this.pageSize = 1e3,
                    this._eventsPollingInterval = (0,
                    Jl.F)(5e3),
                    this._eventsPoller = Ql.E.subscribe(),
                    this._pollingEvents = !1,
                    this.activeFilterCount = 0,
                    this._thumbnailSearchPanelStatus = Sd.THUMBNAIL_SEARCH_CLOSE,
                    this._detailsPanelQueued = !1,
                    this.screenWidth = window.innerWidth,
                    this.minimumVersionFeature = Sr.EVENT_SUBSCRIPTIONS,
                    this._handleIFrameMessage = e => {
                        if (e.data.event && e.data.event.type && e.data.event.message && "panel-status" === e.data.event.type)
                            if (e.data.event.message === Sd.GET_PANEL_STATUS)
                                this._postDetailsPanelStatus(this.detailsPanel.opened);
                            else
                                this._togglePanelWithThumbnailSearch(e)
                    }
                    ,
                    this.filterOptions = {
                        categoryIds: [],
                        range: {
                            from: void 0,
                            to: Date.now()
                        },
                        isDateRange: !1,
                        eventNameSearchTerms: [],
                        cameraNameSearchTerms: [],
                        eventStateFilters: [],
                        subscriptionIds: []
                    },
                    this.numNewEvents = 0,
                    this.scrollPageToTop()
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign({}, L.messages.events.eventsViewer), L.messages.events.orchidSelector)
                }
                stopSizerDrag(e) {
                    this.sizer.clickGutter(e, 0),
                    this.draggingSizer = !1
                }
                _postDetailsPanelStatus(e) {
                    e ? this._utilityService.postMessageAPIPlayer({
                        message: Sd.DETAILS_PANEL_OPEN,
                        type: "panel-status"
                    }) : this._utilityService.postMessageAPIPlayer({
                        message: Sd.DETAILS_PANEL_CLOSE,
                        type: "panel-status"
                    })
                }
                _togglePanelWithThumbnailSearch(e) {
                    this._thumbnailSearchPanelStatus = e.data.event.message,
                    e.data.event.message !== Sd.THUMBNAIL_SEARCH_OPEN && e.data.event.message !== Sd.CONTROL_OPEN || !this.detailsPanel.opened ? e.data.event.message === Sd.THUMBNAIL_SEARCH_CLOSE && this._detailsPanelQueued && (this._detailsPanelQueued = !1,
                    this.detailsPanel.toggle()) : this.toggleDetailsPanel()
                }
                ngAfterViewInit() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this._renewableService.orchidsPromise().then((e => {
                            this.isOrchid ? (this.firstViewing = !1,
                            this.orchid = e[0],
                            this.eventsService = this._orchidEventsServiceFactory.create(this.orchid),
                            this.getOrchidData()) : (this.orchids = e,
                            this.pageReady = !0)
                        }
                        )),
                        window.addEventListener("message", this._handleIFrameMessage)
                    }
                    ))
                }
                ngOnDestroy() {
                    this._eventsPoller.unsubscribe(),
                    this._timeout && clearTimeout(this._timeout),
                    window.removeEventListener("message", this._handleIFrameMessage)
                }
                _pollForEvents() {
                    if (this._pollingEvents || this.filterOptions.isDateRange)
                        return;
                    this._pollingEvents = !0;
                    const e = this.filterOptions.range.to ? this.filterOptions.range.to : Date.now() + 864e5
                      , t = Date.now();
                    this.eventsService.getEvents(e, t, void 0, this.filterOptions.categoryIds, void 0, void 0, void 0, this.filterOptions.eventStateFilters, this.filterOptions.subscriptionIds).then((e => {
                        this.numNewEvents = e.length
                    }
                    )).catch(( () => {}
                    )).finally(( () => {
                        this._pollingEvents = !1
                    }
                    ))
                }
                getOrchidData() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (void 0 !== this.orchid && null !== this.orchid) {
                            this.numNewEvents = 0;
                            try {
                                !1 !== this.isOrchid || this._sessionIdService.hasSessionId(this.orchid.id) || (yield(0,
                                dt.z)(this._sessionIdService.getSessionId$(this.orchid.id)));
                                const [e,t,n] = yield Promise.all([this.eventsService.getCategories(), this.eventsService.getSubscriptions(), this._renewableService.fetchCameras(this.orchid)]);
                                this._categoriesMap = e.reduce(( (e, t) => (e[t.id.toString()] = t,
                                e)), {}),
                                this.categories = ld(e),
                                this._camerasMap = n.reduce(( (e, t) => (e[t.id] = t,
                                e)), {}),
                                this.subscriptions = t.map((e => ({
                                    id: e.id,
                                    name: e.name,
                                    category: this._categoriesMap[e.categoryId.toString()],
                                    type: e.type,
                                    source: this.getSubscriptionSource(e),
                                    cameras: e.associatedCameraIds.map((e => this._camerasMap[e.toString()])).filter((e => void 0 !== e))
                                }))),
                                this._eventsPoller.unsubscribe(),
                                this._eventsPoller = this._eventsPollingInterval.subscribe({
                                    next: () => this._pollForEvents()
                                }),
                                this.orchidDataReady = !0
                            } catch (e) {
                                this.pageReady = !0,
                                this.pageUnavailable = !0
                            }
                            this.scrollPageToTop()
                        }
                    }
                    ))
                }
                setSelectedOrchid(e) {
                    e ? (this.firstViewing && !1 === this.iFrameReady && (this.pageReady = !1),
                    this.orchid = e,
                    this.eventsService = this._orchidEventsServiceFactory.create(this.orchid),
                    this.filterOptions = {
                        cameraNameSearchTerms: [],
                        eventNameSearchTerms: [],
                        eventStateFilters: [],
                        isDateRange: !1,
                        range: {
                            from: void 0,
                            to: Date.now()
                        },
                        subscriptionIds: [],
                        categoryIds: []
                    },
                    this.activeFilterCount = 0,
                    this.getOrchidData(),
                    this.firstViewing = !1) : this.orchid = null,
                    this.selectedEvent = null
                }
                getOrchidOptionLabel(e) {
                    return e ? e.name : ""
                }
                getSubscriptionCameras(e) {
                    const t = [];
                    return e && e.forEach((e => {
                        t.push(this._camerasMap[e])
                    }
                    ), []),
                    t
                }
                getSubscriptionSource(e) {
                    return "onvif" === e.type ? e.onvifTopic ? e.onvifTopic : "---" : e.cameraId ? this._camerasMap[e.cameraId].name : "---"
                }
                setSelectedCamera(e) {
                    this.selectedEvent && (this.selectedEvent.selectedCamera = e)
                }
                setSelectedEvent(e) {
                    null !== this.selectedEvent && null !== e && this.selectedEvent.eventId === e.eventId ? this.selectedEvent.eventTime++ : (this.selectedEvent && (this.selectedEvent.selectedCamera = this.setDefaultCamera(this.selectedEvent.cameras)),
                    this.selectedEvent = e)
                }
                setDefaultCamera(e) {
                    return e.length > 0 ? e[0] : null
                }
                checkValidPlayer() {
                    var e;
                    return !!this.selectedEvent && !!(null === (e = this.selectedEvent) || void 0 === e ? void 0 : e.selectedCamera)
                }
                _updateFilters() {
                    this.activeFilterCount = this.filterOptions.categoryIds ? this.filterOptions.categoryIds.length : 0,
                    this.filterOptions.cameraNameSearchTerms && (this.activeFilterCount += this.filterOptions.cameraNameSearchTerms.length),
                    this.filterOptions.eventNameSearchTerms && (this.activeFilterCount += this.filterOptions.eventNameSearchTerms.length),
                    this.filterOptions.eventStateFilters && (this.activeFilterCount += this.filterOptions.eventStateFilters.length),
                    this.filterOptions.range.from && this.activeFilterCount++
                }
                onFiltersChanges(e) {
                    JSON.stringify(this.filterOptions) !== JSON.stringify(e) && (this.filterOptions = xt(e),
                    this.numNewEvents = 0,
                    this._pollForEvents(),
                    this.screenWidth <= 1e3 ? this.eventsFilterDrawer.close().then(( () => {
                        this._updateFilters()
                    }
                    )) : this._updateFilters())
                }
                refreshEvents() {
                    this.eventsTable.refresh()
                }
                toggleDetailsPanel() {
                    if (this.detailsPanel.opened)
                        this._timeout = setTimeout(( () => {
                            this._utilityService.postMessageAPIPlayer({
                                message: Sd.DETAILS_PANEL_CLOSE,
                                type: "panel-status"
                            })
                        }
                        ), 500);
                    else if (this._utilityService.postMessageAPIPlayer({
                        message: Sd.DETAILS_PANEL_OPEN,
                        type: "panel-status"
                    }),
                    this._thumbnailSearchPanelStatus === Sd.THUMBNAIL_SEARCH_OPEN)
                        return void (this._detailsPanelQueued = !0);
                    this.detailsPanel.toggle()
                }
                handleIFrameReady() {
                    this.iFrameReady = !0,
                    this.pageReady = !0
                }
                toggleSizerDragging() {
                    this.draggingSizer = !this.draggingSizer
                }
                scrollPageToTop() {
                    window.scroll({
                        top: 0,
                        left: 0,
                        behavior: "smooth"
                    })
                }
                checkServers() {
                    return !!this.isOrchid || !this.isOrchid && this.orchids.length > 0
                }
                onResize() {
                    window.innerWidth !== this.screenWidth && (this.screenWidth = window.innerWidth,
                    this.screenWidth <= 1e3 && this.eventsFilterDrawer && this.eventsFilterDrawer.close())
                }
                get drawerMode() {
                    return this.screenWidth > 1e3 ? "side" : "over"
                }
                get numNewEventsDisplay() {
                    return this.numNewEvents > 99 ? "99+" : this.numNewEvents.toString()
                }
            }
            ;
            var wd;
            (0,
            c.gn)([(0,
            i.ViewChild)(od), (0,
            c.w6)("design:type", "function" == typeof (dd = void 0 !== od && od) ? dd : Object)], Cd.prototype, "eventsTable", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(bi.jA), (0,
            c.w6)("design:type", "function" == typeof (ud = void 0 !== bi.jA && bi.jA) ? ud : Object)], Cd.prototype, "detailsPanel", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("sizer"), (0,
            c.w6)("design:type", "function" == typeof (md = void 0 !== d.Mq && d.Mq) ? md : Object)], Cd.prototype, "sizer", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("eventsFilterDrawer"), (0,
            c.w6)("design:type", "function" == typeof (hd = void 0 !== bi.jA && bi.jA) ? hd : Object)], Cd.prototype, "eventsFilterDrawer", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("detailsPanelDrawer"), (0,
            c.w6)("design:type", "function" == typeof (pd = void 0 !== bi.jA && bi.jA) ? pd : Object)], Cd.prototype, "detailsPanelDrawer", void 0),
            Cd = (0,
            c.gn)([(0,
            i.Component)({
                selector: "events-viewer",
                template: n(39280)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(xe)), (0,
            c.fM)(1, (0,
            i.Inject)(Gt)), (0,
            c.fM)(2, (0,
            i.Inject)(ur)), (0,
            c.fM)(3, (0,
            i.Inject)(st)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (gd = void 0 !== xe && xe) ? gd : Object, "function" == typeof (fd = Gt) ? fd : Object, "function" == typeof (vd = void 0 !== ur && ur) ? vd : Object, "function" == typeof (yd = st) ? yd : Object, "function" == typeof (bd = void 0 !== td && td) ? bd : Object])], Cd);
            let Id = class {
                constructor(e, t) {
                    this.options = e,
                    this.matDialogRef = t
                }
                close() {
                    this.matDialogRef.close()
                }
                get showDialogTitle() {
                    return !this.options.hideTitle
                }
            }
            ;
            Id = (0,
            c.gn)([(0,
            i.Component)({
                selector: "info-dialog",
                template: n(37406)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.so)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (wd = void 0 !== hn.so && hn.so) ? wd : Object])], Id);
            class Td extends zl {
                constructor(e, t, n, i, a, r, s) {
                    if (super(e, 0, "canvas"),
                    this._orchidDataService = t,
                    this._orchid = n,
                    this._stream = i,
                    this._canvas = a,
                    this._image = r,
                    this._containerSize = s,
                    this._playCompleteResolve = null,
                    this._playCompleteReject = null,
                    !a || a instanceof HTMLCanvasElement == !1)
                        throw new Error("canvas must be an HTML canvas tag");
                    if (!r || r instanceof HTMLImageElement == !1)
                        throw new Error("image must be an HTML image tag");
                    this._image.crossOrigin = "Anonymous",
                    this._image.onload = this._onImageLoad.bind(this),
                    this._image.onerror = this._onImageError.bind(this),
                    this._lastSize = this._containerSize,
                    this._playCompleteResolve = null,
                    this._playCompleteReject = null
                }
                _getVideoFrame() {
                    return {
                        target: this._canvas,
                        resolution: this._lastSize
                    }
                }
                _createPlayPromise(e) {
                    const t = new Promise(( (e, t) => {
                        this._playCompleteResolve = e,
                        this._playCompleteReject = t
                    }
                    ));
                    return e.then(( () => {
                        this._image.src = this._generateUrl(this._currentPlayRequest.time)
                    }
                    )).then(( () => t))
                }
                _createStopPromise(e) {
                    return e
                }
                _onImageError() {
                    null !== this._playCompleteReject && (this._playCompleteReject(new Rl(!0,"Error rendering image")),
                    this._playCompleteReject = null,
                    this._playCompleteResolve = null)
                }
                _onImageLoad() {
                    var e;
                    if (null !== this._playCompleteResolve && (this._playCompleteResolve(void 0),
                    this._playCompleteResolve = null,
                    this._playCompleteReject = null),
                    this._stopPromisePending)
                        return;
                    const t = {
                        height: this._image.naturalHeight,
                        width: this._image.naturalWidth
                    };
                    t.height === this._lastSize.height && t.width === this._lastSize.width || (this._canvas.height = t.height,
                    this._canvas.width = t.width,
                    this._lastSize = t,
                    this._notifyResize(t)),
                    this._canvas.height = t.height,
                    this._canvas.width = t.width,
                    null === (e = this._canvas.getContext("2d")) || void 0 === e || e.drawImage(this._image, 0, 0),
                    this._notifyVideoFrame({
                        target: this._canvas,
                        resolution: t
                    })
                }
                isAdaptive() {
                    return !0
                }
                _generateUrl(e) {
                    return this._orchidDataService.frameUrl(this._orchid, this._stream, e, this._containerSize, !0)
                }
                _checkPlayCancel() {}
                _checkedPlayPromise(e, t, n, i) {
                    return e
                }
                _pause() {}
                setVolume(e) {}
                _clear() {
                    var e;
                    null === (e = this._canvas.getContext("2d")) || void 0 === e || e.clearRect(0, 0, this._canvas.width, this._canvas.height)
                }
            }
            let Ed = class {
                constructor() {
                    this.msgs = Object.assign(Object.assign({}, L.messages.player.bidirectionalAudio), {
                        ok: L.messages.player.ok
                    })
                }
            }
            ;
            Ed = (0,
            c.gn)([(0,
            i.Component)({
                selector: "permission-notice-dialog",
                template: n(79117)
            })], Ed);
            let _d = class {
                constructor() {
                    this.msgs = Object.assign(Object.assign({}, L.messages.player.bidirectionalAudio), {
                        ok: L.messages.player.ok
                    })
                }
            }
            ;
            _d = (0,
            c.gn)([(0,
            i.Component)({
                selector: "no-device-notice-dialog",
                template: n(84091)
            })], _d);
            const {v4: xd} = n(21614)
              , Dd = "rip"
              , Od = "play"
              , Ad = {
                NO_VIDEO: "no_video",
                CONNECTING: "connecting",
                ERROR: "error",
                DELAY: "delay",
                NONE: "",
                UNSUPPORTED: "unsupported"
            }
              , Rd = {
                EXPANDER: 0,
                SINGLE: 1,
                NONE: 2
            }
              , Pd = "canvas.player"
              , kd = "video.player"
              , Md = 2e3;
            let Ld = function() {
                function e(t, n, i, a) {
                    (0,
                    S.Z)(this, e),
                    this.stream = t,
                    this.isPrimary = n,
                    this.isRecording = i,
                    this.isOnvif = a,
                    this.description = [],
                    this.name = this.isOnvif ? this.stream.configuration.Video.Resolution : this.stream.name
                }
                return (0,
                b.Z)(e, [{
                    key: "isWebRtcCompatible",
                    get: function() {
                        return !this.isOnvif || "H264" === this.stream.configuration.Video.Encoder
                    }
                }, {
                    key: "id",
                    get: function() {
                        return this.stream.id
                    }
                }]),
                e
            }();
            const Nd = {
                Error: "error",
                FullScreen: "full-screen",
                Large: "large",
                Medium: "medium",
                Paused: "paused",
                PTZ: "ptz",
                Small: "small",
                SmartSearch: "smart-search",
                ThumbnailSearch: "thumbnail-search",
                Stats: "stats",
                Transitioning: "transitioning",
                Unlinked: "unlinked",
                Unpaused: "unpaused"
            }
              , Fd = O("Player");
            let Ud = function() {
                function e(t, n, i, a, r, s, o, c, l, d, u, m, h, p, g, f, v, y, b, C, I, T, E, _, x, D, O) {
                    var A = this;
                    (0,
                    S.Z)(this, e),
                    this._playerStatisticsKeys = Wl(L.messages.statisticKeys.player),
                    this._webSocketStatisticsKeys = Wl(L.messages.statisticKeys.websocket),
                    this._webrtcStatisticsKeys = Wl(L.messages.statisticKeys.webrtc),
                    this._urlCreator = window.URL || window.webkitURL,
                    this._$scope = t,
                    this._$rootScope = n,
                    this._$element = i,
                    this._$timeout = a,
                    this._$interval = r,
                    this._$window = s,
                    this._$mdDialog = o,
                    this._OrchidDataService = l,
                    this._StageService = d,
                    this._PubSub = u,
                    this._MatrixService = m,
                    this._TimelineServiceFactory = h,
                    this._UtilityService = v,
                    this._PlayerResetService = T,
                    this._TimeService = y,
                    this._PlayerModeService = f,
                    this._TimelineEventService = b,
                    this._MinimumVersionService = D,
                    this._FeatureFlagService = _,
                    this._isOrchid = w.isOrchid,
                    this._isPWA = w.isPWA,
                    this.showLBM = !0,
                    this.showSmartSearch = !1,
                    this._SessionIdService = C,
                    this._PerformanceTrackerService = I,
                    this.overlayStates = Ad,
                    this.showStreamSelectControls = !1,
                    this.smartSearchRegionBounds = [],
                    this.overlayState = Ad.CONNECTING,
                    this._smartSearchIsAvailable = !1,
                    this._thumbnailSearchIsAvailable = !0,
                    this._NGStageService = E,
                    this._isDestroying = !1,
                    this.destroyed$ = new St.x,
                    this.bidirectionalAudioMuted = !0,
                    this.showBidirectionalAudio = !1,
                    this.showMicrophoneSelector = !1,
                    this.bidirectionalAudioEnabled = !1,
                    this.bidirectionalAudioAvailable = this._isOrchid,
                    this.cameraDisablementIsSupported = !0,
                    this._matDialog = x,
                    this._audioInputService = O,
                    this.activeMicrophoneStream = null,
                    this._cameraSideMotionDetectionIsAvailable = !0,
                    this._playerResizeObserver = new ResizeObserver((function(e) {
                        e[0].contentRect.width < 640 && A.bidirectionalAudioEnabled && A.controlsExpanded && (A.controlsExpanded = !1)
                    }
                    )),
                    this.playingSourceStatistics$ = new P.X(void 0),
                    this.playingSourceStatsConnectionLoaded$ = this.playingSourceStatistics$.pipe((0,
                    ra.h)((function(e) {
                        return e && e[A._webrtcStatisticsKeys.CONNECTION] && e[A._webrtcStatisticsKeys.CONNECTION][A._webrtcStatisticsKeys.CONNECTION]
                    }
                    ))),
                    this.showThumbnailSearchOverlay = !1,
                    this.thumbnailSearchDisabled = !0,
                    this.controlsExpanded = !1,
                    this._userSelectedStream = !1,
                    this.showPtzControls = !1,
                    this._isMobile = g.isMobile,
                    this.deviceInfo = g.getDeviceInfo(),
                    this.noHideHeader = !1,
                    this._liveBufferSeconds = w.secondsPlaybackFromLive,
                    this._backgroundVolume = 0,
                    this._wasUnlinked = !1,
                    this.digitalPtzPosition = new Sl(0,0,1),
                    this._playerStatsInterval = null,
                    this._timelineSubscriptions = {},
                    this._lastSize = {
                        height: 0,
                        width: 0,
                        aspectRatio: 0
                    },
                    this._sourceFactory = p,
                    this._isAdministrator = c.getAuthenticationData().isAdministrator(),
                    this.mode = Od,
                    this.unlinked = !1,
                    this.expandTzAlert = !1,
                    this.dewarpMode = 0,
                    this.previousDewarpMode = void 0,
                    this.dewarpAvailable = !1,
                    this.expandPresets = !1,
                    this.volume = 0,
                    this.ptzAvailable = !1,
                    this.state = Pl,
                    this._bindClassMethods(),
                    this._errorRetryAttempts = 0,
                    this._skipNextRipEvent = !1,
                    this.clientTimezone = R()(Date.now()).tz(R().tz.guess()).zoneAbbr(),
                    this.serverTimezone = "",
                    this.timeOffsetDisplayText = "",
                    this.volumeAvailable = !1,
                    this.containerAspectRatio = this._$element[0].clientWidth / this._$element[0].clientHeight,
                    this.image = void 0,
                    this._resizingSmartSearch = !1,
                    this._startTime = Date.now(),
                    this.wasFullScreen = !1,
                    this.controls = Rd.NONE,
                    this.controlsLayout = Rd,
                    this._detailsPanelStatus = "",
                    this._thumbnailSearchQueued = !1,
                    this._muteBidirectionalAudio$ = new St.x,
                    this.muteBidirectionalAudio$ = this._muteBidirectionalAudio$.asObservable(),
                    this.showLiveMotionRegions = !1,
                    this._liveMotionRegionsAreSupported = !0,
                    this.liveMotionRegions = []
                }
                return (0,
                b.Z)(e, [{
                    key: "liveMotionRegionsAreSupported",
                    get: function() {
                        return this._liveMotionRegionsAreSupported && this.playerType === nn
                    }
                }, {
                    key: "onTalk",
                    value: function(e) {
                        this.bidirectionalAudioMuted = !1,
                        this.activeMicrophoneStream = e.stream
                    }
                }, {
                    key: "onMute",
                    value: function(e) {
                        this.bidirectionalAudioMuted = !0,
                        this.activeMicrophoneStream = null
                    }
                }, {
                    key: "toggleForcedHoverState",
                    value: function(e) {
                        e ? this._$element[0].classList.add("mic-selector-open") : this._$element[0].classList.remove("mic-selector-open")
                    }
                }, {
                    key: "onMediaStreamChange",
                    value: function(e) {
                        this.activeMicrophoneStream = e.stream
                    }
                }, {
                    key: "showPlayerFrameDownloader",
                    get: function() {
                        return !(!this.canPlayback || !this.timelineContext.getCurrentState().paused) && (!this._isPWA || "MacOS" !== this.deviceInfo.operatingSystem)
                    }
                }, {
                    key: "_updateTimeOffset",
                    value: function(e) {
                        var t = null === e ? 0 : e.offset
                          , n = Math.abs(t - this._timeOffset) > 5e3;
                        this._timeOffset = t,
                        n && void 0 !== this.source && this._resumePlaying()
                    }
                }, {
                    key: "_setServerTimezone",
                    value: function(e) {
                        if (!1 !== this.options.showTimezoneOffset) {
                            this.serverTimezone = e.tz;
                            var t = -1 * (new Date).getTimezoneOffset()
                              , n = e.tzOffset;
                            if (n !== t) {
                                var i = Math.floor(Math.abs((n - t) / 60))
                                  , a = n > t ? "+" : "-";
                                this.timeOffsetDisplayText = this.msgs.clientServerTimeDiffSpaced({
                                    SIGN: a,
                                    DIFF: i
                                })
                            }
                        }
                    }
                }, {
                    key: "onDewarpError",
                    value: function(e) {
                        this.setDewarpMode(0),
                        alert(e)
                    }
                }, {
                    key: "clearRegions",
                    value: function() {
                        this.smartSearchRegionBounds = []
                    }
                }, {
                    key: "_initPlayer",
                    value: async function() {
                        var e = this;
                        if (this.overlayState = Ad.CONNECTING,
                        this._isOrchid || (this._thumbnailSearchIsAvailable = this._MinimumVersionService.isFeatureSupported(this.orchid, Sr.THUMBNAIL_SEARCH),
                        this._cameraSideMotionDetectionIsAvailable = this._MinimumVersionService.isFeatureSupported(this.orchid, Sr.CAMERA_SIDE_MOTION_DETECTION),
                        this.bidirectionalAudioAvailable = this._MinimumVersionService.isFeatureSupported(this.orchid, Sr.TWO_WAY_AUDIO),
                        this.cameraDisablementIsSupported = this._MinimumVersionService.isFeatureSupported(this.orchid, Sr.CAMERA_DISABLEMENT),
                        this._liveMotionRegionsAreSupported = this._MinimumVersionService.isFeatureSupported(this.orchid, Sr.MOTION_REGIONS_OVERLAY)),
                        this.id || (this.id = "preview-" + xd()),
                        this.ptzControlColor = this.options.ptzControlColor,
                        this._statsCollector = new Hl(this.camera),
                        this._diagnosticsCollector = new ql(this.id,this.streamId),
                        this._closeAllMenus(),
                        this._FeatureFlagService.isFeatureEnabled(qe.fetchOrchidsOmittingCapabilities)) {
                            const t = await this._OrchidDataService.fetchCamera(this.orchid, this.camera.id).catch((function(t) {
                                e._setOverlayState(Ad.ERROR),
                                e.error = {
                                    message: t.statusText
                                }
                            }
                            ));
                            if (void 0 === t)
                                return;
                            this.camera.capabilities = t.capabilities
                        }
                        if (this._initializeBindings(),
                        this._startOrchidRecoveryEventHandling(),
                        this._resetTimeline(),
                        this._createEventSubscriptions(),
                        !se(this.camera.primaryStream)) {
                            const e = this.camera.primaryStream.dewarpConfiguration;
                            this.stream && e ? (this.dewarpConfig = e,
                            !0 !== this.dewarpConfig.enable && "true" !== this.dewarpConfig.enable || (this.dewarpMode = void 0 !== this.options.dewarpMode ? this.options.dewarpMode : 1)) : this.dewarpConfig = {
                                enable: !1
                            }
                        }
                        this.showLBM = this._PlayerModeService.isLbmAvailable(),
                        this._getSessionId(this.orchid).then((function() {
                            e._shouldCheckForSmartSearch() ? e._TimelineEventService.getSmartSearchStatus(e.orchid).then((function(t) {
                                e._smartSearchIsAvailable = t.available
                            }
                            )).catch((function() {
                                e._smartSearchIsAvailable = !1
                            }
                            )).finally((function() {
                                e.doNotStart || e._onStageResized(),
                                e.isThumbnailSearchAvailable && e.isSmartSearchAvailable ? e.controls = Rd.EXPANDER : e.isThumbnailSearchAvailable && !e.isSmartSearchAvailable || !e.isThumbnailSearchAvailable && e.isSmartSearchAvailable ? e.controls = Rd.SINGLE : e.isThumbnailSearchAvailable || e.isSmartSearchAvailable || (e.controls = Rd.NONE),
                                e.canPlayback || (e.controls = Rd.NONE)
                            }
                            )) : (e.isThumbnailSearchAvailable ? e.controls = Rd.SINGLE : e.controls = Rd.NONE,
                            e.canPlayback || (e.controls = Rd.NONE),
                            e.doNotStart || e._onStageResized())
                        }
                        )),
                        this._TimeService.getOrchidTimeInfoPromise(this.orchid.id).then((function(t) {
                            t ? (e._timeOffset = t.offset,
                            e._setServerTimezone(t)) : e._timeOffset = 0,
                            e._setPauseImage()
                        }
                        )),
                        this._updateTimeOffsetBound = this._updateTimeOffset.bind(this),
                        this._TimeService.addUpdateListener(this.orchid.id, this._updateTimeOffsetBound),
                        this.options.showTimeline && !se(this.camera.primaryStream) && void 0 !== this.orchid && void 0 !== this.camera.primaryStream.id && this._tryAddMotionRequest(this.id, this.orchid, this.camera.primaryStream.id),
                        this._perfTracker = this._PerformanceTrackerService.startTracking(this.orchid),
                        this.doNotStart && (this._UtilityService.postMessage({
                            message: Sd.GET_PANEL_STATUS,
                            type: "panel-status"
                        }),
                        this.showThumbnailSearchOverlay && this.toggleThumbnailSearch())
                    }
                }, {
                    key: "$onInit",
                    value: function() {
                        this._initPlayer(),
                        this._startPlayerResetEventHandling()
                    }
                }, {
                    key: "_shouldCheckForSmartSearch",
                    value: function() {
                        return void 0 !== this.camera.primaryStream && this.overlayState !== Ad.ERROR && (Va(this.camera.primaryStream).id !== Fa.CAMERA || this._cameraSideMotionDetectionIsAvailable)
                    }
                }, {
                    key: "_startOrchidRecoveryEventHandling",
                    value: function() {
                        var e = this;
                        const t = new St.x;
                        this.orchidRecoveryListener = this._$rootScope.$on("advancedRecover", (function(e, n) {
                            return t.next(n.oldOrchidId)
                        }
                        )),
                        t.pipe((0,
                        ra.h)((function(t) {
                            return t === e.orchid.id
                        }
                        )), (0,
                        oa.R)(this.destroyed$)).subscribe((function() {
                            return e.close()
                        }
                        ))
                    }
                }, {
                    key: "_stopOrchidRecoveryEventHandling",
                    value: function() {
                        this.orchidRecoveryListener()
                    }
                }, {
                    key: "_startPlayerResetEventHandling",
                    value: function() {
                        var e = this;
                        this._playerResetEventHandler = function(t) {
                            let {orchid: n, camera: i} = t;
                            e.orchid = n,
                            e.camera = i,
                            e.stream = i.primaryStream,
                            e.streamId = i.primaryStream.id,
                            e.source && (e.updateVolume(0),
                            e.source.stop(),
                            e.source = void 0),
                            e.clearSmartSearch(),
                            e._initPlayer()
                        }
                        ,
                        this._PlayerResetService.on(this._playerResetEventHandler)
                    }
                }, {
                    key: "_stopPlayerResetEventHandling",
                    value: function() {
                        this._PlayerResetService.off(this._playerResetEventHandler)
                    }
                }, {
                    key: "_initializeBindings",
                    value: function() {
                        this.msgs = {
                            ...L.messages.player,
                            unknown: L.messages.statisticKeys.player.unknown
                        },
                        this.playerType = this.options.availablePlayerModes[0],
                        this._diagnosticsCollector.updatePlayerTypeStats(this.playerType),
                        this._generateStats(),
                        this.streamOptions = [],
                        se(this.camera.primaryStream) || (this._normalizeCameraStreams(this.camera),
                        this._initializeStream()),
                        this.canPlayback = !0 === this.camera.permissions.actions.playback,
                        this.canPlayLive = !0 === this.camera.permissions.actions.live,
                        this.canPTZ = !0 === this.camera.permissions.actions.ptz,
                        this.ptzConfig = N(this.camera),
                        this.canManagePtzPresets = this._isAdministrator && this.options.canManagePtzPresets,
                        this.volumeAvailable = !1,
                        this.volume = 0
                    }
                }, {
                    key: "_normalizeCameraStreams",
                    value: function(e) {
                        if (!0 !== this._isOrchid)
                            return;
                        const t = [];
                        e.secondaryStreams.forEach((function(n) {
                            const i = e.streams.find((function(e) {
                                return n.id === e.id
                            }
                            ));
                            i ? Object.assign(n, i) : t.push(n.id)
                        }
                        )),
                        t.length > 0 && Fd("error", `No info for streams with ids [${t.join(", ")}].`, e)
                    }
                }, {
                    key: "_initializeStream",
                    value: function() {
                        var e = this;
                        const t = this._getPrimaryStreamOption(this.camera)
                          , n = this._getSecondaryStreamOptions(this.camera);
                        let i, a = this._filterStreamOptions(t, n);
                        if (a = this._sortStreamOptions(a),
                        this._populateStreamDescriptions(a),
                        this.webrtcIsAvailable ? this.streamOptions = a : this.streamOptions = [],
                        this.playerType === nn) {
                            const t = this.streamOptions.map((function(e) {
                                return e.stream
                            }
                            )).find((function(t) {
                                return e.streamId === t.id
                            }
                            ));
                            t && (i = t)
                        }
                        void 0 === i && (i = t,
                        this.playerType !== nn || t.isWebRtcCompatible || (this.lbmIsAvailable ? this._$timeout((function() {
                            e.togglePlayerMode(!1)
                        }
                        )) : a.length > 0 && (i = this.streamOptions[0])),
                        i = i.stream),
                        this._setStream(i)
                    }
                }, {
                    key: "$onDestroy",
                    value: function() {
                        this._isDestroying = !0,
                        this.isFullScreen && this.toggleFullScreen(),
                        this.options.showTimeline && this._TimelineEventService.removeMotionRequest(this.id),
                        this._reFetchSessionIdTimeout && this._$timeout.cancel(this._reFetchSessionIdTimeout),
                        this._$timeout.cancel(this._restartInterval),
                        this._$interval.cancel(this._noVideoInterval),
                        this._$interval.cancel(this._countdownInterval),
                        this._$interval.cancel(this._playerStatsInterval),
                        this._TimeService.removeUpdateListener(this.orchid.id, this._updateTimeOffsetBound),
                        this._playerResizeObserver.disconnect(),
                        this._unsubscribeEventSubscriptions(),
                        this._unsubscribeTimeline(),
                        this.options.showTimeline && this.timelineContext.unlinkPlayer(this.orchid.id, this),
                        !0 !== this.unlinked && !1 !== this.options.showTimeline || this._TimelineServiceFactory.releaseContext(this.id),
                        this.source && this.source.stop(),
                        this._stopPlayerResetEventHandling(),
                        this._stopOrchidRecoveryEventHandling(),
                        this._$element.remove(),
                        this._$window.removeEventListener("message", this._handleEventsViewerMessage),
                        this._perfTracker.done(),
                        this.destroyed$.next(),
                        this.destroyed$.complete()
                    }
                }, {
                    key: "_setStream",
                    value: function(e) {
                        this.stream = e,
                        this.streamId = e.id,
                        this._diagnosticsCollector.updateStreamId(this.streamId),
                        !this.id || this.id.startsWith("api") || this.id.startsWith("preview-") || this._StageService.persistPlayerStreamState(this.id, e.id)
                    }
                }, {
                    key: "_persistPlayerType",
                    value: function() {
                        this.id && this._StageService.persistPlayerLowBandwidthState(this.id, this.playerType === tn)
                    }
                }, {
                    key: "onFullScreenChanged",
                    value: function(e, t) {
                        this.overlayState !== Ad.DELAY && this.id !== t.controllerId && this.volumeAvailable && (t.isFullscreen ? (this._backgroundVolume = this.volume,
                        this.updateVolume(0),
                        null !== this.activeMicrophoneStream && (this.onMute(),
                        this.bidirectionalAudioEnabled = !1)) : (this.updateVolume(this._backgroundVolume),
                        delete this._backgroundVolume))
                    }
                }, {
                    key: "_getPlayerSize",
                    value: function() {
                        let e = this._$element[0].querySelector(".player-sizer")
                          , t = this._$window.devicePixelRatio;
                        return this._isDewarpAvailable() && 0 !== this.dewarpMode && (t *= 4),
                        {
                            height: Math.floor(e.offsetHeight * t),
                            width: Math.floor(e.offsetWidth * t),
                            aspectRatio: e.offsetWidth / e.offsetHeight
                        }
                    }
                }, {
                    key: "_hasSessionId",
                    value: function(e) {
                        return this._SessionIdService.hasSessionId(e)
                    }
                }, {
                    key: "_getSessionId",
                    value: function(e) {
                        var t = this;
                        return w.isOrchid || this._hasSessionId(this.orchid.id) ? Promise.resolve() : new Promise((function(n, i) {
                            t._SessionIdService.getSessionId$(e.id).subscribe((function() {
                                return n()
                            }
                            ), (function(e) {
                                t.error = {
                                    message: t.msgs.noSessionExistsFor({
                                        VALUE: t.orchid.name
                                    }),
                                    state: "not_available"
                                },
                                t._reFetchSessionIdTimeout = t._$timeout((function() {
                                    t._getSessionId(t.orchid).then((function() {
                                        t._restartPlayer()
                                    }
                                    ))
                                }
                                ), 5e3),
                                i()
                            }
                            ))
                        }
                        ))
                    }
                }, {
                    key: "_setPauseImage",
                    value: function() {
                        var e = this;
                        if (!this.timelineContext)
                            return;
                        const t = this.timelineContext.getCurrentState();
                        if (!1 === t.paused)
                            return;
                        this._setOverlayState(Ad.CONNECTING);
                        const n = this._getPlayerSize();
                        let i = 0;
                        i = t.speed > 0 && t.time >= Date.now() - 1e3 * this._liveBufferSeconds ? Date.now() - 1e3 * this._liveBufferSeconds : t.time;
                        const a = this._OrchidDataService.frameUrl(this.orchid, this.stream, this._applyOrchidOffset(i), n, !1);
                        this.pausedTime = i;
                        const r = new Image;
                        let s;
                        r.setAttribute("crossOrigin", "anonymous"),
                        r.src = a,
                        r.onload = function() {
                            e.aspectRatio = r.naturalWidth / r.naturalHeight,
                            e.playerType === nn ? (e._$element[0].querySelector(kd).src = "",
                            e._$element[0].querySelector(kd).setAttribute("poster", a),
                            s = document.createElement("canvas")) : s = e._$element[0].querySelector(Pd);
                            const t = s.getContext("2d");
                            s.height = r.naturalHeight,
                            s.width = r.naturalWidth,
                            t.drawImage(r, 0, 0, s.width, s.height),
                            e.image = s,
                            e._setOverlayState(Ad.NONE),
                            e._setPlayerState(Nd.Paused)
                        }
                        ,
                        r.onerror = function() {
                            e._setOverlayState(Ad.ERROR),
                            e.error = {
                                message: e.msgs.noFrameToDisplay()
                            }
                        }
                    }
                }, {
                    key: "_onStageResized",
                    value: function() {
                        if (this.options.showTimeline) {
                            if (this.timelineContext.getCurrentState().paused)
                                return
                        }
                        if (!this.stream)
                            return this._setOverlayState(Ad.ERROR),
                            void (this.error = {
                                message: this.msgs.noStreamsConfigured()
                            });
                        let e = this._getPlayerSize();
                        if (e.height === this._lastSize.height && e.width === this._lastSize.width)
                            return;
                        const t = e.width * e.height;
                        if (t > 5e5 ? this._setPlayerState(Nd.Large) : t > 5e4 ? this._setPlayerState(Nd.Medium) : this._setPlayerState(Nd.Small),
                        this.containerAspectRatio = e.aspectRatio,
                        this.source && !this.source.isAdaptive())
                            return;
                        if (this.overlayState === Ad.DELAY)
                            return;
                        if (0 !== this._lastSize.height && 0 !== this._lastSize.width && 0 !== this._lastSize.aspectRatio) {
                            if (Math.abs(e.aspectRatio - this._lastSize.aspectRatio) / Math.abs(this._lastSize.aspectRatio) * 100 < 10)
                                return
                        }
                        this._lastSize = e;
                        let n = {
                            playerType: this.playerType,
                            mode: this.mode,
                            target: this._getTarget(this.mode, this.playerType)
                        };
                        this._startPlaying(n)
                    }
                }, {
                    key: "close",
                    value: function() {
                        var e = this;
                        this.showThumbnailSearchOverlay && this.closeThumbnailSearch(),
                        this._$timeout((function() {
                            e.onClose(),
                            e._$rootScope.$broadcast("stageInteract"),
                            e.id && !e.id.startsWith("preview-") && e._StageService.removeCellById(e.id)
                        }
                        ))
                    }
                }, {
                    key: "canShowPlayerModeIcon",
                    get: function() {
                        return !1 !== this.options.showPlayerMode && (!(!this.lbmIsAvailable && this.streamOptions && this.streamOptions.length <= 1) && !!this.webrtcIsAvailable)
                    }
                }, {
                    key: "onPlayerModeClick",
                    value: function(e) {
                        if (this.showStreamSelectControls)
                            this._closeStreamSelect();
                        else {
                            if (0 === this.streamOptions.length)
                                return;
                            1 === this.streamOptions.length && this.streamOptions[0].isPrimary ? this.togglePlayerMode(!0) : (e.stopPropagation(),
                            this._openStreamSelect(this.camera))
                        }
                    }
                }, {
                    key: "_openStreamSelect",
                    value: function() {
                        this._closeAllMenus(),
                        this.showStreamSelectControls = !0
                    }
                }, {
                    key: "onStreamSelect",
                    value: function(e) {
                        if (this.volumeAvailable = !1,
                        this.volume = 0,
                        this._userSelectedStream = !0,
                        void 0 === e)
                            return this._closeStreamSelect(),
                            this.togglePlayerMode(!0);
                        if (this.playerType === tn && this.options.availablePlayerModes.length > 1 && this._incrementPlayerType(),
                        this._persistPlayerType(),
                        this._closeStreamSelect(),
                        this._setStream(e.stream),
                        this.timelineContext && this.timelineContext.getCurrentState().paused)
                            this._setPauseImage();
                        else {
                            const e = this._getPrePlayOptions();
                            this._startPlaying(e)
                        }
                    }
                }, {
                    key: "_closeStreamSelect",
                    value: function() {
                        this.showStreamSelectControls && (this.showStreamSelectControls = !1)
                    }
                }, {
                    key: "onHeaderClick",
                    value: function() {
                        this._closeStreamSelect()
                    }
                }, {
                    key: "_closeAllMenus",
                    value: function() {
                        this.showStreamSelectControls = !1,
                        this.showPtzControls = !1,
                        this.showDewarpControls = !1,
                        this.showStats = !1
                    }
                }, {
                    key: "_getPrimaryStreamOption",
                    value: function(e) {
                        const t = "PROXY_ONLY_MODE" !== e.primaryStream.recordingConfiguration.mode;
                        return new Ld(e.primaryStream,!0,t,this.isOnvif)
                    }
                }, {
                    key: "_getSecondaryStreamOptions",
                    value: function(e) {
                        var t = this;
                        return e.secondaryStreams.map((function(e) {
                            return new Ld(e,!1,e.recording,t.isOnvif)
                        }
                        ))
                    }
                }, {
                    key: "_sortStreamOptions",
                    value: function(e) {
                        const t = [...e];
                        return this.isOnvif ? (t.sort((function(e, t) {
                            const i = n(e)
                              , a = n(t)
                              , r = [i[0] - a[0], i[1] - a[1]].find((function(e) {
                                return 0 !== e
                            }
                            ));
                            return r || 0
                        }
                        )),
                        t.reverse()) : e;
                        function n(e) {
                            const t = [1, 1];
                            let n = e.stream.configuration.Video.Resolution.split("x");
                            return 2 !== n.length ? t : (n = n.map((function(e) {
                                return parseInt(e)
                            }
                            )),
                            n.includes(NaN) ? t : n)
                        }
                    }
                }, {
                    key: "_filterStreamOptions",
                    value: function(e, t) {
                        let n = [];
                        return n.push(e),
                        n = n.concat(t.filter((function(e) {
                            return e.isWebRtcCompatible
                        }
                        ))),
                        n
                    }
                }, {
                    key: "_populateStreamDescriptions",
                    value: function(e) {
                        var t = this;
                        if (e.map((function(e) {
                            e.isPrimary && e.description.push(t.msgs.primary())
                        }
                        )),
                        this.isOnvif) {
                            const n = {};
                            e.forEach((function(e) {
                                const t = e.stream.configuration.Video.Resolution;
                                n[t] = n[t] || [],
                                n[t].push(e)
                            }
                            )),
                            Object.values(n).forEach((function(e) {
                                if (e.length <= 1)
                                    return;
                                const n = function(e, t) {
                                    const n = e.map((function(e) {
                                        let n = e.stream.configuration.Video.FrameRate;
                                        return `${t.valueFps({
                                            VALUE: n
                                        })}`
                                    }
                                    ));
                                    if (a(n))
                                        return n;
                                    const i = e.map((function(e) {
                                        let t = parseFloat(e.stream.configuration.Video.BitRate);
                                        return 2147483647 === t ? t = 0 : t *= 1e3,
                                        (new Ja).transform(t.toString())
                                    }
                                    ));
                                    return a(i),
                                    i;
                                    function a(e) {
                                        const t = new Set;
                                        for (let n of e) {
                                            if (t.has(n))
                                                return !1;
                                            t.add(n)
                                        }
                                        return !0
                                    }
                                }(e, t.msgs);
                                for (let t = 0; t < n.length; t++)
                                    void 0 !== n[t] && e[t].description.push(n[t])
                            }
                            ))
                        }
                        return e
                    }
                }, {
                    key: "toggleStats",
                    value: function(e) {
                        this.showSmartSearch = !1,
                        this.showThumbnailSearchOverlay = !1,
                        this.previousDewarpMode && (this.setDewarpMode(this.previousDewarpMode),
                        this.previousDewarpMode = void 0),
                        this._setPlayerState(Nd.Stats),
                        this.showStats ? this.showStats = !1 : (this._closeAllMenus(),
                        this.showStats = !0)
                    }
                }, {
                    key: "toggleDewarp",
                    value: function() {
                        this.showSmartSearch = !1,
                        this._$element.removeClass(Nd.SmartSearch),
                        this.previousDewarpMode && (this.previousDewarpMode = void 0),
                        this.showDewarpControls ? this.showDewarpControls = !1 : (this._closeAllMenus(),
                        this.showDewarpControls = !0)
                    }
                }, {
                    key: "hasPlayerModeSelected",
                    get: function() {
                        return this.playerType === tn || this.showStreamSelectControls
                    }
                }, {
                    key: "togglePlayerMode",
                    value: function(e) {
                        if (this.volumeAvailable = !1,
                        this.volume = 0,
                        this.showSmartSearch && this.toggleSmartSearch(),
                        !1 === this.showLBM)
                            return void this._setOverlayState(Ad.UNSUPPORTED);
                        if (1 === this.options.availablePlayerModes.length)
                            return;
                        if (delete this.error,
                        this._incrementPlayerType(),
                        this.options.showTimeline && this.timelineContext.getCurrentState().paused)
                            return void this._setPauseImage();
                        this.playerType === tn && (this.showLiveMotionRegions = !1,
                        this._setStream(this.camera.primaryStream));
                        let t = this._getPrePlayOptions();
                        this._startPlaying(t),
                        e && this._persistPlayerType()
                    }
                }, {
                    key: "_incrementPlayerType",
                    value: function() {
                        var e = this;
                        let t = this.options.availablePlayerModes.findIndex((function(t) {
                            return t === e.playerType
                        }
                        ));
                        ++t >= this.options.availablePlayerModes.length && (t = 0),
                        this.playerType = this.options.availablePlayerModes[t],
                        this._diagnosticsCollector.updatePlayerTypeStats(this.playerType)
                    }
                }, {
                    key: "setDewarpMode",
                    value: function(e, t) {
                        if (!(e >= 0 && e <= 2))
                            throw new RangeError("dewarpMode must be 0, 1 or 2");
                        let n = this.playerType === tn && this.dewarpMode !== e && (0 === this.dewarpMode || 0 === e);
                        if (this.dewarpMode = e,
                        n) {
                            let e = this._getPrePlayOptions();
                            this._startPlaying(e)
                        }
                        this.id && !1 !== t && this._StageService.persistDewarpModeState(this.id, this.dewarpMode)
                    }
                }, {
                    key: "toggleLink",
                    value: function() {
                        var e = this;
                        if (!1 === this.options.showTimeline)
                            return;
                        this.unlinked = !this.unlinked,
                        this._setPlayerState(Nd.Unlinked);
                        let t = this.timelineContext.getCurrentState().time;
                        this._resetTimeline(),
                        !this.unlinked && this._TimelineServiceFactory.getContext("master").getPaused() ? this._$timeout((function() {
                            e._stopPlaying(),
                            e._setPauseImage()
                        }
                        )) : this._$timeout((function() {
                            e.unlinked && e.timelineContext.setTime(t, {
                                publish: !0
                            }),
                            e._startPlaying(e._getPrePlayOptions())
                        }
                        ))
                    }
                }, {
                    key: "toggleFullScreen",
                    value: function() {
                        var e = this;
                        this.isFullScreen = !this.isFullScreen,
                        this._setPlayerState(Nd.Transitioning),
                        this.isFullScreen || !this.showThumbnailSearchOverlay || this._isDestroying || this.toggleThumbnailSearch(),
                        this._MatrixService.toggleFullScreen({
                            target: this._$element[0]
                        });
                        let t = this.timelineContext.getCurrentState()
                          , n = {
                            controllerId: this.id,
                            linked: this.isFullScreen ? !this.unlinked : !this._wasUnlinked,
                            isFullscreen: this.isFullScreen,
                            state: t
                        };
                        this.isFullScreen ? (this._wasUnlinked = this.unlinked,
                        this.unlinked = !1) : this.unlinked = this._wasUnlinked,
                        this._resetTimeline(),
                        this.unlinked && this._$timeout((function() {
                            e.timelineContext.setTime(n.state.time, {
                                publish: !0
                            })
                        }
                        )),
                        this._$timeout((function() {
                            e._NGStageService.setFullscreenState(n),
                            e._setPlayerState(Nd.FullScreen)
                        }
                        )),
                        this.isFullScreen ? this._TimelineEventService.fullScreenPlayerId = this.id : this._TimelineEventService.fullScreenPlayerId = void 0
                    }
                }, {
                    key: "updateVolume",
                    value: function(e) {
                        this.volume = e,
                        this.source.setVolume(e)
                    }
                }, {
                    key: "toggleShowPtzControls",
                    value: function() {
                        this._setPlayerState(Nd.PTZ),
                        this.showPtzControls ? this.showPtzControls = !1 : (this._closeAllMenus(),
                        this.showPtzControls = !0),
                        this._isMobile && (this.noHideHeader = !this.noHideHeader)
                    }
                }, {
                    key: "canDisplayControls",
                    value: function() {
                        return this.options.showTimeline && this.overlayState === this.overlayStates.NONE && (this.mode === Od || this.mode === Dd)
                    }
                }, {
                    key: "_bindClassMethods",
                    value: function() {
                        this._onStats = this._onStats.bind(this),
                        this._onError = this._onError.bind(this),
                        this._onPacketLoss = this._onPacketLoss.bind(this),
                        this._onPauseChanged = this._onPauseChanged.bind(this),
                        this._onResize = this._onResize.bind(this),
                        this._onMotionRegions = this._onMotionRegions.bind(this),
                        this._onRip = this._onRip.bind(this),
                        this._onSpeedChanged = this._onSpeedChanged.bind(this),
                        this._onStateChange = this._onStateChange.bind(this),
                        this._onTimeChanged = this._onTimeChanged.bind(this),
                        this._onTrack = this._onTrack.bind(this),
                        this._hideSmartSearchDuringResize = this._hideSmartSearchDuringResize.bind(this),
                        this._showSmartSearchAfterResize = this._showSmartSearchAfterResize.bind(this),
                        this._handleEventsViewerMessage = this._handleEventsViewerMessage.bind(this)
                    }
                }, {
                    key: "_createEventSubscriptions",
                    value: function() {
                        var e = this;
                        this._$scope.$on("toggle-player-mode", (function(t) {
                            t.stopPropagation(),
                            e.togglePlayerMode(!0)
                        }
                        )),
                        this._$scope.$on("fullscreen-changed", this.onFullScreenChanged.bind(this));
                        const t = new St.x;
                        this._$scope.$on("resize.stage", (function() {
                            return t.next()
                        }
                        )),
                        t.pipe((0,
                        sa.b)((function() {
                            return e._hideSmartSearchDuringResize()
                        }
                        )), (0,
                        Zl.b)(500), (0,
                        oa.R)(this.destroyed$)).subscribe((function() {
                            e._onStageResized(),
                            e._showSmartSearchAfterResize()
                        }
                        )),
                        this._$window.addEventListener("message", this._handleEventsViewerMessage)
                    }
                }, {
                    key: "_hideSmartSearchDuringResize",
                    value: function() {
                        !0 === this.showSmartSearch && (this._resizingSmartSearch = !0,
                        this.showSmartSearch = !1)
                    }
                }, {
                    key: "_showSmartSearchAfterResize",
                    value: function() {
                        this._resizingSmartSearch && (this._resizingSmartSearch = !1,
                        this.showSmartSearch = !0)
                    }
                }, {
                    key: "_handleEventsViewerMessage",
                    value: function(e) {
                        e.data.event && e.data.event.type && e.data.event.message && ("panel-status" === e.data.event.type && (this._detailsPanelStatus = e.data.event.message),
                        e.data.event.message === Sd.DETAILS_PANEL_OPEN ? (this.showThumbnailSearchOverlay && this.toggleThumbnailSearch(),
                        this.controlsExpanded && window.parent.innerWidth <= 1024 && this.clickControlExpander()) : e.data.event.message === Sd.DETAILS_PANEL_CLOSE && this._thumbnailSearchQueued && (this._thumbnailSearchQueued = !1,
                        this._toggleThumbnailSearchOverlay()))
                    }
                }, {
                    key: "_unsubscribeEventSubscriptions",
                    value: function() {
                        this._$element.off("mouseenter"),
                        this._$element.off("mouseleave")
                    }
                }, {
                    key: "_applyOrchidOffset",
                    value: function(e) {
                        return e - this._timeOffset
                    }
                }, {
                    key: "_applyOrchidOffsetAndEvaluateLiveBuffer",
                    value: function(e) {
                        return 0 === e.time ? e.time : e.speed > 0 && e.time >= Date.now() - 1e3 * this._liveBufferSeconds ? 0 : this._applyOrchidOffset(e.time)
                    }
                }, {
                    key: "_onError",
                    value: function(e) {
                        var t = this;
                        Fd("error", e),
                        e.message && (this._diagnosticsCollector.playerError = e.message,
                        this._capturePerformanceStats()),
                        this.volumeAvailable = !1,
                        this._skipNextRipEvent = !1;
                        const n = this.stream.id === this.camera.primaryStream.id;
                        if (this.showThumbnailSearchOverlay && this.toggleThumbnailSearch(),
                        !e.isRecoverable) {
                            if ("IncompatibleError" !== e.name || n)
                                this.togglePlayerMode(!1);
                            else {
                                if (!1 === this._userSelectedStream && this.lbmIsAvailable && !w.singlePlayerMode)
                                    return void this.togglePlayerMode(!1);
                                void 0 !== e.mediaType ? this.error = {
                                    message: this.msgs.secondaryStreamsOfThisMediaTypeCanNotBePlayed({
                                        MEDIA_TYPE: e.mediaType
                                    })
                                } : this.error = {
                                    message: e.message
                                },
                                this._setOverlayState(Ad.ERROR)
                            }
                            return
                        }
                        this._errorRetryAttempts++;
                        let i = this.timelineContext ? this.timelineContext.getCurrentState() : {
                            time: 0
                        }
                          , a = this._applyOrchidOffsetAndEvaluateLiveBuffer(i);
                        new Promise((function(e, t) {
                            0 === a ? t() : e()
                        }
                        )).then((function() {
                            return t._getArchivesStartingAt(a)
                        }
                        )).then((function(e) {
                            return t._evaluateArchives(e, a)
                        }
                        )).catch((function() {
                            t._setOverlayState(Ad.ERROR),
                            t.error = {
                                ...e,
                                retryAttempts: t._errorRetryAttempts
                            },
                            t._restartPlayer(5)
                        }
                        ))
                    }
                }, {
                    key: "_restartPlayer",
                    value: function(e) {
                        var t = this;
                        this._$timeout.cancel(this._restartInterval),
                        this._restartInterval = this._$timeout((function() {
                            t._resumePlaying()
                        }
                        ), 1e3 * e)
                    }
                }, {
                    key: "_onPacketLoss",
                    value: function() {
                        this._$scope.$broadcast("show-bandwidth-warning")
                    }
                }, {
                    key: "_onResize",
                    value: function(e) {
                        this.aspectRatio = e.width / e.height,
                        this.dimensions = e
                    }
                }, {
                    key: "_onMotionRegions",
                    value: function(e) {
                        this.timelineContext ? !1 === this.timelineContext.getCurrentState().paused && (this.liveMotionRegions = e) : this.liveMotionRegions = e
                    }
                }, {
                    key: "_onStateChange",
                    value: function(e) {
                        var t = this;
                        "playing" === e ? (this._startCollectingPlayerStatistics(),
                        this._setOverlayState(Ad.NONE),
                        delete this.error,
                        this._errorRetryAttempts = 0,
                        this.waitingForVideo = !1,
                        this._setPlayerState(Nd.Playing),
                        this.source instanceof Td || (0,
                        Xl.S)(this.playingSourceStatsConnectionLoaded$.pipe((0,
                        pn.q)(1)), (0,
                        Kl.H)(3e3)).subscribe((function() {
                            return t._capturePerformanceStats()
                        }
                        ))) : "connecting" === e && this.mode !== Dd && (this._startTime = Date.now(),
                        this._resetStats(),
                        this._generateStats(),
                        this._setOverlayState(Ad.CONNECTING)),
                        this.mode !== Dd && this._postSinglePlayerMessage(e),
                        this.state = e
                    }
                }, {
                    key: "_capturePerformanceStats",
                    value: function() {
                        const e = this._diagnosticsCollector.generateStats();
                        let t = {
                            type: "stream-session-startup",
                            time: (new Date).getTime(),
                            details: {}
                        };
                        e && (this._populateDiagnosticsDetails(t.details, e),
                        this._populatePlaybackDetails(t.details, e)),
                        t.details.userAgent = window.navigator.userAgent,
                        t.details.proxied = this._OrchidDataService.webrtcSocketUrl(this.orchid).includes("orchid-proxy"),
                        this._perfTracker.post(t)
                    }
                }, {
                    key: "_populateDiagnosticsDetails",
                    value: function(e, t) {
                        e.playerId = t[this._playerStatisticsKeys.general][this._playerStatisticsKeys.playerId],
                        e.mode = t[this._playerStatisticsKeys.general][this._playerStatisticsKeys.mode],
                        e.streamId = t[this._playerStatisticsKeys.general][this._playerStatisticsKeys.streamId],
                        this._diagnosticsCollector.playerError || (e.playbackTime = t[this._playerStatisticsKeys.general][this._playerStatisticsKeys.playbackTime],
                        e.timeToPlayingMs = t[this._playerStatisticsKeys.general][this._playerStatisticsKeys.timeToPlay]),
                        e.startupError = this._diagnosticsCollector.playerError
                    }
                }, {
                    key: "_populatePlaybackDetails",
                    value: function(e, t) {
                        this._diagnosticsCollector.playerError || (e.timeToPlayingMs = t[this._playerStatisticsKeys.general][this._playerStatisticsKeys.timeToPlay]),
                        this._populateSourceStatistics(e)
                    }
                }, {
                    key: "_populateSourceStatistics",
                    value: function(e) {
                        if (this.playingSourceStatistics$.value) {
                            const t = this.playingSourceStatistics$.value
                              , n = t[this._webrtcStatisticsKeys.CONNECTION] ? t[this._webrtcStatisticsKeys.CONNECTION] : {};
                            e.timeToWsOpenMs = this.playerType === nn ? n[this._webrtcStatisticsKeys.TIME_TO_WS] : t[this._webSocketStatisticsKeys.timeToWebSocket],
                            e.timeToChosenPairMs = this.playerType === nn ? n[this._webrtcStatisticsKeys.TIME_TO_CHOSEN_PAIR] : null,
                            this.playerType === nn && this._populateWebRTCCandidates(e, n)
                        }
                    }
                }, {
                    key: "_populateWebRTCCandidates",
                    value: function(e, t) {
                        e.candidates = {
                            server: t[this._webrtcStatisticsKeys.REMOTE_CANDIDATES] ? t[this._webrtcStatisticsKeys.REMOTE_CANDIDATES].join(",") : null,
                            client: t[this._webrtcStatisticsKeys.LOCAL_CANDIDATES] ? t[this._webrtcStatisticsKeys.LOCAL_CANDIDATES].join(",") : null
                        };
                        const [n,i] = t[this._webrtcStatisticsKeys.CONNECTION] ? t[this._webrtcStatisticsKeys.CONNECTION].split("->").map((function(e) {
                            return e.trim()
                        }
                        )) : [null, null];
                        e.candidates.selectedServer = n,
                        e.candidates.selectedClient = i
                    }
                }, {
                    key: "_generateStats",
                    value: function() {
                        this.stats = this._statsCollector.generateStats(),
                        this.diagnostics = this._diagnosticsCollector.generateStats()
                    }
                }, {
                    key: "_resetStats",
                    value: function() {
                        this._statsCollector.reset(),
                        this._diagnosticsCollector.reset(),
                        this.playingSourceStatistics$.next(void 0)
                    }
                }, {
                    key: "_postSinglePlayerMessage",
                    value: function(e) {
                        var t;
                        t = e === Ll ? "playing" : e === Pl ? this.playerType === tn ? "play-jpeg" : "play-webrtc" : "stop",
                        this._UtilityService.postMessage({
                            component: "player",
                            type: t
                        })
                    }
                }, {
                    key: "_onStats",
                    value: function(e) {
                        !o().isUndefined(this.timelineContext) && this.timelineContext.getCurrentState().paused || (e.Audio && (e.Audio[this._webrtcStatisticsKeys.ENCODER] || (e.Audio[this._webrtcStatisticsKeys.ENCODER] = L.messages.statisticKeys.player.unknown())),
                        this.playingSourceStatistics$.next(e))
                    }
                }, {
                    key: "_onTrack",
                    value: function(e) {
                        if (e.supportsBidirectionalAudio) {
                            var t = !0;
                            this.camera.configuration.Talkdown && "false" === this.camera.configuration.Talkdown.enabled.trim().toLowerCase() && (t = !1),
                            this.showBidirectionalAudio = t && this._isLive()
                        } else
                            this.showBidirectionalAudio = !1;
                        "audio" === e.type && (this.volumeAvailable = this.options.showVolume),
                        "no_audio" === e.type && (this.volumeAvailable = !1),
                        this.showBidirectionalAudio && this.controls === Rd.EXPANDER && this._playerResizeObserver.observe(this._$element[0])
                    }
                }, {
                    key: "_onRip",
                    value: function(e, t) {
                        if (this.mode === Od) {
                            if (this._skipNextRipEvent)
                                return void (this._skipNextRipEvent = !1);
                            let e = this._getPrePlayOptions({
                                ripping: !0
                            });
                            this._startPlaying(e)
                        } else
                            this._seek(t)
                    }
                }, {
                    key: "_onSpeedChanged",
                    value: function(e, t) {
                        let n = t >= 0 ? Od : Dd;
                        if (this._skipNextRipEvent = !0,
                        n !== this.mode) {
                            let e = this._getPrePlayOptions({
                                ripping: t < 0
                            });
                            this._startPlaying(e)
                        } else {
                            if (t >= 0 && this._isLive())
                                return void (this.ptzAvailable = this._isPtzAvailable());
                            this._resumePlaying()
                        }
                    }
                }, {
                    key: "_isLive",
                    value: function() {
                        if (void 0 === this.timelineContext)
                            return !0;
                        let e = this.timelineContext.getCurrentState();
                        return 0 === this._applyOrchidOffsetAndEvaluateLiveBuffer(e)
                    }
                }, {
                    key: "_onTimeChanged",
                    value: function(e, t) {
                        this._$timeout.cancel(this._restartInterval),
                        this._errorRetryAttempts = 0;
                        let n = t.speed >= 0 ? Od : Dd;
                        if (this.onMute(),
                        n !== this.mode) {
                            let e = this.playerType === nn ? kd : Pd;
                            this._startPlaying({
                                playerType: this.playerType,
                                mode: n,
                                target: this._$element[0].querySelector(e)
                            })
                        } else {
                            t.paused && this.timelineContext.setPaused(!1, {
                                publish: !1
                            });
                            let e = {
                                time: this._applyOrchidOffsetAndEvaluateLiveBuffer(t),
                                speed: t.speed
                            };
                            this._resumePlaying(e)
                        }
                    }
                }, {
                    key: "_onPauseChanged",
                    value: function(e, t) {
                        if (this._setPlayerState(Nd.Paused),
                        t) {
                            if (this.pausedTime = this.timelineContext.getCurrentState().time,
                            this._pausePlaying(),
                            this.onMute(),
                            this.showMicrophoneSelector = !1,
                            this.showBidirectionalAudio = !1,
                            void 0 === this.source)
                                return;
                            const e = this.source.getVideoFrame();
                            if (e.resolution) {
                                const t = document.createElement("canvas");
                                t.width = e.resolution.width,
                                t.height = e.resolution.height,
                                t.getContext("2d").drawImage(e.target, 0, 0, t.width, t.height),
                                this.image = t
                            } else
                                this._setPauseImage()
                        } else
                            this.pausedTime = void 0,
                            this._startPlaying({
                                playerType: this.playerType,
                                mode: this.mode,
                                target: this._getTarget(this.mode, this.playerType)
                            })
                    }
                }, {
                    key: "_getTarget",
                    value: function(e, t) {
                        if (e === Dd)
                            return this._$element[0].querySelector(Pd);
                        let n;
                        if (void 0 !== this.options.availablePlayerModes.find((function(e) {
                            return e === t
                        }
                        )))
                            n = t === nn ? kd : Pd;
                        else {
                            if (void 0 === this.options.availablePlayerModes || 0 === this.options.availablePlayerModes.length)
                                return;
                            n = this.options.availablePlayerModes[0] === nn ? kd : Pd
                        }
                        return this._$element[0].querySelector(n)
                    }
                }, {
                    key: "_subscribeTimeline",
                    value: function() {
                        this.timelineContext && (this._timelineSubscriptions.deregisterOnPauseChanged = this.timelineContext.on("pause-changed", this._onPauseChanged),
                        this._timelineSubscriptions.deregisterOnRip = this.timelineContext.on(Dd, this._onRip),
                        this._timelineSubscriptions.deregisterOnSpeedChanged = this.timelineContext.on("speed-changed", this._onSpeedChanged),
                        this._timelineSubscriptions.deregisterOnTimeChanged = this.timelineContext.on("time-changed", this._onTimeChanged))
                    }
                }, {
                    key: "_unsubscribeTimeline",
                    value: function() {
                        this.timelineContext && (this.timelineContext.off(this._timelineSubscriptions.deregisterOnPauseChanged),
                        this.timelineContext.off(this._timelineSubscriptions.deregisterOnRip),
                        this.timelineContext.off(this._timelineSubscriptions.deregisterOnSpeedChanged),
                        this.timelineContext.off(this._timelineSubscriptions.deregisterOnTimeChanged),
                        this.timelineContext.unlinkPlayer(this.orchid.id, this),
                        "master" !== this.timelineContext.id && this._TimelineServiceFactory.releaseContext(this.timelineContext.id))
                    }
                }, {
                    key: "_resetTimeline",
                    value: function() {
                        var e = this;
                        this.options.showTimeline && !this._isDestroying && (this._unsubscribeTimeline(),
                        !0 === this.unlinked ? this.timelineContext = this._TimelineServiceFactory.createContext(this.id, this.orchid, this.camera) : this.timelineContext = this._TimelineServiceFactory.getContext("master"),
                        this.timelineContext.linkPlayer(this.orchid, this),
                        this._subscribeTimeline(),
                        !0 === this.unlinked ? setTimeout((function() {
                            const t = e.timelineContext
                              , n = e._TimelineEventService.isolateTimeline(e.id, (function() {
                                const e = t.getCurrentState();
                                return null === e ? null : {
                                    minSegment: t.getTimeLengthFromPixels(1 / 3),
                                    speed: e.speed,
                                    start: e.fineTime.start,
                                    stop: e.fineTime.stop,
                                    time: e.time
                                }
                            }
                            ), e.smartSearchCanvasSize, e._toSearchRegions(e.smartSearchRegionBounds));
                            e.timelineContext.subscribeEventSource(n.events$),
                            e._oldTimelineEventService = e._TimelineEventService,
                            e._TimelineEventService = n
                        }
                        )) : void 0 !== this._oldTimelineEventService && setTimeout((function() {
                            e._TimelineEventService.setTimelineStateFn(void 0),
                            e._TimelineEventService.removeMotionRequest(e.id),
                            e._TimelineEventService = e._oldTimelineEventService,
                            delete e._oldTimelineEventService,
                            e.isFullScreen ? e._TimelineEventService.fullScreenPlayerId = e.id : e._TimelineEventService.fullScreenPlayerId = void 0,
                            0 === e.smartSearchRegionBounds.length ? e._tryAddMotionRequest(e.id, e.orchid, e.camera.primaryStream.id) : e._tryAddMotionRequest(e.id, e.orchid, e.camera.primaryStream.id, e.smartSearchCanvasSize, e._toSearchRegions(e.smartSearchRegionBounds))
                        }
                        )))
                    }
                }, {
                    key: "_getPrePlayOptions",
                    value: function(e) {
                        let t = {
                            playerType: this.playerType,
                            mode: Od,
                            target: void 0
                        }
                          , n = this.options.showTimeline ? this.timelineContext.getCurrentState().speed : 1
                          , i = this.playerType === nn ? kd : Pd;
                        return (n < 0 || e && e.ripping) && (t.playerType = tn,
                        t.mode = Dd,
                        i = Pd),
                        t.target = this._$element[0].querySelector(i),
                        t
                    }
                }, {
                    key: "_getPlayOptions",
                    value: function(e) {
                        let t = {
                            time: 0,
                            speed: 1,
                            paused: !1,
                            waitThreshold: Md
                        };
                        if (this.options.showTimeline) {
                            let e = this.timelineContext.getCurrentState();
                            t.time = this._applyOrchidOffsetAndEvaluateLiveBuffer(e),
                            t.paused = e.paused && this.mode !== Dd,
                            t.speed = e.speed,
                            t.waitThreshold = Md * e.speed
                        }
                        return e && (re(e.time) || (t.time = e.time),
                        re(e.speed) || (t.speed = e.speed),
                        re(e.paused) || (t.paused = e.paused)),
                        t.isLive = 0 === t.time,
                        this._diagnosticsCollector.updatePlaybackTime(t.time),
                        t
                    }
                }, {
                    key: "_checkConfiguration",
                    value: function(e) {
                        if (!this.stream || void 0 === this.stream.id)
                            throw {
                                message: this.msgs.noStreamsConfigured(),
                                state: "not_available"
                            };
                        if (e.isLive && this.playerType === tn) {
                            if ("PROXY_ONLY_MODE" === this.stream.recordingConfiguration.mode)
                                throw {
                                    message: this.msgs.cannotPlayProxyOnlyStreamInLB(),
                                    state: "not_available"
                                };
                            if ("EMBEDDED_LITE_MODE" === this.stream.recordingConfiguration.mode)
                                throw {
                                    message: this.msgs.cannotPlayLBStreamsWithoutMotionDetection(),
                                    state: "not_available"
                                }
                        }
                    }
                }, {
                    key: "_checkOrchidCompatibility",
                    value: function() {
                        if (!0 !== this._isOrchid && !0 !== this.orchid.isCompatibleVersion)
                            throw {
                                message: this.msgs.unsupportedOrchid(),
                                state: "not_available"
                            }
                    }
                }, {
                    key: "_checkPermissions",
                    value: function(e) {
                        if (this.orchid.permissions && !this._hasSessionId(this.orchid.id))
                            throw {
                                message: this.msgs.noSessionExistsFor({
                                    VALUE: this.orchid.name
                                }),
                                state: "not_available"
                            };
                        this.dewarpAvailable = this._isDewarpAvailable(),
                        this.ptzAvailable = this._isPtzAvailable();
                        let t = e.isLive ? this.canPlayLive : this.canPlayback
                          , n = e.isLive ? this.msgs.doNotHavePermissionThisStream.liveStream() : this.msgs.doNotHavePermissionThisStream.playback();
                        if (!t)
                            throw {
                                message: n,
                                state: "not_available"
                            }
                    }
                }, {
                    key: "_isDewarpAvailable",
                    value: function() {
                        return this.dewarpConfig && this.options.showDewarp && (!0 === this.dewarpConfig.enable || "true" === this.dewarpConfig.enable)
                    }
                }, {
                    key: "_isPtzAvailable",
                    value: function() {
                        let e = !0
                          , t = 1
                          , n = !1;
                        if (this.options.showTimeline) {
                            let i = this.timelineContext.getCurrentState()
                              , a = this._applyOrchidOffsetAndEvaluateLiveBuffer(i);
                            e = this.mode === Od && 0 === a,
                            t = i.speed,
                            n = i.paused
                        }
                        return this.canPTZ && F(this.camera) && this.options.showPtz && e && 1 === t && !n
                    }
                }, {
                    key: "_startPlaying",
                    value: function(e) {
                        var t = this;
                        this.onMute(),
                        this.showMicrophoneSelector = !1,
                        this.showBidirectionalAudio = !1,
                        this._setPlayerState(Nd.Unpaused),
                        this._clearCountdown(),
                        this._clearNoVideoInterval(),
                        this._clearCanvas(),
                        this._prePlay(e).then((function() {
                            return t._play(t._getPlayOptions())
                        }
                        )).then((function() {
                            return t._postPlay()
                        }
                        )).catch((function(e) {}
                        ))
                    }
                }, {
                    key: "_seek",
                    value: function(e) {
                        this._play(this._getPlayOptions({
                            time: this._applyOrchidOffset(e)
                        }))
                    }
                }, {
                    key: "_resumePlaying",
                    value: function(e) {
                        this._clearCountdown(),
                        this._clearNoVideoInterval(),
                        this._stopCollectingPlayerStatistics(),
                        this._play(this._getPlayOptions(e))
                    }
                }, {
                    key: "_stopPlaying",
                    value: function() {
                        return this._clearCountdown(),
                        this._clearNoVideoInterval(),
                        this._stopCollectingPlayerStatistics(),
                        this.source.stop()
                    }
                }, {
                    key: "_pausePlaying",
                    value: function() {
                        this._stopCollectingPlayerStatistics(),
                        this.overlayState === Ad.CONNECTING && this._setOverlayState(Ad.NONE),
                        this.ptzAvailable = this._isPtzAvailable(),
                        this.source && this.source.pause()
                    }
                }, {
                    key: "_prePlay",
                    value: function(e) {
                        var t = this;
                        return this._$timeout.cancel(this._restartInterval),
                        this._stopCollectingPlayerStatistics(),
                        this._resetSource(e).then((function() {
                            t.options.showTimeline && t.timelineContext.getCurrentState().paused && t.source.clear(),
                            t.mode = e.mode
                        }
                        ))
                    }
                }, {
                    key: "_play",
                    value: function(e) {
                        try {
                            if (this._stopCollectingPlayerStatistics(),
                            this._checkOrchidCompatibility(),
                            this._checkPermissions(e),
                            this._checkConfiguration(e),
                            e.paused)
                                return Promise.resolve();
                            if (!this.source) {
                                const e = {
                                    playerType: this.playerType,
                                    mode: this.mode,
                                    target: this._getTarget(this.mode, this.playerType)
                                };
                                this._resetSource(e)
                            }
                            return this.liveMotionRegions && this.liveMotionRegions.regions && this.liveMotionRegions.regions.length > 0 && this._onMotionRegions({
                                regions: [],
                                timeEpochMs: Date.now()
                            }),
                            this.image = void 0,
                            this.source.play(e.time, e.speed, e.waitThreshold).catch((function(e) {}
                            ))
                        } catch (e) {
                            void 0 === this.options.availablePlayerModes || 0 === this.options.availablePlayerModes.length ? this._setOverlayState(Ad.UNSUPPORTED) : (this.state = "error",
                            this._setOverlayState(Ad.ERROR),
                            this.error = e)
                        }
                    }
                }, {
                    key: "_postPlay",
                    value: function() {
                        return this._skipNextRipEvent = !1,
                        this.timelineContext.getCurrentState().paused && this._onPauseChanged(void 0, !0),
                        Promise.resolve()
                    }
                }, {
                    key: "_resetSource",
                    value: function(e) {
                        this._unsubscribePlayingSource();
                        let t = this._getPlayerSize()
                          , n = e.mode === Dd ? Dd : e.playerType;
                        return this._target = e.target,
                        void 0 !== n && void 0 !== this.stream && (this.source = this._sourceFactory.create(n, e.target, this.orchid, this.stream, t, this._OrchidDataService),
                        this.updateVolume(this.volume),
                        this._subscribePlayingSource()),
                        Promise.resolve()
                    }
                }, {
                    key: "_unsubscribePlayingSource",
                    value: function() {
                        this.source && (this.source.stop(),
                        this.source.off($l, this._onStats),
                        this.source.off(Ul, this._onStateChange),
                        this.source.off(Nl, this._onError),
                        this.source.off(Gl, this._onTrack),
                        this.source.off(Vl, this._onPacketLoss),
                        this.source.off(Fl, this._onResize),
                        this.source.off(Bl, this._onMotionRegions))
                    }
                }, {
                    key: "_subscribePlayingSource",
                    value: function() {
                        this.source && (this.source.on($l, this._onStats),
                        this.source.on(Ul, this._onStateChange),
                        this.source.on(Nl, this._onError),
                        this.source.on(Gl, this._onTrack),
                        this.source.on(Vl, this._onPacketLoss),
                        this.source.on(Fl, this._onResize),
                        this.source.on(Bl, this._onMotionRegions))
                    }
                }, {
                    key: "_getArchivesStartingAt",
                    value: function(e) {
                        return this._OrchidDataService.fetchArchiveAt(e, this.stream.id, this.orchid, 2).then((function(e) {
                            return e.data.archives
                        }
                        ))
                    }
                }, {
                    key: "_evaluateArchives",
                    value: function(e, t) {
                        let n = e.find((function(e) {
                            return e.start - Md < t && (e.end > t + Md || e.active)
                        }
                        ))
                          , i = e.find((function(e) {
                            return e.start > t
                        }
                        ));
                        return n ? Promise.reject(this.msgs.expectedArchiveIsNotPlayable()) : i ? (this._clearNoVideoInterval(),
                        this._displayCountdownToNextArchive(i)) : this._displayNoVideo()
                    }
                }, {
                    key: "_clearNoVideoInterval",
                    value: function() {
                        this._$interval.cancel(this._noVideoInterval),
                        this._setOverlayState(Ad.NONE)
                    }
                }, {
                    key: "_displayNoVideo",
                    value: function() {
                        return delete this.error,
                        this._setOverlayState(Ad.NO_VIDEO),
                        this._noVideoInterval = this._$interval(this._checkForVideo.bind(this), 1e3),
                        Promise.resolve()
                    }
                }, {
                    key: "_checkForVideo",
                    value: function() {
                        var e = this;
                        let t = this._applyOrchidOffset(this.timelineContext.getTime());
                        this._getArchivesStartingAt(t).then((function(t) {
                            t.length > 0 && (e._clearNoVideoInterval(),
                            e._displayCountdownToNextArchive(t[0]))
                        }
                        ))
                    }
                }, {
                    key: "_clearCountdown",
                    value: function() {
                        this._$interval.cancel(this._countdownInterval),
                        this._setOverlayState(Ad.NONE),
                        delete this.countdownPercentComplete,
                        delete this.countdownTimeRemaining
                    }
                }, {
                    key: "_clearCanvas",
                    value: function() {
                        const e = document.querySelector(Pd);
                        if (e) {
                            e.getContext("2d").clearRect(0, 0, e.width, e.height)
                        }
                    }
                }, {
                    key: "_setOverlayState",
                    value: function(e) {
                        this.overlayState = e,
                        e !== Ad.NONE && (this._muteBidirectionalAudio$.next(),
                        this.showBidirectionalAudio = !1,
                        this.showMicrophoneSelector = !1),
                        e !== Ad.ERROR && e !== Ad.DELAY && e !== Ad.NO_VIDEO || this._setPlayerState(Nd.Error)
                    }
                }, {
                    key: "_displayCountdownToNextArchive",
                    value: function(e) {
                        var t = this;
                        delete this.error,
                        this._setOverlayState(Ad.DELAY);
                        let n = this._applyOrchidOffset(this.timelineContext.getTime())
                          , i = e.start - n;
                        return this._$interval.cancel(this._countdownInterval),
                        this._stopCollectingPlayerStatistics(),
                        this._countdownInterval = this._$interval((function() {
                            let n = t.timelineContext.getCurrentState()
                              , a = t._applyOrchidOffset(n.time);
                            if (t.countdownTimeRemaining = (e.start - a) / n.speed,
                            t.countdownPercentComplete = 100 - (e.start - a) / i * 100,
                            t.countdownTimeRemaining < 1500) {
                                let i = {
                                    time: e.start - 1500 * n.speed,
                                    speed: n.speed
                                };
                                t._resumePlaying(i)
                            }
                        }
                        ), 100),
                        Promise.resolve()
                    }
                }, {
                    key: "_stopCollectingPlayerStatistics",
                    value: function() {
                        this._$interval.cancel(this._playerStatsInterval)
                    }
                }, {
                    key: "_startCollectingPlayerStatistics",
                    value: function() {
                        var e = this;
                        this._resetStats(),
                        this.mode !== Dd && this._diagnosticsCollector.updatePlayTimeStats(this._startTime),
                        this._generateStats(),
                        void 0 !== this.timelineContext && !1 !== this.timelineContext.getCurrentState().paused || (this._playerStatsInterval && this._$interval.cancel(this._playerStatsInterval),
                        this._playerStatsInterval = this._$interval((function() {
                            e._generateStats()
                        }
                        ), 1e3))
                    }
                }, {
                    key: "webrtcIsAvailable",
                    get: function() {
                        return this.options.availablePlayerModes.includes(nn)
                    }
                }, {
                    key: "lbmIsAvailable",
                    get: function() {
                        return this.options.availablePlayerModes.includes(tn)
                    }
                }, {
                    key: "isOnvif",
                    get: function() {
                        return this.camera.driver === Q.ONVIF
                    }
                }, {
                    key: "isSmartSearchAvailable",
                    get: function() {
                        return this._smartSearchIsAvailable
                    }
                }, {
                    key: "isThumbnailSearchAvailable",
                    get: function() {
                        return this._thumbnailSearchIsAvailable
                    }
                }, {
                    key: "_setPlayerState",
                    value: function(e) {
                        switch (e) {
                        case Nd.Playing:
                            this._$element.removeClass(Nd.Error);
                            break;
                        case Nd.Error:
                            this._$element.addClass(Nd.Error);
                            break;
                        case Nd.Small:
                        case Nd.Medium:
                        case Nd.Large:
                            this._$element.removeClass(`${Nd.Small} ${Nd.Medium} ${Nd.Large}`),
                            this._$element.addClass(e);
                            break;
                        case Nd.PTZ:
                            this._$element.removeClass(`${Nd.SmartSearch} ${Nd.Stats}`),
                            this._$element.toggleClass(Nd.PTZ),
                            this.showSmartSearch = !1,
                            this.showThumbnailSearchOverlay = !1,
                            this.previousDewarpMode && (this.setDewarpMode(this.previousDewarpMode),
                            this.previousDewarpMode = void 0);
                            break;
                        case Nd.SmartSearch:
                            this._$element.removeClass(`${Nd.PTZ} ${Nd.Stats}`),
                            this._$element.toggleClass(Nd.SmartSearch),
                            this.showSmartSearch = this._$element.hasClass(Nd.SmartSearch);
                            break;
                        case Nd.ThumbnailSearch:
                            this._$element.removeClass(`${Nd.PTZ} ${Nd.Stats}`),
                            this._$element.toggleClass(`${Nd.ThumbnailSearch}`),
                            this.showThumbnailSearchOverlay = this._$element.hasClass(Nd.ThumbnailSearch),
                            this.showMicrophoneSelector = !1;
                            break;
                        case Nd.Transitioning:
                            this._$element.addClass(Nd.Transitioning);
                            break;
                        case Nd.Unlinked:
                            this._$element.toggleClass(Nd.Unlinked);
                            break;
                        case Nd.FullScreen:
                            this._$element.removeClass(Nd.Transitioning),
                            this._$element.toggleClass(Nd.FullScreen);
                            break;
                        case Nd.Stats:
                            this._$element.removeClass(`${Nd.PTZ} ${Nd.SmartSearch}`),
                            this._$element.toggleClass(Nd.Stats);
                            break;
                        case Nd.Paused:
                            this._$element.addClass(Nd.Paused);
                            break;
                        case Nd.Unpaused:
                            this._$element.removeClass(Nd.Paused);
                            break;
                        default:
                            Fd.warn(`Unsupported player state ${e}`)
                        }
                    }
                }, {
                    key: "handleMinutePreviewClick",
                    value: function(e) {
                        window.innerWidth <= 767 && this.toggleThumbnailSearch(),
                        this.timelineContext.setTime(e, {
                            publish: !0
                        })
                    }
                }, {
                    key: "clickControlExpander",
                    value: function() {
                        this.controlsExpanded = !this.controlsExpanded,
                        this.controlsExpanded && this.bidirectionalAudioEnabled && this._$element[0].offsetWidth < 640 && this.toggleBidirectionalAudio(),
                        this.controlsExpanded && this.doNotStart && window.parent.innerWidth <= 1024 && this._UtilityService.postMessage({
                            message: Sd.CONTROL_OPEN,
                            type: "panel-status"
                        })
                    }
                }, {
                    key: "_toggleThumbnailSearchOverlay",
                    value: function() {
                        var e = this;
                        this.showThumbnailSearchOverlay || (this.wasFullScreen = this.isFullScreen,
                        this._closeAllMenus()),
                        this.showThumbnailSearchOverlay || this.showSmartSearch || (this.previousDewarpMode = this.dewarpMode,
                        this.setDewarpMode(0, !1)),
                        this.showThumbnailSearchOverlay && !this.showSmartSearch && this.setDewarpMode(this.previousDewarpMode),
                        this.showThumbnailSearchOverlay ? this._$timeout((function() {
                            e.thumbnailSearchDisabled = !0
                        }
                        ), 500) : this.thumbnailSearchDisabled = !1,
                        this._setPlayerState(Nd.ThumbnailSearch),
                        this.id.startsWith("api") || (!this.isFullScreen && this.showThumbnailSearchOverlay ? this.toggleFullScreen() : this.showThumbnailSearchOverlay || this.wasFullScreen || !this.isFullScreen || this.toggleFullScreen())
                    }
                }, {
                    key: "toggleThumbnailSearch",
                    value: function() {
                        var e = this;
                        !this.showThumbnailSearchOverlay && this.doNotStart ? this._UtilityService.postMessage({
                            message: Sd.THUMBNAIL_SEARCH_OPEN,
                            type: "panel-status"
                        }) : this.showThumbnailSearchOverlay && this.doNotStart && this._$timeout((function() {
                            e._UtilityService.postMessage({
                                message: Sd.THUMBNAIL_SEARCH_CLOSE,
                                type: "panel-status"
                            })
                        }
                        ), 500),
                        this._detailsPanelStatus !== Sd.DETAILS_PANEL_OPEN || this.showThumbnailSearchOverlay ? this._toggleThumbnailSearchOverlay() : this._thumbnailSearchQueued = !0
                    }
                }, {
                    key: "toggleSmartSearch",
                    value: function() {
                        if (!1 !== this.showSmartSearch || this.showThumbnailSearchOverlay ? !0 !== this.showSmartSearch || this.showThumbnailSearchOverlay || this.setDewarpMode(this.previousDewarpMode) : (this.previousDewarpMode = this.dewarpMode,
                        this.setDewarpMode(0, !1)),
                        this._closeAllMenus(),
                        this.digitalPtzPosition.scale = 1,
                        this._setPlayerState(Nd.SmartSearch),
                        this.showSmartSearch) {
                            const e = this.timelineContext.getCurrentState();
                            this._TimelineEventService.prewarm(this.orchid, this.camera.primaryStream.id, e.fineTime.start, e.fineTime.stop)
                        }
                    }
                }, {
                    key: "clearSmartSearch",
                    value: function() {
                        this._TimelineEventService.removeMotionRequest(this.id),
                        this.smartSearchRegionBounds = [],
                        this._tryAddMotionRequest(this.id, this.orchid, this.camera.primaryStream.id),
                        this._setPlayerState(Nd.SmartSearch),
                        this.showSmartSearch = !1,
                        this._$element.removeClass(Nd.SmartSearch),
                        this.previousDewarpMode && !this.showThumbnailSearchOverlay && (this.setDewarpMode(this.previousDewarpMode),
                        this.previousDewarpMode = void 0)
                    }
                }, {
                    key: "onSmartSearchRegionsChanged",
                    value: function(e) {
                        this.smartSearchRegionBounds = e.regions,
                        this.smartSearchCanvasSize = {
                            height: e.size.height,
                            width: e.size.width
                        },
                        0 === e.regions.length ? this._tryAddMotionRequest(this.id, this.orchid, this.camera.primaryStream.id) : this._tryAddMotionRequest(this.id, this.orchid, this.camera.primaryStream.id, this.smartSearchCanvasSize, this._toSearchRegions(this.smartSearchRegionBounds))
                    }
                }, {
                    key: "_toSearchRegions",
                    value: function(e) {
                        return e.map((function(e, t) {
                            return {
                                vertices: e.map((function(e) {
                                    return {
                                        x: e.x,
                                        y: e.y
                                    }
                                }
                                ))
                            }
                        }
                        ))
                    }
                }, {
                    key: "_tryAddMotionRequest",
                    value: function(e, t, n, i, a) {
                        this.camera.permissions.actions.playback && this._TimelineEventService.addMotionRequest(e, t, n, i, a)
                    }
                }, {
                    key: "toggleBidirectionalAudio",
                    value: function() {
                        var e = this;
                        this.bidirectionalAudioEnabled ? (this.bidirectionalAudioEnabled = !1,
                        this.bidirectionalAudioMuted = !0,
                        this.showMicrophoneSelector = !1) : navigator.mediaDevices ? this._audioInputService.requestMicrophonePermission().then((function(t) {
                            "denied" === t && qs.show(e._matDialog, {
                                maxWidth: 400,
                                disableClose: !0,
                                data: {
                                    confirmText: e.msgs.ok(),
                                    content: Ed
                                }
                            }),
                            "prompt" === t && qs.show(e._matDialog, {
                                maxWidth: 400,
                                disableClose: !0,
                                data: {
                                    confirmText: e.msgs.ok(),
                                    content: _d
                                }
                            }),
                            "granted" === t && (e.bidirectionalAudioEnabled = !0,
                            e._$element[0].offsetWidth < 640 && (e.controlsExpanded = !1))
                        }
                        )) : this._matDialog.open(Id, {
                            data: {
                                message: this.msgs.bidirectionalAudio.secureContextNotice(),
                                okText: this.msgs.ok(),
                                hideTitle: !0
                            }
                        })
                    }
                }, {
                    key: "shouldShowLBMLink",
                    value: function() {
                        return !!this.camera.active && (this.error.retryAttempts > 2 && "lowbandwidth" !== this.playerType && this.showLBM)
                    }
                }, {
                    key: "toggleShowLiveMotionRegions",
                    value: function() {
                        this.showLiveMotionRegions = !this.showLiveMotionRegions,
                        this.showStats = !1
                    }
                }]),
                e
            }();
            function $d(e) {
                return {
                    openDialog: function(t) {
                        return function(t) {
                            return e.show(t)
                        }(t)
                    }
                }
            }
            Ud.$inject = ["$scope", "$rootScope", "$element", "$timeout", "$interval", "$window", "$mdDialog", "AuthenticationService", "OrchidDataService", "StageService", "PubSub", "MatrixService", "TimelineServiceFactory", "PlayingSourceFactory", "BrowserInfoService", "PlayerModeService", "UtilityService", "TimeService", "TimelineEventService", "SessionIdService", "PerformanceTrackerService", "PlayerResetService", "NGStageService", "FeatureFlagService", "MatDialog", "MinimumVersionService", "AudioInputService"],
            Ud.template = n(82952),
            Ud.controller = Ud,
            Ud.controllerAs = "player",
            Ud.bindings = {
                id: "@",
                cameraName: "@",
                orchid: "=",
                camera: "=",
                streamId: "=?",
                doNotStart: "=?",
                onClose: "&",
                options: "="
            },
            o().module("ipconfigure.orchid.singularity").component("player", Ud),
            angular.module("ipconfigure.orchid.singularity").factory("LegacyDialogService", $d),
            $d.$inject = ["$mdDialog"],
            angular.module("ipconfigure.orchid.singularity").service("ControlledShutdownService", Ea);
            const jd = L.messages
              , Vd = O("InactivityMonitorService");
            class Gd {
                constructor(e, t, n, i, a, r) {
                    this.$timeout = e,
                    this.$document = t,
                    this.$rootScope = n,
                    this.$mdDialog = i,
                    this.$interval = a,
                    this.MatDialog = r,
                    this._thresholdMillis = 0,
                    this._warningSeconds = 0,
                    this._restartActivityMonitorBound = this._restartActivityMonitor.bind(this),
                    this.activityThresholdExceededBound = this.activityThresholdExceeded.bind(this)
                }
                start(e=0, t=-1) {
                    e <= 0 || t < 0 || (Vd("debug", `Starting activity monitor with threshold of ${e} minutes`),
                    this._thresholdMillis = 1e3 * e * 60,
                    this._warningSeconds = t,
                    this.$document.on("keydown", this._restartActivityMonitorBound),
                    this.$document.on("mousemove", this._restartActivityMonitorBound),
                    this.$document.on("click", this._restartActivityMonitorBound),
                    this.$document.on("visibilitychange", this._restartActivityMonitorBound),
                    this._restartActivityMonitor())
                }
                _cancelWarning() {
                    this._warningCountdownPromise && (this.$interval.cancel(this._warningCountdownPromise),
                    delete this._warningCountdownPromise)
                }
                _restartActivityMonitor() {
                    this._warningCountdownPromise || (this.$timeout.cancel(this._activityMonitorPromise),
                    this._activityMonitorPromise = this.$timeout(this.activityThresholdExceededBound, this._thresholdMillis))
                }
                _logUserOut() {
                    this._warningCountdownPromise && this.$mdDialog.hide(!1);
                    const e = this.$document.find("md-dialog").length;
                    for (let t = 0; t < e; t++)
                        this.$mdDialog.cancel();
                    this.MatDialog.closeAll(),
                    this.$timeout.cancel(this._activityMonitorPromise),
                    this._cancelWarning(),
                    this.$rootScope.$broadcast("logout")
                }
                _warnUser() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const e = {
                            disableClose: !0,
                            panelClass: "inactivity-dialog",
                            data: {
                                confirmText: jd.inactivityMonitor.continueSession(),
                                message: jd.inactivityMonitor.yourSessionIsTimingOutDueToInactivityItWillExpireInCOUNTSeconds({
                                    COUNT: this._warningSeconds
                                })
                            }
                        };
                        (0,
                        dt.z)(qs.show(this.MatDialog, e)).then((e => {
                            e && (this._cancelWarning(),
                            this._restartActivityMonitor())
                        }
                        )),
                        this._warningCountdownPromise = this.$interval((t => e.data.message = jd.inactivityMonitor.yourSessionIsTimingOutDueToInactivityItWillExpireInCOUNTSeconds({
                            COUNT: this._warningSeconds - t
                        })), 1e3, this._warningSeconds),
                        this._warningCountdownPromise.then(( () => this._cancelWarning)).then(( () => this._logUserOut())).catch(( () => s.noop()))
                    }
                    ))
                }
                activityThresholdExceeded() {
                    !0 === this.$document[0].hidden ? this._logUserOut() : this._warnUser()
                }
                stop() {
                    this.$timeout.cancel(this._activityMonitorPromise),
                    delete this._activityMonitorPromise,
                    this._cancelWarning(),
                    this.$document.off("keydown", this._restartActivityMonitorBound),
                    this.$document.off("mousemove", this._restartActivityMonitorBound),
                    this.$document.off("click", this._restartActivityMonitorBound),
                    this.$document.off("visibilitychange", this._restartActivityMonitorBound)
                }
            }
            Gd.$inject = ["$timeout", "$document", "$rootScope", "$mdDialog", "$interval", "MatDialog"],
            s.module("ipconfigure.orchid.singularity").service("InactivityMonitorService", Gd),
            function() {
                function e(e, t, n, i, a, r) {
                    let s;
                    return {
                        response: function(e) {
                            return (angular.isUndefined(e.config.headers.OrchidId) || !0 === w.isOrchid) && e.config.url.indexOf("/ping") > -1 ? (re(s) && (s = t.get("ControlledShutdownService")),
                            !0 === w.fusionDestroyed && a.reason() === a.reasons.ping && (s.requireApplicationReloadControl ? s.reloadApplication() : i.location.reload())) : angular.isDefined(e.config.headers.OrchidId) && -1 === e.config.url.indexOf("service/orchid-proxy") && r.getProxyStateById(e.config.headers.OrchidId) === ct.UNKNOWN && r.setProxyState(e.config.headers.OrchidId, ct.UNPROXIED),
                            e
                        },
                        responseError: function(s) {
                            if (function(e) {
                                if ("GET" !== e.config.method || -1 === e.config.url.indexOf("/ping"))
                                    return !1;
                                const t = -1 === e.status || e.status >= 502 && e.status <= 504
                                  , n = !0 === w.isOrchid || angular.isUndefined(e.config.headers.OrchidId);
                                return t && n && !0 !== w.fusionDestroyed
                            }(s))
                                return a.die(a.reasons.ping),
                                e.reject(s);
                            if (-1 === s.status) {
                                if (angular.isDefined(s.config.headers.OrchidId) && r.getProxyStateById(s.config.headers.OrchidId) !== ct.PROXIED) {
                                    var o = t.get("OrchidDataService");
                                    return r.setProxyState(s.config.headers.OrchidId, ct.PROXIED),
                                    angular.isUndefined(s.config.headers.ProxyTest) ? o.retry({
                                        id: s.config.headers.OrchidId,
                                        uri: s.config.url.split("/service")[0]
                                    }, s.config) : e.reject(s)
                                }
                                return e.reject(s)
                            }
                            if (!(!0 !== n.signingOut && !0 === w.isOrchid && 401 === s.status && -1 === s.config.url.indexOf("/version") && -1 === s.config.url.indexOf("/session") && -1 === s.config.url.indexOf("/identity") && s.config.url.indexOf(w.baseUrl) > -1))
                                return e.reject(s);
                            i.location.reload()
                        }
                    }
                }
                e.$inject = ["$q", "$injector", "$rootScope", "$window", "DeathService", "OrchidProxyService"],
                angular.module("ipconfigure.orchid.singularity").factory("HttpResponseErrorHandler", ["$q", "$injector", "$rootScope", "$window", "DeathService", "OrchidProxyService", e])
            }(),
            function() {
                function e(e, t, n, i) {
                    this.request = function(e) {
                        var n = document.createElement("a");
                        return n.href = e.url,
                        function(e, n) {
                            let i = t.get("AuthenticationService")
                              , a = i.isAuthenticated()
                              , r = document.createElement("a");
                            if (r.href = w.baseUrl,
                            a) {
                                let t = i.getAuthenticationData();
                                t.sessionId && r.protocol === n.protocol && r.hostname === n.hostname && r.port === n.port && "/users/login" !== n.pathname && -1 === n.pathname.indexOf("service/orchid-proxy") ? e.headers.Authorization = "Bearer " + t.sessionId : w.isOrchid && t.token && (e.headers.Authorization = "Bearer " + t.token)
                            }
                        }(e, n),
                        function(e, t) {
                            if ("GET" === e.method)
                                if (1 === t.pathname.indexOf("service") && -1 === e.url.indexOf("cache-bust"))
                                    -1 != e.url.indexOf("?") ? e.url += "&cache-bust=" + Date.now() : e.url += "?cache-bust=" + Date.now();
                                else {
                                    var n = e.url.indexOf(".html")
                                      , i = "-1738246429652";
                                    -1 != n && 0 === t.pathname.replace("/", "").indexOf("components") && i.indexOf("@") < 0 && (e.url = e.url.slice(0, n) + i + e.url.slice(n))
                                }
                        }(e, n),
                        e
                    }
                }
                e.$inject = ["$rootScope", "$injector", "$log", "$sessionStorage"],
                angular.module("ipconfigure.orchid.singularity").service("PreflightService", e)
            }(),
            zd.$inject = ["$rootScope", "$log", "$timeout", "FusionConfigService", "AuthenticationService", "RenewableService", "TimelineServiceFactory", "PlayerOptionsFactory", "TimeService", "DataService", "GamepadService", "UtilityService", "PlayerResetService"];
            const {v4: Bd} = n(21614);
            function zd(e, t, n, i, a, r, s, o, c, l, d, u, m) {
                var h, p, g = this;
                window.addEventListener("message", (function(e) {
                    void 0 !== e.data.orchidId && Promise.all([r.orchidsPromise, c.getOrchidTimeOffsetPromise(e.data.orchidId)]).then((function(t) {
                        let[,n] = t;
                        const i = r.findOrchid(e.data.orchidId)
                          , a = r.findCamera(e.data.orchidId, e.data.cameraId);
                        g.cameraName = a.name,
                        g.orchid = i,
                        g.camera = a;
                        const o = s.getContext("master");
                        let c = parseInt(e.data.time) + n;
                        c > Date.now() - 5e3 && (c -= 5e3),
                        c -= 2e3,
                        o.setTime(c, {
                            publish: !0
                        }),
                        m.trigger({
                            orchid: i,
                            camera: a
                        })
                    }
                    ))
                }
                )),
                g.startAt = xn(location)["start-time"],
                g.displayTimeline = "true" !== xn(location)["hide-timeline"],
                e.isOrchid = w.isOrchid,
                e.singlePlayerStreamId = xn(location)["single-player"],
                e.singlePlayerOrchidId = xn(location)["single-player-orchid"],
                g.doNotStart = "true" === xn(location).doNotStart,
                g.streamId = e.singlePlayerStreamId || g.streamId,
                g.orchidId = e.singlePlayerOrchidId,
                /^\d+$/.test(g.streamId) && (g.streamId = parseInt(g.streamId)),
                g.$onInit = function() {
                    d.startListening()
                }
                ,
                g.$onDestroy = function() {
                    d.stopListening()
                }
                ,
                a.getAuthenticationDataPromise().then((function() {
                    return t.info("SinglePlayer: fetching servers and cameras")
                }
                )).then(r.orchidsPromise).then((function() {
                    return !0 !== e.isOrchid ? l.fetchPrivate().then((function(e) {
                        i.setPostAuthentication(e.data)
                    }
                    )) : Promise.resolve()
                }
                )).then((async function() {
                    if (!0 !== e.isOrchid)
                        g.orchidId && await l.fetchOrchid(g.orchidId).then((function(e) {
                            return g.orchid = e
                        }
                        )).catch((function(t) {
                            e.singlePlayerError = L.messages.singlePlayer.noAccessToOrchid({
                                VALUE: g.orchidId
                            })
                        }
                        ));
                    else {
                        var i = await r.orchidsPromise();
                        g.orchid = i[0]
                    }
                    !function() {
                        n((function() {
                            p = e.$watch((function() {
                                return s.getContext("master")
                            }
                            ), (function(e) {
                                e && (p(),
                                g.ready = !0,
                                g.orchidId && g.streamId && c.getOrchidTimeOffsetPromise(g.orchidId).then((function(t) {
                                    g.startAt && e.setTime(parseInt(g.startAt) + t, {
                                        publish: !0
                                    })
                                }
                                )))
                            }
                            ))
                        }
                        ));
                        const i = {
                            ...xn(location),
                            forceWebrtc: !1
                        };
                        g.options = o.createApiPlayerOptions(i),
                        g.options.showTimeline = g.displayTimeline,
                        g.orchid && g.streamId > 0 ? l.fetchCameras(g.orchid).then((function() {
                            n((function() {
                                for (const t of g.orchid.cameras) {
                                    let i;
                                    if (t.streams && (i = t.streams.find((function(e) {
                                        return e.id === g.streamId
                                    }
                                    ))),
                                    void 0 !== i) {
                                        const a = i.id !== t.primaryStream.id
                                          , r = {
                                            ...xn(location),
                                            forceWebrtc: a
                                        };
                                        g.options = o.createApiPlayerOptions(r),
                                        g.options.showTimeline = g.displayTimeline;
                                        const s = !g.options.availablePlayerModes.includes(nn);
                                        if (a && s)
                                            break;
                                        const c = t.driver === Q.ONVIF
                                          , l = c ? i.configuration.Video.Encoder : void 0;
                                        if (a && c && "H264" !== l)
                                            break;
                                        const d = void 0 === t.secondaryStreams.find((function(e) {
                                            return e.id === i.id
                                        }
                                        ));
                                        if (a && d)
                                            break;
                                        g.camera = t,
                                        g.cameraName = e.isOrchid ? g.camera.name : `${g.orchid.name}: ${g.camera.name}`,
                                        n((function() {
                                            e.appLoaded = !0
                                        }
                                        ));
                                        break
                                    }
                                }
                                angular.isUndefined(g.camera) && (e.singlePlayerError = L.messages.singlePlayer.cannotOpenStream({
                                    VALUE: g.streamId
                                }))
                            }
                            ))
                        }
                        ), (function(e) {
                            t.error("Failed to fetch cameras:", e.data.reason)
                        }
                        )) : (e.appLoaded = !0,
                        u.postMessage({
                            component: "app",
                            type: "ready"
                        }));
                        function a() {
                            h && n.cancel(h),
                            h = n((function() {
                                e.$broadcast("resize")
                            }
                            ), 150, !1)
                        }
                        window.addEventListener("resize", (function() {
                            a()
                        }
                        ), !0),
                        window.addEventListener("orientationchange", (function() {
                            n((function() {
                                a()
                            }
                            ), 500)
                        }
                        ), !0),
                        g.playControl,
                        g.containerId = "api-" + Bd(),
                        g.fakeCell = {},
                        g.selectionMode = !1
                    }()
                }
                )).catch((function(n) {
                    n ? "no-authorization-received" === n.reason ? e.singlePlayerError = L.messages.singlePlayer.timedOutWaitingForAuthorizationToken() : "authentication-failed" === n.reason || n.data && "Authorization failed" === n.data.reason ? (t.error("SinglePlayer: Authentication failed."),
                    e.singlePlayerError = L.messages.singlePlayer.authenticationFailed()) : (t.error("SinglePlayer: failed to fetch servers:", n),
                    e.singlePlayerError = L.messages.singlePlayer.cannotFetchCameraAndServerInformation()) : (t.error("SinglePlayer: No error provided"),
                    e.singlePlayerError = L.messages.anUnexpectedErrorOccurred())
                }
                ))
            }
            angular.module("ipconfigure.orchid.singularity").controller("SinglePlayerController", zd).directive("singlePlayer", [function() {
                return {
                    restrict: "E",
                    template: n(91090),
                    controller: "SinglePlayerController as singlePlayer",
                    bindToController: {
                        childPlayer: "@?",
                        orchids: "=?",
                        orchid: "=?",
                        camera: "=?",
                        enablePtz: "=?",
                        hideControls: "=?",
                        hideTimeline: "=?"
                    },
                    scope: {},
                    link: function(e, t, n, i) {
                        e.$watch((function() {
                            return i.selectionMode
                        }
                        ), (function() {
                            !0 === i.selectionMode ? t[0].classList.add("selection-mode") : !1 === i.selectionMode && t[0].classList.remove("selection-mode")
                        }
                        ))
                    }
                }
            }
            ]);
            n.p,
            n.p,
            n.p,
            n.p,
            n.p,
            n.p,
            n.p;
            n(65502),
            n(39925),
            n(45129),
            n(8753),
            n(93575),
            n(23695),
            n(19107),
            n(78858);
            n.p;
            o().module("ipconfigure.orchid.singularity").service("PlayerResetService", class {
                constructor() {
                    this._handlers = [],
                    this._eventManager = new wn
                }
                trigger(e) {
                    this._eventManager.trigger("player-reset", e)
                }
                on(e) {
                    this._eventManager.on("player-reset", e)
                }
                off(e) {
                    this._eventManager.off("player-reset", e)
                }
            }
            );
            n.p,
            n.p,
            n.p,
            n.p,
            n.p;
            var Hd, Wd, qd, Yd, Xd, Kd, Zd;
            y().formats.push((function(e, t, n) {
                n.unshift(e.name + ": ")
            }
            )),
            function(e) {
                e[e.Loading = 0] = "Loading",
                e[e.Loaded = 1] = "Loaded",
                e[e.Failed = 2] = "Failed"
            }(Zd || (Zd = {}));
            O("StreamPreviewComponent");
            let Jd = Hd = class {
                constructor(e, t, n, a) {
                    this._dataService = e,
                    this._window = t,
                    this._renewableService = n,
                    this._minimumVersionService = a,
                    this.isCameraActive = !0,
                    this.previewImagePixelWidth = 500,
                    this.retryOnError = !0,
                    this.stateChange = new i.EventEmitter,
                    this.msgs = L.messages.streamPreview,
                    this.state = Zd.Loading,
                    this.widePreview = !1,
                    this._failedRequestAttempts = 0,
                    this.urlCreator = window.URL || window.webkitURL,
                    this.cameraDisablementIsSupported = !0
                }
                get ComponentState() {
                    return Zd
                }
                ngOnDestroy() {
                    this._clearPendingRequestingAndExistingBlob()
                }
                ngOnInit() {
                    this.orchidId && (this._orchid = this._renewableService.findOrchid(this.orchidId),
                    !w.isOrchid && this._orchid && (this.cameraDisablementIsSupported = this._minimumVersionService.isFeatureSupported(this._orchid, Sr.CAMERA_DISABLEMENT))),
                    this.cameraDisablementIsSupported || (this.isCameraActive = !0)
                }
                ngOnChanges(e) {
                    Hd._inputFieldChanged(e) && (this.state = Zd.Loading,
                    this._clearPendingRequestingAndExistingBlob(),
                    this._refreshPreviewImage())
                }
                _clearPendingRequestingAndExistingBlob() {
                    this.cancelPendingPreviewNetworkRequest && this.cancelPendingPreviewNetworkRequest(),
                    this._refreshSubscription && this._refreshSubscription.unsubscribe(),
                    this.imgBlobURL && this.urlCreator.revokeObjectURL(this.imgBlobURL)
                }
                _fetchAndSetPreviewImageBlob(e) {
                    const t = this._dataService.fetchPreviewPromiseAndCanceller(e);
                    this.cancelPendingPreviewNetworkRequest = t.cancel,
                    t.promise.then((e => {
                        this.imgBlobURL && this.urlCreator.revokeObjectURL(this.imgBlobURL),
                        this.imgBlobURL = this.urlCreator.createObjectURL(e),
                        this.image.nativeElement.src = this.imgBlobURL,
                        this.onLoad()
                    }
                    )).catch((e => {
                        null !== e.data && this.onError()
                    }
                    ))
                }
                _refreshPreviewImage() {
                    if (this.retryOnError)
                        try {
                            let e = j.CHIP;
                            const t = Math.trunc(this.previewImagePixelWidth * this._window.devicePixelRatio);
                            t > 72 && (e = j.SMALL),
                            t > 330 && (e = j.LARGE);
                            let n = "";
                            this.orchidId && this.cameraId && (n = this._dataService.cameraPreviewUrl(this.orchidId, this.cameraId, e, void 0, this.noCache)),
                            this._fetchAndSetPreviewImageBlob(n)
                        } catch (e) {
                            this.onError()
                        }
                }
                onLoad() {
                    const e = this.state;
                    this.state = Zd.Loaded,
                    this._resetTimer();
                    const t = this.image.nativeElement;
                    this.widePreview = t.naturalWidth / t.naturalHeight >= 16 / 9,
                    this.stateChange.emit({
                        state: this.state,
                        previousState: e
                    })
                }
                onError() {
                    const e = this.state;
                    e === Zd.Failed ? this._failedRequestAttempts++ : this._failedRequestAttempts = 1,
                    this.state = Zd.Failed,
                    this._resetTimer(),
                    this.stateChange.emit({
                        state: this.state,
                        previousState: e
                    })
                }
                _resetTimer() {
                    const e = this._refreshDelay;
                    this._refreshSubscription = (0,
                    Kl.H)(e).subscribe(( () => this._refreshPreviewImage()))
                }
                get _refreshDelay() {
                    return this.state === Zd.Failed && this._failedRequestAttempts < 10 ? 2500 : Math.round(3e4 * Math.random() + 6e4)
                }
                static _inputFieldChanged(e) {
                    return void 0 !== e.cameraId || void 0 !== e.orchidId || void 0 !== e.noCache || void 0 !== e.isCameraActive || void 0 !== e.retryOnError
                }
            }
            ;
            var Qd, eu;
            (0,
            c.gn)([(0,
            i.ViewChild)("preview"), (0,
            c.w6)("design:type", "function" == typeof (Wd = void 0 !== i.ElementRef && i.ElementRef) ? Wd : Object)], Jd.prototype, "image", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Jd.prototype, "orchidId", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Jd.prototype, "cameraId", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], Jd.prototype, "isCameraActive", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], Jd.prototype, "noCache", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Jd.prototype, "previewImagePixelWidth", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Jd.prototype, "retryOnError", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], Jd.prototype, "stateChange", void 0),
            Jd = Hd = (0,
            c.gn)([(0,
            i.Component)({
                selector: "stream-preview",
                template: n(32117)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(tt)), (0,
            c.fM)(1, (0,
            i.Inject)(Window)), (0,
            c.fM)(2, (0,
            i.Inject)(Gt)), (0,
            c.fM)(3, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (qd = tt) ? qd : Object, "function" == typeof (Yd = "undefined" != typeof Window && Window) ? Yd : Object, "function" == typeof (Xd = Gt) ? Xd : Object, "function" == typeof (Kd = void 0 !== Cr && Cr) ? Kd : Object])], Jd);
            const tu = O("StreamPreviewCheckbox");
            class nu {
                constructor(e, t) {
                    this.stream = e,
                    this.isOnvif = t,
                    this.name = this._getName()
                }
                _getName() {
                    const e = this.stream;
                    if (this.isOnvif) {
                        const t = e.configuration.Video;
                        return [t.Resolution, L.messages.library.valueFps({
                            VALUE: t.FrameRate
                        }), t.Encoder].join(", ")
                    }
                    return e.name
                }
                static fromCamera(e) {
                    var t;
                    const n = [e.primaryStream];
                    null === (t = e.secondaryStreams) || void 0 === t || t.forEach((e => {
                        !0 === e.recording && n.push(e)
                    }
                    ));
                    const i = e.driver === Q.ONVIF;
                    return n.map((e => new nu(e,i)))
                }
                static sortOnvifOptionsByResolution(e, t=!1) {
                    if (!e.every((e => e.isOnvif)))
                        return tu.error("Attempted to sort non-ONVIF options", e),
                        e;
                    const n = [...e];
                    return n.sort(( (e, t) => {
                        const n = i(e)
                          , a = i(t)
                          , r = [n[0] - a[0], n[1] - a[1]].find((e => 0 !== e));
                        return r || 0
                    }
                    )),
                    !0 === t ? n.reverse() : n;
                    function i(e) {
                        const t = [1, 1];
                        let n = e.stream.configuration.Video.Resolution.split("x");
                        return 2 !== n.length ? t : (n = n.map((e => parseInt(e))),
                        n.includes(NaN) ? t : n)
                    }
                }
            }
            let iu = class {
                constructor(e) {
                    this.cd = e,
                    this.showCameraName = !0,
                    this.fallbackCameraName = "",
                    this.checkboxActionFailed = !1,
                    this.label = "",
                    this.stateChanges = new i.EventEmitter,
                    this.streamPreviewFailed = !1,
                    this._error = "",
                    this.disablePreviewCheckbox = !1,
                    this.isRecordingWithoutMotion = !1,
                    this.streamOptions = [],
                    this.msgs = {
                        noStreamsConfigured: L.messages.player.noStreamsConfigured,
                        cameraNotConfiguredForMotion: L.messages.notifications.cameraNotConfiguredForMotion
                    }
                }
                get error() {
                    return this._error
                }
                set error(e) {
                    this._error = e,
                    this.checkboxActionFailed = !!e
                }
                ngAfterViewInit() {
                    !0 === this.preSelected && (this.checkbox.toggle(),
                    this.cd.detectChanges())
                }
                ngOnInit() {
                    var e;
                    const t = !se(this.camera.primaryStream);
                    if (!0 === this.enableMotionWarning && t) {
                        const t = Za(null === (e = this.camera.primaryStream) || void 0 === e ? void 0 : e.recordingConfiguration);
                        t.id !== qa.PROXY_ONLY && t.id !== qa.CONTINUOUS_NO_MOTION || (this.isRecordingWithoutMotion = !0)
                    }
                    t || this.hideStreamSelect ? this.hideStreamSelect || (this.streamOptions = nu.fromCamera(this.camera),
                    this.camera.driver === Q.ONVIF ? (this.streamOptions = nu.sortOnvifOptionsByResolution(this.streamOptions, !0),
                    this.selectedStream = this.streamOptions[0].stream) : this.selectedStream = this.camera.primaryStream) : this.disablePreviewCheckbox = !0
                }
                onCheckChange(e) {
                    this.emitStateChange()
                }
                imageClicked(e) {
                    if (e.target) {
                        if (null !== e.target.closest(".mat-checkbox"))
                            return
                    }
                    this.disablePreviewCheckbox || this.toggleCheckboxState()
                }
                toggleCheckboxState() {
                    this.checkbox.toggle(),
                    this.emitStateChange()
                }
                onStreamSelect(e) {
                    this.selectedStream = e.stream,
                    this.emitStateChange()
                }
                emitStateChange() {
                    this.stateChanges.emit({
                        camera: this.camera,
                        stream: this.selectedStream,
                        checked: this.checkbox.checked
                    })
                }
                onPreviewStateChange(e) {
                    e.previousState !== Zd.Failed && e.state === Zd.Failed ? this.streamPreviewFailed = !0 : e.previousState === Zd.Failed && e.state !== Zd.Failed && (this.streamPreviewFailed = !1)
                }
                uncheck() {
                    this.checkbox.checked && this.toggleCheckboxState()
                }
                get cameraName() {
                    return this.camera ? this.camera.name : this.fallbackCameraName
                }
            }
            ;
            var au, ru;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], iu.prototype, "hideStreamSelect", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], iu.prototype, "enableMotionWarning", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], iu.prototype, "camera", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], iu.prototype, "preSelected", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], iu.prototype, "showCameraName", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], iu.prototype, "fallbackCameraName", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], iu.prototype, "checkboxActionFailed", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], iu.prototype, "label", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String), (0,
            c.w6)("design:paramtypes", [String])], iu.prototype, "error", null),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], iu.prototype, "stateChanges", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(ai.oG), (0,
            c.w6)("design:type", "function" == typeof (Qd = void 0 !== ai.oG && ai.oG) ? Qd : Object)], iu.prototype, "checkbox", void 0),
            iu = (0,
            c.gn)([(0,
            i.Component)({
                selector: "stream-preview-checkbox",
                template: n(35041)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (eu = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? eu : Object])], iu),
            function(e) {
                e.GENERIC = "generic",
                e.PRIMARY = "primary",
                e.SUCCESS = "success",
                e.ERROR = "error",
                e.WARNING = "warning"
            }(au || (au = {}));
            let su = class {
                constructor() {
                    this.title = "",
                    this.type = au.GENERIC,
                    this.faIcon = "",
                    this.showIcon = !0,
                    this.dismissable = !1,
                    this.onDismiss = new i.EventEmitter,
                    this.bannerIcon = ""
                }
                ngOnInit() {
                    this.setBannerIcon()
                }
                setBannerIcon() {
                    if (this.faIcon.length > 0)
                        this.bannerIcon = this.faIcon;
                    else
                        switch (this.type) {
                        case au.SUCCESS:
                            this.bannerIcon = zt.success;
                            break;
                        case au.ERROR:
                            this.bannerIcon = zt.unavailable;
                            break;
                        case au.WARNING:
                            this.bannerIcon = zt.error;
                            break;
                        default:
                            this.bannerIcon = zt.info
                        }
                }
                showTitle() {
                    return this.title.length > 0
                }
                dismiss() {
                    this.dismissable && this.onDismiss.emit()
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], su.prototype, "title", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (ru = void 0 !== au && au) ? ru : Object)], su.prototype, "type", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], su.prototype, "faIcon", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], su.prototype, "showIcon", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], su.prototype, "dismissable", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], su.prototype, "onDismiss", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("alertBannerTemplate", {
                static: !0
            }), (0,
            c.w6)("design:type", Object)], su.prototype, "template", void 0),
            su = (0,
            c.gn)([(0,
            i.Component)({
                selector: "alert-banner",
                template: n(67597)
            })], su);
            var ou, cu, lu = n(98430);
            let du = class {
                constructor() {
                    this.data = [],
                    this.dataName = "",
                    this.dataType = "",
                    this.tooltip = void 0,
                    this.disabled = !1,
                    this.placeholderChip = void 0,
                    this._valid = null,
                    this.invalidPrompt = "",
                    this.separatorKeysCodes = [ia.K5, ia.OC],
                    this.dataInputCtrl = new p.NI,
                    this.matListCtrl = new p.NI,
                    this.filteredSortedSelectableData$ = (0,
                    ze.of)([]),
                    this.msgs = Object.assign({}, L.messages.chips),
                    this._createValidator = () => e => !1 === this._valid ? {
                        required: !0
                    } : null
                }
                set valid(e) {
                    this._valid = e,
                    this.dataInputCtrl.updateValueAndValidity()
                }
                get valid() {
                    return this._valid
                }
                get selectedFormData() {
                    return this.formGroup.value
                }
                ngOnChanges(e) {
                    e.disabled && (this.disabled ? this.matListCtrl.disable() : this.matListCtrl.enable())
                }
                ngOnInit() {
                    this.dataInputCtrl.setValidators(this._createValidator()),
                    "username"in this.data[0] && this.data.map((e => e.name = e.username)),
                    this.filteredSortedSelectableData$ = this.dataInputCtrl.valueChanges.pipe((0,
                    lu.O)(""), (0,
                    He.U)((e => e ? this._getSortedSelectableData(this._filterItems(e)) : this._getSortedSelectableData(this.data)))),
                    this.dataType = this.dataName.toLowerCase()
                }
                addItem(e) {
                    const t = e.option.value;
                    t && this.data.includes(t) && this.formGroup.value.push(t),
                    this.dataInput && (this.dataInput.nativeElement.value = ""),
                    this.dataInputCtrl.setValue(""),
                    this.formGroup.updateValueAndValidity()
                }
                removeItem(e) {
                    this.formGroup.value.splice(this.formGroup.value.findIndex((t => t.id === e.id)), 1),
                    this.dataInput.nativeElement.value = "",
                    this.dataInputCtrl.setValue(""),
                    this.formGroup.updateValueAndValidity()
                }
                _filterItems(e) {
                    if ("string" == typeof e) {
                        const t = e.toLowerCase();
                        return this.data.filter((e => e.name ? e.name.toLowerCase().indexOf(t) > -1 : void 0))
                    }
                    return [e]
                }
                _getSortedSelectableData(e) {
                    return e.filter((e => -1 === this.formGroup.value.findIndex((t => t.id === e.id)))).sort(( (e, t) => {
                        if (e.name && t.name) {
                            const n = e.name.toLowerCase()
                              , i = t.name.toLowerCase();
                            return n < i ? -1 : n > i ? 1 : 0
                        }
                        return 0
                    }
                    ))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (ou = void 0 !== p.cw && p.cw) ? ou : Object)], du.prototype, "formGroup", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], du.prototype, "data", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], du.prototype, "dataName", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], du.prototype, "tooltip", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], du.prototype, "disabled", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], du.prototype, "placeholderChip", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object), (0,
            c.w6)("design:paramtypes", [Object])], du.prototype, "valid", null),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], du.prototype, "invalidPrompt", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("dataInput"), (0,
            c.w6)("design:type", "function" == typeof (cu = void 0 !== i.ElementRef && i.ElementRef) ? cu : Object)], du.prototype, "dataInput", void 0),
            du = (0,
            c.gn)([(0,
            i.Component)({
                selector: "autocomplete-chip-input",
                template: n(72422)
            })], du);
            let uu = class {
                constructor() {
                    this.changes = new St.x,
                    this.itemsPerPageLabel = "",
                    this.nextPageLabel = "",
                    this.previousPageLabel = "",
                    this.firstPageLabel = "",
                    this.lastPageLabel = "",
                    this.getRangeLabel = this.getPaginatorRangeLabel,
                    this.itemsPerPageLabel = L.messages.licensing.paginator.itemsPerPage(),
                    this.nextPageLabel = L.messages.licensing.paginator.nextPage(),
                    this.previousPageLabel = L.messages.licensing.paginator.previousPage(),
                    this.firstPageLabel = L.messages.licensing.paginator.firstPage(),
                    this.lastPageLabel = L.messages.licensing.paginator.lastPage()
                }
                getPaginatorRangeLabel(e, t, n) {
                    const i = e * t + 1
                      , a = Math.min(n, (e + 1) * t);
                    return L.messages.licensing.paginator.countOfTotal({
                        COUNT: `${i}  ${a}`,
                        TOTAL: n
                    })
                }
                setLabel(e) {
                    e = e.charAt(0).toUpperCase() + e.slice(1),
                    this.itemsPerPageLabel = `${e} ` + L.messages.licensing.paginator.perPage(),
                    this.changes.next()
                }
            }
            ;
            uu = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.w6)("design:paramtypes", [])], uu);
            class mu {
                constructor(e, t, n) {
                    this.options = e,
                    this.test = t,
                    this.pageMap = n
                }
            }
            var hu, pu, gu, fu, vu;
            !function(e) {
                e.FIXED_SMALL = "fixedSmall",
                e.FIXED_MEDIUM = "fixedMedium",
                e.FIXED_LARGE = "fixedLarge",
                e.AUTO = "auto"
            }(gu || (gu = {})),
            function(e) {
                e.chip = "chip",
                e.text = "text"
            }(fu || (fu = {})),
            function(e) {
                e.GREEN = "green",
                e.BLUE = "blue",
                e.NONE = "none"
            }(vu || (vu = {}));
            let yu = class {
                constructor(e) {
                    this.paginator = e,
                    this.msgs = Object.assign(Object.assign(Object.assign({
                        name: L.messages.dashboard.name,
                        search: L.messages.dashboard.search
                    }, L.messages.dialogs), L.messages.groups), L.messages.cameras.cameraPicker),
                    this.msgs2 = Object.assign(Object.assign({
                        name: L.messages.dashboard.name,
                        search: L.messages.dashboard.search
                    }, L.messages.dialogs), L.messages.groups, L.messages.cameras.cameraPicker),
                    this.listType = fu.chip,
                    this.pageSize = 16,
                    this.pageSizeOptions = [16, 24, 32, 40],
                    this.hidePageSize = !1,
                    this.hidePagination = !1,
                    this.emptyMessageCross = !1,
                    this.emptyMessageRed = !1,
                    this.allItems = !1,
                    this.chipWidth = gu.AUTO,
                    this.icon = void 0,
                    this.style = vu.NONE,
                    this.CHIP_WIDTH = gu,
                    this.LIST_TYPE = fu,
                    this.CHIP_STYLE_TYPE = vu,
                    this.pagedData = [],
                    this.paginatorLabel = "",
                    this.emptyMessage = ""
                }
                ngOnInit() {
                    var e, t;
                    this.paginatorLabel = null !== (e = this.paginatorLabelInput) && void 0 !== e ? e : L.messages.cameras.cameraPicker.items(),
                    this.emptyMessage = null !== (t = this.emptyMessageInput) && void 0 !== t ? t : L.messages.cameras.none(),
                    this.paginator.setLabel(this.paginatorLabel);
                    const n = {
                        target: {
                            innerWidth: window.innerWidth
                        }
                    };
                    this.onResize(n)
                }
                updatePagedData(e) {
                    this.pagedData = e
                }
                handlePageEvent(e) {
                    this.pageSize = e.pageSize
                }
                getTooltip(e, t) {
                    return void 0 !== t ? t + ": " + e : e
                }
                chipWidthSmallPageOptions() {
                    return [new mu([16, 24, 32, 40],(e => e > 1430),{
                        6: 16,
                        8: 16,
                        10: 16,
                        12: 16,
                        14: 16,
                        16: 16,
                        18: 16,
                        20: 24,
                        21: 24,
                        24: 24,
                        28: 24,
                        30: 32,
                        32: 32,
                        35: 32,
                        36: 40,
                        40: 40,
                        44: 40
                    }), new mu([14, 21, 28, 35],(e => e <= 1430 && e > 1290 || e <= 1180 && e > 1055),{
                        6: 14,
                        8: 14,
                        10: 14,
                        12: 14,
                        14: 14,
                        16: 14,
                        18: 21,
                        20: 21,
                        21: 21,
                        24: 21,
                        28: 28,
                        30: 28,
                        32: 28,
                        35: 35,
                        36: 35,
                        40: 35,
                        44: 35
                    }), new mu([12, 24, 36, 44],(e => e <= 1290 && e > 1180 || e <= 1055 && e > 915 || e <= 636),{
                        6: 12,
                        8: 12,
                        10: 12,
                        12: 12,
                        14: 12,
                        16: 12,
                        18: 18,
                        20: 18,
                        21: 24,
                        24: 24,
                        28: 24,
                        30: 24,
                        32: 36,
                        35: 36,
                        36: 36,
                        40: 44,
                        44: 44
                    }), new mu([10, 20, 30, 40],(e => e <= 915 && e > 775),{
                        6: 10,
                        8: 10,
                        10: 10,
                        12: 10,
                        14: 10,
                        16: 10,
                        18: 20,
                        20: 20,
                        21: 20,
                        24: 20,
                        28: 30,
                        30: 30,
                        32: 30,
                        35: 30,
                        36: 40,
                        40: 40,
                        44: 40
                    }), new mu([8, 16, 24, 32],(e => e <= 775 && e > 636),{
                        6: 8,
                        8: 8,
                        10: 8,
                        12: 8,
                        14: 16,
                        16: 16,
                        18: 16,
                        20: 24,
                        21: 24,
                        24: 24,
                        28: 24,
                        30: 32,
                        32: 32,
                        35: 32,
                        36: 32,
                        40: 32,
                        44: 32
                    })]
                }
                chipWidthMediumPageOptions() {
                    return [new mu([12, 24, 36, 48],(e => e > 1430),{
                        12: 12,
                        24: 24,
                        36: 36,
                        48: 48
                    }), new mu([12, 24, 36, 48],(e => e <= 1430 && 915 <= e),{
                        12: 12,
                        24: 24,
                        36: 36,
                        48: 48
                    }), new mu([12, 24, 36, 48],(e => e <= 915),{
                        12: 12,
                        24: 24,
                        36: 36,
                        48: 48
                    })]
                }
                onResize(e) {
                    const t = e.target.innerWidth;
                    let n = [];
                    this.chipWidth === gu.FIXED_SMALL ? n = this.chipWidthSmallPageOptions() : this.chipWidth === gu.FIXED_MEDIUM && (n = this.chipWidthMediumPageOptions()),
                    n.forEach((e => {
                        e.test(t) && (this.pageSizeOptions = e.options,
                        this.pageSize = e.pageMap[this.pageSize])
                    }
                    ))
                }
            }
            ;
            var bu, Su, Cu;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], yu.prototype, "listType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (hu = "undefined" != typeof Array && Array) ? hu : Object)], yu.prototype, "data", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], yu.prototype, "paginatorLabelInput", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yu.prototype, "pageSize", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yu.prototype, "pageSizeOptions", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yu.prototype, "hidePageSize", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yu.prototype, "hidePagination", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], yu.prototype, "emptyMessageInput", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yu.prototype, "emptyMessageCross", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yu.prototype, "emptyMessageRed", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yu.prototype, "allItems", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], yu.prototype, "allItemsMessage", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], yu.prototype, "chipWidth", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], yu.prototype, "icon", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yu.prototype, "style", void 0),
            yu = (0,
            c.gn)([(0,
            i.Component)({
                selector: "chip-list",
                template: n(67021),
                providers: [{
                    provide: pi.ye,
                    useClass: uu
                }]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pi.ye)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (pu = void 0 !== uu && uu) ? pu : Object])], yu),
            function(e) {
                e.checkbox = "checkbox"
            }(Cu || (Cu = {}));
            let wu = class extends yu {
                constructor(e) {
                    super(e),
                    this.msgs = L.messages.common,
                    this.checkboxForm = new p.NI([]),
                    this.selectAll = !1,
                    this.allSelected = !1,
                    this.TYPE = Cu
                }
                handleChipSelect(e) {
                    var t, n;
                    e.selected = !e.selected;
                    const i = null === (t = this.checkboxForm) || void 0 === t ? void 0 : t.value;
                    if (e.selected)
                        i.push(e.value);
                    else {
                        const t = i.indexOf(e.value);
                        i.splice(t, 1)
                    }
                    null === (n = this.checkboxForm) || void 0 === n || n.setValue(i),
                    this.selectAll && (i.length === this.pagedData.length ? this.handleAllChipSelect() : this.clearAllChip())
                }
                handleAllChipSelect() {
                    var e;
                    this.allSelected = !this.allSelected;
                    const t = this.allSelected ? [...this.pagedData] : [];
                    null === (e = this.checkboxForm) || void 0 === e || e.setValue(t)
                }
                clearAllChip() {
                    this.allSelected = !1
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (bu = void 0 !== p.NI && p.NI) ? bu : Object)], wu.prototype, "checkboxForm", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], wu.prototype, "selectAll", void 0),
            wu = (0,
            c.gn)([(0,
            i.Component)({
                selector: "selectable-chip-list",
                template: n(11930),
                providers: [{
                    provide: pi.ye,
                    useClass: uu
                }]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pi.ye)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Su = void 0 !== uu && uu) ? Su : Object])], wu);
            let Iu = class {
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Iu.prototype, "tooltip", void 0),
            Iu = (0,
            c.gn)([(0,
            i.Component)({
                selector: "circle-hint",
                template: n(55760)
            })], Iu);
            const Tu = O("OpenPanelService");
            let Eu = class {
                constructor() {
                    this.triggers = []
                }
                closePanelsOnScroll() {
                    this.triggers.forEach((e => {
                        e.panelOpen && e.closePanel()
                    }
                    ))
                }
                addAutocompleteTrigger(e) {
                    return this.triggers.push(e),
                    this.triggers
                }
                removeAutocompleteTrigger(e) {
                    const t = this.triggers.findIndex((t => t.autocomplete.id === e.autocomplete.id));
                    return -1 !== t ? this.triggers.splice(t, 1) : Tu("warn", "Failed attempt to remove an input trigger"),
                    this.triggers
                }
            }
            ;
            var _u, xu, Du;
            Eu = (0,
            c.gn)([(0,
            i.Injectable)()], Eu);
            const Ou = O("CloseOnScrollDirective");
            let Au = class {
                constructor(e, t, n) {
                    this._OpenPanelService = e,
                    this.el = t,
                    this.autoCompleteTrigger = n
                }
                ngOnInit() {
                    null !== this.autoCompleteTrigger ? this._OpenPanelService.addAutocompleteTrigger(this.autoCompleteTrigger) : Ou("warn", `Could not add trigger ${this.el.nativeElement.tagName} to the Open Panel Service`)
                }
                ngOnDestroy() {
                    null !== this.autoCompleteTrigger ? this._OpenPanelService.removeAutocompleteTrigger(this.autoCompleteTrigger) : Ou("warn", `Could not remove trigger ${this.el.nativeElement.tagName} from the Open Panel Service`)
                }
            }
            ;
            Au = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "[closeOnScroll]"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Eu)), (0,
            c.fM)(1, (0,
            i.Inject)(i.ElementRef)), (0,
            c.fM)(2, (0,
            i.Inject)(Qn.ZL)), (0,
            c.fM)(2, (0,
            i.Optional)()), (0,
            c.w6)("design:paramtypes", ["function" == typeof (_u = void 0 !== Eu && Eu) ? _u : Object, "function" == typeof (xu = void 0 !== i.ElementRef && i.ElementRef) ? xu : Object, "function" == typeof (Du = void 0 !== Qn.ZL && Qn.ZL) ? Du : Object])], Au);
            let Ru = class {
                constructor() {
                    this.canClose = !0,
                    this.onClose = new i.EventEmitter
                }
                clearError() {
                    this.onClose.emit()
                }
                displayError() {
                    return void 0 !== this.errmsg
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Ru.prototype, "errmsg", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Ru.prototype, "canClose", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], Ru.prototype, "onClose", void 0),
            Ru = (0,
            c.gn)([(0,
            i.Component)({
                selector: "sing-dialog-errors",
                template: n(40957)
            })], Ru);
            var Pu, ku = n(17567);
            let Mu = class {
                constructor() {
                    this.click$ = new St.x,
                    this.doubleClick = new i.EventEmitter
                }
                onClick(e) {
                    this.click$.next(e)
                }
                ngOnInit() {
                    this.click$.pipe((0,
                    ku.f)(this.click$.pipe((0,
                    Zl.b)(250))), (0,
                    ra.h)((e => 2 === e.length)), (0,
                    He.U)((e => e[1]))).subscribe(this.doubleClick)
                }
                ngOnDestroy() {
                    this.click$.complete()
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], Mu.prototype, "doubleClick", void 0),
            (0,
            c.gn)([(0,
            i.HostListener)("click", ["$event"]), (0,
            c.w6)("design:type", Function), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Pu = "undefined" != typeof MouseEvent && MouseEvent) ? Pu : Object]), (0,
            c.w6)("design:returntype", void 0)], Mu.prototype, "onClick", null),
            Mu = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "[doubleClick]"
            })], Mu);
            let Lu = class {
                constructor() {
                    this.msgs = L.messages.errors,
                    this.title = "",
                    this.message = "",
                    this.onRefresh = null
                }
                canRefresh() {
                    return null !== this.onRefresh
                }
                refreshHandler() {
                    this.onRefresh && this.onRefresh()
                }
            }
            ;
            var Nu, Fu, Uu, $u;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Lu.prototype, "title", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Lu.prototype, "message", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Lu.prototype, "onRefresh", void 0),
            Lu = (0,
            c.gn)([(0,
            i.Component)({
                selector: "error-page",
                template: n(91677)
            })], Lu),
            function(e) {
                e.PRIMARY = "primary",
                e.WARNING = "warning",
                e.WHITE = "white"
            }(Nu || (Nu = {})),
            function(e) {
                e.TRIANGLE = "triangle",
                e.DRAWER = "drawer"
            }(Fu || (Fu = {})),
            function(e) {
                e.EXPANDABLE = "expandable",
                e.BARS = "bars"
            }(Uu || (Uu = {})),
            function(e) {
                e.PLUS = "plus",
                e.MINUS = "minus",
                e.BARS = "bars",
                e.LEFT = "chevron-left",
                e.RIGHT = "chevron-right"
            }($u || ($u = {}));
            let ju = class {
                constructor() {
                    this.expanded = !1,
                    this.color = Nu.PRIMARY,
                    this.type = Fu.TRIANGLE,
                    this.iconType = Uu.EXPANDABLE,
                    this.direction = "right",
                    this.icon = $u.BARS
                }
                ngOnInit() {
                    this.checkButtonState()
                }
                ngOnChanges() {
                    this.checkButtonState()
                }
                checkButtonState() {
                    this.type === Fu.DRAWER ? this.checkDrawerButtonState() : this.checkBagButtonState()
                }
                checkBagButtonState() {
                    this.iconType === Uu.EXPANDABLE && (this.icon = this.expanded ? $u.MINUS : $u.PLUS)
                }
                checkDrawerButtonState() {
                    this.iconType === Uu.EXPANDABLE && ("left" === this.direction ? this.icon = this.expanded ? $u.RIGHT : $u.LEFT : this.icon = this.expanded ? $u.LEFT : $u.RIGHT)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], ju.prototype, "expanded", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], ju.prototype, "color", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], ju.prototype, "type", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], ju.prototype, "iconType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], ju.prototype, "direction", void 0),
            ju = (0,
            c.gn)([(0,
            i.Component)({
                selector: "expand-button",
                template: n(76087)
            })], ju);
            let Vu = class {
                constructor() {
                    this.icon = "fa-video-camera"
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Number)], Vu.prototype, "number", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], Vu.prototype, "primaryColor", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Vu.prototype, "icon", void 0),
            Vu = (0,
            c.gn)([(0,
            i.Component)({
                selector: "icon-total",
                template: n(33057)
            })], Vu);
            let Gu = class {
                constructor() {
                    this.failed = !1,
                    this.disabled = !1
                }
                onError() {
                    this.failed = !0
                }
            }
            ;
            var Bu;
            (0,
            c.gn)([(0,
            i.Input)("src"), (0,
            c.w6)("design:type", String)], Gu.prototype, "src", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], Gu.prototype, "disabled", void 0),
            Gu = (0,
            c.gn)([(0,
            i.Component)({
                selector: "sing-image-loader",
                template: n(36966)
            })], Gu);
            let zu = class {
                constructor(e) {
                    this._minimumVersionService = e,
                    this.msgs = L.messages.cameraSelection,
                    this.loading = !1,
                    this.cameras = [],
                    this.selectedCameras = [],
                    this.multiSelect = !0,
                    this.viewOnly = !1,
                    this.pageSize = 8,
                    this.pageSizeOptions = [8, 12, 24, 48],
                    this.pageIndex = 0,
                    this.cameraSelected = new i.EventEmitter,
                    this.paginatedCameras = [],
                    this._isCameraDisablementSupported = !0
                }
                get hasCameras() {
                    return this.cameras.length > 0
                }
                cameraIsSelected(e) {
                    return this.selectedCameras.includes(e)
                }
                onCameraSelected(e) {
                    this.viewOnly || (0 === this.selectedCameras.length ? this.selectedCameras = [e] : this.selectedCameras.includes(e) ? this.selectedCameras.splice(this.selectedCameras.indexOf(e), 1) : (!1 === this.multiSelect && (this.selectedCameras = []),
                    this.selectedCameras.push(e)),
                    this.cameraSelected.emit(this.selectedCameras))
                }
                onPaginatorChange(e) {
                    this.paginatedCameras = Mc(this.cameras, e.pageSize, e.pageIndex)
                }
                _sortCamerasByNameAndSelected() {
                    this.cameras.sort(( (e, t) => Tt(e.cameraName).toLocaleLowerCase().localeCompare(Tt(t.cameraName).toLocaleLowerCase()))),
                    this.cameras = [...this.cameras.filter((e => this.selectedCameras.includes(e))), ...this.cameras.filter((e => !this.selectedCameras.includes(e)))]
                }
                cameraIsEnabled(e) {
                    var t;
                    return !this._isCameraDisablementSupported || null !== (t = e.active) && void 0 !== t && t
                }
                ngOnInit() {
                    this.loading = !0,
                    this._sortCamerasByNameAndSelected(),
                    this.paginatedCameras = Mc(this.cameras, this.pageSize, this.pageIndex),
                    this.loading = !1,
                    !w.isOrchid && this.orchid && (this._isCameraDisablementSupported = this._minimumVersionService.isFeatureSupported(this.orchid, Sr.CAMERA_DISABLEMENT))
                }
                ngOnChanges(e) {
                    (e.cameras || e.pageSizeOptions && !Rc(e.pageSizeOptions.currentValue, e.pageSizeOptions.previousValue)) && (this._sortCamerasByNameAndSelected(),
                    this.paginatedCameras = Mc(this.cameras, this.pageSize, this.pageIndex))
                }
            }
            ;
            var Hu, Wu, qu, Yu;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], zu.prototype, "cameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], zu.prototype, "selectedCameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zu.prototype, "multiSelect", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zu.prototype, "viewOnly", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zu.prototype, "pageSize", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zu.prototype, "pageSizeOptions", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zu.prototype, "pageIndex", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zu.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], zu.prototype, "cameraSelected", void 0),
            zu = (0,
            c.gn)([(0,
            i.Component)({
                selector: "orchid-camera-picker",
                template: n(81687)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Bu = void 0 !== Cr && Cr) ? Bu : Object])], zu);
            let Xu = class {
                constructor() {
                    this.length = 0,
                    this.pageSize = 10,
                    this.pageSizeOptions = [10, 20, 30, 50],
                    this.dataSource = [],
                    this.hidePageSize = !1,
                    this.pageData = {
                        pageIndex: 0,
                        length: this.length,
                        pageSize: this.pageSize
                    },
                    this.isPaginationVisible = !0,
                    this.pagedData = new i.EventEmitter,
                    this.page = new i.EventEmitter
                }
                ngOnInit() {
                    this.length = this.dataSource.length,
                    this.fixedPageSize = this.pageSizeOptions[0],
                    this.isPaginationVisible = this._testPaginationVisible()
                }
                ngOnChanges(e) {
                    e.dataSource && (this.pageData.pageIndex = 0,
                    this.paginator.firstPage()),
                    this.pagedData.emit(this.dataSource.slice(0, this.pageSize)),
                    this.isPaginationVisible = this._testPaginationVisible(),
                    this.length = this.dataSource.length
                }
                onChangePage(e) {
                    this.page.emit(e),
                    this.length = e.length,
                    this.pageSize = e.pageSize;
                    const t = e.pageIndex * e.pageSize;
                    let n = t + e.pageSize;
                    n > this.length && (n = this.length),
                    this.pagedData.emit(this.dataSource.slice(t, n))
                }
                _testPaginationVisible() {
                    return !(this.dataSource.length <= this.fixedPageSize)
                }
            }
            ;
            var Ku, Zu, Ju;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Xu.prototype, "pageSize", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Xu.prototype, "pageSizeOptions", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Hu = "undefined" != typeof Array && Array) ? Hu : Object)], Xu.prototype, "dataSource", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Xu.prototype, "hidePageSize", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (Wu = void 0 !== i.EventEmitter && i.EventEmitter) ? Wu : Object)], Xu.prototype, "pagedData", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (qu = void 0 !== i.EventEmitter && i.EventEmitter) ? qu : Object)], Xu.prototype, "page", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW, {
                static: !0
            }), (0,
            c.w6)("design:type", "function" == typeof (Yu = void 0 !== pi.NW && pi.NW) ? Yu : Object)], Xu.prototype, "paginator", void 0),
            Xu = (0,
            c.gn)([(0,
            i.Component)({
                selector: "pagination",
                template: n(81175)
            })], Xu),
            function(e) {
                e.HIDDEN = "eye",
                e.VISIBLE = "eye-slash"
            }(Zu || (Zu = {})),
            function(e) {
                e.PASSWORD = "password",
                e.TEXT = "text"
            }(Ju || (Ju = {}));
            let Qu = class {
                constructor(e) {
                    this.ngControl = e,
                    this.label = "",
                    this.placeholder = "",
                    this.errorMessage = "",
                    this.required = !1,
                    this.matInput = null,
                    this.icon = Zu.HIDDEN,
                    this.type = Ju.PASSWORD,
                    this.touched = !1,
                    this.disabled = !1,
                    this.value = "",
                    this.hidden = !0,
                    null !== e && (e.valueAccessor = this)
                }
                get matcher() {
                    return this
                }
                isErrorState() {
                    var e;
                    return this.touched && null !== (e = this.ngControl.invalid) && void 0 !== e && e
                }
                onFocusOut() {
                    var e;
                    this.touched = !0,
                    this.onTouched(),
                    null === (e = this.matInput) || void 0 === e || e.updateErrorState()
                }
                onInput(e) {
                    const t = e.currentTarget;
                    this.value = t.value,
                    this.touched = !0,
                    this.onChange(this.value)
                }
                onIconClick(e) {
                    this.hidden = !this.hidden,
                    this.icon = this.hidden ? Zu.HIDDEN : Zu.VISIBLE,
                    this.type = this.hidden ? Ju.PASSWORD : Ju.TEXT,
                    e.stopPropagation()
                }
                writeValue(e) {
                    this.value = e
                }
                registerOnChange(e) {
                    this.onChange = e
                }
                registerOnTouched(e) {
                    this.onTouched = e
                }
                setDisabledState(e) {
                    this.disabled = e
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Qu.prototype, "label", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Qu.prototype, "placeholder", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Qu.prototype, "errorMessage", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Qu.prototype, "required", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(ui.Nt), (0,
            c.w6)("design:type", Object)], Qu.prototype, "matInput", void 0),
            Qu = (0,
            c.gn)([(0,
            i.Component)({
                selector: "password-form-field",
                template: n(12930)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(p.a5)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Ku = void 0 !== p.a5 && p.a5) ? Ku : Object])], Qu);
            let em = class {
                constructor() {
                    this.color = "primary",
                    this.icon = "",
                    this.text = "Button Text Here",
                    this.disabled = !1,
                    this.showSpinner = !1
                }
            }
            ;
            var tm;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], em.prototype, "color", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], em.prototype, "icon", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], em.prototype, "text", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], em.prototype, "textColor", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], em.prototype, "disabled", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], em.prototype, "showSpinner", void 0),
            em = (0,
            c.gn)([(0,
            i.Component)({
                selector: "spinner-button",
                template: n(69858)
            })], em),
            function(e) {
                e.ONVIF = "onvif",
                e.EXTERNAL = "external"
            }(tm || (tm = {}));
            const nm = Object.assign(Object.assign({}, au), {
                EXTERNAL: tm.EXTERNAL,
                ONVIF: tm.ONVIF,
                DISABLED_CAMERA: "disabled-camera",
                RESOURCE_TAG_KEY: "resource-tag-key",
                RESOURCE_TAG_VAL: "resource-tag-val"
            });
            let im = class {
                constructor() {
                    this.type = nm.GENERIC,
                    this.label = "",
                    this.icon = "",
                    this.msgs = Object.assign({}, L.messages.events.eventsSubscriptions)
                }
                ngOnChanges() {
                    if ("string" == typeof this.label && "string" == typeof this.label && 0 === this.label.length)
                        switch (this.type) {
                        case nm.EXTERNAL:
                            this.label = this.msgs.external();
                            break;
                        case nm.ONVIF:
                            this.label = this.type;
                            break;
                        case nm.DISABLED_CAMERA:
                            this.label = L.messages.cameras.disabled()
                        }
                    this.setIcon()
                }
                setIcon() {
                    if (0 === this.icon.length)
                        switch (this.type) {
                        case nm.SUCCESS:
                            this.icon = zt.success;
                            break;
                        case nm.ERROR:
                            this.icon = zt.unavailable;
                            break;
                        case nm.WARNING:
                            this.icon = zt.error;
                            break;
                        case nm.DISABLED_CAMERA:
                            this.icon = qt.camera_disabled;
                            break;
                        default:
                            this.icon = ""
                        }
                }
            }
            ;
            var am;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], im.prototype, "type", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], im.prototype, "label", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], im.prototype, "icon", void 0),
            im = (0,
            c.gn)([(0,
            i.Component)({
                selector: "tag",
                template: n(9910)
            })], im);
            let rm = class {
                constructor(e) {
                    this._OpenPanelService = e
                }
                onScroll() {
                    this._OpenPanelService.closePanelsOnScroll()
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.HostListener)("scroll", ["$event"]), (0,
            c.w6)("design:type", Function), (0,
            c.w6)("design:paramtypes", []), (0,
            c.w6)("design:returntype", void 0)], rm.prototype, "onScroll", null),
            rm = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "[triggerCloseOnScroll]"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Eu)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (am = void 0 !== Eu && Eu) ? am : Object])], rm);
            let sm = class {
                get href() {
                    return window.location.href
                }
                set href(e) {
                    window.location.href = e
                }
            }
            ;
            var om, cm;
            sm = (0,
            c.gn)([(0,
            i.Injectable)()], sm);
            let lm = class {
                constructor(e, t) {
                    this._windowLocationService = e,
                    this._activatedRoute = t,
                    this.destroyed$ = new St.x
                }
                ngOnInit() {
                    this._activatedRoute.queryParams.pipe((0,
                    oa.R)(this.destroyed$)).subscribe((e => {
                        e.redirectTo && (this._windowLocationService.href = e.redirectTo)
                    }
                    ))
                }
                ngOnDestroy() {
                    this.destroyed$.next(),
                    this.destroyed$.complete()
                }
            }
            ;
            var dm;
            lm = (0,
            c.gn)([(0,
            i.Component)({
                selector: "external-redirect",
                template: "<div></div>"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(sm)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (om = void 0 !== sm && sm) ? om : Object, "function" == typeof (cm = void 0 !== Bt.gz && Bt.gz) ? cm : Object])], lm);
            let um = class {
                constructor() {
                    this.pageSize = 0,
                    this.dataSource = [],
                    this.showSpinner = !1,
                    this.moreClick = new i.EventEmitter,
                    this.msgs = L.messages.events
                }
            }
            ;
            var mm, hm, pm;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], um.prototype, "pageSize", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], um.prototype, "dataSource", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], um.prototype, "showSpinner", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (dm = void 0 !== i.EventEmitter && i.EventEmitter) ? dm : Object)], um.prototype, "moreClick", void 0),
            um = (0,
            c.gn)([(0,
            i.Component)({
                selector: "table-indeterminate-footer",
                template: n(54424)
            })], um);
            let gm = class {
                constructor(e, t, n) {
                    this._paginator = e,
                    this._minimumVersionService = t,
                    this._changeDetectorRef = n,
                    this.loaded = !1,
                    this._orchids = [],
                    this._selectedOrchids = [],
                    this.disabled = !1,
                    this.disableAll = !1,
                    this.onOrchidSelect = new i.EventEmitter,
                    this.icons = zt,
                    this.messages = L.messages.recorderPicker,
                    this.pageSize = 10,
                    this.pagedServers = [],
                    this.length = 0,
                    this.pageSizeOptions = [10, 20, 30, 50],
                    this.searchableList = [],
                    this.searchResults = [],
                    this.filteredServers = [],
                    this.selectAll = !1,
                    this.numSupportedOrchids = 0,
                    this.msgs = Object.assign({}, L.messages.events.orchidSelector),
                    this._unsupportedSelectedOrchids = []
                }
                set orchids(e) {
                    this._orchids = this._sortOrchids(e)
                }
                get orchids() {
                    return this._orchids
                }
                set selectedOrchids(e) {
                    this._selectedOrchids = e,
                    this.orchids.length > 0 && (this._orchids = this._sortOrchids(this.orchids))
                }
                get selectedOrchids() {
                    return this._selectedOrchids
                }
                ngOnInit() {
                    this._paginator.setLabel(this.messages.recorders()),
                    this.numSupportedOrchids = this.orchids.filter((e => this.orchidIsSupported(e))).length,
                    this._unsupportedSelectedOrchids = this.selectedOrchids.filter((e => !this.orchidIsSupported(e)))
                }
                ngOnChanges(e) {
                    e.loaded && void 0 !== this.orchids && (this.filteredServers = this._sortOrchids(this.orchids),
                    this.orchids.forEach((e => {
                        this.searchableList.push(e.name),
                        this.searchableList.push(e.uri)
                    }
                    )),
                    this.searchResults = this.searchableList)
                }
                updateFilteredData(e) {
                    this.filteredServers = this._sortOrchids(this.orchids.filter((t => e.includes(t.name) || e.includes(t.uri))))
                }
                updatePagedData(e) {
                    this.pagedServers = e,
                    this._changeDetectorRef.detectChanges()
                }
                handlePage(e) {
                    this.pageSize = e.pageSize
                }
                onOrchidSelected(e) {
                    let t = [];
                    if (0 === this.selectedOrchids.length)
                        t = [e];
                    else {
                        const n = this.selectedOrchids.indexOf(e);
                        n > -1 ? (t = this.selectedOrchids.slice(),
                        t.splice(n, 1),
                        this.selectAll = !1) : (t = this.selectedOrchids,
                        t.push(e),
                        t.length === this.orchids.length && (this.selectAll = !0))
                    }
                    this.onOrchidSelect.emit(this._getValidOrchidsToEmit(t))
                }
                isOrchidSelected(e) {
                    return this.selectedOrchids.includes(e) || this._unsupportedSelectedOrchids.includes(e)
                }
                onSelectAllClick(e) {
                    this.selectAll = e.checked,
                    this.selectedOrchids = [],
                    this.selectAll && (this.selectedOrchids = this.orchids),
                    this.onOrchidSelect.emit(this._getValidOrchidsToEmit(this.selectedOrchids))
                }
                orchidIsSupported(e) {
                    return !this.requiredOrchidVersion || this._minimumVersionService.isFeatureSupported(e, this.requiredOrchidVersion)
                }
                _sortOrchids(e) {
                    if (this.disabled) {
                        return [...this._sortSelectedOrchidsToTop(e)]
                    }
                    const t = e.filter((e => this.orchidIsSupported(e)))
                      , n = e.filter((e => !this.orchidIsSupported(e)));
                    return [...this._sortSelectedOrchidsToTop(t), ...this._sortSelectedOrchidsToTop(n)]
                }
                _sortSelectedOrchidsToTop(e) {
                    const t = []
                      , n = [];
                    return e.forEach((e => {
                        this.isOrchidSelected(e) ? t.push(e) : n.push(e)
                    }
                    )),
                    t.sort(( (e, t) => e.name.toLowerCase().localeCompare(t.name.toLowerCase()))),
                    n.sort(( (e, t) => e.name.toLowerCase().localeCompare(t.name.toLowerCase()))),
                    [...t, ...n]
                }
                _getValidOrchidsToEmit(e) {
                    return e.filter((e => this.orchidIsSupported(e)))
                }
            }
            ;
            var fm;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], gm.prototype, "loaded", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array), (0,
            c.w6)("design:paramtypes", [Array])], gm.prototype, "orchids", null),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array), (0,
            c.w6)("design:paramtypes", [Array])], gm.prototype, "selectedOrchids", null),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], gm.prototype, "disabled", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], gm.prototype, "disableAll", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], gm.prototype, "requiredOrchidVersion", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], gm.prototype, "onOrchidSelect", void 0),
            gm = (0,
            c.gn)([(0,
            i.Component)({
                selector: "recorder-picker",
                template: n(43149),
                providers: [{
                    provide: pi.ye,
                    useClass: uu
                }],
                changeDetection: i.ChangeDetectionStrategy.OnPush
            }), (0,
            c.fM)(0, (0,
            i.Inject)(uu)), (0,
            c.fM)(1, (0,
            i.Inject)(Cr)), (0,
            c.fM)(2, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (mm = void 0 !== uu && uu) ? mm : Object, "function" == typeof (hm = void 0 !== Cr && Cr) ? hm : Object, "function" == typeof (pm = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? pm : Object])], gm);
            let vm = class {
                constructor() {
                    this.showDrawer = !1,
                    this.showDrawerChange = new i.EventEmitter,
                    this.drawerTitle = "",
                    this.drawerInfoText = "",
                    this.ActionsIcons = Ht
                }
                handleCloseButtonClick() {
                    this.showDrawer = !1,
                    this.showDrawerChange.emit(this.showDrawer)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], vm.prototype, "showDrawer", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (fm = void 0 !== i.EventEmitter && i.EventEmitter) ? fm : Object)], vm.prototype, "showDrawerChange", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], vm.prototype, "drawerTitle", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], vm.prototype, "drawerInfoText", void 0),
            vm = (0,
            c.gn)([(0,
            i.Component)({
                selector: "info-drawer",
                template: n(53182)
            })], vm);
            let ym = class {
            }
            ;
            ym = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [su, du, yu, Iu, Au, qs, Ru, Mu, _r, Lu, ju, lm, ds, Vu, Gu, Id, vm, zu, Xu, Qu, fn, Go, gm, aa, wu, em, um, im, rm],
                exports: [su, du, yu, Iu, Au, qs, Ru, Mu, _r, Lu, ju, ds, lm, Vu, Gu, Id, vm, zu, Xu, Qu, fn, Go, gm, aa, wu, em, um, im, rm],
                imports: [l.ez, u.PW, p.u5, Ai, p.UX],
                entryComponents: [qs, Id, fn, Go, Vu]
            })], ym);
            let bm = class {
            }
            ;
            var Sm, Cm, wm, Im, Tm, Em, _m, xm;
            bm = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [Jd, iu],
                exports: [Jd, iu],
                imports: [l.ez, Ai, ym]
            })], bm),
            function(e) {
                e[e.Initial = 0] = "Initial",
                e[e.AddingItems = 1] = "AddingItems",
                e[e.AddItemsFailure = 2] = "AddItemsFailure"
            }(xm || (xm = {}));
            const Dm = "date-range"
              , Om = "library-item-name"
              , Am = "max-export-exceeded"
              , Rm = "server-required";
            let Pm = Sm = class {
                constructor(e, t, n, i, a, r) {
                    this._FusionDataService = e,
                    this._FusionConfigService = t,
                    this.data = n,
                    this.mdDialogRef = i,
                    this._matDialog = a,
                    this._authenticator = r,
                    this.newDateTime = (new Date).getTime(),
                    this.dateMillRoundDown = new Date(this.newDateTime - this.newDateTime % 1e3),
                    this.libraryItemGroup = new p.cw({
                        name: new p.NI(void 0,[p.kI.required, e => null !== e.value && void 0 !== e.value ? null : {
                            [Om]: !0
                        }]),
                        server: new p.NI(void 0,[p.kI.required, e => {
                            const t = e.value;
                            return null != t && "string" != typeof t ? null : {
                                [Rm]: !0
                            }
                        }
                        ]),
                        streams: new p.Oe([],[p.kI.required, p.kI.min(1)]),
                        from: new p.NI(new Date(this.dateMillRoundDown.getTime() - 24e4),p.kI.required),
                        to: new p.NI(this.dateMillRoundDown,p.kI.required)
                    },(e => {
                        var t, n;
                        const i = null === (t = e.get("from")) || void 0 === t ? void 0 : t.value
                          , a = null === (n = e.get("to")) || void 0 === n ? void 0 : n.value;
                        if (!this.isRangeValid(i, a))
                            return {
                                [Dm]: !0
                            };
                        if (null === this.maxExportHours)
                            return null;
                        return (a.getTime() - i.getTime()) / 36e5 > this.maxExportHours ? {
                            [Am]: !0
                        } : null
                    }
                    )),
                    this.msgs = Object.assign(Object.assign({}, L.messages.library), {
                        timeRangeError: L.messages.stage.timeRangeError,
                        maximumExportDuration: L.messages.stage.maximumExportDuration,
                        noChildNameServersHaveBeenRegistered: L.messages.dashboard.noChildNameServersHaveBeenRegistered,
                        unknownErrorOccurred: L.messages.errors.unknownErrorOccurred,
                        oneOrMoreOfTheLibraryItemsFailedToBeCreated: L.messages.library.oneOrMoreOfTheLibraryItemsFailedToBeCreated
                    }),
                    this.dateTimeFormat = L.formats.ipcDatePicker.seconds,
                    this._destroy$ = new St.x,
                    this.filteredOrchids$ = (0,
                    ze.of)([]),
                    this._orchids = [],
                    this.hasOrchids = !0,
                    this.state = xm.Initial,
                    this.isAdmin = !1,
                    this.maxExportHours = null,
                    this.log = O("AddLibraryItemDialogComponent"),
                    this._mappedCameras = new Map
                }
                static show(e, t) {
                    return e.open(Sm, {
                        minWidth: "300px",
                        width: "50vw",
                        panelClass: "add-lib-item-dialog-panel",
                        disableClose: !0,
                        data: t
                    }).afterClosed()
                }
                get addLibItemsFailed() {
                    return this.state === xm.AddItemsFailure
                }
                get showAddLibItemButton() {
                    return this.state === xm.Initial || this.state === xm.AddItemsFailure
                }
                get addLibItemButtonDisabled() {
                    return this.libraryItemGroup.invalid || this.state === xm.AddingItems
                }
                get serverFieldValid() {
                    return this.libraryItemGroup.controls.server.valid
                }
                get serverCameras() {
                    const e = this.libraryItemGroup.controls.server.value;
                    if ("object" != typeof e)
                        return null;
                    let t = this._mappedCameras.get(e.id);
                    return void 0 === t && (t = [...e.cameras],
                    this._mappedCameras.set(e.id, t)),
                    t
                }
                get hasServerCameras() {
                    const e = this.serverCameras;
                    return !!e && e.length > 0
                }
                get fromDate() {
                    return this.libraryItemGroup.controls.from.value
                }
                get toDate() {
                    return this.libraryItemGroup.controls.to.value
                }
                get haveDisplayableErrors() {
                    return this.exportTimespanExceedsMaximum || this.dateRangeInvalid
                }
                get dateRangeInvalid() {
                    return this.libraryItemGroup.hasError(Dm)
                }
                get exportTimespanExceedsMaximum() {
                    return this.libraryItemGroup.hasError(Am)
                }
                get errorMessage() {
                    return this.exportTimespanExceedsMaximum ? this.msgs.maximumExportDuration({
                        VALUE: this.maxExportHours
                    }) : this.dateRangeInvalid ? this.msgs.timeRangeError() : ""
                }
                ngOnInit() {
                    this._orchids = this.data.sort(( (e, t) => e.name.toLowerCase() < t.name.toLowerCase() ? -1 : e.name.toLowerCase() > t.name.toLowerCase() ? 1 : 0)),
                    0 === this._orchids.length && (this.hasOrchids = !1),
                    this.filteredOrchids$ = this.libraryItemGroup.controls.server.valueChanges.pipe((0,
                    lu.O)(""), (0,
                    He.U)((e => (e || this.libraryItemGroup.controls.streams.clear(),
                    this._filterOrchids(e)))));
                    try {
                        this.maxExportHours = this._FusionConfigService.getConfigPostAuth().maxLibraryExportHours
                    } catch (e) {
                        this.maxExportHours = null,
                        this.log.error("unable to get maximum library export hours")
                    }
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                showDatetimePicker(e) {
                    Pi(this._matDialog, {
                        date: this.libraryItemGroup.controls[e ? "to" : "from"].value,
                        title: `${e ? this.msgs.to() : this.msgs.from()}`,
                        okText: this.msgs.go()
                    }).subscribe((t => {
                        void 0 !== t && this.libraryItemGroup.controls[e ? "to" : "from"].setValue(t)
                    }
                    ))
                }
                isRangeValid(e, t) {
                    return e.getTime() + 1e4 <= t.getTime() && t.getTime() <= Date.now()
                }
                cancel() {
                    this.close(!1)
                }
                onSelectionStateChange(e) {
                    const t = this.libraryItemGroup.get("streams")
                      , n = Array.isArray(e.camera.secondaryStreams) ? e.camera.secondaryStreams : []
                      , i = [e.camera.primaryStream, ...n].map((e => null == e ? void 0 : e.id))
                      , a = t.controls.filter((e => !i.includes(e.value.id)));
                    e.checked && a.push(new p.NI(e.stream)),
                    t.clear(),
                    a.forEach((e => t.push(e)))
                }
                close(e) {
                    this.mdDialogRef.close(e)
                }
                confirm() {
                    const e = this.libraryItemGroup.value;
                    e.server && Array.isArray(e.streams) ? (this.state = xm.AddingItems,
                    this.addLibraryItems(e).catch((e => {
                        this.log.error(e)
                    }
                    ))) : this.close(!1)
                }
                addLibraryItems({name: e, server: t, streams: n, from: i, to: a}) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const r = [];
                        let s = !1;
                        for (let o = 0; o < n.length; o++) {
                            const c = n[o];
                            c && r.push(this._FusionDataService.newLibraryExport({
                                name: e,
                                request: {
                                    source: {
                                        orchidId: t.id,
                                        streamId: c.id
                                    },
                                    startTimeMs: i.getTime(),
                                    stopTimeMs: a.getTime()
                                }
                            }).then(( () => {
                                const e = this.checkboxes.find((e => {
                                    var t;
                                    return (null === (t = e.selectedStream) || void 0 === t ? void 0 : t.id) === c.id
                                }
                                ));
                                Ke(e) && (e.error = "",
                                e.uncheck())
                            }
                            )).catch((e => {
                                s = !0;
                                let t = this.msgs.unknownErrorOccurred();
                                e.reason ? t = e.reason : e.data && (e.data.reason ? t = e.data.reason : e.data.message && (t = e.data.message));
                                const n = this.checkboxes.find((e => {
                                    var t;
                                    return (null === (t = e.selectedStream) || void 0 === t ? void 0 : t.id) === c.id
                                }
                                ));
                                Ke(n) && (n.error = t)
                            }
                            )))
                        }
                        yield Promise.all(r),
                        s ? this.state = xm.AddItemsFailure : this.close(!0)
                    }
                    ))
                }
                displayServerName(e) {
                    return e && e.name ? e.name : ""
                }
                _filterOrchids(e) {
                    if ("string" == typeof e && e) {
                        const t = e.toLowerCase();
                        return this._orchids.filter((e => e.name && e.name.toLowerCase().indexOf(t) > -1))
                    }
                    return "object" == typeof e && e.cameras ? (e.cameras = this._filterCamerasToExportOnly(e.cameras),
                    e.cameras = this._sortCameras(e.cameras),
                    [e]) : this._orchids
                }
                _sortCameras(e) {
                    return e = e.sort(( (e, t) => Tt(e.name).localeCompare(Tt(t.name))))
                }
                _filterCamerasToExportOnly(e) {
                    const t = this._authenticator.getAuthenticationData()
                      , n = t.hasLibraryAccess();
                    this.isAdmin = t.isAdministrator();
                    let i = e;
                    return n && !this.isAdmin && (i = e.filter((e => !0 === e.permissions.actions.export))),
                    i
                }
                dismissMe() {
                    this.state = xm.Initial
                }
            }
            ;
            var km, Mm;
            (0,
            c.gn)([(0,
            i.ViewChildren)(iu), (0,
            c.w6)("design:type", "function" == typeof (Cm = void 0 !== i.QueryList && i.QueryList) ? Cm : Object)], Pm.prototype, "checkboxes", void 0),
            Pm = Sm = (0,
            c.gn)([(0,
            i.Component)({
                selector: "add-library-item",
                template: n(65247)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Qe)), (0,
            c.fM)(1, (0,
            i.Inject)(cc)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(3, (0,
            i.Inject)(hn.so)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (wm = Qe) ? wm : Object, "function" == typeof (Im = void 0 !== cc && cc) ? Im : Object, Array, "function" == typeof (Tm = void 0 !== hn.so && hn.so) ? Tm : Object, "function" == typeof (Em = void 0 !== hn.uw && hn.uw) ? Em : Object, "function" == typeof (_m = void 0 !== xe && xe) ? _m : Object])], Pm);
            let Lm = class {
                constructor(e, t) {
                    this._prerequisitesService = e,
                    this._fusionConfigService = t,
                    this._showLBM = !0,
                    this.warned = !1,
                    void 0 !== window.localStorage.compatibilityMode && "true" === window.localStorage.compatibilityMode && this.setDefaultPlayerMode(tn),
                    delete window.localStorage.compatibilityMode
                }
                clearDefaultPlayerMode() {
                    delete window.localStorage.defaultPlayerMode
                }
                getDefaultPlayerMode() {
                    if (void 0 !== window.localStorage.defaultPlayerMode) {
                        const e = window.localStorage.defaultPlayerMode;
                        return ae(e, an) && (e !== tn || this.isLbmAvailable()) ? e : null
                    }
                    return null
                }
                getAvailablePlayerModes(e) {
                    if (void 0 !== e && !1 === ae(e, an))
                        throw new Error(`Unsupported player mode: ${e}`);
                    return this._determineAvailablePlayers(e)
                }
                setDefaultPlayerMode(e) {
                    if (!1 === ae(e, an))
                        throw new Error(`Unsupported player mode: ${e}`);
                    window.localStorage.defaultPlayerMode = e
                }
                isLbmAvailable() {
                    return !!w.isOrchid || ie(this._fusionConfigService.getConfigPreAuth().config["player.low.bandwidth"])
                }
                _determineAvailablePlayers(e) {
                    w.isOrchid || (this._showLBM = this.isLbmAvailable());
                    const t = []
                      , n = this._prerequisitesService.getBrowser()
                      , i = this._prerequisitesService.browserSupportsWebRTC(n);
                    if (!i && !1 === this._showLBM)
                        return t;
                    const a = i ? nn : tn
                      , r = void 0 !== e ? e : this.getDefaultPlayerMode();
                    return null !== r ? t.push(r) : t.push(a),
                    -1 === t.indexOf(tn) && this._showLBM && t.push(tn),
                    -1 === t.indexOf(nn) && i && t.push(nn),
                    t
                }
            }
            ;
            var Nm, Fm, Um, $m;
            Lm = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.fM)(0, (0,
            i.Inject)(Ve)), (0,
            c.fM)(1, (0,
            i.Inject)(cc)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (km = Ve) ? km : Object, "function" == typeof (Mm = void 0 !== cc && cc) ? Mm : Object])], Lm),
            function(e) {
                e.NONE = "NONE",
                e.ERROR = "ERROR",
                e.WARN = "WARN",
                e.INFO = "INFO",
                e.LOG = "LOG",
                e.DEBUG = "DEBUG",
                e.TRACE = "TRACE"
            }($m || ($m = {}));
            const jm = [$m.NONE, $m.ERROR, $m.WARN, $m.INFO, $m.LOG, $m.DEBUG, $m.TRACE];
            var Vm;
            !function(e) {
                e.DEFAULT = "Default",
                e.DARK = "Dark"
            }(Vm || (Vm = {}));
            const Gm = "enabled"
              , Bm = "disabled";
            let zm = class {
                constructor(e, t, n) {
                    this._window = e,
                    this._playerModeService = t,
                    this._userSettingsService = n,
                    this.enabledDisabledValues = [Gm, Bm],
                    this.appThemeOptions = [Vm.DEFAULT, Vm.DARK],
                    this.selectedAppTheme = Vm.DEFAULT,
                    this.defaultPlayerMode = Bm,
                    this.logLevel = $m.NONE,
                    this.showLBM = !0,
                    this.playerModes = ["Disabled", "LowBandwidth", "WebRTC"],
                    this.logLevels = jm,
                    this.defaultPlayerMode = this._playerModeService.getDefaultPlayerMode() || Bm;
                    const i = this._window.localStorage.log;
                    ae(i, jm) ? this.logLevel = i : this.logLevel = $m.NONE;
                    const a = this._window.localStorage.webRTCSupportOverride || Bm;
                    if (ae(a, this.enabledDisabledValues) ? this.webRTCSupportOverride = a : this.webRTCSupportOverride = Bm,
                    !1 === w.isOrchid) {
                        const e = this._window.localStorage.forceOrchidProxy;
                        ae(e, this.enabledDisabledValues) ? this.forceOrchidProxy = e : this.forceOrchidProxy = Bm,
                        this.showLBM = this._playerModeService.isLbmAvailable(),
                        !1 === this.showLBM && (this.playerModes = ["Disabled", "WebRTC"]),
                        this.selectedAppTheme = this._userSettingsService.getSettings("isDark") ? Vm.DARK : Vm.DEFAULT
                    }
                }
                get isCustomLicense() {
                    return w.isCustomLicense
                }
                isFusion() {
                    return !1 === w.isOrchid
                }
                cancel() {
                    this._window.history.back()
                }
                save() {
                    this.defaultPlayerMode === Bm ? this._playerModeService.clearDefaultPlayerMode() : this._playerModeService.setDefaultPlayerMode(this.defaultPlayerMode),
                    this.webRTCSupportOverride !== Gm ? delete this._window.localStorage.webRTCSupportOverride : this._window.localStorage.webRTCSupportOverride = Gm,
                    this.logLevel === $m.NONE || !1 === ae(this.logLevel, jm) ? delete this._window.localStorage.log : this._window.localStorage.log = this.logLevel,
                    !1 === w.isOrchid && (this.forceOrchidProxy !== Gm ? delete this._window.localStorage.forceOrchidProxy : this._window.localStorage.forceOrchidProxy = Gm,
                    this.selectedAppTheme === Vm.DARK ? this._userSettingsService.setSettings("isDark", !0) : this._userSettingsService.setSettings("isDark", !1)),
                    this._window.location.href = w.baseUrl
                }
            }
            ;
            zm = (0,
            c.gn)([(0,
            i.Component)({
                selector: "advanced-settings",
                template: n(74220)
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Nm = "undefined" != typeof Window && Window) ? Nm : Object, "function" == typeof (Fm = void 0 !== Lm && Lm) ? Fm : Object, "function" == typeof (Um = Qt) ? Um : Object])], zm);
            let Hm = class {
                constructor() {
                    this.brand = JSON.parse('{"COMPANY_NAME":"IPConfigure Inc.","COMPANY_NAME_BRIEF":"IPConfigure","COMPANY_ID":"ipconfigure","COMPANY_ID_BRIEF":"ipc","COMPANY_URL":"http://www.ipconfigure.com","APP_ID":"hybrid","APP_NAME":"Orchid Hybrid VMS","WINDOWS_APP_NAME_OVERRIDE":"hybrid","APP_NAME_BRIEF":"Orchid Hybrid VMS","APP_LOGO_TEXT":"Orchid Hybrid","PRIMARY_COLOR":"#e11a50","OVERLAY_COLOR":"#ad103a","PRIMARY_COLOR_FADE":"#e6c1cb","CHILD_PRIMARY_COLOR":"#0670a5","CHILD_OVERLAY_COLOR":"#0670a5","CHILD_PLAYER_CONTROL_COLOR":"#0670a5","COPYRIGHT_YEAR":"2016","CHILD_APP_ID":"orchid","CHILD_NAME":"Orchid Recorder","SHOW_RESOURCES":"true","DEFAULT_HTTP_PORT":"80","DEFAULT_RTSP_PORT_WINDOWS":"8554","DEFAULT_RTSP_PORT_LINUX":"554","SUPPORT_URL":"https://support.ipconfigure.com","CHILD_ID":"orchid","PARENT_NAME":"Orchid Hybrid VMS"}')
                }
            }
            ;
            var Wm;
            Hm = (0,
            c.gn)([(0,
            i.Injectable)()], Hm);
            let qm = class {
                constructor(e) {
                    this._brandService = e,
                    this.msgs = L.messages.ambulance
                }
                ngOnInit() {
                    this._brandService.brand.SUPPORT_URL && (this.errorHelp = L.messages.errors.errorHelp({
                        VALUE: this._brandService.brand.SUPPORT_URL
                    }))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], qm.prototype, "orchid", void 0),
            qm = (0,
            c.gn)([(0,
            i.Component)({
                selector: "ambulance",
                template: n(89795)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Hm)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Wm = void 0 !== Hm && Hm) ? Wm : Object])], qm);
            class Ym {
                constructor(e, t) {
                    this._sortOnProperty = e,
                    this._sortDescending = t,
                    this.compare = this._compare.bind(this)
                }
                get sortOnProperty() {
                    return this._sortOnProperty
                }
                set sortOnProperty(e) {
                    this._sortOnProperty = e
                }
                get sortDescending() {
                    return this._sortDescending
                }
                set sortDescending(e) {
                    this._sortDescending = e
                }
                _compare(e, t) {
                    ue.isSet(this._sortOnProperty);
                    const n = this.getProperty(e, this._sortOnProperty)
                      , i = this.getProperty(t, this._sortOnProperty);
                    return void 0 === n && void 0 === i ? 0 : void 0 === n ? this._sortDescending ? 1 : -1 : void 0 === i ? this._sortDescending ? -1 : 1 : "string" == typeof n && "string" == typeof i ? this._sortDescending ? i.toLocaleLowerCase().localeCompare(n.toLocaleLowerCase()) : n.toLocaleLowerCase().localeCompare(i.toLocaleLowerCase()) : n < i ? this._sortDescending ? 1 : -1 : n > i ? this._sortDescending ? -1 : 1 : 0
                }
                getProperty(e, t) {
                    if (null === e || "object" != typeof e)
                        return;
                    const n = t.split(".")
                      , i = n.shift();
                    if (void 0 === i)
                        return;
                    let a = e[i];
                    for (t of n) {
                        if (null == a)
                            return;
                        if (void 0 === a[t])
                            return;
                        a = a[t]
                    }
                    return a
                }
            }
            const Xm = O("HumanizeMimeTypePipe");
            let Km = class {
                transform(e, t) {
                    if (re(e))
                        return t;
                    switch (e.toLowerCase()) {
                    case "application/zip":
                        return "zip";
                    case "video/x-matroska":
                        return "mkv";
                    case "video/quicktime":
                        return "mov";
                    case "video/mp4":
                        return "mp4";
                    default:
                        return Xm.warn(`Unsupported ${e}`),
                        t
                    }
                }
            }
            ;
            var Zm, Jm;
            Km = (0,
            c.gn)([(0,
            i.Pipe)({
                name: "humanizeMimeType"
            })], Km),
            function(e) {
                e.Completed = "completed",
                e.Started = "started",
                e.Pending = "pending",
                e.Canceled = "canceled",
                e.Failed = "failed"
            }(Zm || (Zm = {})),
            function(e) {
                e.PreviewFromVMS = "preview-from-vms",
                e.ExportFromVMS = "export-from-vms",
                e.UploadToStorage = "upload-to-storage"
            }(Jm || (Jm = {}));
            const Qm = O("AnchorLinkDownloader");
            class eh extends class extends class {
                open() {
                    throw new Error("not implemented")
                }
                download(e) {
                    throw new Error("not implemented")
                }
                close() {
                    throw new Error("not implemented")
                }
            }
            {
                open() {}
                close() {}
            }
            {
                constructor(e, t, n) {
                    super(),
                    this.document = e,
                    this.platform = t,
                    this.fileNameGenerator = n
                }
                download(e) {
                    const t = this.document.createElement("a");
                    if (t.href = e,
                    this.platform.FIREFOX && (t.target = "_blank"),
                    this.fileNameGenerator)
                        try {
                            t.download = this.fileNameGenerator(e)
                        } catch (t) {
                            Qm.error("failed to generate file name", e),
                            Qm.error(t)
                        }
                    this.document.body.appendChild(t),
                    t.click(),
                    this.document.body.removeChild(t)
                }
            }
            var th, nh;
            let ih = class {
                constructor(e, t) {
                    this.document = e,
                    this.platform = t
                }
                createDownloader(e) {
                    return new eh(this.document,this.platform,e)
                }
            }
            ;
            var ah, rh, sh, oh, ch, lh, dh, uh;
            ih = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(l.K0)), (0,
            c.fM)(1, (0,
            i.Inject)(g.t4)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (th = "undefined" != typeof Document && Document) ? th : Object, "function" == typeof (nh = void 0 !== g.t4 && g.t4) ? nh : Object])], ih),
            function(e) {
                e[e.Loading = 0] = "Loading",
                e[e.Loaded = 1] = "Loaded",
                e[e.Failed = 2] = "Failed"
            }(uh || (uh = {}));
            const mh = O("LibraryComponent");
            let hh = class {
                constructor(e, t, n, a, r, s, o) {
                    this._document = e,
                    this._browserInfoService = t,
                    this._fusionDataService = n,
                    this._renewableService = a,
                    this._downloaderService = r,
                    this._matDialog = s,
                    this._datePipe = o,
                    this.paginatorList = new i.QueryList,
                    this.libraryItems = new Array,
                    this.filteredLibraryItems = new Array,
                    this.pageSize = 10,
                    this.pageIndex = 0,
                    this.componentState = uh.Loading,
                    this.searchTerms = [],
                    this.separatorKeysCodes = [ia.K5, ia.OC],
                    this.msgs = Object.assign(Object.assign({}, L.messages.library), L.messages.errors),
                    this.formats = L.formats.library,
                    this.orchids = [],
                    this._comparator = new Ym("createdOnMs",!0)
                }
                get ComponentState() {
                    return uh
                }
                get LibraryItemState() {
                    return Zm
                }
                ngOnDestroy() {
                    this._unsubWebSocketEvents && this._unsubWebSocketEvents.unsubscribe(),
                    this._matDialog.closeAll()
                }
                ngOnInit() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const [e,t] = yield Promise.all([this._fusionDataService.fetchLibraryExports().catch((e => (mh.error(e),
                        null))), this._renewableService.orchidsPromise()]);
                        null === e ? this.componentState = uh.Failed : (this.libraryItems = e,
                        this.libraryItems.forEach((e => {
                            e.status.state === Zm.Started && (e.transferStatus = this._getStepProgress(e.status.progress))
                        }
                        )),
                        this._unsubWebSocketEvents = this._renewableService.subscribe({
                            next: e => this._processLibraryEvents(e)
                        }),
                        this._resetPaginator(),
                        this.componentState = uh.Loaded),
                        null !== t && (this.orchids = t)
                    }
                    ))
                }
                addLibraryItem() {
                    Pm.show(this._matDialog, this.orchids).subscribe((e => {
                        e && this._resetPaginator()
                    }
                    ))
                }
                get sortDescending() {
                    return this._comparator.sortDescending
                }
                set sortDescending(e) {
                    this._comparator.sortDescending = e
                }
                get sortOnProperty() {
                    return this._comparator.sortOnProperty
                }
                set sortOnProperty(e) {
                    this._comparator.sortOnProperty = e
                }
                calcDuration(e) {
                    const t = new vl
                      , n = e.request.stopTimeMs - e.request.startTimeMs;
                    return t.formatDurationHumanized(n)
                }
                _getStepProgress(e) {
                    switch (e.step) {
                    case Jm.ExportFromVMS:
                        return 0 === e.transfer.sizeBytes ? this.msgs.preparingFileCOMPLETEDofTOTAL({
                            COMPLETED: e.transfersCompleted + 1,
                            TOTAL: e.numberOfTransfers
                        }) : this.msgs.transferringCOMPLETEDofTOTAL({
                            COMPLETED: e.transfersCompleted + 1,
                            TOTAL: e.numberOfTransfers
                        });
                    case Jm.PreviewFromVMS:
                        return this.msgs.retrievingPreview();
                    case Jm.UploadToStorage:
                        return this.msgs.storing();
                    default:
                        throw new Error(`step value: '${e.step} not supported`)
                    }
                }
                handlePage(e) {
                    this._clearLibraryItems(),
                    this.pageIndex = e.pageIndex,
                    this.pageSize = e.pageSize
                }
                onSearchTermAdded(e) {
                    const t = e.input
                      , n = e.value;
                    (n || "").trim() && this.searchTerms.push(n),
                    t.value = "",
                    this._resetPaginator()
                }
                onSearchTermRemoved(e) {
                    const t = this.searchTerms.indexOf(e);
                    t > -1 && this.searchTerms.splice(t, 1),
                    this._resetPaginator()
                }
                onSortSelectionChanged() {
                    this._resetPaginator()
                }
                _clearLibraryItems() {
                    this.libraryItems.forEach((e => {
                        e.expanded = !1,
                        e.error = "",
                        e.selectedForDelete = !1
                    }
                    ))
                }
                _processLibraryEvents(e) {
                    let t;
                    switch (e.eventType) {
                    case "LIBRARY_EXPORT_ADDED":
                        t = e.response,
                        this.libraryItems.push(t);
                        break;
                    case "LIBRARY_EXPORT_PROGRESS":
                    case "LIBRARY_EXPORT_MODIFIED":
                        {
                            t = e.response,
                            t.status.progress && (t.transferStatus = this._getStepProgress(t.status.progress),
                            t.calculatedProgress = t.status.progress.transfer.sentBytes / t.status.progress.transfer.sizeBytes * 100);
                            const n = this.libraryItems.findIndex((e => e.id === t.id));
                            if (n > -1) {
                                const e = this.libraryItems[n];
                                this.libraryItems[n] = Object.assign(e, t)
                            }
                            break
                        }
                    case "LIBRARY_EXPORT_REMOVED":
                        {
                            t = e.response;
                            const n = this.libraryItems.findIndex((e => e.id === t.id));
                            if (n > -1 && (this.libraryItems.splice(n, 1),
                            this.paginatorList && this.paginatorList.length > 0)) {
                                const e = this.paginatorList.first;
                                e && e.pageIndex >= this.libraryItems.length / e.pageSize && e.previousPage()
                            }
                            break
                        }
                    default:
                        return void mh.warn(`The event type ${e.eventType} is not handled`)
                    }
                    this._applyFilterAndSort()
                }
                onSortDescendChanged(e) {
                    e.stopPropagation(),
                    this.sortDescending = !this.sortDescending,
                    this._resetPaginator()
                }
                _applyFilterAndSort() {
                    const e = this.libraryItems.filter((e => {
                        let t = !1;
                        if (0 === this.searchTerms.length)
                            return !0;
                        for (let n = 0; n < this.searchTerms.length; n++) {
                            const i = this.searchTerms[n].toLowerCase()
                              , a = e.request.source.orchidName.toLowerCase()
                              , r = e.request.source.cameraName.toLowerCase();
                            if (e.name.toLowerCase().indexOf(i) > -1 || a && a.indexOf(i) > -1 || r && r.indexOf(i) > -1) {
                                t = !0;
                                break
                            }
                        }
                        return t
                    }
                    ));
                    e.sort(this._comparator.compare),
                    this.filteredLibraryItems = e
                }
                _resetPaginator() {
                    this._clearLibraryItems(),
                    this._applyFilterAndSort()
                }
                areAnySelectedForDelete() {
                    return this.filteredLibraryItems.slice(this.pageIndex * this.pageSize, (this.pageIndex + 1) * this.pageSize).some((e => e.selectedForDelete))
                }
                areAllSelectedForDelete() {
                    return this.filteredLibraryItems.slice(this.pageIndex * this.pageSize, (this.pageIndex + 1) * this.pageSize).every((e => e.selectedForDelete))
                }
                rename(e) {
                    const t = {
                        panelClass: "sing-dialog-panel",
                        data: {
                            value: e.name,
                            message: this.msgs.rename(),
                            title: this.msgs.renameLibraryItem(),
                            confirmText: this.msgs.ok(),
                            cancelText: this.msgs.cancel()
                        }
                    };
                    e.error = "",
                    fn.show(this._matDialog, t).subscribe((t => (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (t) {
                            const n = {
                                name: t
                            };
                            try {
                                yield this._fusionDataService.patchLibraryExport(e.id, n)
                            } catch (t) {
                                mh.error(t.data),
                                e.error = t.data.reason
                            }
                        }
                    }
                    ))))
                }
                download(e) {
                    if (e.status.state !== Zm.Completed)
                        throw new Error("Expected a Completed library item");
                    if (void 0 === e.files || 0 === e.files.length)
                        throw new Error("Expected a populated files array");
                    const t = this._fusionDataService.authorizeUrl(e.files[0].downloadUrl);
                    this._downloaderService.createDownloader(( () => this._formatFileName(e))).download(t)
                }
                open(e) {
                    var t, n;
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (e.status.state !== Zm.Completed)
                            throw new Error("Expected a Completed library item");
                        if (void 0 === e.files || 0 === e.files.length)
                            throw new Error("Expected a populated files array");
                        if (!1 === e.files[0].isExternal)
                            throw new Error("Expected an external file");
                        let i = null;
                        try {
                            e.opening = !0,
                            this._browserInfoService.isMobileSafari() && !1 === w.isPWA && (i = window.open());
                            const t = yield this._fusionDataService.fetchLibraryItemExternalLink(e.id, e.files[0].id);
                            null !== i ? i.location.href = t : window.open(t)
                        } catch (a) {
                            mh.error(a),
                            void 0 !== (null === (t = a.data) || void 0 === t ? void 0 : t.reason) ? e.error = null === (n = a.data) || void 0 === n ? void 0 : n.reason : e.error = this.msgs.unexpectedErrorOccurred(),
                            i && i.close()
                        } finally {
                            e.opening = !1
                        }
                    }
                    ))
                }
                onLibraryItemPanelExpanded(e) {
                    e.expanded = !0,
                    this.useAnchorTagToOpen && e.files[0].isExternal && (e.externalUrl || this.getExternalLink(e))
                }
                onLibraryItemPanelCollapsed(e) {
                    e.expanded = !1
                }
                get useAnchorTagToOpen() {
                    return "Safari" === this._browserInfoService.getBrowserInfo().name && !1 === w.isPWA
                }
                getExternalLink(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const t = yield this._fusionDataService.fetchLibraryItemExternalLink(e.id, e.files[0].id);
                        e.externalUrl = t
                    }
                    ))
                }
                _formatFileName(e) {
                    if (void 0 === e.files || 0 === e.files.length)
                        return "";
                    const t = e.name.replace(/ /g, "_")
                      , n = e.request.source.orchidName
                      , i = e.request.source.cameraName
                      , a = this._datePipe.transform(new Date(e.request.startTimeMs), this.formats.fileName)
                      , r = this._datePipe.transform(new Date(e.request.stopTimeMs), this.formats.fileName)
                      , s = (new Km).transform(e.files[0].contentType, "");
                    return this.msgs.exportFileName({
                        LIBRARYITEMNAME: t,
                        ORCHIDNAME: n,
                        CAMERANAME: i,
                        START: a,
                        FINISH: r,
                        EXTENSION: s
                    })
                }
                retry(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        e.error = "";
                        try {
                            yield this._fusionDataService.retryLibraryExport(e.id)
                        } catch (t) {
                            mh.error(t.data),
                            e.error = t.data.reason
                        }
                    }
                    ))
                }
                cancel(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        e.error = "";
                        try {
                            yield this._fusionDataService.cancelLibraryExport(e.id)
                        } catch (t) {
                            mh.error(t.data),
                            e.error = t.data.reason
                        }
                    }
                    ))
                }
                toggleSelectAll(e) {
                    this.libraryItems.forEach((e => e.selectedForDelete = !1)),
                    !1 !== e && this.filteredLibraryItems.slice(this.pageIndex * this.pageSize, (this.pageIndex + 1) * this.pageSize).forEach((t => t.selectedForDelete = e))
                }
                delete(e) {
                    const t = void 0 !== e ? 1 : this.filteredLibraryItems.filter((e => e.selectedForDelete)).length
                      , n = {
                        panelClass: "sing-dialog-panel",
                        data: {
                            message: this.msgs.areYouSureYouWantToDeleteTheseCOUNTLibraryItems({
                                COUNT: t
                            }),
                            confirmText: this.msgs.delete(),
                            cancelText: this.msgs.cancel()
                        }
                    };
                    qs.show(this._matDialog, n).subscribe((t => (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (t) {
                            const t = void 0 !== e ? [e] : this.filteredLibraryItems.filter((e => e.selectedForDelete));
                            t.forEach((e => e.processing = !0));
                            for (const e of t) {
                                e.error = "";
                                try {
                                    yield this._fusionDataService.deleteLibraryExport(e.id)
                                } catch (t) {
                                    mh.error(t.data),
                                    e.error = t.data.reason,
                                    e.processing = !1
                                }
                            }
                            this._resetPaginator()
                        }
                    }
                    ))))
                }
            }
            ;
            var ph, gh, fh;
            (0,
            c.gn)([(0,
            i.ViewChildren)(pi.NW), (0,
            c.w6)("design:type", Object)], hh.prototype, "paginatorList", void 0),
            hh = (0,
            c.gn)([(0,
            i.Component)({
                selector: "library",
                template: n(58738)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(l.K0)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (ah = "undefined" != typeof Document && Document) ? ah : Object, "function" == typeof (rh = rt) ? rh : Object, "function" == typeof (sh = Qe) ? sh : Object, "function" == typeof (oh = Gt) ? oh : Object, "function" == typeof (ch = void 0 !== ih && ih) ? ch : Object, "function" == typeof (lh = void 0 !== hn.uw && hn.uw) ? lh : Object, "function" == typeof (dh = void 0 !== l.uU && l.uU) ? dh : Object])], hh);
            let vh = class {
                constructor(e, t, n) {
                    this._orchidDataService = e,
                    this._downloaderService = t,
                    this._matDialog = n,
                    this.msgs = L.messages.system,
                    this.dateTimeFormat = L.formats.ipcDatePicker.noSeconds,
                    this.morning = new Date,
                    this.evening = new Date,
                    this.exportFormat = "gzip",
                    this.range = !1
                }
                toggleCheckbox() {
                    this.error = "",
                    this.from && this.to && this.from > this.to && (this.from = this.morning,
                    this.to = this.evening)
                }
                showDatetimePicker(e) {
                    Pi(this._matDialog, {
                        date: e ? this.to : this.from,
                        title: `${e ? this.msgs.to() : this.msgs.from()}`,
                        okText: this.msgs.go(),
                        useOrchidTheme: !0
                    }).subscribe((t => {
                        void 0 !== t && (e ? this.to = t : this.from = t)
                    }
                    ))
                }
                exportLogs() {
                    this.error = "";
                    const e = this._orchidDataService.logExportUrl(this.orchid, this.exportFormat, this.from.getTime(), this.to.getTime(), this.range);
                    if ("text" === this.exportFormat && !1 === w.isPWA)
                        window.open(e);
                    else {
                        this._downloaderService.createDownloader().download(e)
                    }
                }
                ngOnInit() {
                    this.morning.setHours(0),
                    this.morning.setMinutes(0),
                    this.morning.setSeconds(0),
                    this.morning.setMilliseconds(0),
                    this.evening.setHours(23),
                    this.evening.setMinutes(59),
                    this.evening.setSeconds(0),
                    this.evening.setMilliseconds(0),
                    this.from = this.morning,
                    this.to = this.evening
                }
            }
            ;
            var yh, bh;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], vh.prototype, "orchid", void 0),
            vh = (0,
            c.gn)([(0,
            i.Component)({
                selector: "app-log-export",
                template: n(22344)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pt)), (0,
            c.fM)(1, (0,
            i.Inject)(ih)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (ph = pt) ? ph : Object, "function" == typeof (gh = void 0 !== ih && ih) ? gh : Object, "function" == typeof (fh = void 0 !== hn.uw && hn.uw) ? fh : Object])], vh);
            O("updateClientDialog");
            let Sh = class {
                constructor(e, t) {
                    this.matDialogRef = e,
                    this._OrchidDataService = t,
                    this.isProcessing = !1,
                    this.hasError = !1,
                    this.msgs = L.messages.dialogs
                }
                cancel() {
                    this.matDialogRef.close(!1)
                }
                selectFile(e) {
                    if (null === e.target)
                        return;
                    const t = e.target;
                    if (this.inputFileList = t.files,
                    !this.inputFileList || 0 === this.inputFileList.length)
                        return void (this.error = L.messages.dialogs.updateClientDialog.noFileSpecified());
                    const n = this.inputFileList.item(0);
                    this._file = n
                }
                updateClient() {
                    return this.inputFileList && 0 !== this.inputFileList.length ? (this.hasError = !0,
                    this.isProcessing = !0,
                    this.shouldClose(),
                    this._OrchidDataService.updateUserInterface(this._file).then(( () => {
                        this.hasError = !1,
                        this.isProcessing = !1,
                        this.matDialogRef.close(!0)
                    }
                    )).catch((e => {
                        if ("object" == typeof e.data && e.data.reason) {
                            const t = e.data;
                            this.error = t.code ? `${t.code}: ${t.reason}` : t.reason
                        } else
                            this.error = L.messages.errors.unexpectedErrorOccurred();
                        this.hasError = !0,
                        this.isProcessing = !1
                    }
                    )).finally(( () => {
                        this.isProcessing = !1,
                        this.hasError && void 0 === this.error && (this.error = L.messages.errors.unexpectedErrorOccurred())
                    }
                    ))) : (this.error = L.messages.dialogs.updateClientDialog.noFileSpecified(),
                    Promise.resolve())
                }
                shouldClose() {
                    this.error = void 0
                }
                onEsc() {
                    this.cancel()
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.HostListener)("keydown.esc"), (0,
            c.w6)("design:type", Function), (0,
            c.w6)("design:paramtypes", []), (0,
            c.w6)("design:returntype", void 0)], Sh.prototype, "onEsc", null),
            Sh = (0,
            c.gn)([(0,
            i.Component)({
                selector: "update-client-dialog",
                template: n(81827)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(1, (0,
            i.Inject)(pt)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (yh = void 0 !== hn.so && hn.so) ? yh : Object, "function" == typeof (bh = pt) ? bh : Object])], Sh);
            n.p;
            const Ch = Object.assign(Object.assign({}, co), {
                appendSidToURL: function(e) {
                    return (t, {sessionIdService: n}) => {
                        let i;
                        if (w.isOrchid) {
                            if (i = n.getLocalSessionId(),
                            !i)
                                throw new Error("The local session ID is undefined!")
                        } else if (i = n.getSessionId(e),
                        !i)
                            throw new Error(`The session ID for recorder ID: ${e} is undefined!`);
                        return Object.assign(Object.assign({}, t), {
                            params: Object.assign(Object.assign({}, t.params), {
                                sid: i
                            })
                        })
                    }
                },
                authorizeRecorder: fr,
                proxy: vr
            });
            var wh;
            let Ih = class {
                constructor(e) {
                    this._requestBuilder = e
                }
                getVersionInformation(e) {
                    return w.isOrchid ? this._requestBuilder.createRequest(`${w.baseUrl}/service/version`).with(co.applySearchParams({
                        all: "true"
                    }), Ch.authorizeRecorder()).get() : e.orchid ? this._requestBuilder.createRequest(`${e.orchid.discoverableOrchid.baseUrl}/service/version`).with(co.applySearchParams({
                        all: "true"
                    }), Ch.proxy({
                        id: e.orchid.id,
                        uri: e.orchid.uri
                    }, {
                        forceProxy: !0
                    })).get() : this._requestBuilder.createRequest(`${w.baseUrl}/service/version`).with(lo.authorizeFusion()).get()
                }
            }
            ;
            var Th, Eh, _h, xh, Dh, Oh, Ah;
            Ih = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(gr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (wh = void 0 !== gr && gr) ? wh : Object])], Ih),
            function(e) {
                e[e.Loading = 0] = "Loading",
                e[e.Loaded = 1] = "Loaded",
                e[e.Failed = 2] = "Failed"
            }(Ah || (Ah = {}));
            let Rh = class {
                constructor(e, t, n, i, a, r) {
                    this._versionInfoService = e,
                    this._brandService = t,
                    this._authService = n,
                    this._matDialog = i,
                    this._window = a,
                    this._minimumVersionService = r,
                    this.msgs = Object.assign(Object.assign({}, L.messages.versionInfo), {
                        errors: L.messages.errors
                    }),
                    this.formats = L.messages.versionInfo,
                    this.isAdmin = !1,
                    this.isOrchid = w.isOrchid,
                    this.startYear = this._brandService.brand.COPYRIGHT_YEAR,
                    this.year = (new Date).getFullYear().toString(),
                    this.cpYear = this.year === this.startYear ? this.year : this.startYear + "-" + this.year,
                    this.componentState = Ah.Loading
                }
                ngOnInit() {
                    this._performVersionInfoFetch(),
                    this.isAdmin = this._authService.getAuthenticationData().isAdministrator()
                }
                get ComponentState() {
                    return Ah
                }
                getApiRoute() {
                    if (this.isPageWithNavigation())
                        return "#!/api";
                    if (!w.isOrchid && this.orchid) {
                        return this._minimumVersionService.isFeatureSupported(this.orchid, Sr.API_UI_LINK_UPDATE) ? `${this.orchid.discoverableOrchid.baseUrl}/#!/api` : `${this.orchid.discoverableOrchid.baseUrl}/api`
                    }
                    return this.componentState = Ah.Failed,
                    ""
                }
                getApiRouteLabel() {
                    return this.isPageWithNavigation() ? "Orchid Hybrid VMS API" : !w.isOrchid && this.orchid ? this.msgs.apiManual() : (this.componentState = Ah.Failed,
                    "")
                }
                isPageWithNavigation() {
                    return w.isOrchid || !w.isOrchid && !this.orchid
                }
                _performVersionInfoFetch() {
                    this._versionInfoService.getVersionInformation({
                        orchid: this.orchid
                    }).pipe((0,
                    pn.q)(1)).subscribe((e => {
                        this.info = e,
                        this.componentState = Ah.Loaded
                    }
                    ), (e => {
                        if (e.data && e.data.reason) {
                            const t = e.data;
                            this.error = t.code ? `${t.code}: ${t.reason}` : t.reason
                        } else
                            this.error = this.msgs.errors.unexpectedErrorOccurred();
                        this.componentState = Ah.Failed
                    }
                    ))
                }
                _reloadPage() {
                    this._window.location.reload()
                }
                showUpdateClient() {
                    this._matDialog.open(Sh, {
                        disableClose: !0,
                        panelClass: "show-update-client-panel",
                        minWidth: "300px"
                    }).afterClosed().subscribe((e => {
                        e && this._reloadPage()
                    }
                    ))
                }
            }
            ;
            var Ph, kh, Mh;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Rh.prototype, "orchid", void 0),
            Rh = (0,
            c.gn)([(0,
            i.Component)({
                selector: "version",
                template: n(88832)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Ih)), (0,
            c.fM)(1, (0,
            i.Inject)(Hm)), (0,
            c.fM)(2, (0,
            i.Inject)(xe)), (0,
            c.fM)(3, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(4, (0,
            i.Inject)(Window)), (0,
            c.fM)(5, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Th = void 0 !== Ih && Ih) ? Th : Object, "function" == typeof (Eh = void 0 !== Hm && Hm) ? Eh : Object, "function" == typeof (_h = void 0 !== xe && xe) ? _h : Object, "function" == typeof (xh = void 0 !== hn.uw && hn.uw) ? xh : Object, "function" == typeof (Dh = "undefined" != typeof Window && Window) ? Dh : Object, "function" == typeof (Oh = void 0 !== Cr && Cr) ? Oh : Object])], Rh),
            function(e) {
                e.CURRENT = "currentPassword",
                e.NEW = "newPassword",
                e.CONFIRM = "confirmPassword"
            }(Mh || (Mh = {}));
            let Lh = class {
                constructor(e, t, n) {
                    this.matDialogRef = e,
                    this.userData = t,
                    this._DataService = n,
                    this.msgs = Object.assign(Object.assign({}, L.messages.accountSettings.editPassword), L.messages.errors),
                    this.formMsgs = L.messages.credentialsForm,
                    this.processing = !1,
                    this.errorMessage = "";
                    const i = new p.qu;
                    this.newPasswordForm = i.group({
                        [Mh.NEW]: ["", [p.kI.required, p.kI.minLength(4)]],
                        [Mh.CONFIRM]: ["", [p.kI.required]]
                    }, {
                        validators: this.passwordMatchValidator
                    })
                }
                passwordMatchValidator(e) {
                    const t = e.get(Mh.NEW)
                      , n = e.get(Mh.CONFIRM);
                    if (t && n && t.value !== n.value) {
                        const e = {
                            mismatch: !0
                        };
                        return n.setErrors(e),
                        e
                    }
                    return null
                }
                getNewPasswordErrorMessage() {
                    const e = this.newPasswordForm.get(Mh.NEW);
                    if (e) {
                        if (e.hasError("required"))
                            return this.formMsgs.errors.password.passwordRequired();
                        if (e.hasError("minlength"))
                            return this.formMsgs.errors.password.passwordMustBeAtLeast4Characters()
                    }
                    return ""
                }
                getConfirmPasswordErrorMessage() {
                    const e = this.newPasswordForm.get(Mh.CONFIRM);
                    if (e) {
                        if (e.hasError("required"))
                            return this.formMsgs.errors.password.passwordComfirmationRequired();
                        if (this.newPasswordForm.hasError("mismatch"))
                            return this.formMsgs.errors.password.passwordDoNotMatch()
                    }
                    return ""
                }
                saveButtonHandler() {
                    var e;
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.processing = !0;
                        const t = null === (e = this.newPasswordForm.get(Mh.NEW)) || void 0 === e ? void 0 : e.value
                          , n = Object.assign(Object.assign({}, this.userData), {
                            password: t
                        });
                        this._DataService.updateUser(n).then(( () => {
                            this.processing = !1,
                            this.matDialogRef.close()
                        }
                        ), (e => {
                            this.processing = !1,
                            this.errorMessage = (null == e ? void 0 : e.reason) ? e.reason : this.msgs.unexpectedErrorOccurred()
                        }
                        ))
                    }
                    ))
                }
                showErrorMessage() {
                    return this.errorMessage.length > 0
                }
                dismissErrorMessage() {
                    this.errorMessage = ""
                }
            }
            ;
            var Nh, Fh, Uh, $h;
            Lh = (0,
            c.gn)([(0,
            i.Component)({
                selector: "edit-password-dialog",
                template: n(43814)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(2, (0,
            i.Inject)(Qe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Ph = void 0 !== hn.so && hn.so) ? Ph : Object, Object, "function" == typeof (kh = Qe) ? kh : Object])], Lh);
            const jh = {
                id: "",
                username: "",
                emailAddress: "",
                groups: [],
                admin: !1,
                superUser: !1
            };
            var Vh;
            !function(e) {
                e.PROCESSING = "processing",
                e.LOADED = "loaded"
            }(Vh || (Vh = {}));
            let Gh = class {
                constructor(e, t, n, i) {
                    this._dataService = t,
                    this.passwordDialog = n,
                    this._userSettingsService = i,
                    this.msgs = Object.assign(Object.assign({}, L.messages.accountSettings), L.messages.errors),
                    this.pageStatus = Vh.PROCESSING,
                    this.locales = [{
                        value: "en",
                        label: "English"
                    }, {
                        value: "es",
                        label: "Espaol"
                    }, {
                        value: "fr",
                        label: "Franais"
                    }, {
                        value: "de",
                        label: "Deutsch"
                    }, {
                        value: "it",
                        label: "Italiano"
                    }, {
                        value: "nl",
                        label: "Nederlands"
                    }, {
                        value: "pt",
                        label: "Portugus"
                    }],
                    this.selectedLocale = this.locales[0].value,
                    this.authData = e.getAuthenticationData(),
                    this.userData = jh
                }
                ngOnInit() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.authData.source === De.AZURE || this.authData.source === De.FREEIPA || this.authData.source === De.ACTIVE_DIRECTORY || this.authData.source === De.SAML ? (this.setUserData({
                            id: this.authData.userId,
                            username: this.authData.username,
                            emailAddress: "",
                            groups: [],
                            admin: this.authData._admin,
                            superUser: !1
                        }),
                        this.pageStatus = Vh.LOADED) : yield this.getUserData()
                    }
                    ))
                }
                getUserData() {
                    var e;
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.pageStatus = Vh.PROCESSING;
                        try {
                            this.userData = yield this._dataService.fetchUser(this.authData.userId),
                            this.pageStatus = Vh.LOADED
                        } catch (t) {
                            this.errorMessage = null !== (e = null == t ? void 0 : t.reason) && void 0 !== e ? e : this.msgs.unexpectedErrorOccurred()
                        }
                    }
                    ))
                }
                setUserData(e) {
                    this.userData = e
                }
                isFusion() {
                    return !w.isOrchid
                }
                openPasswordDialog() {
                    this.passwordDialog.open(Lh, {
                        data: this.userData
                    })
                }
                canUserChangePassword() {
                    return this.authData.canChangePassword()
                }
                get showPreferences() {
                    return !1
                }
            }
            ;
            var Bh, zh;
            Gh = (0,
            c.gn)([(0,
            i.Component)({
                selector: "account-settings",
                template: n(23882)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(xe)), (0,
            c.fM)(1, (0,
            i.Inject)(Qe)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(3, (0,
            i.Inject)(Qt)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Nh = void 0 !== xe && xe) ? Nh : Object, "function" == typeof (Fh = Qe) ? Fh : Object, "function" == typeof (Uh = void 0 !== hn.uw && hn.uw) ? Uh : Object, "function" == typeof ($h = Qt) ? $h : Object])], Gh);
            let Hh = class {
                constructor(e) {
                    this._DataService = e,
                    this.msgs = Object.assign(Object.assign({}, L.messages.accountSettings.generalSettings), L.messages.errors),
                    this.formMsgs = L.messages.credentialsForm,
                    this.errorMessage = "",
                    this.editMode = !1,
                    this.canEditInformation = !1,
                    this.canEditUsername = !1,
                    this.canEditEmail = !1,
                    this.processing = !1,
                    this.userData = null,
                    this.onUserDataUpdate = new i.EventEmitter;
                    const t = new p.qu;
                    this.generalForm = t.group({
                        username: [{
                            value: "",
                            disabled: !this.canEditUsername
                        }, [p.kI.max(30), p.kI.pattern("/^a-zA-Z0-9_]+$")]],
                        email: [{
                            value: "",
                            disabled: !this.canEditEmail
                        }, [p.kI.email]]
                    })
                }
                ngOnChanges() {
                    this.userData && (this.generalForm.controls.username.setValue(this.userData.username),
                    this.generalForm.controls.email.setValue(this.userData.emailAddress))
                }
                canSave() {
                    return !this.processing && !this.generalForm.invalid && !this.generalForm.pristine
                }
                saveButtonHandler() {
                    var e, t;
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this.userData) {
                            this.processing = !0;
                            const n = Object.assign(Object.assign({}, this.userData), {
                                username: null === (e = this.generalForm.get("username")) || void 0 === e ? void 0 : e.value,
                                emailAddress: null === (t = this.generalForm.get("email")) || void 0 === t ? void 0 : t.value
                            });
                            this._DataService.updateUser(n).then((e => {
                                this.processing = !1,
                                this.toggleEditMode(!1),
                                this.onUserDataUpdate.emit(e)
                            }
                            ), (e => {
                                var t;
                                this.processing = !1,
                                this.errorMessage = null !== (t = e.reason) && void 0 !== t ? t : this.msgs.unexpectedErrorOccurred()
                            }
                            ))
                        }
                    }
                    ))
                }
                dismissErrorMessage() {
                    this.errorMessage = ""
                }
                showErrorMessage() {
                    return this.errorMessage.length > 0
                }
                getUserEmail() {
                    var e;
                    return (null === (e = this.userData) || void 0 === e ? void 0 : e.emailAddress) ? this.userData.emailAddress : "--"
                }
                toggleEditMode(e) {
                    this.editMode = e
                }
                getUsernameErrorMessage() {
                    return this.generalForm.controls.username.hasError("pattern") ? this.formMsgs.errors.username.invalidUsername() : ""
                }
                getEmailErrorMessage() {
                    return this.generalForm.controls.email.hasError("email") ? this.formMsgs.errors.email.aValidEmailAddressRequired() : ""
                }
            }
            ;
            var Wh, qh, Yh, Xh, Kh, Zh, Jh, Qh, ep, tp, np, ip, ap, rp, sp, op, cp, lp, dp, up, mp, hp, pp, gp, fp, vp, yp, bp, Sp, Cp, wp, Ip, Tp, Ep, _p, xp, Dp, Op;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Hh.prototype, "userData", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (Bh = void 0 !== i.EventEmitter && i.EventEmitter) ? Bh : Object)], Hh.prototype, "onUserDataUpdate", void 0),
            Hh = (0,
            c.gn)([(0,
            i.Component)({
                selector: "general-settings",
                template: n(86867)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Qe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (zh = Qe) ? zh : Object])], Hh);
            let Ap = class extends r.iB {
                constructor(e, t) {
                    super("app", e, t)
                }
            }
            ;
            Ap = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "app"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Wh = void 0 !== i.ElementRef && i.ElementRef) ? Wh : Object, "function" == typeof (qh = void 0 !== i.Injector && i.Injector) ? qh : Object])], Ap);
            let Rp = class extends r.iB {
                constructor(e, t) {
                    super("cameraGroupConfig", e, t)
                }
            }
            ;
            Rp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "camera-group-config"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Yh = void 0 !== i.ElementRef && i.ElementRef) ? Yh : Object, "function" == typeof (Xh = void 0 !== i.Injector && i.Injector) ? Xh : Object])], Rp);
            let Pp = class extends r.iB {
                constructor(e, t) {
                    super("controlledServerShutdown", e, t)
                }
            }
            ;
            Pp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "controlled-server-shutdown"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Kh = void 0 !== i.ElementRef && i.ElementRef) ? Kh : Object, "function" == typeof (Zh = void 0 !== i.Injector && i.Injector) ? Zh : Object])], Pp);
            let kp = class extends r.iB {
                constructor(e, t) {
                    super("custom", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], kp.prototype, "plugin", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], kp.prototype, "extension", void 0),
            kp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "custom"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Jh = void 0 !== i.ElementRef && i.ElementRef) ? Jh : Object, "function" == typeof (Qh = void 0 !== i.Injector && i.Injector) ? Qh : Object])], kp);
            let Mp = class extends r.iB {
                constructor(e, t) {
                    super("dashboard", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], Mp.prototype, "orchids", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (ep = void 0 !== Bt.gz && Bt.gz) ? ep : Object)], Mp.prototype, "route", void 0),
            Mp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "dashboard"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (tp = void 0 !== i.ElementRef && i.ElementRef) ? tp : Object, "function" == typeof (np = void 0 !== i.Injector && i.Injector) ? np : Object])], Mp);
            let Lp = class extends r.iB {
                constructor(e, t) {
                    super("navigation", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Lp.prototype, "display", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Function)], Lp.prototype, "onSignOut", void 0),
            Lp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "navigation"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (ip = void 0 !== i.ElementRef && i.ElementRef) ? ip : Object, "function" == typeof (ap = void 0 !== i.Injector && i.Injector) ? ap : Object])], Lp);
            let Np = class extends r.iB {
                constructor(e, t) {
                    super("orchidAdmin", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], Np.prototype, "orchids", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Np.prototype, "component", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (rp = void 0 !== Bt.gz && Bt.gz) ? rp : Object)], Np.prototype, "route", void 0),
            Np = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "orchid-admin"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (sp = void 0 !== i.ElementRef && i.ElementRef) ? sp : Object, "function" == typeof (op = void 0 !== i.Injector && i.Injector) ? op : Object])], Np);
            let Fp = class extends r.iB {
                constructor(e, t) {
                    super("pageLoading", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Fp.prototype, "cardClass", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Fp.prototype, "loadingMsgClass", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Fp.prototype, "loadingContainerClass", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Fp.prototype, "errorClass", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Function)], Fp.prototype, "error", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Function)], Fp.prototype, "progress", void 0),
            Fp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "page-loading"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (cp = void 0 !== i.ElementRef && i.ElementRef) ? cp : Object, "function" == typeof (lp = void 0 !== i.Injector && i.Injector) ? lp : Object])], Fp);
            let Up = class extends r.iB {
                constructor(e, t) {
                    super("notificationSettings", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], Up.prototype, "orchids", void 0),
            Up = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "notification-settings"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (dp = void 0 !== i.ElementRef && i.ElementRef) ? dp : Object, "function" == typeof (up = void 0 !== i.Injector && i.Injector) ? up : Object])], Up);
            let $p = class extends r.iB {
                constructor(e, t) {
                    super("signedOut", e, t)
                }
            }
            ;
            $p = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "signed-out"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (mp = void 0 !== i.ElementRef && i.ElementRef) ? mp : Object, "function" == typeof (hp = void 0 !== i.Injector && i.Injector) ? hp : Object])], $p);
            let jp = class extends r.iB {
                constructor(e, t) {
                    super("singlePlayer", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], jp.prototype, "orchids", void 0),
            jp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "single-player"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (pp = void 0 !== i.ElementRef && i.ElementRef) ? pp : Object, "function" == typeof (gp = void 0 !== i.Injector && i.Injector) ? gp : Object])], jp);
            let Vp = class extends r.iB {
                constructor(e, t) {
                    super("stage", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], Vp.prototype, "orchids", void 0),
            Vp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "stage"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (fp = void 0 !== i.ElementRef && i.ElementRef) ? fp : Object, "function" == typeof (vp = void 0 !== i.Injector && i.Injector) ? vp : Object])], Vp);
            let Gp = class extends r.iB {
                constructor(e, t) {
                    super("statsForNerds", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Gp.prototype, "value", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Gp.prototype, "expandAll", void 0),
            Gp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "stats-for-nerds"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (yp = void 0 !== i.ElementRef && i.ElementRef) ? yp : Object, "function" == typeof (bp = void 0 !== i.Injector && i.Injector) ? bp : Object])], Gp);
            let Bp = class extends r.iB {
                constructor(e, t) {
                    super("userManagerList", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Bp.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Bp.prototype, "groups", void 0),
            Bp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "user-manager-list"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Sp = void 0 !== i.ElementRef && i.ElementRef) ? Sp : Object, "function" == typeof (Cp = void 0 !== i.Injector && i.Injector) ? Cp : Object])], Bp);
            let zp = class extends r.iB {
                constructor(e, t) {
                    super("player", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], zp.prototype, "id", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], zp.prototype, "cameraName", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zp.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zp.prototype, "camera", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], zp.prototype, "streamId", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Function)], zp.prototype, "onClose", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zp.prototype, "options", void 0),
            zp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "player"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (wp = void 0 !== i.ElementRef && i.ElementRef) ? wp : Object, "function" == typeof (Ip = void 0 !== i.Injector && i.Injector) ? Ip : Object])], zp);
            let Hp = class extends r.iB {
                constructor(e, t) {
                    super("diskUtesBar", e, t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Hp.prototype, "forceBreak", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Hp.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], Hp.prototype, "loading", void 0),
            Hp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "disk-utes-bar"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Tp = void 0 !== i.ElementRef && i.ElementRef) ? Tp : Object, "function" == typeof (Ep = void 0 !== i.Injector && i.Injector) ? Ep : Object])], Hp);
            let Wp = class extends r.iB {
                constructor(e, t) {
                    super("logo", e, t)
                }
            }
            ;
            Wp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "logo"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (_p = void 0 !== i.ElementRef && i.ElementRef) ? _p : Object, "function" == typeof (xp = void 0 !== i.Injector && i.Injector) ? xp : Object])], Wp);
            let qp = class extends r.iB {
                constructor(e, t) {
                    super("propertyEditor", e, t)
                }
            }
            ;
            qp = (0,
            c.gn)([(0,
            i.Directive)({
                selector: "property-editor"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Dp = void 0 !== i.ElementRef && i.ElementRef) ? Dp : Object, "function" == typeof (Op = void 0 !== i.Injector && i.Injector) ? Op : Object])], qp);
            var Yp, Xp, Kp, Zp, Jp, Qp, eg, tg = n(2237), ig = n(84955), ag = n(28013);
            const rg = O("WebSocketEventsService");
            let sg = class {
                create(e) {
                    return (0,
                    ag.j)(e)
                }
            }
            ;
            sg = (0,
            c.gn)([(0,
            i.Injectable)()], sg);
            let og = class {
                constructor(e, t, n, i, a, r, s, o) {
                    this._webSocketFactory = e,
                    this._dataService = t,
                    this._deathService = n,
                    this._browserInfoService = i,
                    this._authenticationService = a,
                    this.$rootScope = r,
                    this._window = s,
                    this._document = o,
                    this.hasVisibilityListener = !1,
                    this.onVisibilityChange = this.onVisibilityChange.bind(this)
                }
                _constructAuthParams() {
                    if (w.singlePlayerMode) {
                        const e = this._authenticationService.getAuthenticationData();
                        if (e.token)
                            return void 0 === e.tokenType ? `?sid=${this._authenticationService.getAuthenticationData().sessionId}` : `?${e.tokenType}=${this._authenticationService.getAuthenticationData().token}`
                    }
                    return `?${w.isOrchid ? "sid" : "fsid"}=${this._authenticationService.getAuthenticationData().sessionId}`
                }
                constructEventsUrl() {
                    const e = new URL(w.baseUrl);
                    e.protocol = "https:" === e.protocol ? "wss://" : "ws://";
                    const t = this._constructAuthParams()
                      , n = w.isOrchid ? "service/streams/webrtc" : "service/events";
                    return `${e.toString()}${n}${t}`
                }
                close() {
                    window.removeEventListener("beforeunload", this.close),
                    this._webSocketSubject$ && this._webSocketSubject$.complete(),
                    delete this._webSocketSubject$,
                    this.hasVisibilityListener && this._document.removeEventListener("visibilitychange", this.onVisibilityChange)
                }
                open(e) {
                    const t = w.isPWA && this._browserInfoService.isMobileSafari()
                      , n = w.singlePlayerMode;
                    t && !1 === n && !1 === this.hasVisibilityListener && (this._document.addEventListener("visibilitychange", this.onVisibilityChange),
                    this.hasVisibilityListener = !0),
                    this._webSocketSubject$ = this._webSocketFactory.create(e);
                    let i = 0;
                    return window.addEventListener("beforeunload", this.close),
                    this._webSocketSubject$.pipe((0,
                    sa.b)(( () => i = 0)), (0,
                    tg.a)((e => e.pipe((0,
                    Tr.b)((e => {
                        if (rg.debug("attempting again", i),
                        i++ >= 1)
                            throw new Error("Max reconnection attempts [1] reached");
                        return (0,
                        ze.of)(e).pipe((0,
                        ig.g)(1e3))
                    }
                    )), (0,
                    lr.K)(( () => (0,
                    ze.of)([]))), (0,
                    Ir.x)(( () => (rg.error(`Could not reconnect after ${i} attempts`),
                    this._dataService.ping().then(( () => {
                        this._deathService.die("ws")
                    }
                    )).catch(( () => {
                        this._deathService.die(this._deathService.reasons.ping)
                    }
                    )),
                    (0,
                    ze.of)([]))))))))
                }
                onVisibilityChange() {
                    if (this._document.hidden) {
                        this.$rootScope.appLoaded = !1;
                        const e = () => {
                            !1 === this._document.hidden && this._window.location.reload(),
                            this._document.removeEventListener("visibilitychange", e)
                        }
                        ;
                        this._document.addEventListener("visibilitychange", e)
                    }
                }
            }
            ;
            var cg, lg;
            og = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.fM)(0, (0,
            i.Inject)(sg)), (0,
            c.fM)(1, (0,
            i.Inject)(tt)), (0,
            c.fM)(2, (0,
            i.Inject)(gt)), (0,
            c.fM)(3, (0,
            i.Inject)(rt)), (0,
            c.fM)(4, (0,
            i.Inject)(xe)), (0,
            c.fM)(5, (0,
            i.Inject)("$rootScope")), (0,
            c.fM)(6, (0,
            i.Inject)(Window)), (0,
            c.fM)(7, (0,
            i.Inject)(l.K0)), (0,
            c.w6)("design:paramtypes", [sg, "function" == typeof (Yp = tt) ? Yp : Object, "function" == typeof (Xp = gt) ? Xp : Object, "function" == typeof (Kp = rt) ? Kp : Object, "function" == typeof (Zp = void 0 !== xe && xe) ? Zp : Object, "function" == typeof (Jp = void 0 !== s && s.IRootScopeService) ? Jp : Object, "function" == typeof (Qp = "undefined" != typeof Window && Window) ? Qp : Object, "function" == typeof (eg = "undefined" != typeof Document && Document) ? eg : Object])], og),
            function(e) {
                e.GET = "GET",
                e.POST = "POST",
                e.DELETE = "DELETE",
                e.PUT = "PUT",
                e.PATCH = "PATCH"
            }(cg || (cg = {}));
            class dg {
                static Events_CameraStream_Prewarm_POST(e, t, n, i) {
                    return {
                        method: "POST",
                        url: `${e}/service/events/camera-stream/smart-search/prewarm?start=${t}&stop=${n}&id=${i.join(",")}`
                    }
                }
                static Events_CameraStream_SmartSearch_POST(e, t) {
                    return {
                        method: "POST",
                        url: `${e}/service/events/camera-stream/smart-search`,
                        withCredentials: !0,
                        data: t
                    }
                }
                static Events_CameraStream_SmartSearch_GET(e, t) {
                    return {
                        method: "GET",
                        url: `${e}/service/events/camera-stream/smart-search/${t}`
                    }
                }
                static Events_CameraStream_SmartSearch_DELETE(e, t) {
                    return {
                        method: "DELETE",
                        url: `${e}/service/events/camera-stream/smart-search/${t}`
                    }
                }
                static Events_CameraStream_SmartSearch_Results_GET(e, t, n, i, a, r) {
                    const s = new URL(`${e}/service/events/camera-stream/smart-search/${t}/results?start=${n}&id=${i.join(",")}`);
                    return this._addParam(s, "count", a),
                    void 0 !== r && this._addParam(s, "from_end", !0 === r ? "1" : "0"),
                    {
                        method: "GET",
                        url: decodeURIComponent(s.toString())
                    }
                }
                static Events_CameraStream_SmartSearch_Results_Histogram_GET(e, t, n, i, a, r, s) {
                    const o = new URL(`${e}/service/events/camera-stream/smart-search/${t}/results/histogram?start=${n}&id=${i.join(",")}`);
                    return a && this._addParam(o, "minSegment", a),
                    r && this._addParam(o, "fixedSegment", r),
                    s && this._addParam(o, "stop", s),
                    {
                        method: "GET",
                        url: decodeURIComponent(o.toString())
                    }
                }
                static Events_CameraStream_GET(e, t, n, i, a, r, s, o) {
                    const c = new URL(`${e}/service/events/camera-stream?eventType=${i.join(",")}&start=${t}&id=${n.join(",")}`);
                    return this._addParam(c, "minSegment", r),
                    this._addParam(c, "stop", a),
                    this._addParam(c, "count", s),
                    void 0 !== o && this._addParam(c, "from_end", !0 === o ? "1" : "0"),
                    {
                        method: "GET",
                        url: decodeURIComponent(c.toString())
                    }
                }
                static Events_CameraStream_Histogram_GET(e, t, n, i, a, r, s) {
                    const o = new URL(`${e}/service/events/camera-stream/histogram?start=${t}&stop=${n}&id=${i.join(",")}&eventType=${a.join(",")}`);
                    return void 0 !== r && this._addParam(o, "minSegment", r),
                    void 0 !== s && this._addParam(o, "fixedSegment", s),
                    {
                        method: "GET",
                        url: decodeURIComponent(o.toString())
                    }
                }
                static Events_CameraStream_MotionMinutes_GET(e, t, n, i) {
                    const a = new URL(`${e}/service/events/camera-stream/motion-minutes?start=${n}&id=${t}`);
                    return void 0 !== i && this._addParam(a, "smartSearchSessionUUID", i),
                    {
                        method: "GET",
                        url: decodeURIComponent(a.toString())
                    }
                }
                static Server_SmartSearch_Status_GET(e) {
                    return {
                        method: cg.GET,
                        url: `${e}/service/server/smart-search/status`
                    }
                }
                static _addParam(e, t, n) {
                    void 0 !== n && e.searchParams.append(t, n.toString())
                }
            }
            let ug = class {
                constructor(e) {
                    this._eventManager = e,
                    this._timeInfoCache = [],
                    this._refreshInterval = null
                }
                getOrchidTimeInfo(e) {
                    if (void 0 === this._timeInfoCache[e])
                        return null;
                    {
                        const t = Object.assign({}, this._timeInfoCache[e]);
                        return Object.freeze(t),
                        t
                    }
                }
                getOrchidTimeInfoPromise(e, t) {
                    return !0 === t || void 0 === this._timeInfoCache[e] ? this._fetchAndUpdateTimeInfo().then(( () => this.getOrchidTimeInfo(e))) : Promise.resolve(this.getOrchidTimeInfo(e))
                }
                getOrchidTimeOffset(e) {
                    const t = this.getOrchidTimeInfo(e);
                    return null === t ? 0 : t.offset
                }
                getOrchidTimeOffsetPromise(e, t) {
                    return t || void 0 === this._timeInfoCache[e] ? this._fetchAndUpdateTimeInfo().then(( () => this.getOrchidTimeOffset(e))) : Promise.resolve(this.getOrchidTimeOffset(e))
                }
                addUpdateListener(e, t) {
                    this._eventManager.on(e, t)
                }
                removeUpdateListener(e, t) {
                    this._eventManager.off(e, t)
                }
                startRefreshInterval(e) {
                    this.stopRefreshInterval(),
                    this._fetchAndUpdateTimeInfo(),
                    this._refreshInterval = setInterval(( () => this._fetchAndUpdateTimeInfo()), e)
                }
                stopRefreshInterval() {
                    clearInterval(this._refreshInterval)
                }
                _fetchAndUpdateTimeInfo() {
                    return this._fetchTimeInfo().then((e => this._updateTimeInfo(e)))
                }
                _updateTimeInfo(e) {
                    e.forEach((e => {
                        if (void 0 === this._timeInfoCache[e.id] || this._timeInfoCache[e.id].offset !== e.offset || this._timeInfoCache[e.id].tz !== e.tz || this._timeInfoCache[e.id].tzOffset !== e.tzOffset) {
                            this._timeInfoCache[e.id] = {
                                offset: e.offset,
                                tz: e.tz,
                                tzOffset: e.tzOffset
                            };
                            const t = Object.assign({}, this._timeInfoCache[e.id]);
                            Object.freeze(t),
                            this._eventManager.trigger(e.id, t)
                        }
                    }
                    ))
                }
            }
            ;
            var mg, hg, pg;
            ug = (0,
            c.gn)([(0,
            c.fM)(0, (0,
            i.Inject)(wn)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (lg = void 0 !== wn && wn) ? lg : Object])], ug);
            let gg = class {
                constructor(e, t, n) {
                    this._orchidDataService = e,
                    this._orchidProxyService = t,
                    this._timeService = n
                }
                fetchNextMotionEvent(e, t, n, i, a, r, s, o) {
                    const c = this._timeService.getOrchidTimeOffset(e.id);
                    return this._orchidDataService.performRequest(dg.Events_CameraStream_GET(this._orchidProxyService.orchidUri({
                        id: e.id,
                        uri: e.uri
                    }), t - c, n, i, a ? a - c : a, r, s, o), e).then((e => e.data)).then((e => (null == e || e.events.forEach((e => {
                        e.start += c,
                        e.stop += c
                    }
                    )),
                    e)))
                }
                fetchMotionEvents(e, t, n, i, a, r, s) {
                    const o = this._timeService.getOrchidTimeOffset(e.id);
                    return this._orchidDataService.performRequest(dg.Events_CameraStream_Histogram_GET(this._orchidProxyService.orchidUri({
                        id: e.id,
                        uri: e.uri
                    }), t - o, i - o, n, a, r, s), e).then((e => e.data)).then((e => (null == e || e.events.forEach((e => {
                        e.start += o,
                        e.stop += o
                    }
                    )),
                    e)))
                }
                fetchMotionEventMinuteReport(e, t, n, i) {
                    const a = this._timeService.getOrchidTimeOffset(e.id);
                    return this._orchidDataService.performRequest(dg.Events_CameraStream_MotionMinutes_GET(this._orchidProxyService.orchidUri(e), t, n - a, i), e).then((e => e.data)).then((e => {
                        for (const t of null == e ? void 0 : e.hours) {
                            t.hourStart += a;
                            for (const e of t.motionMinutes)
                                e.minuteStart += a,
                                e.earliestMotionStart += a
                        }
                        return e
                    }
                    ))
                }
                prewarmSmartSearch(e, t, n, i) {
                    const a = this._timeService.getOrchidTimeOffset(e.id);
                    return this._orchidDataService.performRequest(dg.Events_CameraStream_Prewarm_POST(this._orchidProxyService.orchidUri({
                        id: e.id,
                        uri: e.uri
                    }), t - a, n - a, i), e)
                }
                createSmartSearchSession(e, t) {
                    return this._orchidDataService.performRequest(dg.Events_CameraStream_SmartSearch_POST(this._orchidProxyService.orchidUri({
                        id: e.id,
                        uri: e.uri
                    }), t), e).then((e => e.data))
                }
                fetchSmartSearchSession(e, t) {
                    return this._orchidDataService.performRequest(dg.Events_CameraStream_SmartSearch_GET(this._orchidProxyService.orchidUri({
                        id: e.id,
                        uri: e.uri
                    }), t), e)
                }
                deleteSmartSearchSession(e, t) {
                    return this._orchidDataService.performRequest(dg.Events_CameraStream_SmartSearch_DELETE(this._orchidProxyService.orchidUri({
                        id: e.id,
                        uri: e.uri
                    }), t), e)
                }
                fetchSmartSearchSessionResults(e, t, n, i, a, r) {
                    const s = this._timeService.getOrchidTimeOffset(e.id)
                      , o = dg.Events_CameraStream_SmartSearch_Results_GET(this._orchidProxyService.orchidUri({
                        id: e.id,
                        uri: e.uri
                    }), t, n - s, i, a, r);
                    return this._orchidDataService.performRequest(o, e).then((e => e.data)).then((e => {
                        var t;
                        return null === (t = e.events) || void 0 === t || t.forEach((e => {
                            e.start += s,
                            e.stop += s
                        }
                        )),
                        e
                    }
                    ))
                }
                fetchSmartSearchSessionResultsHistogram(e, t, n, i, a, r, s) {
                    const o = this._timeService.getOrchidTimeOffset(e.id)
                      , c = dg.Events_CameraStream_SmartSearch_Results_Histogram_GET(this._orchidProxyService.orchidUri({
                        id: e.id,
                        uri: e.uri
                    }), t, n - o, i, a, r, s ? s - o : s);
                    return this._orchidDataService.performRequest(c, e).then((e => e.data)).then((e => {
                        var t;
                        return null === (t = e.events) || void 0 === t || t.forEach((e => {
                            e.start += o,
                            e.stop += o
                        }
                        )),
                        e
                    }
                    ))
                }
                fetchSmartSearchStatus(e) {
                    const t = dg.Server_SmartSearch_Status_GET(this._orchidProxyService.orchidUri({
                        id: e.id,
                        uri: e.uri
                    }));
                    return this._orchidDataService.performRequest(t, e).then((e => e.data))
                }
            }
            ;
            function fg(e, t) {
                return e - 1e3 * t
            }
            function vg(e, t) {
                return e + Math.round(function(e) {
                    return e > 0 ? 1001 : 5e3
                }(t) * Math.abs(t))
            }
            function yg(e, t) {
                return e - function(e) {
                    return e > 0 ? 5e3 : 1001
                }(t) * Math.abs(t)
            }
            gg = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.w6)("design:paramtypes", ["function" == typeof (mg = pt) ? mg : Object, "function" == typeof (hg = void 0 !== mt && mt) ? hg : Object, "function" == typeof (pg = void 0 !== ug && ug) ? pg : Object])], gg);
            const bg = O("orchidMotionRequest");
            class Sg {
                constructor(e, t, n) {
                    this._orchidAPI = e,
                    this.orchid = t,
                    this.streamIds = n
                }
                complete() {
                    return Promise.resolve()
                }
                fetch(e, t, n, i, a) {
                    return this._orchidAPI.fetchMotionEvents(this.orchid, e, this.streamIds, t, [q.IPC_MOTION_EVENT], i, a).then((e => e.events.map((e => Object.assign(e, {
                        source: "histogram"
                    })))))
                }
                fetchMotionReport(e, t) {
                    return this._orchidAPI.fetchMotionEventMinuteReport(this.orchid, t, e, void 0)
                }
                fetchNext(e, t) {
                    const n = vg(e, t);
                    return this._fetchNextPrevious(n, 1, t)
                }
                fetchPrevious(e, t) {
                    const n = yg(e, t);
                    return this._fetchNextPrevious(n, -1, t)
                }
                _fetchNextPrevious(e, t, n) {
                    return this._orchidAPI.fetchNextMotionEvent(this.orchid, Math.round(e), this.streamIds, [q.IPC_MOTION_EVENT], void 0, void 0, t, !(n > 0)).then((e => {
                        if (e.events && e.events.length > 0) {
                            return fg(n >= 0 ? e.events[0].start : e.events[0].stop, n)
                        }
                        return null
                    }
                    )).catch((e => (bg.error("Failed fetching next/previous motion event", e),
                    null)))
                }
            }
            const Cg = O("OrchidMotionSmartSearchRequest");
            class wg {
                constructor(e, t, n) {
                    this._orchidAPI = e,
                    this.orchid = t,
                    this.searchRegionMappings = n;
                    const i = {
                        searchRegionsMapping: n
                    };
                    this._smartSearchSession = this._orchidAPI.createSmartSearchSession(this.orchid, i).catch((e => {
                        throw Cg.error("Could not create Smart Search session"),
                        e
                    }
                    ))
                }
                complete() {
                    return this._smartSearchSession.then((e => {
                        null !== e && this._orchidAPI.deleteSmartSearchSession(this.orchid, e.smartSearchSessionId).catch((e => Cg.error("Could not delete smart search session", e))).finally(( () => this._smartSearchSession = Promise.resolve(null)))
                    }
                    )).catch(( () => Promise.resolve()))
                }
                fetch(e, t, n, i, a) {
                    return this._smartSearchSession.then((n => null === n ? Promise.reject() : this._orchidAPI.fetchSmartSearchSessionResultsHistogram(this.orchid, n.smartSearchSessionId, e, this.searchRegionMappings.map((e => e.streamId)), i, a, t).then((e => e.events)).then((e => e.map((e => Object.assign(e, {
                        source: "smart-search"
                    }))))))).catch(( () => Promise.resolve([])))
                }
                fetchMotionReport(e, t) {
                    return this._smartSearchSession.then((n => null === n ? Promise.reject() : this._orchidAPI.fetchMotionEventMinuteReport(this.orchid, t, e, n.smartSearchSessionId)))
                }
                fetchNext(e, t) {
                    const n = vg(e, t);
                    return this._fetchNextPrevious(n, 1, t)
                }
                fetchPrevious(e, t) {
                    const n = yg(e, t);
                    return this._fetchNextPrevious(n, -1, t)
                }
                _fetchNextPrevious(e, t, n) {
                    return this._smartSearchSession.then((i => null === i ? null : this._orchidAPI.fetchSmartSearchSessionResults(this.orchid, i.smartSearchSessionId, e, this.searchRegionMappings.map((e => e.streamId)), t, n < 0).then((e => {
                        if (e.events && e.events.length > 0) {
                            return fg(n >= 0 ? e.events[0].start : e.events[0].stop, n)
                        }
                        return null
                    }
                    )).catch((e => (Cg.error("Failed fetching next/previous Smart Search motion event", e),
                    null))))).catch(( () => Promise.resolve(null)))
                }
            }
            var Ig;
            let Tg = class {
                constructor(e) {
                    this._orchidDataService = e
                }
                createMotionRequest(e, t) {
                    return new Sg(this._orchidDataService,e,t)
                }
                createSmartSearchMotionRequest(e, t) {
                    return new wg(this._orchidDataService,e,t)
                }
            }
            ;
            var Eg, _g, xg;
            Tg = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Ig = void 0 !== gg && gg) ? Ig : Object])], Tg);
            const Dg = O("timelineEvent.service");
            class Og {
                constructor(e, t, n) {
                    this.id = e,
                    this.orchid = t,
                    this.streamId = n,
                    this.type = "orchid-stream"
                }
            }
            class Ag extends Og {
                constructor(e, t, n, i, a, r) {
                    super(e, t, n),
                    this.id = e,
                    this.orchid = t,
                    this.streamId = n,
                    this.canvasHeight = i,
                    this.canvasWidth = a,
                    this.searchRegions = r,
                    this.type = "orchid-stream-cell-regions"
                }
            }
            let Rg = Eg = class {
                constructor(e, t) {
                    this._motionRequestFactory = e,
                    this._orchidDataService = t,
                    this._streams = [],
                    this._events$ = new St.x,
                    this._requests = [],
                    this._orchidSmartSearchStatus = {}
                }
                setTimelineStateFn(e) {
                    this._timelineStateFn = e
                }
                prewarm(e, t, n, i) {
                    this._orchidDataService.prewarmSmartSearch(e, n, i, [t])
                }
                getSmartSearchStatus(e) {
                    return void 0 === this._orchidSmartSearchStatus[e.id] && (this._orchidSmartSearchStatus[e.id] = this._orchidDataService.fetchSmartSearchStatus(e)),
                    this._orchidSmartSearchStatus[e.id]
                }
                addMotionRequest(e, t, n, i, a) {
                    Dg.debug(`Adding source ${e}, orchid: ${t.name}, stream: ${n}, size: ${i}, regions: ${a}`),
                    clearTimeout(this._timeout),
                    delete this._timeout,
                    this._streams = this._streams.filter((t => t.id !== e)),
                    void 0 !== i && void 0 !== a && (null == a ? void 0 : a.length) > 0 ? this._streams.push(new Ag(e,t,n,i.height,i.width,a)) : this._streams.push(new Og(e,t,n)),
                    this._requests = this._generateRequests(this._streams, !0),
                    void 0 !== this._debouncer && clearTimeout(this._debouncer),
                    this._debouncer = setTimeout(( () => {
                        this._fetchEvents(),
                        this._debouncer = void 0
                    }
                    ), 300)
                }
                removeMotionRequest(e) {
                    Dg.debug(`Removing source: ${e}`),
                    clearTimeout(this._timeout),
                    delete this._timeout,
                    this._streams = this._streams.filter((t => t.id !== e)),
                    this._requests = this._generateRequests(this._streams, !0),
                    this._fetchEvents()
                }
                fetchEvent(e, t, n) {
                    const i = this._getFetchRequests();
                    if (0 === i.length)
                        return Promise.resolve(null);
                    const a = [];
                    for (const r of i)
                        "next" === e ? a.push(r.fetchNext(t, n)) : a.push(r.fetchPrevious(t, n));
                    return Promise.all(a).then((t => {
                        const n = t.filter((e => null !== e)).flat();
                        return 0 === n.length ? null : "next" === e ? Math.min(...n) : Math.max(...n)
                    }
                    )).catch((e => (Dg.error(e),
                    null)))
                }
                _getFetchRequests() {
                    if (this.fullScreenPlayerId) {
                        const e = this._streams.find((e => e.id === this.fullScreenPlayerId));
                        return void 0 === e ? [] : this._generateRequests([e], !1)
                    }
                    return this._requests
                }
                _generateRequests(e, t) {
                    t && this._requests.forEach((e => e.complete()));
                    const n = {};
                    for (const t of e)
                        if (void 0 === n[t.orchid.id] && (n[t.orchid.id] = {
                            orchid: t.orchid,
                            streamIds: [],
                            streamIdRegions: []
                        }),
                        "orchid-stream-cell-regions" === t.type) {
                            const e = t;
                            n[t.orchid.id].streamIdRegions.push(e)
                        } else
                            n[t.orchid.id].streamIds.push(t.streamId);
                    const i = [];
                    for (const e of Object.values(n)) {
                        if (e.streamIdRegions.length > 0) {
                            const t = e.streamIdRegions.map((e => ({
                                canvasHeight: e.canvasHeight,
                                canvasWidth: e.canvasWidth,
                                searchRegions: e.searchRegions,
                                streamId: e.streamId
                            })));
                            i.push(this._motionRequestFactory.createSmartSearchMotionRequest(e.orchid, t))
                        }
                        e.streamIds.length > 0 && i.push(this._motionRequestFactory.createMotionRequest(e.orchid, e.streamIds))
                    }
                    return i
                }
                get fullScreenPlayerId() {
                    return this._fullScreenPlayerId
                }
                set fullScreenPlayerId(e) {
                    this._fullScreenPlayerId !== e && (this._fullScreenPlayerId = e,
                    clearTimeout(this._timeout),
                    delete this._timeout,
                    this._timeout = setTimeout(( () => this._fetchEvents()), 0))
                }
                _fetchEvents() {
                    if (void 0 !== this._timelineStateFn)
                        try {
                            this._timeout && (clearTimeout(this._timeout),
                            delete this._timeout);
                            const e = this._timelineStateFn();
                            if (null === e)
                                return;
                            if (0 === e.minSegment || isNaN(e.minSegment))
                                return void (this._timeout = setTimeout(( () => this._fetchEvents()), 500));
                            const t = this._getFetchRequests();
                            if (0 === t.length)
                                return void this._events$.next([]);
                            const n = [];
                            for (const i of t)
                                n.push(i.fetch(e.start, e.stop, void 0, e.minSegment, void 0));
                            Promise.all(n).then((e => {
                                this._events$.next(e.flat())
                            }
                            )).catch((e => {
                                Dg.warn("Error fetching motion/smart search events", e)
                            }
                            )).finally(( () => {
                                0 !== this._requests.length ? this._timeout = setTimeout(( () => this._fetchEvents()), 1500) : this._events$.next([])
                            }
                            ))
                        } catch (e) {
                            Dg.error("Unexpected response", e)
                        }
                }
                get events$() {
                    return this._events$.asObservable()
                }
                isolateTimeline(e, t, n, i) {
                    const a = this._streams.find((t => t.id === e));
                    if (void 0 === a || void 0 === a.orchid)
                        throw new Error("Stream not being fetched");
                    this._streams = this._streams.filter((t => t.id !== e)),
                    this.removeMotionRequest(e);
                    const r = new Eg(this._motionRequestFactory,this._orchidDataService);
                    return r.setTimelineStateFn(t),
                    r.addMotionRequest(e, null == a ? void 0 : a.orchid, null == a ? void 0 : a.streamId, n, i),
                    r
                }
            }
            ;
            Rg = Eg = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.w6)("design:paramtypes", ["function" == typeof (_g = void 0 !== Tg && Tg) ? _g : Object, "function" == typeof (xg = void 0 !== gg && gg) ? xg : Object])], Rg);
            const Pg = {
                provide: tt,
                useFactory: e => e.get("DataService"),
                deps: ["$injector"]
            }
              , kg = {
                provide: Qe,
                useFactory: e => e.get("FusionDataService"),
                deps: ["$injector"]
            }
              , Mg = {
                provide: pt,
                useFactory: e => e.get("OrchidDataService"),
                deps: ["$injector"]
            }
              , Lg = {
                provide: Gt,
                useFactory: e => e.get("RenewableService"),
                deps: ["$injector"]
            }
              , Ng = {
                provide: Qt,
                useFactory: e => e.get("UserSettingsService"),
                deps: ["$injector"]
            }
              , Fg = {
                provide: et,
                useFactory: e => e.get("PluginService"),
                deps: ["$injector"]
            }
              , Ug = {
                provide: cn,
                useFactory: e => e.get("StageService"),
                deps: ["$injector"]
            }
              , $g = {
                provide: en,
                useFactory: e => e.get("MatrixService"),
                deps: ["$injector"]
            }
              , jg = {
                provide: rt,
                useFactory: e => e.get("BrowserInfoService"),
                deps: ["$injector"]
            }
              , Vg = {
                provide: st,
                useFactory: e => e.get("UtilityService"),
                deps: ["$injector"]
            }
              , Gg = {
                provide: xe,
                useFactory: e => e.get("AuthenticationService"),
                deps: ["$injector"]
            }
              , Bg = {
                provide: gt,
                useFactory: e => e.get("DeathService"),
                deps: ["$injector"]
            }
              , zg = {
                provide: og,
                useFactory: e => e.get("WebSocketEventsService"),
                deps: ["$injector"]
            }
              , Hg = {
                provide: sg,
                useFactory: e => e.get("WebSocketSubjectFactory"),
                deps: ["$injector"]
            }
              , Wg = {
                provide: Ve,
                useFactory: e => e.get("PrerequisitesService"),
                deps: ["$injector"]
            }
              , qg = {
                provide: Ea,
                useFactory: e => e.get("ControlledShutdownService"),
                deps: ["$injector"]
            }
              , Yg = {
                provide: $d,
                useFactory: e => e.get("LegacyDialogService"),
                deps: ["$injector"]
            }
              , Xg = {
                provide: bn,
                useFactory: e => e.get("CrossOrchidDataService"),
                deps: ["$injector"]
            }
              , Kg = {
                provide: En,
                useFactory: e => e.get("GamepadService"),
                deps: ["$injector"]
            }
              , Zg = {
                provide: sn,
                useFactory: e => e.get("PlayerOptionsFactory"),
                deps: ["$injector"]
            }
              , Jg = {
                provide: Rg,
                useFactory: e => e.get("TimelineEventService"),
                deps: ["$injector"]
            };
            var Qg, ef;
            let tf = class {
                constructor(e, t) {
                    this._http = e,
                    this._dateAdapter = t,
                    this._version = new P.X(""),
                    this.version$ = this._version.asObservable(),
                    this._license = new P.X(""),
                    this.license$ = this._license.asObservable(),
                    this._brand = new P.X(""),
                    this.brand$ = this._brand.asObservable()
                }
                getAppInfo() {
                    return this._http.get(w.baseUrl + "/service/version").pipe((0,
                    Ks.w)((e => {
                        const t = e;
                        if (this.setVersion(t.version),
                        this.setLicense(t.license),
                        w.isCustomLicense ? this.setBrand("hybrid") : this.setBrand(t.brand),
                        w.isOrchid) {
                            const e = t.locale;
                            return this._dateAdapter.setLocale(e),
                            L.setLocale(e)
                        }
                        return Ql.E
                    }
                    )), (0,
                    pn.q)(1))
                }
                setVersion(e) {
                    this._version.next(e)
                }
                setBrand(e) {
                    this._brand.next(e)
                }
                setLicense(e) {
                    this._license.next(this._removeTimedSuffix(e))
                }
                _removeTimedSuffix(e) {
                    const t = "-timed";
                    return null != e && e.endsWith(t) ? e.slice(0, -t.length) : e
                }
            }
            ;
            var nf, af, rf;
            tf = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.fM)(0, (0,
            i.Inject)(lt.eN)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Qg = void 0 !== lt.eN && lt.eN) ? Qg : Object, "function" == typeof (ef = void 0 !== si._A && si._A) ? ef : Object])], tf);
            let sf = class {
                constructor(e, t, n) {
                    this.document = e,
                    this._userSettingsService = t,
                    this.$rootScope = n,
                    this._theme = new P.X("md"),
                    this._palettes = Object.assign(Object.assign(Object.assign(Object.assign({}, Hc()), qc()), Xc()), Kc),
                    this.theme$ = this._theme.asObservable()
                }
                getPrimaryColorHex() {
                    if (!Object.keys(this._palettes).includes(this._theme.value))
                        throw new Error(`No palette found for ${this._theme.value}!`);
                    return this._palettes[this._theme.value][500].hex
                }
                setTheme(e) {
                    this._theme.next(e);
                    const {classList: t} = this.document.body;
                    if (t.length > 0) {
                        const n = [...t].find((e => e.startsWith("md-")));
                        n ? t.replace(n, `md-${e.toLowerCase()}-theme`) : t.add(`md-${e.toLowerCase()}-theme`)
                    }
                    this.$rootScope.theme = e
                }
                updateTheme(e) {
                    w.license = e;
                    const t = this._userSettingsService.getTheme();
                    "" !== t && this.setTheme(t)
                }
                _updateApplicationIcon(e) {
                    let t = document.querySelector("link[rel~='icon']");
                    t || (t = document.createElement("link"),
                    t.rel = "icon",
                    document.head.appendChild(t)),
                    t.href = `./images/${"orchid" === e ? "core" : e}_favicon.png`
                }
            }
            ;
            var of, cf;
            sf = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(l.K0)), (0,
            c.fM)(1, (0,
            i.Inject)(Qt)), (0,
            c.fM)(2, (0,
            i.Inject)("$rootScope")), (0,
            c.w6)("design:paramtypes", ["function" == typeof (nf = "undefined" != typeof Document && Document) ? nf : Object, "function" == typeof (af = Qt) ? af : Object, "function" == typeof (rf = "undefined" != typeof angular && angular.IRootScopeService) ? rf : Object])], sf);
            let lf = class {
                constructor(e, t) {
                    this._appService = e,
                    this._themeService = t,
                    this.destroy$ = new St.x
                }
                ngOnInit() {
                    this._applyTheme()
                }
                _applyTheme() {
                    const e = w.isOrchid && !w.isCustomLicense;
                    (e ? this._appService.license$ : this._appService.brand$).pipe((0,
                    oa.R)(this.destroy$)).subscribe((t => {
                        const n = e && "core" === t ? "orchid" : t;
                        this._themeService.updateTheme(n),
                        e && this._themeService._updateApplicationIcon(n)
                    }
                    ))
                }
                ngOnDestroy() {
                    this.destroy$.next(),
                    this.destroy$.complete()
                }
            }
            ;
            lf = (0,
            c.gn)([(0,
            i.Component)({
                selector: "app-root",
                template: n(69828)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(tf)), (0,
            c.fM)(1, (0,
            i.Inject)(sf)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (of = void 0 !== tf && tf) ? of : Object, "function" == typeof (cf = void 0 !== sf && sf) ? cf : Object])], lf);
            var df, uf = n(75029), mf = n(53741);
            class hf {
                constructor(e, t) {
                    this._bigHeight = e,
                    this._smallHeight = t,
                    this._scrolledIndexChange = new St.x,
                    this.scrolledIndexChange = this._scrolledIndexChange.pipe((0,
                    mf.x)()),
                    this._viewport = null,
                    this._runlengthEncoding = null
                }
                attach(e) {
                    this._viewport = e,
                    this._updateTotalContentSize(),
                    this._updateRenderedRange()
                }
                detach() {
                    this._scrolledIndexChange.complete(),
                    this._viewport = null
                }
                onContentScrolled() {
                    this._updateRenderedRange()
                }
                onDataLengthChanged() {
                    this._updateTotalContentSize(),
                    this._updateRenderedRange()
                }
                onContentRendered() {}
                onRenderedOffsetChanged() {}
                scrollToIndex(e, t) {
                    this._viewport && this._viewport.scrollToOffset(this._findOffset(e), t)
                }
                updateRunlengthEncode(e) {
                    this._runlengthEncoding = e,
                    this._updateTotalContentSize(),
                    this._updateRenderedRange()
                }
                updateSizes(e, t) {
                    this._bigHeight = e,
                    this._smallHeight = t,
                    this._updateTotalContentSize(),
                    this._updateRenderedRange()
                }
                _getHeightMultiplier(e) {
                    return e === bt.Big ? this._bigHeight : this._smallHeight
                }
                _updateTotalContentSize() {
                    if (!this._viewport)
                        return;
                    if (null === this._runlengthEncoding)
                        return void this._viewport.setTotalContentSize(0);
                    const e = this._runlengthEncoding.reduce(( (e, t) => e + this._getHeightMultiplier(t.category) * t.runlength), 0);
                    this._viewport.setTotalContentSize(e)
                }
                _findOffset(e) {
                    if (null === this._runlengthEncoding)
                        return 0;
                    let t = 0
                      , n = 0;
                    for (let i = 0; i < this._runlengthEncoding.length; i++) {
                        const {runlength: a, category: r} = this._runlengthEncoding[i]
                          , s = this._getHeightMultiplier(r);
                        if (e < n + a)
                            return t + (e - n) * s;
                        t += a * s,
                        n += a
                    }
                    return t
                }
                _findIndex(e) {
                    if (e <= 0 || null === this._runlengthEncoding)
                        return {
                            index: 0,
                            offset: 0
                        };
                    let t = 0
                      , n = 0;
                    for (let i = 0; i < this._runlengthEncoding.length; i++) {
                        const {runlength: a, category: r} = this._runlengthEncoding[i]
                          , s = this._getHeightMultiplier(r)
                          , o = t + a * s;
                        if (o >= e) {
                            const i = Math.floor((e - t) / s);
                            return {
                                index: n + i,
                                offset: t + i * s
                            }
                        }
                        n += a,
                        t = o
                    }
                    return {
                        index: n,
                        offset: t
                    }
                }
                _updateRenderedRange() {
                    if (!this._viewport || null === this._runlengthEncoding)
                        return;
                    const e = this._viewport.getViewportSize()
                      , t = this._viewport.measureScrollOffset()
                      , n = this._viewport.getDataLength()
                      , i = this._findIndex(t)
                      , a = this._findIndex(t + e)
                      , r = Math.min(a.index + 1, n);
                    this._viewport.setRenderedRange({
                        start: i.index,
                        end: r
                    }),
                    this._viewport.setRenderedContentOffset(i.offset),
                    this._scrolledIndexChange.next(i.index)
                }
            }
            let pf = df = class {
                constructor() {
                    this._scrollStrategy = class {
                        static create(e, t) {
                            return new hf(e,t)
                        }
                    }
                    .create(df.defaultBigItemGridHeight, df.defaultSmallItemHeight),
                    this.renderInfo = null,
                    this.loading = !0,
                    this.orchidsLength = -1,
                    this.layout = "GRID",
                    this.bagIsExpanded = !1,
                    this.handleItemClick = new i.EventEmitter,
                    this.handleStreamPreviewDoubleClick = new i.EventEmitter
                }
                get BagItemType() {
                    return vt
                }
                get BagViewMode() {
                    return ft
                }
                get bigItemLargeHeight() {
                    return df.bigItemLargeHeight
                }
                onStreamPreviewDoubleClick(e, t) {
                    this.handleStreamPreviewDoubleClick.emit({
                        orchidId: e.orchidId,
                        cameraId: e.cameraId,
                        target: t.target
                    })
                }
                ngOnChanges(e) {
                    if (e.layout)
                        switch (e.layout.currentValue) {
                        case "GRID":
                            this._scrollStrategy.updateSizes(df.defaultBigItemGridHeight, df.defaultSmallItemHeight);
                            break;
                        case "LARGE":
                            this._scrollStrategy.updateSizes(df.bigItemLargeHeight, df.defaultSmallItemHeight);
                            break;
                        case "DETAIL":
                            this._scrollStrategy.updateSizes(df.bigItemDetailHeight, df.defaultSmallItemHeight)
                        }
                    null !== this.renderInfo && this._scrollStrategy.updateRunlengthEncode(this.renderInfo.runlengthEncoding)
                }
                getRowId(e, t) {
                    return `${t.name}-${t.type}-${e}`
                }
                getClassLabel(e) {
                    switch (e) {
                    case yt.Header:
                        return "header-text";
                    case yt.Empty:
                        return "empty-data-text";
                    case yt.Error:
                        return "error-msg";
                    case yt.FilterMismatch:
                        return "filter-msg"
                    }
                }
                getEmptyLabelMessageTooltip(e) {
                    return e.msgType === yt.Empty ? e.name : ""
                }
            }
            ;
            pf.defaultBigItemGridHeight = 40,
            pf.bigItemLargeHeight = 165,
            pf.bigItemDetailHeight = 75,
            pf.defaultSmallItemHeight = 40,
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], pf.prototype, "renderInfo", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], pf.prototype, "loading", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], pf.prototype, "orchidsLength", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], pf.prototype, "layout", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], pf.prototype, "bagIsExpanded", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], pf.prototype, "handleItemClick", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], pf.prototype, "handleStreamPreviewDoubleClick", void 0),
            pf = df = (0,
            c.gn)([(0,
            i.Component)({
                selector: "bag-render",
                template: n(75615),
                providers: [{
                    provide: uf.yU,
                    useFactory: e => e._scrollStrategy,
                    deps: [(0,
                    i.forwardRef)(( () => df))]
                }]
            })], pf);
            let gf = class {
                constructor() {
                    this._fullscreenState$ = new P.X({
                        controllerId: null,
                        isFullscreen: !1,
                        linked: null,
                        state: null
                    }),
                    this.fullscreenState$ = this._fullscreenState$.asObservable()
                }
                get isInFullscreenMode() {
                    const e = this._fullscreenState$.getValue();
                    return void 0 !== e && e.isFullscreen
                }
                setFullscreenState(e) {
                    this._fullscreenState$.next(e)
                }
                getFullscreenState() {
                    return this._fullscreenState$.value
                }
            }
            ;
            var ff, vf, yf, bf, Sf;
            gf = (0,
            c.gn)([(0,
            i.Injectable)()], gf);
            let Cf = class {
                constructor(e, t, n, i, a) {
                    this._stageServiceJS = e,
                    this._stageService = t,
                    this._matrixService = n,
                    this._timelineEventService = i,
                    this.elementRef = a,
                    this._fullscreenToggled = !1
                }
                close() {
                    this._fullscreenToggled && this.toggleFullScreen(),
                    this._stageServiceJS.removeCellById(this.id)
                }
                get fullscreenToggled() {
                    return this._fullscreenToggled
                }
                toggleFullScreen() {
                    this._fullscreenToggled = this._matrixService.toggleFullScreen({
                        target: this.elementRef.nativeElement.parentElement
                    }),
                    this._fullscreenToggled ? this._timelineEventService.fullScreenPlayerId = this.id : this._timelineEventService.fullScreenPlayerId = void 0;
                    const e = this._stageService.getFullscreenState();
                    e.isFullscreen = this._fullscreenToggled,
                    this._stageService.setFullscreenState(e)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Cf.prototype, "id", void 0),
            Cf = (0,
            c.gn)([(0,
            i.Component)({
                selector: "cell",
                template: n(1196)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(cn)), (0,
            c.fM)(1, (0,
            i.Inject)(gf)), (0,
            c.fM)(2, (0,
            i.Inject)(en)), (0,
            c.fM)(3, (0,
            i.Inject)(Rg)), (0,
            c.fM)(4, (0,
            i.Inject)(i.ElementRef)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (ff = cn) ? ff : Object, "function" == typeof (vf = void 0 !== gf && gf) ? vf : Object, "function" == typeof (yf = en) ? yf : Object, "function" == typeof (bf = void 0 !== Rg && Rg) ? bf : Object, "function" == typeof (Sf = void 0 !== i.ElementRef && i.ElementRef) ? Sf : Object])], Cf);
            let wf = class {
            }
            ;
            wf = (0,
            c.gn)([(0,
            i.Component)({
                selector: "licensing",
                template: n(60244)
            })], wf);
            var If, Tf, Ef, _f, xf = n(52053);
            const Df = new i.InjectionToken("CameraLinkOverlay - CameraInjectionToken")
              , Of = new i.InjectionToken("CameraLinkOverlay - EventsInjectionToken")
              , Af = new i.InjectionToken("CameraLinkOverlay - OrchidInjectionToken")
              , Rf = new i.InjectionToken("CameraLinkOverlay - OnStage");
            var Pf;
            !function(e) {
                e[e.Loading = 0] = "Loading",
                e[e.Loaded = 1] = "Loaded",
                e[e.LoadedWithError = 2] = "LoadedWithError"
            }(Pf || (Pf = {}));
            let kf = If = class {
                constructor(e, t, n, i, a, r) {
                    this.camera = e,
                    this.orchid = t,
                    this.onStage = n,
                    this.events$ = i,
                    this._dataService = a,
                    this._minimumVersionService = r,
                    this._loadingState = Pf.Loading,
                    this._isDisabledCamera = !1,
                    this.previewSrcURL = ""
                }
                static createComponentPortal({camera: e, orchid: t, parentInjector: n, onStage: a}) {
                    const r = new St.x;
                    return {
                        events$: r,
                        portal: new xf.C5(If,null,i.Injector.create({
                            parent: n,
                            providers: [{
                                provide: Df,
                                useValue: e
                            }, {
                                provide: Af,
                                useValue: t
                            }, {
                                provide: Rf,
                                useValue: a
                            }, {
                                provide: Of,
                                useValue: r
                            }]
                        }))
                    }
                }
                get previewFail() {
                    return this._loadingState === Pf.LoadedWithError
                }
                get loading() {
                    return this._loadingState === Pf.Loading
                }
                get disabled() {
                    return this._isDisabledCamera
                }
                ngOnInit() {
                    var e;
                    this.previewSrcURL = this._dataService.cameraPreviewUrl(this.camera.orchidId, this.camera.id, j.SMALL, !0);
                    const t = this._minimumVersionService.isFeatureSupported(this.orchid, Sr.CAMERA_DISABLEMENT);
                    this._isDisabledCamera = !!t && (null === (e = !this.camera.active) || void 0 === e || e)
                }
                ngOnDestroy() {
                    this.events$.complete(),
                    this.events$.unsubscribe()
                }
                imageLoaded() {
                    this._loadingState = Pf.Loaded
                }
                imageLoadFailed() {
                    this._loadingState = Pf.LoadedWithError
                }
                close() {
                    this.emitEvent("close")
                }
                addToStage() {
                    this.emitEvent("add-to-stage")
                }
                emitEvent(e) {
                    this.events$.next({
                        kind: e
                    })
                }
            }
            ;
            kf = If = (0,
            c.gn)([(0,
            i.Component)({
                selector: "camera-link-overlay",
                template: n(25415)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Df)), (0,
            c.fM)(1, (0,
            i.Inject)(Af)), (0,
            c.fM)(2, (0,
            i.Inject)(Rf)), (0,
            c.fM)(3, (0,
            i.Inject)(Of)), (0,
            c.fM)(4, (0,
            i.Inject)(tt)), (0,
            c.fM)(5, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", [Object, Object, Boolean, "function" == typeof (Tf = void 0 !== St.x && St.x) ? Tf : Object, "function" == typeof (Ef = tt) ? Ef : Object, "function" == typeof (_f = void 0 !== Cr && Cr) ? _f : Object])], kf);
            var Mf, Lf, Nf, Ff, Uf, $f, jf, Vf = n(31015), Gf = n(28641), Bf = n(60188), zf = n(32857), Hf = n(63267), Wf = n(13205), qf = n(14474), Yf = n(834), Xf = n(20686), Kf = n(84825), Zf = n(11230), Jf = n(78714), Qf = n(62706), ev = n(51345), tv = n(58958), nv = n(89080), iv = n(21280), av = n(22401), rv = n(67229), sv = n(8951), ov = n(32135), cv = n(81090), lv = n(7859), dv = n(20228), uv = n(12169), mv = n(94259), hv = n(61882), pv = n(29619), gv = n(29650), fv = n(97080), vv = n(8891), yv = n(73159);
            class bv {
                static createFeature(e) {
                    return new cv.Z(e)
                }
                static createProjection(e) {
                    return new pv.Z(e)
                }
                static createMap(e) {
                    return new mv.Z(e)
                }
                static createStaticImageSource(e) {
                    return new gv.Z(e)
                }
                static createImageLayer(e) {
                    return new dv.Z(e)
                }
                static createOverlay(e) {
                    return new hv.Z(e)
                }
                static createVectorSource(e) {
                    return new fv.Z(e)
                }
                static createVectorLayer(e) {
                    return new uv.Z(e)
                }
                static createView(e) {
                    return new vv.ZP(e)
                }
                static createTransformInteraction(e) {
                    return new yv.Z(e)
                }
                static createPopupOverlay(e) {
                    return new ov.Z(e)
                }
                static createHoverInteraction(e) {
                    return new sv.Z(e)
                }
                static createFontSymbol(e) {
                    return new lv.Z(e)
                }
            }
            function Sv(e, t) {
                return [e[0] / (t[0] / 2) - 1, e[1] / (t[1] / 2) - 1]
            }
            !function(e) {
                e.ImageLoadError = "image-load-error",
                e.MapClicked = "map-clicked",
                e.MapError = "map-error",
                e.FeatureSelected = "feature-selected"
            }(Mf || (Mf = {})),
            function(e) {
                e.SingleClick = "singleclick",
                e.DoubleClick = "dblclick",
                e.PointerDrag = "pointerdrag"
            }(Lf || (Lf = {})),
            function(e) {
                e.CAMERA = "",
                e.DEWARP = "",
                e.MAP = "",
                e.PTZ = "",
                e.ROTATE = ""
            }(jf || (jf = {}));
            const Cv = .5;
            let wv = Nf = class {
                constructor(e, t, n) {
                    this._platform = e,
                    this._injector = t,
                    this._themeService = n,
                    this._overlay = null,
                    this._overlayOpts = null,
                    this._olextTransformInteraction = null,
                    this._olextHoverInteraction = null,
                    this._isInitialDragEventAFeature = void 0,
                    this._listeners = [],
                    this._editable = !1,
                    this._editActionActive = !1,
                    this._haveSelected = !1,
                    this.events$ = new St.x,
                    this.clickEvent$ = new St.x,
                    this._featureZindex = 1
                }
                static forComponent() {
                    return {
                        provide: Nf,
                        useClass: Nf
                    }
                }
                get isEditable() {
                    return this._editable
                }
                get editActionActive() {
                    return this._editActionActive
                }
                get dragPanDisabled() {
                    return void 0 !== this._lastMouseDownFeature
                }
                getBaseFontSymbol(e) {
                    return {
                        font: "Font Awesome Kit",
                        fontSize: 1,
                        radius: e.isTouch ? 14 : 16,
                        rotation: e.rotation,
                        fill: new ev.Z({
                            color: this._themeService.getPrimaryColorHex()
                        }),
                        stroke: new tv.Z({
                            color: "white",
                            width: e.selected ? 3 : 2
                        })
                    }
                }
                eventWithinMap(e) {
                    if (void 0 === this._map)
                        throw new Error("There is no linked map");
                    const t = this._map.getEventCoordinate(e);
                    return null !== t && (0,
                    Gf.jE)(this._map.getView().getProjection().getExtent(), t[0], t[1])
                }
                getMapCoordinatesFromEvent(e) {
                    if (void 0 === this._map)
                        throw new Error("There is no linked map");
                    return this._map.getEventCoordinate(e)
                }
                getMapCenter() {
                    if (void 0 === this._map)
                        throw new Error("There is no linked map");
                    return this._map.getView().getCenter()
                }
                updateMapSize() {
                    void 0 !== this._map && this._map.updateSize()
                }
                enableEditing() {
                    if (void 0 === this._map || void 0 === this._markerLayer)
                        throw new Error("Cannot enable editing. The map is destroyed or has not been created yet");
                    if (!this._editable) {
                        if (this._editable = !0,
                        this._olextHoverInteraction && this._olextHoverInteraction.setActive(!1),
                        null === this._olextTransformInteraction) {
                            this._olextTransformInteraction = bv.createTransformInteraction({
                                layers: [this._markerLayer],
                                rotate: !0,
                                translate: !0,
                                scale: !1,
                                stretch: !1,
                                hitTolerance: 1
                            }),
                            this._map.addInteraction(this._olextTransformInteraction);
                            const e = this._platform.ANDROID || this._platform.IOS
                              , t = bv.createFontSymbol(Object.assign(Object.assign({}, this.getBaseFontSymbol({
                                isTouch: e,
                                rotation: 0,
                                selected: !1
                            })), {
                                text: jf.ROTATE,
                                radius: e ? 5 : 10,
                                offsetX: e ? 2 : 10,
                                offsetY: e ? 4 : 15
                            }));
                            this._olextTransformInteraction.setStyle("rotate", new nv.ZP({
                                image: t
                            })),
                            this._manageListeners([this._olextTransformInteraction.on("select", (e => {
                                if (!this.isEditable || void 0 === this._mapLayer)
                                    return;
                                const t = this._mapLayer.getOpacity();
                                this._lastSelectedFeature && this._lastSelectedFeature.set("selected", !1),
                                this._lastSelectedFeature = e.feature,
                                this._lastSelectedFeature ? (this._haveSelected = !0,
                                this._lastSelectedFeature.set("selected", !0),
                                t !== Cv && this._mapLayer.setOpacity(Cv),
                                this.events$.next({
                                    kind: Mf.FeatureSelected,
                                    feature: this._lastSelectedFeature.get("dto")
                                })) : (this.events$.next({
                                    kind: Mf.FeatureSelected,
                                    feature: void 0
                                }),
                                this._haveSelected = !1,
                                t === Cv && this._mapLayer.setOpacity(1))
                            }
                            )), this._olextTransformInteraction.on("translatestart", ( () => {
                                this.isEditable && (this._editActionActive = !0,
                                null !== this._overlay && this._overlay.getVisible() && this.hideOverlay())
                            }
                            )), this._olextTransformInteraction.on("translateend", (e => {
                                if (!this.isEditable)
                                    return;
                                this._editActionActive = !1;
                                const t = e.feature
                                  , n = t.get("dto")
                                  , i = t.getGeometry().getFirstCoordinate();
                                n.mapPosition && ([n.mapPosition.x,n.mapPosition.y] = Sv(i, this._mapSize)),
                                null === this._overlay || this._overlay.getVisible() || this.showOverlay(i)
                            }
                            )), this._olextTransformInteraction.on("rotatestart", ( () => {
                                this.isEditable && (this._editActionActive = !0,
                                null !== this._overlay && this._overlay.getVisible() && this.hideOverlay())
                            }
                            )), this._olextTransformInteraction.on("rotating", (e => {
                                this.isEditable && e.feature.set("rotation", -1 * e.angle)
                            }
                            )), this._olextTransformInteraction.on("rotateend", (e => {
                                if (!this.isEditable)
                                    return;
                                this._editActionActive = !1;
                                const t = e.feature
                                  , n = t.get("dto");
                                n.mapPosition && (n.mapPosition.theta = t.get("rotation")),
                                null === this._overlay || this._overlay.getVisible() || this.showOverlay(t.getGeometry().getFirstCoordinate())
                            }
                            ))])
                        } else
                            this._olextTransformInteraction.setActive(!0);
                        void 0 === this._viewResolutionChangeSub && (this._viewResolutionChangeSub = new Ln.y((e => {
                            if (void 0 === this._mapView)
                                return;
                            const t = this._mapView.on("change:resolution", ( () => {
                                this.isEditable && void 0 !== this._mapLayer && this._mapLayer.getOpacity() === Cv && e.next()
                            }
                            ));
                            return () => {
                                (0,
                                Qf.B)(t)
                            }
                        }
                        )).subscribe(( () => {
                            this._olextTransformInteraction.drawSketch_()
                        }
                        )))
                    }
                }
                disableEditing() {
                    if (void 0 === this._map || null === this._olextTransformInteraction)
                        throw new Error("Cannot disable editing. The map is destroyed or has not been created yet");
                    this._editable && (this._editable = !1,
                    this._editActionActive = !1,
                    this._lastSelectedFeature = void 0,
                    this._olextTransformInteraction.setActive(!1),
                    this._olextHoverInteraction && this._olextHoverInteraction.setActive(!0),
                    this._viewResolutionChangeSub && (this._viewResolutionChangeSub.unsubscribe(),
                    this._viewResolutionChangeSub = void 0))
                }
                selectFeature(e) {
                    if (void 0 === this._map || void 0 === this._markerLayerSource || !this.isEditable)
                        return !1;
                    const t = this._markerLayerSource.getFeatureById(this._getCameraLinkIdentifier(e));
                    return null !== t && (0 !== this._olextTransformInteraction.getFeatures().getLength() && this._olextTransformInteraction.select(),
                    this._olextTransformInteraction.select(t, !0),
                    !0)
                }
                addOverlay(e) {
                    if (void 0 === this._map)
                        throw new Error("Cannot add an overlay. The map is destroyed or has not been created yet");
                    null !== this._overlay && this.closeOverlay(),
                    this._overlay = bv.createPopupOverlay({
                        popupClass: "default",
                        positioning: "auto",
                        closeBox: !0,
                        anim: !0,
                        stopEvent: !0,
                        onclose: () => {
                            this.editActionActive || this.closeOverlay()
                        }
                    }),
                    this._map.addOverlay(this._overlay),
                    this._overlayOpts = e
                }
                showOverlay(e) {
                    if (void 0 === this._map || null === this._overlay || null === this._overlayOpts)
                        throw new Error("Cannot show an overlay. The map or the overlay is destroyed or has not been created yet");
                    this._overlay.show(e, this._overlayOpts.hostElement)
                }
                hideOverlay() {
                    if (void 0 === this._map || null === this._overlay)
                        throw new Error("Cannot hide an overlay. The map or the overlay is destroyed or has not been created yet");
                    this._overlay.hide()
                }
                closeOverlay() {
                    if (void 0 === this._map)
                        throw new Error("Cannot remove an overlay. The map is destroyed or has not been created yet");
                    null !== this._overlay && (this._map.removeOverlay(this._overlay),
                    this._overlay.onclose = void 0,
                    this._overlay.setElement(void 0),
                    this._overlay.dispose(),
                    this._overlay = null,
                    this._overlayOpts = null)
                }
                showCameraLinkOverlay({orchid: e, camera: t, onStage: n, overlayElement: i}) {
                    this.closeOverlay();
                    const {portal: a, events$: r} = kf.createComponentPortal({
                        orchid: e,
                        camera: t,
                        onStage: n,
                        parentInjector: this._injector
                    });
                    return this.addOverlay({
                        hostElement: i
                    }),
                    {
                        events$: r,
                        portal: a
                    }
                }
                determineCameraType(e) {
                    var t, n;
                    const i = {
                        isDewarp: !1,
                        isPTZ: !1
                    }
                      , a = null === (n = null === (t = e.primaryStream) || void 0 === t ? void 0 : t.dewarpConfiguration) || void 0 === n ? void 0 : n.enable;
                    return !0 !== a && "true" !== a || (i.isDewarp = !0),
                    i.isPTZ = F(e),
                    i
                }
                addCameraLinkMarker(e, t, n) {
                    if (void 0 === this._map || void 0 === this._markerLayerSource)
                        throw new Error("Cannot add an camera link marker. The map is destroyed or has not been created yet");
                    const {x: i, y: a, theta: r} = t.mapPosition
                      , s = (null == n ? void 0 : n.transformMapPosition) ? (o = [i, a],
                    c = this._mapSize,
                    [Math.ceil((o[0] + 1) * (c[0] / 2)), Math.ceil((o[1] + 1) * (c[1] / 2))]) : [i, a];
                    var o, c;
                    const l = bv.createFeature(new Bf.Z(s));
                    l.setId(this._getCameraLinkIdentifier(t)),
                    l.set("dto", t),
                    l.set("rotation", r),
                    l.set("selected", !1),
                    l.set("kind", "camera");
                    const d = new iv.Z({
                        font: '15px Roboto, "Helvetica Neue", sans-serif',
                        overflow: !0,
                        fill: new ev.Z({
                            color: "#fff"
                        }),
                        offsetY: -25,
                        stroke: new tv.Z({
                            color: "#000",
                            width: 2
                        }),
                        text: n ? n.label : "",
                        textAlign: "center",
                        textBaseline: "center"
                    })
                      , u = this._platform.ANDROID || this._platform.IOS
                      , m = this.determineCameraType(e);
                    m.isDewarp ? this._addDewarpCamera(l, d, u) : m.isPTZ && !m.isDewarp ? this._addPtzCamera(l, d, u) : this._addRegularCamera(l, d, u),
                    this._markerLayerSource.addFeature(l)
                }
                _addDewarpCamera(e, t, n) {
                    const i = bv.createFontSymbol(Object.assign(Object.assign({}, this.getBaseFontSymbol({
                        isTouch: n,
                        rotation: e.get("rotation"),
                        selected: !1
                    })), {
                        text: jf.DEWARP,
                        fontSize: .8
                    }))
                      , a = bv.createFontSymbol(Object.assign(Object.assign({}, this.getBaseFontSymbol({
                        isTouch: n,
                        rotation: e.get("rotation"),
                        selected: !0
                    })), {
                        text: jf.DEWARP,
                        fontSize: .8
                    }))
                      , r = new nv.ZP({
                        image: i,
                        text: t,
                        zIndex: this._featureZindex++
                    })
                      , s = new nv.ZP({
                        image: a,
                        text: t,
                        zIndex: Number.POSITIVE_INFINITY
                    });
                    e.set("image", r),
                    e.set("selected-image", s)
                }
                _addPtzCamera(e, t, n) {
                    const i = bv.createFontSymbol(Object.assign(Object.assign({}, this.getBaseFontSymbol({
                        isTouch: n,
                        rotation: e.get("rotation"),
                        selected: !1
                    })), {
                        text: jf.PTZ,
                        fontSize: .8
                    }))
                      , a = bv.createFontSymbol(Object.assign(Object.assign({}, this.getBaseFontSymbol({
                        isTouch: n,
                        rotation: e.get("rotation"),
                        selected: !0
                    })), {
                        text: jf.PTZ,
                        fontSize: .8
                    }))
                      , r = new nv.ZP({
                        image: i,
                        text: t,
                        zIndex: this._featureZindex++
                    })
                      , s = new nv.ZP({
                        image: a,
                        text: t,
                        zIndex: Number.POSITIVE_INFINITY
                    });
                    e.set("image", r),
                    e.set("selected-image", s)
                }
                _addRegularCamera(e, t, n) {
                    const i = bv.createFontSymbol(Object.assign(Object.assign({}, this.getBaseFontSymbol({
                        isTouch: n,
                        rotation: e.get("rotation"),
                        selected: !1
                    })), {
                        text: jf.CAMERA,
                        fontSize: .8
                    }))
                      , a = bv.createFontSymbol(Object.assign(Object.assign({}, this.getBaseFontSymbol({
                        isTouch: n,
                        rotation: e.get("rotation"),
                        selected: !0
                    })), {
                        text: jf.CAMERA,
                        fontSize: .8
                    }))
                      , r = new nv.ZP({
                        image: i,
                        text: t,
                        zIndex: this._featureZindex++
                    })
                      , s = new nv.ZP({
                        image: a,
                        text: t,
                        zIndex: Number.POSITIVE_INFINITY
                    });
                    e.set("image", r),
                    e.set("selected-image", s)
                }
                removeMarker(e) {
                    if (void 0 === this._map || void 0 === this._markerLayerSource)
                        throw new Error("Cannot remove a map or camera link marker. The map is destroyed or has not been created yet");
                    const t = this._markerLayerSource.getFeatureById(this._getCameraLinkIdentifier(e));
                    if (t) {
                        if (this._lastSelectedFeature === t && (this._haveSelected = !1,
                        this._lastSelectedFeature = void 0),
                        this._mapLayer) {
                            this._mapLayer.getOpacity() === Cv && this._mapLayer.setOpacity(1)
                        }
                        return t.get("selected") && this._olextTransformInteraction.select(),
                        this._markerLayerSource.removeFeature(t),
                        !0
                    }
                    return !1
                }
                zoomIn() {
                    this._zoomByDelta(1)
                }
                zoomOut() {
                    this._zoomByDelta(-1)
                }
                link(e) {
                    var t;
                    this._editable = !1,
                    this.destroy(),
                    this._featureZindex = 1;
                    const n = bv.createProjection(Object.assign({
                        code: "ipconfigure-map",
                        units: "pixels",
                        extent: e.view.extent || e.mapLayerSource.imageExtent
                    }, e.projection))
                      , i = e.mapLayerSource.imageExtent || e.view.extent || n.getExtent();
                    this._mapLayerSource = bv.createStaticImageSource({
                        imageSize: e.mapLayerSource.imageSize,
                        crossOrigin: e.mapLayerSource.crossOrigin,
                        url: e.mapLayerSource.url,
                        imageExtent: i,
                        projection: n
                    }),
                    this._mapLayer = bv.createImageLayer({
                        source: this._mapLayerSource
                    }),
                    this._mapSize = Array.isArray(e.mapLayerSource.imageSize) ? e.mapLayerSource.imageSize : i.slice(2),
                    this._manageListeners(this._mapLayerSource.on("imageloaderror", (e => {
                        this.events$.next({
                            kind: Mf.ImageLoadError,
                            olEvent: e
                        })
                    }
                    ))),
                    this._markerLayerSource = bv.createVectorSource({
                        wrapX: !1
                    }),
                    this._markerLayer = bv.createVectorLayer({
                        source: this._markerLayerSource,
                        renderBuffer: 500,
                        style: e => {
                            const t = e.get("selected")
                              , n = e.get(t ? "selected-image" : "image");
                            if (this.isEditable) {
                                const i = n.getImage();
                                i.setRotation(e.get("rotation"));
                                const a = i.getOpacity();
                                this._haveSelected ? t || a === Cv || i.setOpacity(Cv) : a === Cv && i.setOpacity(1)
                            }
                            return n
                        }
                    }),
                    this._mapView = bv.createView(Object.assign({
                        projection: n,
                        center: e.view.center || (0,
                        Gf.qg)(e.view.extent ? e.view.extent : n.getExtent()),
                        showFullExtent: !0
                    }, e.view)),
                    this._map = bv.createMap({
                        controls: [],
                        layers: [this._mapLayer, this._markerLayer],
                        interactions: this._createInteractions(),
                        keyboardEventTarget: e.keyboardEventTarget,
                        view: this._mapView,
                        moveTolerance: 2
                    }),
                    this._manageListeners([this._map.on("dblclick", this._makeSelectEventHandler(Lf.DoubleClick)), this._map.on("singleclick", this._makeSelectEventHandler(Lf.SingleClick)), this._map.on("pointerdrag", this._makeSelectEventHandler(Lf.PointerDrag)), this._map.on("error", (e => {
                        this.events$.next({
                            kind: Mf.MapError,
                            olEvent: e
                        })
                    }
                    ))]),
                    this._platform.ANDROID || this._platform.IOS || (this._olextHoverInteraction = bv.createHoverInteraction({
                        cursor: "pointer",
                        layerFilter: e => e === this._markerLayer
                    }),
                    this._map.addInteraction(this._olextHoverInteraction)),
                    this._visibilityChangeSub = (0,
                    av.R)(document, "visibilitychange", {
                        passive: !0
                    }).pipe((0,
                    rv.j)(2)).subscribe(( () => {
                        var e;
                        null === (e = this._map) || void 0 === e || e.render()
                    }
                    ));
                    const a = oe();
                    return this._map.once("rendercomplete", ( () => {
                        a.resolve()
                    }
                    )),
                    null === (t = this._map) || void 0 === t || t.setTarget(e.target),
                    a.promise
                }
                destroy() {
                    var e, t, n, i, a, r, s;
                    (0,
                    Qf.B)(this._listeners),
                    this._listeners = [],
                    this._editable = !1,
                    this._editActionActive = !1,
                    this._haveSelected = !1,
                    this._lastSelectedFeature = void 0,
                    null === (e = this._visibilityChangeSub) || void 0 === e || e.unsubscribe(),
                    this._visibilityChangeSub = void 0,
                    null === (t = this._viewResolutionChangeSub) || void 0 === t || t.unsubscribe(),
                    this._viewResolutionChangeSub = void 0,
                    null === (n = this._mapLayer) || void 0 === n || n.dispose(),
                    this._mapLayer = void 0,
                    null === (i = this._markerLayer) || void 0 === i || i.dispose(),
                    this._markerLayer = void 0,
                    null === (a = this._olextTransformInteraction) || void 0 === a || a.dispose(),
                    this._olextTransformInteraction = null,
                    null === (r = this._olextHoverInteraction) || void 0 === r || r.dispose(),
                    this._olextHoverInteraction = null,
                    this._map && this._overlay && this.closeOverlay(),
                    null === (s = this._map) || void 0 === s || s.dispose(),
                    this._map = void 0
                }
                resetIsInitialDragEventAFeature() {
                    this._isInitialDragEventAFeature = void 0
                }
                getIsInitialDragEventAFeature() {
                    return this._isInitialDragEventAFeature
                }
                _getCameraLinkIdentifier(e) {
                    return `${e.id}_${e.orchidId}`
                }
                _manageListeners(e) {
                    Array.isArray(e) ? this._listeners = this._listeners.concat(e) : this._listeners.push(e)
                }
                _makeSelectEventHandler(e) {
                    return t => {
                        if (void 0 === this._map || e === Lf.SingleClick && this._editable)
                            return;
                        if (e === Lf.PointerDrag && this._isInitialDragEventAFeature)
                            return;
                        const n = this._lastMouseDownFeature;
                        void 0 !== n ? e === Lf.PointerDrag ? void 0 === this._isInitialDragEventAFeature && (this._isInitialDragEventAFeature = !0,
                        this.clickEvent$.next({
                            kind: e,
                            feature: n.get("dto"),
                            featureKind: n.get("kind"),
                            coordinates: n.getGeometry().getFirstCoordinate()
                        })) : this.clickEvent$.next({
                            kind: e,
                            feature: n.get("dto"),
                            featureKind: n.get("kind"),
                            coordinates: n.getGeometry().getFirstCoordinate()
                        }) : e === Lf.SingleClick ? this.events$.next({
                            kind: Mf.MapClicked,
                            coordinates: t.pixel
                        }) : void 0 === this._isInitialDragEventAFeature && (this._isInitialDragEventAFeature = !1)
                    }
                }
                _zoomByDelta(e) {
                    if (void 0 === this._map)
                        throw new Error("Cannot zoom in. The map is destroyed or has not been created");
                    const t = this._map.getView();
                    if (!t)
                        throw new Error("Cannot zoom in. The map's view has not been created");
                    const n = t.getZoom();
                    if (void 0 !== n) {
                        const i = t.getConstrainedZoom(n + e);
                        t.getAnimating() && t.cancelAnimations(),
                        t.animate({
                            zoom: i,
                            duration: 250,
                            easing: Vf.Vv
                        })
                    } else
                        t.setZoom(e)
                }
                _createInteractions() {
                    const e = new Jf.Z
                      , t = new Zf.Z(-.005,.05,100);
                    return e.push(new zf.Z),
                    e.push(new Hf.Z({
                        condition: e => {
                            var t;
                            return [this._lastMouseDownFeature] = null === (t = this._map) || void 0 === t ? void 0 : t.getFeaturesAtPixel(e.pixel, {
                                layerFilter: e => e === this._markerLayer,
                                hitTolerance: 2
                            }),
                            void 0 === this._lastMouseDownFeature
                        }
                        ,
                        kinetic: t
                    })),
                    e.push(new Wf.Z),
                    e.push(new qf.Z),
                    e.push(new Yf.Z),
                    e.push(new Xf.Z),
                    e.push(new Kf.Z),
                    e
                }
            }
            ;
            var Iv, Tv, Ev, _v, xv, Dv;
            wv = Nf = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.fM)(0, (0,
            i.Inject)(g.t4)), (0,
            c.fM)(2, (0,
            i.Inject)(sf)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Ff = void 0 !== g.t4 && g.t4) ? Ff : Object, "function" == typeof (Uf = void 0 !== i.Injector && i.Injector) ? Uf : Object, "function" == typeof ($f = void 0 !== sf && sf) ? $f : Object])], wv);
            let Ov = class {
                constructor(e, t, n, i, a, r, s) {
                    this._stageService = e,
                    this._matrixService = t,
                    this._utilityService = n,
                    this._renewableService = i,
                    this._window = a,
                    this._themeService = r,
                    this._renderer = s,
                    this._draggableCanvasSizeInPixels = {
                        width: 35,
                        height: 35
                    }
                }
                setupMapDragBehavior(e, t) {
                    this.createNewDraggableCanvasOrUsePrevious();
                    const n = f.behavior.drag().on("dragstart", (e => {
                        2 !== f.event.sourceEvent.button && (this._mapService.resetIsInitialDragEventAFeature(),
                        this.onMapDragStart(e))
                    }
                    )).on("drag", (e => this.onMapDrag(e))).on("dragend", (e => this.onMapDragEnd(e)));
                    this._mapService = t,
                    this.mapContent = e,
                    f.select(this.mapContent.nativeElement).on("contextmenu", ( () => {
                        f.event.preventDefault()
                    }
                    )).call(n).data([{}])
                }
                setDatasetAndDrawIconOnCanvas(e, t) {
                    if (this._draggableFeatureCanvasElement && e) {
                        this._renderer.setStyle(this._draggableFeatureCanvasElement, "display", "block"),
                        this._renderer.setStyle(this._draggableFeatureCanvasElement, "opacity", "0.75"),
                        this._renderer.setStyle(this._draggableFeatureCanvasElement, "width", this._draggableCanvasSizeInPixels.width + "px"),
                        this._renderer.setStyle(this._draggableFeatureCanvasElement, "height", this._draggableCanvasSizeInPixels.height + "px"),
                        this._draggableFeatureCanvasElement.dataset.orchidId = t.orchidId,
                        this._draggableFeatureCanvasElement.dataset.cameraId = t.id.toString();
                        const e = this._draggableFeatureCanvasElement.getContext("2d")
                          , n = this._renewableService.findCamera(t.orchidId, t.id)
                          , i = this._mapService.determineCameraType(n);
                        let a = ""
                          , r = "";
                        e && (i.isDewarp ? (a = '23px "Font Awesome Kit"',
                        r = jf.DEWARP) : i.isPTZ && !i.isDewarp ? (a = '23px "Font Awesome Kit"',
                        r = jf.PTZ) : (a = '23px "Font Awesome Kit"',
                        r = jf.CAMERA),
                        e.font = a,
                        e.strokeStyle = "white",
                        e.lineWidth = 2,
                        e.strokeText(r, 4, this._draggableCanvasSizeInPixels.height - 9),
                        e.fillStyle = this._themeService.getPrimaryColorHex(),
                        e.fillText(r, 4, this._draggableCanvasSizeInPixels.height - 9))
                    }
                }
                createNewDraggableCanvasOrUsePrevious() {
                    try {
                        this._draggableFeatureCanvasElement = this._renderer.selectRootElement("#map-floater", !0)
                    } catch (e) {
                        this._draggableFeatureCanvasElement = this._renderer.createElement("canvas"),
                        this._renderer.setAttribute(this._draggableFeatureCanvasElement, "id", "map-floater"),
                        this._renderer.setStyle(this._draggableFeatureCanvasElement, "position", "fixed"),
                        this._renderer.setStyle(this._draggableFeatureCanvasElement, "top", "0px"),
                        this._renderer.setStyle(this._draggableFeatureCanvasElement, "left", "0px"),
                        this._renderer.setProperty(this._draggableFeatureCanvasElement, "width", this._draggableCanvasSizeInPixels.width),
                        this._renderer.setProperty(this._draggableFeatureCanvasElement, "height", this._draggableCanvasSizeInPixels.height),
                        this._renderer.setStyle(this._draggableFeatureCanvasElement, "display", "none"),
                        this._renderer.setStyle(this._draggableFeatureCanvasElement, "z-index", 60),
                        this._renderer.setStyle(this._draggableFeatureCanvasElement, "pointer-events", "none"),
                        this._renderer.appendChild(document.body, this._draggableFeatureCanvasElement)
                    }
                }
                onMapDragStart(e) {
                    if (f.event && f.event.sourceEvent.stopImmediatePropagation(),
                    e.current = e.initial = this.getCursorPositionBasedOnTouchDevice(),
                    e.bagExpansionSize = this.determineIfBagExpandedAndReturnWidth(),
                    this._draggableFeatureCanvasElement) {
                        const t = this._draggableFeatureCanvasElement.getContext("2d");
                        null == t || t.clearRect(0, 0, this._draggableCanvasSizeInPixels.width, this._draggableCanvasSizeInPixels.height);
                        const n = this.mapContent.nativeElement.getBoundingClientRect();
                        e.currentMapBoundary = {
                            bottom: n.bottom,
                            top: n.top,
                            left: n.left,
                            right: n.right
                        },
                        e.offsetX = -1 * this._draggableFeatureCanvasElement.width / 2,
                        e.offsetY = -1 * this._draggableFeatureCanvasElement.height / 2
                    }
                }
                onMapDrag(e) {
                    this._mapService.dragPanDisabled && (e.dragged = !0,
                    e.current = this.getCursorPositionBasedOnTouchDevice(),
                    this._draggableFeatureCanvasElement && (this._renderer.setStyle(this._draggableFeatureCanvasElement, "left", e.current.pageX + e.offsetX + "px"),
                    this._renderer.setStyle(this._draggableFeatureCanvasElement, "top", e.current.pageY + e.offsetY + "px"),
                    this._renderer.setStyle(this._draggableFeatureCanvasElement, "display", "block"),
                    this._renderer.setStyle(this._draggableFeatureCanvasElement, "opacity", ".75"),
                    this._renderer.setStyle(this._draggableFeatureCanvasElement, "pointer-events", "")),
                    e.current.pageX > e.bagExpansionSize && this.determineIfElementIsOutsideCurrentMap(e.current, e.currentMapBoundary) && this._mapService.getIsInitialDragEventAFeature() ? this._matrixService.dragOver(e.current.pageX, e.current.pageY) : this._matrixService.dragClear())
                }
                onMapDragEnd(e) {
                    if (this._draggableFeatureCanvasElement && this._mapService.getIsInitialDragEventAFeature())
                        if (e.dragged && (e.current.pageX < e.bagExpansionSize || !this.determineIfElementIsOutsideCurrentMap(e.current, e.currentMapBoundary)))
                            this.sendDragFloater(this._draggableFeatureCanvasElement, e.initial.pageX + e.offsetX, e.initial.pageY + e.offsetY);
                        else if (e.dragged) {
                            let t;
                            this._draggableFeatureCanvasElement.dataset.cameraId && (t = parseInt(this._draggableFeatureCanvasElement.dataset.cameraId));
                            const n = this._draggableFeatureCanvasElement.dataset.orchidId;
                            this._matrixService.claimCellByCoordinates(e.current.pageX, e.current.pageY, (i => (0,
                            c.mG)(this, void 0, void 0, (function*() {
                                if (!1 === i && this._draggableFeatureCanvasElement)
                                    this.sendDragFloater(this._draggableFeatureCanvasElement, e.initial.pageX + e.offsetX, e.initial.pageY + e.offsetY);
                                else {
                                    if (this.animateDraggableCanvasScaleWhenDropped(i),
                                    i.element.node().firstElementChild) {
                                        const e = i.element.node().firstElementChild.getAttribute("id");
                                        this._stageService.removeCellById(e, !0)
                                    }
                                    setTimeout(( () => {
                                        void 0 !== t && void 0 !== n && this._stageService.addPlayer(this._renewableService.findOrchid(n), this._renewableService.findCamera(n, t), i)
                                    }
                                    ), 333)
                                }
                            }
                            )))),
                            Object.keys(this._draggableFeatureCanvasElement.dataset).forEach((e => {
                                var t;
                                null === (t = this._draggableFeatureCanvasElement) || void 0 === t || delete t.dataset[e]
                            }
                            ))
                        }
                    this._renderer.setStyle(this._draggableFeatureCanvasElement, "pointer-events", "none"),
                    this._matrixService.drop(),
                    this._resetD3Obj(e),
                    this._mapService.resetIsInitialDragEventAFeature()
                }
                sendDragFloater(e, t, n) {
                    f.select(e).style("opacity", .75).transition().duration(333).style("opacity", 0).style("left", t + "px").style("top", n + "px").each("end", ( () => {
                        this._hideDraggableCanvas()
                    }
                    ))
                }
                _resetD3Obj(e) {
                    e.dragged = !1,
                    e.bagExpansionSize = 0,
                    e.currentMapBoundary = {
                        bottom: 0,
                        top: 0,
                        left: 0,
                        right: 0
                    },
                    e.offsetX = 0,
                    e.offsetY = 0,
                    e.current.pageX = 0,
                    e.current.pageY = 0,
                    e.initial.pageX = 0,
                    e.initial.pageY = 0
                }
                _hideDraggableCanvas() {
                    this._renderer.setStyle(this._draggableFeatureCanvasElement, "top", "0px"),
                    this._renderer.setStyle(this._draggableFeatureCanvasElement, "left", "0px"),
                    this._renderer.setStyle(this._draggableFeatureCanvasElement, "display", "none")
                }
                getCursorPositionBasedOnTouchDevice() {
                    return this._window.TouchEvent && f.event.sourceEvent instanceof this._window.TouchEvent ? {
                        pageX: f.event.sourceEvent.touches[0].pageX,
                        pageY: f.event.sourceEvent.touches[0].pageY
                    } : {
                        pageX: f.event.sourceEvent.pageX,
                        pageY: f.event.sourceEvent.pageY
                    }
                }
                determineIfBagExpandedAndReturnWidth() {
                    try {
                        const e = this._renderer.selectRootElement("bag", !0);
                        return e.className.includes("expanded") ? e.offsetWidth : 0
                    } catch (e) {
                        return 0
                    }
                }
                determineIfElementIsOutsideCurrentMap(e, t) {
                    return e.pageX < t.left || e.pageX > t.right || e.pageY > t.bottom || e.pageY < t.top
                }
                animateDraggableCanvasScaleWhenDropped(e) {
                    const t = this._matrixService.getElement()
                      , n = e.top + t.offsetTop + e.height / 2
                      , i = e.left + t.offsetLeft + e.width / 2;
                    f.select(this._draggableFeatureCanvasElement).style("opacity", .8).transition().duration(333).style("opacity", 0).style("top", n + "px").style("left", i + "px").style("width", "0px").style("height", "0px").each("end", ( () => {
                        this._hideDraggableCanvas()
                    }
                    ))
                }
            }
            ;
            Ov = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.fM)(0, (0,
            i.Inject)(cn)), (0,
            c.fM)(1, (0,
            i.Inject)(en)), (0,
            c.fM)(2, (0,
            i.Inject)(st)), (0,
            c.fM)(3, (0,
            i.Inject)(Gt)), (0,
            c.fM)(4, (0,
            i.Inject)(Window)), (0,
            c.fM)(5, (0,
            i.Inject)(sf)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Iv = cn) ? Iv : Object, "function" == typeof (Tv = en) ? Tv : Object, "function" == typeof (Ev = st) ? Ev : Object, "function" == typeof (_v = Gt) ? _v : Object, Object, "function" == typeof (xv = void 0 !== sf && sf) ? xv : Object, "function" == typeof (Dv = void 0 !== i.Renderer2 && i.Renderer2) ? Dv : Object])], Ov);
            let Av = class {
                constructor() {
                    this.msgs = L.messages.maps,
                    this.error = null,
                    this.mappedCameras$ = new St.x,
                    this.showUserRetry = !1,
                    this._retryCount = 0
                }
                handleError(e) {
                    var t;
                    if (this.error = e,
                    this._retryCount < 3) {
                        const e = (0,
                        Kl.H)(5e3);
                        null === (t = this._retrySubscription) || void 0 === t || t.unsubscribe(),
                        this._retrySubscription = e.subscribe(( () => this.retry()))
                    } else
                        this.showUserRetry = !0
                }
                ngAfterViewInit() {
                    this.cameraGroup.cameras.filter((e => null !== e.mapPosition)).forEach((e => {
                        this.mappedCameras$.next(e)
                    }
                    ))
                }
                ngOnDestroy() {
                    var e;
                    null === (e = this._retrySubscription) || void 0 === e || e.unsubscribe()
                }
                retry() {
                    this._retryCount++,
                    this.error = null,
                    this.cameraGroup.mapConfiguration = Object.assign({}, this.cameraGroup.mapConfiguration),
                    setTimeout(( () => {
                        var e;
                        null === (e = this.cameraGroup) || void 0 === e || e.cameras.filter((e => null !== e.mapPosition)).forEach((e => {
                            this.mappedCameras$.next(e)
                        }
                        ))
                    }
                    ))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Av.prototype, "cameraGroup", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Av.prototype, "id", void 0),
            Av = (0,
            c.gn)([(0,
            i.Component)({
                selector: "map-cell",
                template: n(21481),
                providers: [Ov]
            })], Av);
            var Rv, Pv, kv, Mv, Lv, Nv, Fv, Uv, $v, jv, Vv, Gv, Bv, zv, Hv, Wv = n(36501);
            class qv {
                static create(e) {
                    return window.ResizeObserver ? new window.ResizeObserver(e) : new Wv.d(e)
                }
                static createAsObservable(e, t) {
                    return new Ln.y((n => {
                        const i = qv.create((e => {
                            n.next(e)
                        }
                        ));
                        return i.observe(e, t),
                        () => {
                            i.unobserve(e),
                            i.disconnect()
                        }
                    }
                    ))
                }
            }
            const Yv = O("map.component");
            let Xv = class {
                constructor(e, t, n, a, r, s, o, c) {
                    this._stageMapDragService = e,
                    this._mapService = t,
                    this._stageService = n,
                    this._matrixService = a,
                    this._renewableService = r,
                    this._browserInfoService = s,
                    this._fusionDataService = o,
                    this._snackBar = c,
                    this.msgs = L.messages.maps,
                    this.editMode = !1,
                    this.mapConfiguration = null,
                    this.cameras = new St.x,
                    this.loading = !0,
                    this.singleClick = new i.EventEmitter,
                    this.selectFeature = new i.EventEmitter,
                    this.onError = new i.EventEmitter,
                    this.mapCameraOverlayPortal = null,
                    this._cameraLinkOverlayPadding = {
                        width: 25,
                        height: 25
                    },
                    this._cameraLinkOverlaySize = {
                        width: 250,
                        height: 215
                    },
                    this._currentMapCellSize = {
                        width: 0,
                        height: 0
                    },
                    this._cameraLinkOverlayOpenState = !1,
                    this._destroyed = !1
                }
                ngOnChanges(e) {
                    var t;
                    e.mapConfiguration && e.mapConfiguration.currentValue && !1 === e.mapConfiguration.firstChange && (this.loading = !0,
                    this._renderMap()),
                    e.cameras && e.cameras.currentValue && (null === (t = this._cameraObserverSubscription) || void 0 === t || t.unsubscribe(),
                    this._cameraObserverSubscription = e.cameras.currentValue.subscribe((e => {
                        var t;
                        if (Ke(e.event)) {
                            const {width: n, height: i} = null === (t = this.mapConfiguration) || void 0 === t ? void 0 : t.configuration
                              , a = Sv(this._getMapCoordinatesFromEvent(e.event), [n, i]);
                            e.mapPosition.x = a[0],
                            e.mapPosition.y = a[1]
                        }
                        e.mapPosition ? (this._addCameraToMap(e),
                        this._mapService.selectFeature(e)) : this._mapService.removeMarker(e)
                    }
                    )))
                }
                get onMobileAndIsCellMode() {
                    return (this._browserInfoService.isMobile || this._browserInfoService.isTablet) && this.isCellMode
                }
                get isCellMode() {
                    return "cell" === this.mode
                }
                ngAfterViewInit() {
                    this.isCellMode && this._stageMapDragService.setupMapDragBehavior(this.mapContent, this._mapService),
                    this._resizeObserverSubscription = qv.createAsObservable(this.mapContent.nativeElement).subscribe((e => {
                        var t;
                        const n = null === (t = e[0].target.parentElement) || void 0 === t ? void 0 : t.parentElement;
                        n && (this._currentMapCellSize.height = n.offsetHeight,
                        this._currentMapCellSize.width = n.offsetWidth),
                        this._cameraLinkOverlayOpenState && !this._canDisplayOverlay && (this._mapService.closeOverlay(),
                        this._cameraLinkOverlayOpenState = !1),
                        this._mapService.updateMapSize()
                    }
                    )),
                    this._mapEventsSubscription = this._mapService.events$.subscribe({
                        next: e => this._handleEvent(e)
                    }),
                    this._mapClickEventsSubscription = this._mapService.clickEvent$.subscribe({
                        next: e => this._handleClick(e)
                    }),
                    this._renderMap()
                }
                _getMapCoordinatesFromEvent(e) {
                    return this._mapService.getMapCoordinatesFromEvent(e)
                }
                ngOnDestroy() {
                    var e, t, n, i;
                    this._destroyed = !0,
                    null === (e = this._cameraObserverSubscription) || void 0 === e || e.unsubscribe(),
                    null === (t = this._mapEventsSubscription) || void 0 === t || t.unsubscribe(),
                    null === (n = this._mapClickEventsSubscription) || void 0 === n || n.unsubscribe(),
                    null === (i = this._resizeObserverSubscription) || void 0 === i || i.unsubscribe(),
                    this._mapService.destroy()
                }
                getMapCenter() {
                    return this._mapService.getMapCenter()
                }
                showCameraLinkOverlay(e) {
                    const {id: t, orchidId: n} = e.feature
                      , i = this._renewableService.findCamera(n, t);
                    if (!i)
                        return void Yv.warn(`Cannot show camera link overlay for orchid[id=${n}] camera[id=${t}]. The camera was not found`);
                    const a = this._renewableService.findOrchid(n);
                    if (!a)
                        return void Yv.warn(`Cannot show camera link overlay for orchid[id=${n}] camera[id=${t}]. The orchid was not found`);
                    const {events$: r, portal: s} = this._mapService.showCameraLinkOverlay({
                        orchid: a,
                        camera: i,
                        onStage: this.isCellMode,
                        overlayElement: this.cameraMapOverlay.nativeElement
                    });
                    this.mapCameraOverlayPortal = s,
                    this._mapService.showOverlay(e.coordinates),
                    this._cameraLinkOverlayOpenState = !0;
                    const o = r.subscribe((t => {
                        var n;
                        "add-to-stage" === t.kind ? this._dblClickCameraLink(e.feature) : (o.unsubscribe(),
                        this._mapService.hideOverlay(),
                        null === (n = this.mapCameraOverlayPortal) || void 0 === n || n.detach(),
                        this.mapCameraOverlayPortal = null,
                        this._cameraLinkOverlayOpenState = !1)
                    }
                    ))
                }
                zoomIn() {
                    this._mapService.zoomIn()
                }
                zoomOut() {
                    this._mapService.zoomOut()
                }
                _addCameraToMap(e) {
                    const t = this._renewableService.findCamera(e.orchidId, e.id);
                    t && this._mapService.addCameraLinkMarker(t, e, {
                        label: t.name,
                        transformMapPosition: !0
                    })
                }
                _dblClickCameraLink(e) {
                    this.isCellMode && this._matrixService.obtainContainer((t => {
                        this._stageService.addPlayer(this._renewableService.findOrchid(e.orchidId), this._renewableService.findCamera(e.orchidId, e.id), t)
                    }
                    ))
                }
                _handleEvent(e) {
                    switch (e.kind) {
                    case Mf.MapClicked:
                        this._mapService.closeOverlay();
                        break;
                    case Mf.FeatureSelected:
                        this.selectFeature.emit(e.feature);
                        break;
                    case Mf.ImageLoadError:
                    case Mf.MapError:
                        Yv.error(e),
                        this.onError.emit(this.msgs.theMapCouldNotBeLoaded()),
                        this.loading = !1
                    }
                }
                _handleClick(e) {
                    const t = "camera" === e.featureKind;
                    switch (e.kind) {
                    case Lf.SingleClick:
                        t && !this.editMode ? this._canDisplayOverlay ? this.showCameraLinkOverlay(e) : this._snackBar.open(this.msgs.theCameraDetailsCannotBeShownInACellThisSize(), this.msgs.dismiss(), {
                            duration: 3e3,
                            horizontalPosition: "right",
                            verticalPosition: "bottom"
                        }) : this.singleClick.emit(e);
                        break;
                    case Lf.DoubleClick:
                        this._addFeatureToStage(e, t);
                        break;
                    case Lf.PointerDrag:
                        this.isCellMode && this._stageMapDragService.setDatasetAndDrawIconOnCanvas(t, e.feature);
                        break;
                    default:
                        throw new Error(`An unhandled click event '${e.kind}' was received`)
                    }
                }
                _addFeatureToStage(e, t) {
                    t && this._dblClickCameraLink(e.feature)
                }
                _renderMap() {
                    if (void 0 === this.mapConfiguration || null === this.mapConfiguration)
                        return Yv.error("Cannot render a non-existent map"),
                        void (this.loading = !1);
                    const e = this.mapConfiguration.configuration
                      , {width: t, height: n} = e;
                    let i = e.mapImage;
                    !1 === this.isCellMode && (i += "?" + (new Date).getTime()),
                    i = this._fusionDataService.authorizeUrl(i);
                    const a = Math.max(100, .1 * n)
                      , r = Math.max(100, .1 * t);
                    this.mapTarget.nativeElement.style.opacity = "0",
                    this._mapService.link({
                        mapLayerKind: "image",
                        mapLayerSource: {
                            kind: "static-image",
                            url: i,
                            imageExtent: [0, 0, t, n],
                            imageSize: [t, n]
                        },
                        target: this.mapTarget.nativeElement,
                        projection: {
                            code: "ipconfigure-maps",
                            units: "pixels",
                            extent: [0, 0, t, n]
                        },
                        view: {
                            enableRotation: !1,
                            showFullExtent: !0,
                            smoothExtentConstraint: !0,
                            minZoom: 0,
                            zoom: 0,
                            maxZoom: 5,
                            extent: [-r, -a, t + r, n + a]
                        }
                    }).catch((e => {
                        Yv.error(e)
                    }
                    )).then(( () => {
                        this.editMode && this._mapService.enableEditing()
                    }
                    )).finally(( () => {
                        setTimeout(( () => {
                            this._destroyed || (this._mapService.zoomIn(),
                            setTimeout(( () => {
                                this._destroyed || this._mapService.zoomOut()
                            }
                            ), 300),
                            setTimeout(( () => {
                                this._destroyed || (this.loading = !1,
                                this.mapTarget.nativeElement.style.transition = "opacity 250ms",
                                this.mapTarget.nativeElement.style.opacity = "1")
                            }
                            ), 600))
                        }
                        ), 300)
                    }
                    ))
                }
                get _canDisplayOverlay() {
                    function e(e, t, n) {
                        return e > t + n
                    }
                    const t = this._currentMapCellSize
                      , n = this._cameraLinkOverlaySize
                      , i = this._cameraLinkOverlayPadding;
                    return [e(t.height, n.height, i.height), e(t.width, n.width, i.width)].every((e => e))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.ViewChild)("mapcontent"), (0,
            c.w6)("design:type", "function" == typeof (Rv = void 0 !== i.ElementRef && i.ElementRef) ? Rv : Object)], Xv.prototype, "mapContent", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("maptarget"), (0,
            c.w6)("design:type", "function" == typeof (Pv = void 0 !== i.ElementRef && i.ElementRef) ? Pv : Object)], Xv.prototype, "mapTarget", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("cameraMapOverlay"), (0,
            c.w6)("design:type", "function" == typeof (kv = void 0 !== i.ElementRef && i.ElementRef) ? kv : Object)], Xv.prototype, "cameraMapOverlay", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], Xv.prototype, "mode", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Xv.prototype, "editMode", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Xv.prototype, "mapConfiguration", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Mv = void 0 !== St.x && St.x) ? Mv : Object)], Xv.prototype, "cameras", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (Lv = void 0 !== i.EventEmitter && i.EventEmitter) ? Lv : Object)], Xv.prototype, "singleClick", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (Nv = void 0 !== i.EventEmitter && i.EventEmitter) ? Nv : Object)], Xv.prototype, "selectFeature", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (Fv = void 0 !== i.EventEmitter && i.EventEmitter) ? Fv : Object)], Xv.prototype, "onError", void 0),
            Xv = (0,
            c.gn)([(0,
            i.Component)({
                selector: "map",
                template: n(42831),
                providers: [wv.forComponent()]
            }), (0,
            c.fM)(0, (0,
            i.Optional)()), (0,
            c.fM)(0, (0,
            i.Inject)(Ov)), (0,
            c.fM)(1, (0,
            i.Inject)(wv)), (0,
            c.fM)(2, (0,
            i.Inject)(cn)), (0,
            c.fM)(3, (0,
            i.Inject)(en)), (0,
            c.fM)(4, (0,
            i.Inject)(Gt)), (0,
            c.fM)(5, (0,
            i.Inject)(rt)), (0,
            c.fM)(6, (0,
            i.Inject)(Qe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Uv = void 0 !== Ov && Ov) ? Uv : Object, "function" == typeof ($v = void 0 !== wv && wv) ? $v : Object, "function" == typeof (jv = cn) ? jv : Object, "function" == typeof (Vv = en) ? Vv : Object, "function" == typeof (Gv = Gt) ? Gv : Object, "function" == typeof (Bv = rt) ? Bv : Object, "function" == typeof (zv = Qe) ? zv : Object, "function" == typeof (Hv = void 0 !== wi.ux && wi.ux) ? Hv : Object])], Xv);
            var Kv, Zv, Jv = n(23071), Qv = n(65583), ey = n(73424);
            const ty = O("notifications.service");
            var ny, iy, ay;
            !function(e) {
                e.Added = "NOTIFICATION_ADDED",
                e.Removed = "NOTIFICATION_REMOVED",
                e.Modified = "NOTIFICATION_MODIFIED"
            }(ny || (ny = {})),
            function(e) {
                e.Added = "SMTP_SERVER_ADDED",
                e.Removed = "SMTP_SERVER_REMOVED",
                e.Modified = "SMTP_SERVER_MODIFIED"
            }(iy || (iy = {})),
            function(e) {
                e.Added = "SCHEDULE_ADDED",
                e.Removed = "SCHEDULE_REMOVED",
                e.Modified = "SCHEDULE_MODIFIED"
            }(ay || (ay = {}));
            let ry = class {
                constructor(e, t) {
                    this._fusionDataService = e,
                    this._renewableService = t,
                    this._smtpServersSubject = new P.X(null),
                    this._notificationFetch$ = new St.x,
                    this._notificationError$ = new St.x,
                    this._notificationEvent$ = this._renewableService.messages$.pipe((0,
                    He.U)((e => this._handleNotificationEvent(e))), (0,
                    ra.h)((e => null !== e)), (0,
                    Qv.B)()),
                    this._schedulesSubject = new P.X(null)
                }
                getNotifications({reload: e=!1}={}) {
                    const t = (0,
                    Jv.T)((0,
                    Be.P)(( () => (0,
                    ze.of)(this._notificationData))), this._notificationFetch$, this._notificationEvent$, this._notificationError$.pipe((0,
                    Ks.w)((e => (0,
                    cr._)(e))))).pipe((0,
                    He.U)((e => [...e])));
                    return void 0 === this._notificationData || e ? this.reloadNotifications().pipe((0,
                    Ks.w)(( () => t))) : t
                }
                reloadNotifications() {
                    return void 0 === this._notificationPending$ && (this._notificationPending$ = this._fusionDataService.fetchNotifications$().pipe((0,
                    sa.b)((e => {
                        this._notificationData = e,
                        this._notificationFetch$.next(this._notificationData),
                        delete this._notificationPending$
                    }
                    )), (0,
                    He.U)((e => [...e])), (0,
                    lr.K)((e => {
                        throw this._notificationError$.next(e),
                        delete this._notificationPending$,
                        e
                    }
                    )))),
                    this._notificationPending$
                }
                _handleNotificationEvent(e) {
                    if (void 0 === this._notificationData)
                        throw Error();
                    const t = [ny.Added, ny.Modified, ny.Removed]
                      , n = ["ORCHID_REMOVED", "CAMERA_REMOVED", iy.Removed, ay.Removed];
                    if (t.includes(e.eventType)) {
                        const t = e.notification;
                        switch (e.eventType) {
                        case ny.Added:
                            this._notificationData.push(t);
                            break;
                        case ny.Modified:
                            {
                                const e = this._notificationData.findIndex((e => e.id === t.id));
                                e > -1 ? this._notificationData[e] = t : (ty.warn(`The Notification id:${t.id} does not exist.`),
                                this._notificationData.push(t));
                                break
                            }
                        case ny.Removed:
                            {
                                const e = this._notificationData.findIndex((e => e.id === t.id));
                                e > -1 && this._notificationData.splice(e, 1);
                                break
                            }
                        }
                    } else {
                        if (!n.includes(e.eventType))
                            return null;
                        switch (e.eventType) {
                        case "ORCHID_REMOVED":
                            {
                                const t = e.orchidResponse;
                                this._notificationData = this._notificationData.filter((e => {
                                    var n;
                                    return (null === (n = e.conditions[0]) || void 0 === n ? void 0 : n.orchidId) !== t.id
                                }
                                )),
                                this._notificationData.forEach((e => e.conditions.forEach((e => {
                                    e.type !== W.DEVICE_STATE_CONDITION && e.type !== W.IO_ERROR_CONDITION && e.type !== W.SERVER_ERROR_CONDITION && e.type !== W.CAMERA_STATE_CONDITION || (e.exclude.orchids = e.exclude.orchids.filter((e => e !== t.id)),
                                    e.include.orchids = e.include.orchids.filter((e => e !== t.id)))
                                }
                                ))));
                                break
                            }
                        case "CAMERA_REMOVED":
                            {
                                const t = e.cameraResponse
                                  , n = parseInt(t.id);
                                this._notificationData.filter((e => 1 === e.conditions.length && e.conditions[0].type === W.MOTION_ALERT_CONDITION && e.conditions[0].orchidId === t.orchidId)).forEach((e => e.conditions[0].cameraIds = e.conditions[0].cameraIds.filter((e => parseInt(e) !== parseInt(t.id))))),
                                this._notificationData.forEach((e => e.conditions.forEach((e => {
                                    e.type === W.CAMERA_STATE_CONDITION && (e.exclude.cameras = e.exclude.cameras.filter((e => e.orchidId !== t.orchidId || e.id !== n)),
                                    e.include.cameras = e.include.cameras.filter((e => e.orchidId !== t.orchidId || e.id !== n)))
                                }
                                ))));
                                break
                            }
                        case ay.Removed:
                            {
                                const t = e.scheduleResponse;
                                this._notificationData.forEach((e => {
                                    e.conditions.filter((e => e.type === W.MOTION_ALERT_CONDITION)).map((e => e)).filter((e => e.scheduleId === t.id)).forEach((e => e.scheduleId = null))
                                }
                                ));
                                break
                            }
                        case iy.Removed:
                            {
                                const t = e.smtpServer;
                                this._notificationData.forEach((e => {
                                    e.actions.filter((e => e.type === H.MOTION_ALERT_EMAIL_ACTION)).map((e => e)).filter((e => e.smtpServerId === t.id)).forEach((e => e.smtpServerId = null))
                                }
                                )),
                                this._notificationData.forEach((e => {
                                    e.actions.filter((e => e.type === H.EMAIL_ACTION || e.type === H.EMAIL_DIGEST_ACTION)).filter((e => e.smtpServerId === t.id)).forEach((e => e.smtpServerId = null))
                                }
                                ))
                            }
                        }
                    }
                    return this._notificationData
                }
                getNotification(e) {
                    return this._fusionDataService.fetchNotification$(e)
                }
                addNotification(e) {
                    return this._fusionDataService.newNotification$(e)
                }
                updateNotification(e) {
                    return this._fusionDataService.updateNotification$(e)
                }
                deleteNotification(e) {
                    return this._fusionDataService.deleteNotification$(e)
                }
                getSmtpServers() {
                    if (this._smtpServers$)
                        return this._smtpServers$;
                    this._smtpServers$ = this._smtpServersSubject.pipe((0,
                    ra.h)((e => null !== e)));
                    const e = new St.x;
                    return this._fusionDataService.fetchSmtpServers$().pipe((0,
                    sa.b)(( () => e.next()))).subscribe({
                        next: e => this._smtpServersSubject.next(e),
                        error: e => {
                            this._smtpServersSubject.error(e),
                            this._smtpServersSubject = new P.X(null),
                            this._smtpServers$ = void 0
                        }
                    }),
                    this._renewableService.messages$.pipe((0,
                    ey.u)(e), (0,
                    ra.h)(this._isSmtpServerEvent), (0,
                    He.U)((e => this._handleSmtpServerEvent(e)))).subscribe(this._smtpServersSubject),
                    this._smtpServers$
                }
                _isSmtpServerEvent(e) {
                    return ["SMTP_SERVER_ADDED", "SMTP_SERVER_MODIFIED", "SMTP_SERVER_REMOVED"].includes(e.eventType)
                }
                _handleSmtpServerEvent(e) {
                    const t = [...this._smtpServersSubject.value];
                    switch (e.eventType) {
                    case iy.Added:
                        t.push(e.smtpServer);
                        break;
                    case iy.Modified:
                        {
                            const n = t.findIndex((t => t.id === e.smtpServer.id));
                            n > -1 ? t[n] = e.smtpServer : (ty.warn(`The SmtpServer id:${e.smtpServer.id} does not exist.`),
                            t.push(e.smtpServer));
                            break
                        }
                    case iy.Removed:
                        {
                            const n = t.findIndex((t => t.id === e.smtpServer.id));
                            n > -1 && t.splice(n, 1);
                            break
                        }
                    }
                    return t
                }
                getSmtpServer(e) {
                    return this._fusionDataService.fetchSmtpServer$(e)
                }
                addSmtpServer(e) {
                    return this._fusionDataService.newSmtpServer$(e)
                }
                updateSmtpServer(e) {
                    return this._fusionDataService.updateSmtpServer$(e)
                }
                deleteSmtpServer(e) {
                    return this._fusionDataService.deleteSmtpServer$(e)
                }
                getSchedules() {
                    if (this._schedules$)
                        return this._schedules$;
                    this._schedules$ = this._schedulesSubject.pipe((0,
                    ra.h)((e => null !== e)));
                    const e = new St.x;
                    return this._fusionDataService.fetchSchedules$().pipe((0,
                    sa.b)(( () => e.next()))).subscribe({
                        next: e => this._schedulesSubject.next(e),
                        error: e => {
                            const t = e.data;
                            this._schedulesSubject.error(t),
                            this._schedulesSubject = new P.X(null),
                            this._schedules$ = void 0
                        }
                    }),
                    this._renewableService.messages$.pipe((0,
                    ey.u)(e), (0,
                    ra.h)(this._isScheduleEvent), (0,
                    He.U)((e => this._handleScheduleEvent(e)))).subscribe(this._schedulesSubject),
                    this._schedules$
                }
                _isScheduleEvent(e) {
                    return ["SCHEDULE_ADDED", "SCHEDULE_MODIFIED", "SCHEDULE_REMOVED"].includes(e.eventType)
                }
                _handleScheduleEvent(e) {
                    const t = [...this._schedulesSubject.value];
                    switch (e.eventType) {
                    case ay.Added:
                        t.push(e.scheduleResponse);
                        break;
                    case ay.Modified:
                        {
                            const n = t.findIndex((t => t.id === e.scheduleResponse.id));
                            n > -1 ? t[n] = e.scheduleResponse : (ty.warn(`The Schedule id:${e.scheduleResponse.id} does not exist.`),
                            t.push(e.scheduleResponse));
                            break
                        }
                    case ay.Removed:
                        {
                            const n = t.findIndex((t => t.id === e.scheduleResponse.id));
                            n > -1 && t.splice(n, 1);
                            break
                        }
                    }
                    return t
                }
                getSchedule(e) {
                    return this._fusionDataService.fetchSchedule$(e)
                }
                addSchedule(e) {
                    return this._fusionDataService.newSchedule$(e)
                }
                updateSchedule(e) {
                    return this._fusionDataService.updateSchedule$(e)
                }
                deleteSchedule(e) {
                    return this._fusionDataService.deleteSchedule$(e)
                }
            }
            ;
            var sy, oy, cy, ly, dy;
            ry = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Kv = Qe) ? Kv : Object, "function" == typeof (Zv = Gt) ? Zv : Object])], ry);
            const uy = O("MotionAlertDialog");
            var my;
            !function(e) {
                e.NoCamerasSelected = "no-cameras-selected",
                e.NoDecimals = "no-decimals-allowed",
                e.MinValueExceeded = "min",
                e.MaxValueExceeded = "max"
            }(my || (my = {}));
            let hy = sy = class {
                constructor(e, t, n, i, a) {
                    this.optionsData = e,
                    this.matDialogRef = t,
                    this._NotificationsService = n,
                    this._FusionConfigService = i,
                    this.cd = a,
                    this.msgs = Object.assign(Object.assign({}, L.messages.notifications), {
                        timeUnitsPlural: L.messages.timeUnitsPlural,
                        cancel: L.messages.library.cancel,
                        enabled: L.messages.motionAlertsList.enabled
                    }),
                    this.dialogTitle = "",
                    this.allSchedules = [],
                    this.showSaveDialogButton = !0,
                    this.maxExportDurationLimit = 0,
                    this.isNotificationEnabled = !0,
                    this._defaultMaxExportDurationSec = 30
                }
                get currentAdvancedSettings() {
                    return this.motionAlertForm.controls.advancedSettings.value
                }
                get currentSelectedCameras() {
                    return this.motionAlertForm.controls.cameraSelection.value
                }
                get cameraSelectionForm() {
                    return this.motionAlertForm.controls.cameraSelection
                }
                get currentRecipients() {
                    return this.motionAlertForm.controls.recipients.value
                }
                get currentSchedule() {
                    return this.motionAlertForm.controls.schedule.value
                }
                get recipientsForm() {
                    return this.motionAlertForm.controls.recipients
                }
                get advancedSettingForm() {
                    return this.motionAlertForm.controls.advancedSettings
                }
                get MotionAlertDialogErrors() {
                    return my
                }
                get advancedSettingsNegativeNumError() {
                    return this.advancedSettingForm.controls.throttlePerCameraSec.hasError(my.MinValueExceeded) || this.advancedSettingForm.controls.maxExportDurationSec.hasError(my.MinValueExceeded) || this.advancedSettingForm.controls.minEventDurationSec.hasError(my.MinValueExceeded)
                }
                get alertConfigDecimalsError() {
                    return this.advancedSettingForm.controls.throttlePerCameraSec.hasError(my.NoDecimals) || this.advancedSettingForm.controls.maxExportDurationSec.hasError(my.NoDecimals) || this.advancedSettingForm.controls.minEventDurationSec.hasError(my.NoDecimals)
                }
                get cameraSelectionError() {
                    return this.cameraSelectionForm.hasError(my.NoCamerasSelected)
                }
                get scheduleSelectionError() {
                    return this.motionAlertForm.controls.schedule.touched && null === this.motionAlertForm.controls.schedule.value
                }
                static show(e, t) {
                    return e.open(sy, {
                        disableClose: !0,
                        panelClass: "motion-alert-notification-panel",
                        data: t
                    }).afterClosed().pipe((0,
                    pn.q)(1), (0,
                    He.U)((e => e)))
                }
                ngOnInit() {
                    this.orchid = this.optionsData.orchid,
                    this.allUsers = this.optionsData.allUsers,
                    this.allGroups = this.optionsData.allGroups,
                    this._motionNotification = this.optionsData.motionNotification,
                    this._motionNotification && (this.isNotificationEnabled = this._motionNotification.isEnabled),
                    this.dialogTitle = this.optionsData.motionNotification ? `${this.msgs.editMotionAlertFor()} ${this.orchid.name}` : `${this.msgs.addMotionAlertFor()} ${this.orchid.name}`,
                    this.schedulesSubscription = this._NotificationsService.getSchedules().subscribe((e => {
                        if (this.allSchedules = [...e],
                        this.allSchedules.sort(( (e, t) => {
                            const n = e.name.toLowerCase()
                              , i = t.name.toLowerCase();
                            return n < i ? -1 : n > i ? 1 : 0
                        }
                        )),
                        this.motionAlertForm) {
                            const e = this.allSchedules.find((e => {
                                var t;
                                return e.id === (null === (t = this.currentSchedule) || void 0 === t ? void 0 : t.id)
                            }
                            ));
                            e || this.motionAlertForm.controls.schedule.setValue(null)
                        }
                    }
                    )),
                    this.smtpServerSubscription = this._NotificationsService.getSmtpServers().subscribe((e => {
                        if (this.allSmtpServers = [...e],
                        this.allSmtpServers.sort(( (e, t) => {
                            const n = e.name.toLowerCase()
                              , i = t.name.toLowerCase();
                            return n < i ? -1 : n > i ? 1 : 0
                        }
                        )),
                        this.motionAlertForm) {
                            const e = this.allSmtpServers.find((e => {
                                var t;
                                return e.id === (null === (t = this.currentRecipients.smtpServer) || void 0 === t ? void 0 : t.id)
                            }
                            ));
                            e || this.recipientsForm.controls.smtpServer.setValue(null)
                        }
                    }
                    )),
                    this.motionAlertForm = this._initAndGetFormGroup()
                }
                ngAfterViewInit() {
                    this.cd.detectChanges()
                }
                ngOnDestroy() {
                    this.schedulesSubscription.unsubscribe(),
                    this.smtpServerSubscription.unsubscribe()
                }
                _getCameraDTOsFromIds(e) {
                    return this.orchid.cameras.filter((t => e.includes(t.id)))
                }
                _initAndGetFormGroup() {
                    let e, t, n, i = null, a = null;
                    const r = this._FusionConfigService.getConfigPostAuth();
                    if (this.maxExportDurationLimit = isNaN(r.motionAlertMaxExportSeconds) ? this._defaultMaxExportDurationSec : r.motionAlertMaxExportSeconds,
                    null === this._motionNotification) {
                        t = [],
                        e = {
                            users: [],
                            groups: [],
                            emailAddresses: [],
                            smtpServer: a,
                            smtpFromAddress: ""
                        };
                        n = {
                            minEventDurationSec: 1,
                            throttlePerCameraSec: 5,
                            maxExportDurationSec: this.maxExportDurationLimit < this._defaultMaxExportDurationSec ? this.maxExportDurationLimit : this._defaultMaxExportDurationSec
                        }
                    } else {
                        const r = this._motionNotification.actions[0];
                        null !== r.smtpServerId && (a = this.allSmtpServers.find((e => r.smtpServerId === e.id)) || null),
                        e = {
                            users: r.users,
                            groups: r.groups,
                            emailAddresses: r.configuration.recipients,
                            smtpServer: a,
                            smtpFromAddress: r.configuration.from
                        };
                        const s = this._motionNotification.conditions[0];
                        void 0 !== s.scheduleId && (i = this.allSchedules.find((e => s.scheduleId === e.id)) || null),
                        t = s.cameraIds,
                        n = {
                            throttlePerCameraSec: s.configuration.throttlePerCameraSec,
                            maxExportDurationSec: s.configuration.maxExportDurationSec,
                            minEventDurationSec: s.configuration.minEventDurationSec
                        }
                    }
                    const s = this._getCameraDTOsFromIds(t)
                      , o = new p.cw({
                        users: new p.NI(e.users),
                        groups: new p.NI(e.groups),
                        emailAddresses: new p.NI(e.emailAddresses),
                        smtpServer: new p.NI(e.smtpServer),
                        smtpFromAddress: new p.NI(e.smtpFromAddress)
                    })
                      , c = new p.cw({
                        throttlePerCameraSec: new p.NI(n.throttlePerCameraSec,[p.kI.required, p.kI.min(1), sy._validateInteger]),
                        maxExportDurationSec: new p.NI(n.maxExportDurationSec,[p.kI.required, p.kI.min(1), p.kI.max(this.maxExportDurationLimit), sy._validateInteger]),
                        minEventDurationSec: new p.NI(n.minEventDurationSec,[p.kI.required, p.kI.min(1), sy._validateInteger])
                    });
                    return new p.cw({
                        recipients: o,
                        schedule: new p.NI(i),
                        cameraSelection: new p.NI(s,[sy._validateCameras]),
                        advancedSettings: c
                    })
                }
                static _validateCameras(e) {
                    return e.value && 0 === e.value.length ? {
                        [my.NoCamerasSelected]: !0
                    } : null
                }
                static _validateInteger(e) {
                    return Number.isInteger(e.value) ? null : {
                        [my.NoDecimals]: !0
                    }
                }
                _constructNotificationRequest() {
                    let e, t, n;
                    null === this._motionNotification ? (e = this.orchid.id,
                    n = this.orchid.name) : (e = this._motionNotification.conditions[0].orchidId,
                    t = this._motionNotification.id,
                    n = this._motionNotification.name);
                    const i = this.currentSelectedCameras.map((e => e.id))
                      , a = null === this.currentSchedule ? null : this.currentSchedule.id
                      , r = [{
                        type: W.MOTION_ALERT_CONDITION,
                        orchidId: e,
                        cameraIds: i,
                        scheduleId: a,
                        configuration: this.currentAdvancedSettings
                    }]
                      , s = null === this.currentRecipients.smtpServer ? null : this.currentRecipients.smtpServer.id
                      , o = [{
                        type: H.MOTION_ALERT_EMAIL_ACTION,
                        users: this.currentRecipients.users,
                        groups: this.currentRecipients.groups,
                        smtpServerId: s,
                        configuration: {
                            from: this.currentRecipients.smtpFromAddress,
                            subject: n,
                            recipients: this.currentRecipients.emailAddresses
                        }
                    }]
                      , c = {
                        name: n,
                        description: "",
                        isEnabled: this.isNotificationEnabled,
                        conditions: r,
                        actions: o
                    };
                    return void 0 !== t && (c.id = t),
                    c
                }
                confirm() {
                    const e = this._constructNotificationRequest();
                    null === this._motionNotification ? (this.showSaveDialogButton = !1,
                    this._NotificationsService.addNotification(e).subscribe((e => {
                        this.close({
                            MotionAlert: e
                        })
                    }
                    ), (e => {
                        uy("error", e),
                        this.error = this.msgs.errorCreatingNotification(),
                        this.showSaveDialogButton = !0
                    }
                    ))) : (this.showSaveDialogButton = !1,
                    this._NotificationsService.updateNotification(e).subscribe((e => {
                        this.close({
                            MotionAlert: e
                        })
                    }
                    ), (e => {
                        uy("error", e),
                        this.error = this.msgs.errorEditingNotification(),
                        this.showSaveDialogButton = !0
                    }
                    )))
                }
                cancel() {
                    this.close(null)
                }
                close(e) {
                    this.matDialogRef.close(e)
                }
            }
            ;
            hy = sy = (0,
            c.gn)([(0,
            i.Component)({
                selector: "motion-alert-dialog",
                template: n(77919)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(2, (0,
            i.Inject)(ry)), (0,
            c.fM)(3, (0,
            i.Inject)(cc)), (0,
            c.fM)(4, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (oy = void 0 !== hn.so && hn.so) ? oy : Object, "function" == typeof (cy = void 0 !== ry && ry) ? cy : Object, "function" == typeof (ly = void 0 !== cc && cc) ? ly : Object, "function" == typeof (dy = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? dy : Object])], hy);
            var py, gy, fy, vy, yy, by, Sy = n(40564);
            const Cy = O("MotionAlertsList");
            class wy {
                constructor() {
                    this.error = ""
                }
            }
            let Iy = class {
                constructor(e, t, n, i, a) {
                    this._matDialog = e,
                    this._snackBar = t,
                    this._notificationsService = n,
                    this._renewableService = i,
                    this._fusionDataService = a,
                    this.msgs = Object.assign(Object.assign({}, L.messages.motionAlertsList), {
                        noChildNameServersHaveBeenRegistered: L.messages.dashboard.noChildNameServersHaveBeenRegistered,
                        name: L.messages.dashboard.name,
                        enabled: L.messages.notifications.enabled,
                        delete: L.messages.notifications.delete,
                        loadingMotionAlerts: L.messages.motionAlerts.loadingMotionAlerts,
                        failedToLoadMotionAlerts: L.messages.motionAlerts.failedToLoadMotionAlerts,
                        notificationIsDisabledNoNotificationsWillBeSent: L.messages.notifications.notificationIsDisabledNoNotificationsWillBeSent,
                        notificationIsConfiguredCorrectlyNotificationsWillBeSent: L.messages.notifications.notificationIsConfiguredCorrectlyNotificationsWillBeSent
                    }),
                    this.orchids = [],
                    this.motionAlertNotifications = [],
                    this.schedules = [],
                    this.fusionUsers = [],
                    this.fusionPermissionGroups = [],
                    this.loading = !1,
                    this.errorLoadingData = !1,
                    this.orchidNotificationPairs = [],
                    this.filteredOrchidNotifPairs = [],
                    this.searchTerms = [],
                    this.separatorKeysCodes = [ia.K5, ia.OC],
                    this.filteredOrchids = [],
                    this.subscriptions = Ql.E.subscribe(),
                    this.orchidAddedSub = Ql.E.subscribe(),
                    this.pageSize = 10,
                    this.pageIndex = 0,
                    this._comparator = new Ym("orchid.name",!1)
                }
                trackOrchidNotifPair(e, t) {
                    return t.orchid.id
                }
                addEditNotification(e) {
                    const t = e.notification
                      , n = {
                        allUsers: [...this.fusionUsers],
                        allGroups: [...this.fusionPermissionGroups],
                        orchid: Object.assign(Object.assign({}, e.orchid), {
                            cameras: [...e.orchid.cameras]
                        }),
                        motionNotification: xt(t)
                    };
                    hy.show(this._matDialog, n).subscribe({
                        next: t => {
                            t && (e.notification = t.MotionAlert)
                        }
                        ,
                        error: e => {
                            Cy.error(e)
                        }
                    })
                }
                deleteNotification(e) {
                    const t = {
                        panelClass: "delete-notification-dialog",
                        data: {
                            message: this.msgs.areYouSureYouWantToDeleteThisNotification(),
                            confirmText: this.msgs.delete(),
                            cancelText: this.msgs.cancel(),
                            confirmCallbackAsync: () => (0,
                            c.mG)(this, void 0, void 0, (function*() {
                                if (e.notification && e.notification.id)
                                    try {
                                        yield(0,
                                        dt.z)(this._notificationsService.deleteNotification(e.notification.id))
                                    } catch (e) {
                                        throw e.message = this.msgs.errorDeletingNotificationERRORCODEparenthesisERRORMSG({
                                            ERRORCODE: e.status,
                                            ERRORMSG: e.statusText
                                        }),
                                        e
                                    }
                            }
                            ))
                        }
                    };
                    qs.show(this._matDialog, t)
                }
                setCurrentSchedulePreview(e) {
                    var t;
                    (null === (t = e.notification) || void 0 === t ? void 0 : t.conditions[0].scheduleId) && (this.currentSchedulePreview = e)
                }
                findScheduleFromNotification(e) {
                    return this.schedules.find((t => t.id === e.conditions[0].scheduleId)) || {
                        name: "",
                        id: "",
                        timeSlots: []
                    }
                }
                get sortDescending() {
                    return this._comparator.sortDescending
                }
                set sortDescending(e) {
                    this._comparator.sortDescending = e
                }
                get sortOnProperty() {
                    return this._comparator.sortOnProperty
                }
                set sortOnProperty(e) {
                    this._comparator.sortOnProperty = e
                }
                onSearchTermAdded(e) {
                    const t = e.input
                      , n = e.value;
                    (n || "").trim() && this.searchTerms.push(n),
                    t.value = "",
                    this._resetPaginator()
                }
                onSearchTermRemoved(e) {
                    const t = this.searchTerms.indexOf(e);
                    t > -1 && this.searchTerms.splice(t, 1),
                    this._resetPaginator()
                }
                onServerStatusFilterChange() {
                    this._resetPaginator()
                }
                onPaginatorChange(e) {
                    this.pageIndex = e.pageIndex,
                    this.pageSize = e.pageSize
                }
                onSortDescendChange(e) {
                    e.stopPropagation(),
                    this.sortDescending = !this.sortDescending,
                    this._resetPaginator()
                }
                matchNotificationsToOrchids() {
                    this.orchidNotificationPairs = [],
                    this.orchids.forEach((e => {
                        const t = new wy;
                        t.orchid = e,
                        t.notification = this.motionAlertNotifications.find((t => {
                            if (void 0 !== t.conditions[0])
                                return t.conditions[0].orchidId === e.id
                        }
                        )) || null,
                        this.orchidNotificationPairs.push(t)
                    }
                    )),
                    this._resetPaginator()
                }
                willNotifSendEmail(e) {
                    var t, n, i, a, r, s, o, c, l;
                    e.error = "",
                    0 === (null === (t = e.notification) || void 0 === t ? void 0 : t.conditions[0].cameraIds.length) && (e.error = this.msgs.notificationSpecifiesNoCameras()),
                    null === (null === (n = e.notification) || void 0 === n ? void 0 : n.actions[0].smtpServerId) && (e.error = this.msgs.notificationSpecifiesNoSmtpServer());
                    let d = !0;
                    (null === (i = e.notification) || void 0 === i ? void 0 : i.actions[0].configuration) && (null === (a = e.notification) || void 0 === a ? void 0 : a.actions[0].configuration.recipients.length) > 0 && (d = !1),
                    (null === (r = e.notification) || void 0 === r ? void 0 : r.actions[0].users.some((e => null !== e.emailaddress))) && (d = !1);
                    let u = [];
                    (null === (s = e.notification) || void 0 === s ? void 0 : s.actions[0].groups) && (null === (o = e.notification) || void 0 === o ? void 0 : o.actions[0].groups.length) > 0 && (u = Lc(e.notification.actions[0].groups, this.fusionUsers, this.fusionPermissionGroups)),
                    u.length !== (null === (c = e.notification) || void 0 === c ? void 0 : c.actions[0].groups.length) && (d = !1),
                    d && (e.error = this.msgs.notificationSpecifiesNoRecipients()),
                    null === (null === (l = e.notification) || void 0 === l ? void 0 : l.conditions[0].scheduleId) && (e.error = this.msgs.notificationSpecifiesNoSchedule())
                }
                _applyFilterAndSort() {
                    const e = this.orchidNotificationPairs.filter((e => {
                        let t = !1;
                        if (0 === this.searchTerms.length)
                            return !0;
                        for (let n = 0; n < this.searchTerms.length; n++) {
                            const i = this.searchTerms[n].toLowerCase()
                              , a = e.orchid.name.toLowerCase();
                            if (a && a.indexOf(i) > -1) {
                                t = !0;
                                break
                            }
                        }
                        return t
                    }
                    ));
                    e.sort(this._comparator.compare),
                    this.filteredOrchidNotifPairs = e,
                    this.filteredOrchidNotifPairs.forEach((e => {
                        this.willNotifSendEmail(e)
                    }
                    )),
                    this.paginator && this.paginator.firstPage()
                }
                _resetPaginator() {
                    this._applyFilterAndSort()
                }
                ngOnInit() {
                    this.loading = !0,
                    this.subscriptions = (0,
                    Sy.a)([this._notificationsService.getNotifications(), this._notificationsService.getSchedules(), this._notificationsService.getSmtpServers(), this._renewableService.orchidsPromise(), this._fusionDataService.fetchUsers(), this._fusionDataService.fetchGroups().then((e => e.data))]).subscribe({
                        next: e => {
                            const [t,n,i,a,r,s] = e;
                            this.motionAlertNotifications = t.filter((e => 1 === e.conditions.length && e.conditions[0].type === W.MOTION_ALERT_CONDITION)),
                            this.schedules = n,
                            this.orchids = a,
                            this.fusionUsers = r,
                            this.fusionPermissionGroups = s,
                            this.matchNotificationsToOrchids(),
                            this.loading = !1
                        }
                        ,
                        error: e => {
                            Cy.error(e),
                            this.loading = !1,
                            this.errorLoadingData = !0
                        }
                    }),
                    this.orchidAddedSub = this._renewableService.messages$.pipe((0,
                    ra.h)(( () => !this.loading && !this.errorLoadingData)), (0,
                    ra.h)((e => "ORCHID_ADDED" === e.eventType))).subscribe(( () => {
                        this.matchNotificationsToOrchids()
                    }
                    ))
                }
                ngOnDestroy() {
                    this.subscriptions.unsubscribe(),
                    this.orchidAddedSub.unsubscribe()
                }
            }
            ;
            function Ty(e, t) {
                return {
                    x: Math.trunc(e.x - t.x),
                    y: Math.trunc(e.y - t.y)
                }
            }
            function Ey(e) {
                return {
                    x: Math.trunc(e.x),
                    y: Math.trunc(e.y)
                }
            }
            function _y(e, t) {
                var n;
                let i, a;
                ({clientX: i, clientY: a} = "touches"in t ? t.touches[0] : t);
                const r = new DOMPoint(i,a).matrixTransform(null === (n = e.getScreenCTM()) || void 0 === n ? void 0 : n.inverse());
                return {
                    x: r.x,
                    y: r.y
                }
            }
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW), (0,
            c.w6)("design:type", "function" == typeof (py = void 0 !== pi.NW && pi.NW) ? py : Object)], Iy.prototype, "paginator", void 0),
            Iy = (0,
            c.gn)([(0,
            i.Component)({
                selector: "motion-alerts-list",
                template: n(62426)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(1, (0,
            i.Inject)(wi.ux)), (0,
            c.fM)(2, (0,
            i.Inject)(ry)), (0,
            c.fM)(3, (0,
            i.Inject)(Gt)), (0,
            c.fM)(4, (0,
            i.Inject)(Qe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (gy = void 0 !== hn.uw && hn.uw) ? gy : Object, "function" == typeof (fy = void 0 !== wi.ux && wi.ux) ? fy : Object, "function" == typeof (vy = void 0 !== ry && ry) ? vy : Object, "function" == typeof (yy = Gt) ? yy : Object, "function" == typeof (by = Qe) ? by : Object])], Iy);
            class xy {
                constructor(e) {
                    this.start = e,
                    this.offset = {
                        x: 0,
                        y: 0
                    }
                }
                moveTo(e) {
                    return this.offset = Ty(e, this.start),
                    this
                }
                normalize() {
                    const e = {
                        x: 0,
                        y: 0
                    }
                      , t = Ey({
                        x: Math.abs(this.offset.x),
                        y: Math.abs(this.offset.y)
                    });
                    this.offset.x < 0 && (e.x = t.x),
                    this.offset.y < 0 && (e.y = t.y);
                    const n = Ey(Ty(this.start, e));
                    return [{
                        x: n.x,
                        y: n.y
                    }, {
                        x: n.x,
                        y: n.y + t.y
                    }, {
                        x: n.x + t.x,
                        y: n.y + t.y
                    }, {
                        x: n.x + t.x,
                        y: n.y
                    }]
                }
            }
            function Dy(e, t, n={}) {
                const i = f.select(t).append(e);
                for (const e of Object.entries(n))
                    i.attr(e[0], e[1]);
                return i
            }
            function Oy(e) {
                return f.select(e)
            }
            function Ay(e, t) {
                return t ? f.select(t).selectAll(e) : f.selectAll(e)
            }
            function Ry() {
                var e, t;
                return void 0 !== (null === (e = f.event) || void 0 === e ? void 0 : e.sourceEvent) ? null === (t = f.event) || void 0 === t ? void 0 : t.sourceEvent : f.event
            }
            var Py = n(4780)
              , ky = n.n(Py)
              , My = n(98098);
            function Ly(e, t) {
                return e.x === t.x && e.y === t.y
            }
            function Ny(e, t) {
                return Math.hypot(t.x - e.x, t.y - e.y)
            }
            function Fy(e, t, n) {
                return {
                    x: e.x + (t.x - e.x) * n,
                    y: e.y + (t.y - e.y) * n
                }
            }
            function Uy(e) {
                if (void 0 === e)
                    throw new Error("points undefined");
                if (e.length < 3)
                    throw new Error("invalid points");
                const t = e.reduce(( (e, t) => t.x < e.x ? t : e))
                  , n = e.reduce(( (e, t) => t.y < e.y ? t : e))
                  , i = e.reduce(( (e, t) => t.x > e.x ? t : e))
                  , a = e.reduce(( (e, t) => t.y > e.y ? t : e));
                return [{
                    x: t.x,
                    y: n.y
                }, {
                    x: i.x,
                    y: a.y
                }]
            }
            function $y(e) {
                const t = function(e) {
                    let t, n, i, a, r = 0;
                    for (t = 0,
                    n = e.length - 1; t < e.length; n = t,
                    t++)
                        i = e[t],
                        a = e[n],
                        r += i.x * a.y,
                        r -= i.y * a.x;
                    return r /= 2,
                    r
                }(e);
                return Math.abs(t)
            }
            function jy(e, t, n) {
                const i = Uy([...e].map((e => ({
                    x: e.x + t.x,
                    y: e.y + t.y
                }))))
                  , a = i[0]
                  , r = i[1];
                let s = t.x
                  , o = t.y;
                return a.x < 0 && (s += 0 - a.x),
                a.y < 0 && (o += 0 - a.y),
                r.x > n.width && (s += n.width - r.x),
                r.y > n.height && (o += n.height - r.y),
                e.map((e => ({
                    x: e.x + s,
                    y: e.y + o
                })))
            }
            function Vy(e, t) {
                return t.indexOf(e) > -1
            }
            const Gy = "add-vertex"
              , By = "delete-item"
              , zy = "selection-boundary"
              , Hy = "smart-search-active"
              , Wy = O("polygon");
            class qy {
                constructor(e, t, n, i, a, r, s, o) {
                    this.svg = e,
                    this.svgSize = t,
                    this.vertices = n,
                    this._dragBehaviorFactory = i,
                    this._isValid = a,
                    this._onEdit = r,
                    this._onRemove = s,
                    this._onSelected = o,
                    this._initPolygon(),
                    this._initDragListeners()
                }
                get scaleFactor() {
                    var e;
                    return 1 / ((null === (e = this.svg.getScreenCTM()) || void 0 === e ? void 0 : e.a) || 1)
                }
                get _deleteButton() {
                    return Ay(".delete-item", this._polygonGroup.node())
                }
                get _addVertexButtons() {
                    return Ay(".add-vertex", this._polygonGroup.node())
                }
                get _allAddVertexButtons() {
                    return Ay(".add-vertex", this.svg)
                }
                get _dragHandleButtons() {
                    return Ay(".drag-handle", this._polygonGroup.node())
                }
                get _selectionBoundary() {
                    return Oy(".selection-boundary")
                }
                get _allSelectionBoundaries() {
                    return Ay(".selection-boundary", this.svg)
                }
                get _allDeleteButtons() {
                    return Ay(".delete-item", this.svg)
                }
                get _allActiveButtons() {
                    return Ay(".smart-search-active", this.svg)
                }
                activate() {
                    this._selectionBoundary.remove();
                    const [e,t] = Uy(this.vertices)
                      , n = Ty(t, e);
                    this._polygonGroup.append("rect").attr("class", zy).attr("x", e.x).attr("y", e.y).attr("width", n.x).attr("height", n.y),
                    this._polygonGroup.classed(Hy, !0),
                    this._deleteButton.remove(),
                    this._addButton(this._polygonGroup.node(), "", By, this._adjustDeleteButtonPosition({
                        x: t.x,
                        y: e.y
                    }, this.svgSize));
                    const i = this._polygonGroup.node();
                    if (null !== i && (this._addVertexButtons.remove(),
                    this.vertices.length < 255)) {
                        const e = function(e, t) {
                            const n = [];
                            for (let i = 0; i < e.length; i++) {
                                const a = e[i]
                                  , r = e[(i + 1) % e.length];
                                void 0 !== t && Ny(a, r) < t || n.push(Fy(a, r, .5))
                            }
                            return n
                        }(this.vertices, 150);
                        for (const t of e)
                            this._addButton(i, "", Gy, t)
                    }
                }
                activateVertex(e) {
                    const t = Ey(e)
                      , n = this.vertices.filter((e => !1 === Ly(e, t)));
                    this._addVertexButtons.remove(),
                    this._selectionBoundary.remove(),
                    this._dragHandleButtons.classed(Hy, !1);
                    this._dragHandleButtons.filter((t => Ly(t, e))).classed(Hy, !0),
                    this._deleteButton.remove();
                    try {
                        if ($y(n) < 1e4)
                            return
                    } catch (e) {
                        return void Wy.error("An unhandled error occurred", e)
                    }
                    this.vertices.length > 3 && this._isPolygonValid(n) && this._isValid(n) && this._addButton(this._polygonGroup.node(), "", By, this._adjustDeleteButtonPosition(t, this.svgSize))
                }
                deactivate() {
                    this._selectionBoundary.remove(),
                    this._dragHandleButtons.classed(Hy, !1),
                    this._addVertexButtons.remove(),
                    this._deleteButton.remove(),
                    this._polygonGroup.classed(Hy, !1)
                }
                destroy() {
                    this._polygonGroup.remove()
                }
                render() {
                    var e;
                    const t = 0 === (n = this.vertices).length ? "" : n.map((e => [e.x, e.y].join(", "))).join(" ");
                    var n;
                    let i = !0;
                    try {
                        i = this._isPolygonValid(this.vertices) && (null === (e = this._isValid) || void 0 === e ? void 0 : e.call(this, this.vertices))
                    } catch (e) {
                        i = !1
                    }
                    this._polygonGroup.classed("invalid", !1 === i),
                    this._polygon.attr("points", t).attr("stroke-width", 2 * this.scaleFactor).attr("stroke-dasharray", 6 * this.scaleFactor),
                    this._dragHandleButtons.data(this.vertices).enter().append("circle").on("click", ( () => this._onVertexClickHandler())).attr("r", 10).classed("drag-handle", !0),
                    this._dragHandleButtons.data(this.vertices).exit().remove(),
                    this._dragHandleButtons.data(this.vertices).attr("transform", (e => `translate(${e.x}, ${e.y}) scale(${this.scaleFactor})`)),
                    this._addVertexButtons.attr("transform", `scale(${this.scaleFactor})`),
                    this._deleteButton.attr("transform", `scale(${this.scaleFactor})`)
                }
                _addVertex(e) {
                    const t = e || Ry()
                      , n = Ey(this._getCursorPoint(t))
                      , i = this._insertPointOnClosestSegment(n, this.vertices);
                    return this._addVertexButtons.remove(),
                    this.render(),
                    i + 1
                }
                _insertPointOnClosestSegment(e, t) {
                    if (0 === t.length)
                        return -1;
                    let n = Number.MAX_VALUE;
                    const i = t.length;
                    let a = -1;
                    for (let r = 0; r < i; r++) {
                        const s = Ny(e, Fy(t[r], t[r + 1 === i ? 0 : r + 1], .5));
                        s < n && (a = r,
                        n = s)
                    }
                    return this.vertices.splice(a + 1, 0, e),
                    a
                }
                _initDragListeners() {
                    const e = this._dragBehaviorFactory.create(this._polygonGroup.node());
                    e.onDragStart(( (e, t) => this._onDragStart(e, t))),
                    e.onDrag(( (e, t) => this._onDrag(e, t))),
                    e.onDragEnd(( (e, t) => this._onDragEnd(e, t)))
                }
                _initPolygon() {
                    if (this._polygonGroup = function(e, t, n={}, i) {
                        const a = f.select(t).insert(e, i);
                        for (const e of Object.entries(n))
                            a.attr(e[0], e[1]);
                        return a
                    }("g", this.svg),
                    null !== this._polygonGroup.node()) {
                        const e = this.scaleFactor;
                        this._polygonGroup.classed("region", !0),
                        this._polygon = Dy("polygon", this._polygonGroup.node(), {
                            "stroke-dasharray": 6 * e,
                            "stroke-width": 2 * e
                        })
                    }
                    this._polygonGroup.on("click", ( () => this._onPolygonClickHandler())),
                    this.render()
                }
                _getCursorPoint(e) {
                    let t, n;
                    ({clientX: t, clientY: n} = "touches"in e ? e.touches[0] : e);
                    let i = this.svg.createSVGPoint();
                    i.x = t,
                    i.y = n;
                    const a = this.svg.getScreenCTM();
                    return i = i.matrixTransform(null == a ? void 0 : a.inverse()),
                    i
                }
                _isPolygonValid(e) {
                    if (e.length < 3)
                        return !1;
                    const t = $y(e) > 1e4
                      , n = !1 === function(e) {
                        const t = [...e];
                        !1 === Ly(e[0], e[e.length - 1]) && t.push(e[0]);
                        const n = t.map((e => [Math.trunc(e.x), Math.trunc(e.y)]));
                        return ky()(n)
                    }(e);
                    return t && n
                }
                _onDrag(e, t) {
                    var n;
                    const i = _y(this.svg, e)
                      , a = Oy(e.target);
                    if (null === a)
                        return;
                    !1 !== Vy(a.node().nodeName.toLowerCase(), ["circle", "polygon", "svg", "text"]) && (this._allSelectionBoundaries.remove(),
                    this._allDeleteButtons.remove(),
                    void 0 !== t.activeVertexIdx ? this.vertices[t.activeVertexIdx] = Ey({
                        x: Math.min(Math.max(0, i.x), this.svgSize.width),
                        y: Math.max(Math.min(this.svgSize.height, i.y), 0)
                    }) : "polygon" === (null === (n = t.selection) || void 0 === n ? void 0 : n.node().nodeName) && (t.ctx.moveTo(_y(this.svg, e)),
                    this.vertices = jy(t.oldBounds, t.ctx.offset, this.svgSize)),
                    this.render())
                }
                _onDragEnd(e, t) {
                    var n, i;
                    !1 !== this._isPolygonValid(this.vertices) && !1 !== (null === (n = this._isValid) || void 0 === n ? void 0 : n.call(this, this.vertices)) || (this.vertices = t.oldBounds),
                    this.render(),
                    null === (i = this._onEdit) || void 0 === i || i.call(this, this, this.vertices[t.activeVertexIdx])
                }
                _onDragStart(e, t) {
                    var n;
                    const i = Oy(e.target);
                    if (null === i)
                        return;
                    const a = i.node();
                    if (null === a)
                        return;
                    if (!1 === Vy(a.nodeName.toLowerCase(), ["text", "circle", "polygon"]))
                        return;
                    if (this._allActiveButtons.classed(Hy, !1),
                    this._allAddVertexButtons.remove(),
                    null !== a.closest(".delete-item")) {
                        this._deleteButton.remove();
                        const t = i.datum();
                        return void 0 === t.activeVertexIdx ? this._removePolygon() : (this._removeVertex(this.vertices[t.activeVertexIdx]),
                        delete t.activeVertexIdx),
                        e.stopPropagation(),
                        void e.stopImmediatePropagation()
                    }
                    let r;
                    if (null === (n = a.parentElement) || void 0 === n ? void 0 : n.classList.contains(Gy))
                        r = this._addVertex(e),
                        i.classed(Hy, !0);
                    else if ("circle" === a.nodeName.toLowerCase()) {
                        const e = Ey(i.datum());
                        r = this.vertices.findIndex((t => Ly(t, e))),
                        i.classed(Hy, !0)
                    } else
                        this._polygonGroup.classed(Hy, !0);
                    const s = {
                        activeVertexIdx: r,
                        selection: i,
                        ctx: new xy(_y(this.svg, e)),
                        oldBounds: [...this.vertices]
                    };
                    Object.assign(t, s)
                }
                _onPolygonClickHandler() {
                    Ry().stopImmediatePropagation(),
                    this._emitSelection(this._polygonGroup)
                }
                _onVertexClickHandler() {
                    const e = Ry();
                    e.stopImmediatePropagation(),
                    this._emitSelection(Oy(e.target))
                }
                _removePolygon() {
                    var e;
                    Ry().stopImmediatePropagation(),
                    this._polygonGroup.remove(),
                    null === (e = this._onRemove) || void 0 === e || e.call(this, this)
                }
                _removeVertex(e) {
                    var t;
                    Ry().stopImmediatePropagation();
                    const n = this.vertices.findIndex((t => Ly(t, e)));
                    -1 !== n && (this.vertices.splice(n, 1),
                    this.render(),
                    null === (t = this._onEdit) || void 0 === t || t.call(this, this))
                }
                _emitSelection(e) {
                    var t, n, i;
                    if (this._polygonGroup.classed(Hy, !1),
                    this._dragHandleButtons.classed(Hy, !1),
                    void 0 === e)
                        return;
                    const a = function(e) {
                        const t = e.node();
                        if (null === t)
                            throw new Error("The selection did not have a node");
                        return t
                    }(e);
                    if (null != a)
                        if (Vy(a.nodeName, ["g", "polygon"]))
                            null === (t = this._onSelected) || void 0 === t || t.call(this, this);
                        else {
                            const t = null == e ? void 0 : e.datum();
                            null === (n = this._onSelected) || void 0 === n || n.call(this, this, t)
                        }
                    else
                        null === (i = this._onSelected) || void 0 === i || i.call(this, void 0)
                }
                _addButton(e, t, n, i) {
                    const a = Dy("g", e)
                      , r = a.node();
                    if (null !== r) {
                        Dy("rect", r);
                        Dy("text", r).text(t),
                        a.classed(n, !0)
                    }
                    a.attr("transform", `translate(${i.x}, ${i.y}) scale(${this.scaleFactor})`)
                }
                _adjustDeleteButtonPosition(e, t) {
                    const n = 75 * this.scaleFactor
                      , i = 50 * this.scaleFactor
                      , a = e.y < n ? n : e.y - 30;
                    return {
                        x: e.x >= t.width - i ? t.width - i : e.x,
                        y: a
                    }
                }
            }
            class Yy {
                constructor(e) {
                    this._selection = f.select(e),
                    this._selection.data([{}]),
                    this._dragBehavior = f.behavior.drag(),
                    this._selection.call(this._dragBehavior)
                }
                _onDragStart(e) {
                    const t = f.event.sourceEvent;
                    t.stopImmediatePropagation(),
                    t.preventDefault(),
                    this._dragStartFn && this._dragStartFn(t, e)
                }
                _onDrag(e) {
                    const t = f.event.sourceEvent;
                    t.stopImmediatePropagation(),
                    t.preventDefault(),
                    this._dragFn && this._dragFn(t, e)
                }
                _onDragEnd(e) {
                    const t = f.event.sourceEvent;
                    t.stopImmediatePropagation(),
                    t.preventDefault(),
                    this._dragEndFn && this._dragEndFn(t, e)
                }
                onDragStart(e) {
                    this._dragStartFn = e,
                    this._dragBehavior.on("dragstart", this._onDragStart.bind(this))
                }
                onDrag(e) {
                    this._dragFn = e,
                    this._dragBehavior.on("drag", this._onDrag.bind(this))
                }
                onDragEnd(e) {
                    this._dragEndFn = e,
                    this._dragBehavior.on("dragend", this._onDragEnd.bind(this))
                }
            }
            let Xy = class {
                create(e) {
                    return new Yy(e)
                }
            }
            ;
            var Ky;
            Xy = (0,
            c.gn)([(0,
            i.Injectable)()], Xy);
            let Zy = class {
                constructor(e) {
                    this._dragBehaviorFactory = e
                }
                create(e, t, n, i, a, r, s) {
                    return new qy(e,t,n,this._dragBehaviorFactory,i,a,r,s)
                }
            }
            ;
            var Jy, Qy, eb, tb, nb;
            Zy = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.fM)(0, (0,
            i.Inject)(Xy)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Ky = void 0 !== Xy && Xy) ? Ky : Object])], Zy);
            let ib = Jy = class {
                constructor(e, t) {
                    this._polygonFactory = e,
                    this._dragBehaviorFactory = t,
                    this.onRegionsChange = new i.EventEmitter,
                    this.size = {
                        width: Jy.DEFAULT_WIDTH,
                        height: Jy.DEFAULT_HEIGHT
                    },
                    this.helpHasBeenSeen = !1,
                    this._regions = [],
                    this.msgs = L.messages.smartSearch
                }
                ngAfterViewInit() {
                    var e, t;
                    this.helpHasBeenSeen = this.regionBounds.length > 0,
                    this._initRegions(),
                    this._initDragListeners(),
                    (null === (t = null === (e = this.svg) || void 0 === e ? void 0 : e.nativeElement) || void 0 === t ? void 0 : t.parentNode) && (this._resizeObserver = new ResizeObserver(( () => {
                        this._regions.forEach((e => e.render()))
                    }
                    )),
                    this._resizeObserver.observe(this.svg.nativeElement.parentNode))
                }
                ngOnChanges(e) {
                    var t, n, i;
                    (null === (t = e.regionBounds) || void 0 === t ? void 0 : t.isFirstChange()) || 0 === (null === (n = e.regionBounds) || void 0 === n ? void 0 : n.currentValue.length) && (null === (i = e.regionBounds) || void 0 === i ? void 0 : i.previousValue.length) > 0 && this.reset()
                }
                ngOnDestroy() {
                    var e, t, n, i;
                    null === (e = this._resizeObserver) || void 0 === e || e.unobserve(this.svg.nativeElement.parentNode),
                    null === (t = this._resizeObserver) || void 0 === t || t.disconnect(),
                    this._regions.forEach((e => e.destroy())),
                    null === (n = this.help) || void 0 === n || n.nativeElement.remove(),
                    null === (i = this.svg) || void 0 === i || i.nativeElement.remove()
                }
                reset() {
                    this._regions.forEach((e => e.destroy())),
                    this._regions = [],
                    this._emitRegionsChange()
                }
                get _activeElements() {
                    return Ay(".smart-search-active", this.svg.nativeElement)
                }
                _arePolygonsValid(e) {
                    return !1 === this._doesPolygonOverlap(e)
                }
                _doesPolygonOverlap(e, t=!0) {
                    let n = this._regions;
                    return (!t || (n = this._regions.filter((t => !1 === Pc(e, t.vertices))),
                    this._regions.length !== n.length)) && n.some((t => function(e, t) {
                        const n = e.map((e => [e.x, e.y]))
                          , i = t.map((e => [e.x, e.y]));
                        return My(n, i)
                    }(e, t.vertices)))
                }
                _emitRegionsChange() {
                    const e = this._regions.map((e => function(e) {
                        return function(e) {
                            let t = 0;
                            for (let n = 0; n < e.length; n++) {
                                const i = (n + 1) % e.length;
                                t += e[n].x * e[i].y,
                                t -= e[i].x * e[n].y
                            }
                            return t / 2 <= 0
                        }(e) ? e : e.reverse()
                    }(e.vertices)));
                    this.onRegionsChange.emit({
                        regions: e,
                        size: this.size
                    })
                }
                _initDragListeners() {
                    Oy(this.svg.nativeElement).on("click", ( () => {
                        this._onSelected()
                    }
                    ));
                    Oy(this.svg.nativeElement).data([{}]);
                    const e = this._dragBehaviorFactory.create(this.svg.nativeElement);
                    e.onDragStart(( (e, t) => {
                        this._onDragStart(e, t)
                    }
                    )),
                    e.onDrag(( (e, t) => this._onDrag(e, t))),
                    e.onDragEnd(( (e, t) => this._onDragEnd(e, t)))
                }
                _initRegions() {
                    this.size = {
                        width: 3e3 * this.aspectRatio,
                        height: 3e3
                    },
                    this.svg.nativeElement.setAttribute("viewBox", `0 0 ${this.size.width} ${this.size.height}`),
                    this._regions = this.regionBounds.map((e => this._polygonFactory.create(this.svg.nativeElement, this.size, e, (e => !1 === this._doesPolygonOverlap(e, !0)), this._onRegionEdit.bind(this), this._onRegionRemove.bind(this), this._onSelected.bind(this))))
                }
                _onDrag(e, t) {
                    e.preventDefault();
                    const n = _y(this.svg.nativeElement, e);
                    t.ctx.moveTo(n),
                    this._render(t.rect, t.ctx.normalize())
                }
                _onDragEnd(e, t) {
                    t.rect.remove();
                    let n = t.ctx.normalize();
                    if (n.length < 4)
                        return;
                    if (this._doesPolygonOverlap(n, !1))
                        return;
                    const i = $y(n)
                      , a = this._isOutsideBounds(n, this.size);
                    i > 1e4 && !a && (n = jy(n, {
                        x: 0,
                        y: 0
                    }, this.size),
                    this._regions.push(this._polygonFactory.create(this.svg.nativeElement, this.size, n, (e => !1 === this._doesPolygonOverlap(e, !0)), this._onRegionEdit.bind(this), this._onRegionRemove.bind(this), this._onSelected.bind(this))),
                    this._emitRegionsChange())
                }
                _onDragStart(e, t) {
                    this.helpHasBeenSeen = !0,
                    Ay(".selection-boundary, .delete-item").remove(),
                    Ay(".smart-search-active").classed(Hy, !1);
                    const n = Oy(this.svg.nativeElement)
                      , i = _y.bind(void 0, this.svg.nativeElement)
                      , a = n.append("rect");
                    a.classed("region", !0);
                    const r = {
                        ctx: new xy(i(e)),
                        rect: a
                    };
                    Object.assign(t, r)
                }
                _onRegionEdit(e, t) {
                    const n = this._regions.findIndex((t => t.vertices === e.vertices));
                    if (-1 === n)
                        return;
                    const i = e.vertices.map((e => Ey(e)));
                    this._regions[n].vertices = i,
                    this._emitRegionsChange(),
                    t ? e.activateVertex(t) : e.activate()
                }
                _onRegionRemove(e) {
                    const t = this._regions.findIndex((t => (null == e ? void 0 : e.vertices) === t.vertices));
                    -1 !== t && (this._regions.splice(t, 1),
                    this._emitRegionsChange())
                }
                _onSelected(e, t) {
                    if (void 0 !== e) {
                        for (const t of this._regions)
                            t !== e && t.deactivate();
                        t ? e.activateVertex(t) : e && e.activate()
                    } else
                        for (const e of this._regions)
                            e.deactivate()
                }
                _isOutsideBounds(e, t) {
                    for (const n of e) {
                        if (!1 === $s(0, n.x, t.width))
                            return !0;
                        if (!1 === $s(0, n.y, t.height))
                            return !0
                    }
                    return !1
                }
                _render(e, t) {
                    var n;
                    this._activeElements.classed(Hy, !1);
                    const i = 1 / ((null === (n = this.svg.nativeElement.getScreenCTM()) || void 0 === n ? void 0 : n.a) || 1)
                      , a = this._doesPolygonOverlap(t, !1)
                      , r = this._isOutsideBounds(t, this.size);
                    e.attr("x", t[0].x).attr("y", t[0].y).attr("width", t[2].x - t[0].x).attr("height", t[2].y - t[0].y).attr("stroke-dasharray", 6 * i).attr("stroke-width", 2 * i).classed("invalid", a || r)
                }
            }
            ;
            ib.DEFAULT_WIDTH = 3e3,
            ib.DEFAULT_HEIGHT = 3e3,
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Number)], ib.prototype, "aspectRatio", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], ib.prototype, "regionBounds", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], ib.prototype, "onRegionsChange", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("SVG"), (0,
            c.w6)("design:type", "function" == typeof (Qy = void 0 !== i.ElementRef && i.ElementRef) ? Qy : Object)], ib.prototype, "svg", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("help"), (0,
            c.w6)("design:type", "function" == typeof (eb = void 0 !== i.ElementRef && i.ElementRef) ? eb : Object)], ib.prototype, "help", void 0),
            ib = Jy = (0,
            c.gn)([(0,
            i.Component)({
                selector: "smart-search-overlay",
                template: n(14507)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Zy)), (0,
            c.fM)(1, (0,
            i.Inject)(Xy)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (tb = void 0 !== Zy && Zy) ? tb : Object, "function" == typeof (nb = void 0 !== Xy && Xy) ? nb : Object])], ib);
            let ab = class {
                constructor() {
                    this.minimized = !1,
                    this.onClear = new i.EventEmitter,
                    this.onFilter = new i.EventEmitter
                }
                clear() {
                    this.onClear.emit()
                }
                filter() {
                    this.onFilter.emit()
                }
            }
            ;
            var rb, sb, ob, cb;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Number)], ab.prototype, "regionCount", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], ab.prototype, "onClear", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], ab.prototype, "onFilter", void 0),
            ab = (0,
            c.gn)([(0,
            i.Component)({
                selector: "smart-search-control",
                template: n(45386)
            })], ab);
            const lb = O("AuditLogsService");
            var db;
            !function(e) {
                e.SERVICES = "services-error",
                e.LOGS = "logs-error",
                e.CAMERAS = "cameras-error",
                e.USERS = "users-error",
                e.FEATURE_DISABLED = "feature-disabled-error",
                e.NONE = "none",
                e.TRUSTED_ISSUER = "trusted-issuer-error"
            }(db || (db = {}));
            let ub = class {
                constructor(e, t, n, i) {
                    this.http = e,
                    this._orchidDataService = t,
                    this._orchidProxyService = n,
                    this._authenticator = i,
                    this._URLS = {
                        services: "/service/audit/services",
                        logs: "/service/audit/logs",
                        cameras: "/service/audit/cameras",
                        users: "/service/audit/users",
                        export: "/service/audit/logs/export",
                        trustedIssuer: "/service/trusted/issuer"
                    },
                    this._error$ = new P.X({
                        type: db.NONE
                    }),
                    this._services$ = new P.X([]),
                    this._logs$ = new P.X([]),
                    this._cameras$ = new P.X([]),
                    this._users$ = new P.X([]),
                    this._trustedIssuer$ = new P.X({
                        description: "",
                        href: "",
                        id: "",
                        uri: "",
                        name: ""
                    }),
                    this._servicesActionsMap$ = new P.X(new Map),
                    this._servicesDescriptionsMap$ = new P.X(new Map),
                    this._servicesResourcesMap$ = new P.X(new Map),
                    this._resourceServicesMap$ = new P.X(new Map),
                    this._lastTimestamps = {
                        logs: 0
                    }
                }
                get error$() {
                    return this._error$.asObservable()
                }
                get services$() {
                    return this._services$.asObservable()
                }
                get logs$() {
                    return this._logs$.asObservable()
                }
                get cameras$() {
                    return this._cameras$.asObservable()
                }
                get users$() {
                    return this._users$.asObservable()
                }
                get trustedIssuer$() {
                    return this._trustedIssuer$.asObservable()
                }
                get servicesActionsMap$() {
                    return this._servicesActionsMap$.asObservable()
                }
                get servicesDescriptionsMap$() {
                    return this._servicesDescriptionsMap$.asObservable()
                }
                get servicesResourcesMap$() {
                    return this._servicesResourcesMap$.asObservable()
                }
                get resourceServicesMap$() {
                    return this._resourceServicesMap$.asObservable()
                }
                getHeaders() {
                    const e = {};
                    return e.Authorization = "Bearer " + this._authenticator.getAuthenticationData().sessionId,
                    e
                }
                getServices(e, t={}) {
                    const n = new lt.LE;
                    t.actions && n.set("actions", t.actions),
                    t.resources && n.set("resources", t.resources);
                    const i = this.getUrl(this._URLS.services, e)
                      , a = this.getHeaders();
                    this.http.get(i, {
                        params: n,
                        headers: a
                    }).pipe((0,
                    sa.b)((e => {
                        const t = new Map
                          , n = new Map
                          , i = new Map
                          , a = new Map;
                        e.auditedServices.forEach((e => {
                            t.set(e.id, e.action),
                            n.set(e.id, e.translatedDescription);
                            const r = e.resource;
                            if (a.has(r)) {
                                const t = a.get(r);
                                t && t.push(e.id)
                            } else
                                a.set(r, [e.id]);
                            i.set(e.id, e.resource)
                        }
                        )),
                        this._servicesActionsMap$.next(t),
                        this._servicesDescriptionsMap$.next(n),
                        this._servicesResourcesMap$.next(i),
                        this._resourceServicesMap$.next(a)
                    }
                    )), (0,
                    lr.K)(this._handleError("getServices", db.SERVICES, {
                        auditedServices: []
                    }))).subscribe((e => {
                        this._services$.next(e.auditedServices)
                    }
                    ))
                }
                getAuditLogs(e, t) {
                    const n = (new Date).getTime();
                    this._lastTimestamps.logs = n;
                    const {more: i} = t
                      , a = (0,
                    c._T)(t, ["more"]);
                    Object.keys(a).forEach((e => void 0 === a[e] && delete a[e]));
                    const r = new lt.LE({
                        fromObject: a
                    })
                      , s = this.getUrl(this._URLS.logs, e)
                      , o = this.getHeaders();
                    this.http.get(s, {
                        params: r,
                        headers: o
                    }).pipe((0,
                    lr.K)(this._handleError("getAuditLogs", db.LOGS, {
                        auditLogs: []
                    }))).subscribe((e => {
                        this._lastTimestamps.logs === n && (t.more ? this._logs$.next(this._logs$.getValue().concat(e.auditLogs)) : this._logs$.next(e.auditLogs))
                    }
                    ))
                }
                getUrl(e, t) {
                    return `${this._orchidProxyService.orchidUri({
                        id: t.id,
                        uri: t.uri
                    }, {
                        forceProxy: !0
                    })}${e}`
                }
                getCamerasList(e) {
                    const t = this.getUrl(this._URLS.cameras, e)
                      , n = this.getHeaders();
                    this.http.get(t, {
                        headers: n
                    }).pipe((0,
                    lr.K)(this._handleError("getCamerasList", db.CAMERAS, {
                        auditLogCameras: []
                    }))).subscribe((e => {
                        const t = e.auditLogCameras.sort(( (e, t) => {
                            const n = Tt(e.name)
                              , i = Tt(t.name);
                            return n < i ? -1 : n > i ? 1 : 0
                        }
                        ));
                        this._cameras$.next(t)
                    }
                    ))
                }
                getUsersList(e) {
                    const t = this.getUrl(this._URLS.users, e)
                      , n = this.getHeaders();
                    this.http.get(t, {
                        headers: n
                    }).pipe((0,
                    lr.K)(this._handleError("getUsersList", db.USERS, {
                        auditedUsers: []
                    }))).subscribe((e => {
                        const t = e.auditedUsers.sort(( (e, t) => {
                            const n = e.username.toLowerCase()
                              , i = t.username.toLowerCase();
                            return n < i ? -1 : n > i ? 1 : 0
                        }
                        ));
                        this._users$.next(t)
                    }
                    ))
                }
                getTrustedIssuer(e) {
                    const t = this.getUrl(this._URLS.trustedIssuer, e)
                      , n = this.getHeaders();
                    this.http.get(t, {
                        headers: n
                    }).pipe((0,
                    lr.K)(this._handleError("getTrustedIssuer", db.TRUSTED_ISSUER, {
                        description: "",
                        href: "",
                        id: "",
                        uri: "",
                        name: ""
                    }))).subscribe((e => {
                        this._trustedIssuer$.next(e)
                    }
                    ))
                }
                getLogsExportUrl(e, t={}) {
                    const n = new URL(this.getUrl(this._URLS.export, e))
                      , {more: i} = t
                      , a = (0,
                    c._T)(t, ["more"]);
                    return Object.keys(a).forEach((e => {
                        void 0 !== a[e] && "offset" !== e && n.searchParams.set(e, a[e].toString())
                    }
                    )),
                    n.searchParams.set("count", "unlimited"),
                    n.pathname.includes("orchid-proxy") ? n.searchParams.set("fsid", this._authenticator.getAuthenticationData().sessionId) : this._orchidDataService.addOrchidAuthQueryParam(n, e),
                    decodeURIComponent(n.href)
                }
                _handleError(e="operation", t, n) {
                    return i => {
                        var a;
                        return lb(`${e} failed: ${i.message}`),
                        t !== db.TRUSTED_ISSUER && this._error$.next({
                            type: 404 === (null == i ? void 0 : i.status) ? db.FEATURE_DISABLED : t,
                            reason: null === (a = null == i ? void 0 : i.error) || void 0 === a ? void 0 : a.reason
                        }),
                        (0,
                        ze.of)(n)
                    }
                }
                clearData() {
                    this._services$.next([]),
                    this._logs$.next([]),
                    this._cameras$.next([]),
                    this._users$.next([]),
                    this._error$.next({
                        type: db.NONE
                    })
                }
            }
            ;
            var mb;
            ub = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(lt.eN)), (0,
            c.fM)(1, (0,
            i.Inject)(pt)), (0,
            c.fM)(2, (0,
            i.Inject)(mt)), (0,
            c.fM)(3, (0,
            i.Inject)(xe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (rb = void 0 !== lt.eN && lt.eN) ? rb : Object, "function" == typeof (sb = pt) ? sb : Object, "function" == typeof (ob = void 0 !== mt && mt) ? ob : Object, "function" == typeof (cb = void 0 !== xe && xe) ? cb : Object])], ub);
            const hb = O("ManagedRecordersService");
            let pb = class {
                constructor(e) {
                    this._fusionDataService = e,
                    this._managedRecordersSubject = new P.X(null),
                    this._userManagementGroupsSubject = new P.X(null)
                }
                isManaged(e) {
                    return "string" == typeof e ? this._getManagedRecorders().pipe((0,
                    ra.h)((e => null !== e)), (0,
                    He.U)((t => void 0 !== t[e]))) : this._getManagedRecorders().pipe((0,
                    ra.h)((e => null !== e)), (0,
                    He.U)((t => e.map((e => void 0 !== t[e])))))
                }
                _getManagedRecorders() {
                    return this._managedRecorders$ || (this._managedRecorders$ = this._managedRecordersSubject.pipe((0,
                    ra.h)((e => null !== e))),
                    this._fusionDataService.fetchManagedRecorders$().subscribe({
                        next: e => this._managedRecordersSubject.next(this._buildManagedRecordersDictionary(e)),
                        error: e => {
                            hb("error", e),
                            this._managedRecordersSubject.error(e),
                            this._managedRecordersSubject = new P.X(null),
                            this._managedRecorders$ = void 0
                        }
                    })),
                    this._managedRecorders$
                }
                _buildManagedRecordersDictionary(e) {
                    const t = {};
                    if (e)
                        for (let n = 0; n < e.length; ++n) {
                            const i = e[n]
                              , a = {
                                index: n,
                                id: i.id
                            };
                            t[i.id] = a
                        }
                    return t
                }
                getUserManagementGroups() {
                    return this._userManagementGroups$ || (this._userManagementGroups$ = this._userManagementGroupsSubject.pipe((0,
                    ra.h)((e => null !== e))),
                    this._fusionDataService.fetchUserManagementGroups$().subscribe({
                        next: e => {
                            this._userManagementGroupsSubject.next(e)
                        }
                        ,
                        error: e => {
                            hb("error", e),
                            this._userManagementGroupsSubject.error(e),
                            this._userManagementGroupsSubject = new P.X(null),
                            this._userManagementGroups$ = void 0
                        }
                    })),
                    this._userManagementGroups$
                }
                getRecorderManagementGroups(e) {
                    return this._fusionDataService.fetchRecorderManagementGroups$(e)
                }
                clear() {
                    this._managedRecordersSubject = new P.X(null),
                    this._managedRecorders$ = void 0,
                    this._userManagementGroupsSubject = new P.X(null),
                    this._userManagementGroups$ = void 0
                }
                clearOrchid(e) {
                    const t = this._managedRecordersSubject.getValue();
                    t && (delete t[e],
                    this._managedRecordersSubject.next(t))
                }
            }
            ;
            var gb, fb, vb;
            pb = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Qe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (mb = Qe) ? mb : Object])], pb);
            let yb = class {
                constructor(e, t, n) {
                    this._FusionDataService = e,
                    this._RenewableService = t,
                    this._PluginService = n,
                    this.groups = [],
                    this.groupNamesIds = [],
                    this.users = [],
                    this.plugins = [],
                    this.loaded = !1,
                    this.failedToLoad = !1,
                    this.orchidsLoaded = !1,
                    this.orchids = [],
                    this.log = O("permission-groups"),
                    this.msgs = {}
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign({
                        name: L.messages.dashboard.name,
                        search: L.messages.dashboard.search
                    }, L.messages.dialogs), L.messages.groups),
                    this.fetchData()
                }
                fetchData() {
                    Promise.all([this._RenewableService.orchidsPromise(), this._FusionDataService.fetchUsers(), this._FusionDataService.fetchGroupSummaries(1e8, 0), this._FusionDataService.fetchGroupNames(), this._PluginService.getPluginsPromise()]).then((e => (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const [t,n,i,a] = e;
                        this.orchids = t,
                        this.groups = i.data.sort(( (e, t) => e.name.toLowerCase().localeCompare(t.name.toLowerCase()))),
                        this.groupNamesIds = a.data.sort(( (e, t) => e.name.toLowerCase().localeCompare(t.name.toLowerCase()))),
                        this.users = n.sort(( (e, t) => e.username.toLowerCase().localeCompare(t.username.toLowerCase()))),
                        this.plugins = yield this._PluginService.getPlugins(),
                        this.plugins = this.plugins.map((e => ({
                            id: e.id,
                            name: e.name,
                            description: e.description
                        })))
                    }
                    )))).catch((e => {
                        this.log.error(this.msgs.failedToLoadPermissionGroups(), e),
                        this.failedToLoad = !0
                    }
                    )).finally(( () => {
                        this.loaded = !0
                    }
                    ))
                }
            }
            ;
            yb = (0,
            c.gn)([(0,
            i.Component)({
                selector: "permission-groups",
                template: n(76752)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Qe)), (0,
            c.fM)(1, (0,
            i.Inject)(Gt)), (0,
            c.fM)(2, (0,
            i.Inject)(et)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (gb = Qe) ? gb : Object, "function" == typeof (fb = Gt) ? fb : Object, "function" == typeof (vb = et) ? vb : Object])], yb);
            const bb = (0,
            Jo.X$)("slideDownUp", [(0,
            Jo.eR)(":enter", [(0,
            Jo.oB)({
                height: 0,
                opacity: 0
            }), (0,
            Jo.jt)("0.2s ease-out", (0,
            Jo.oB)({
                height: "*",
                opacity: 1
            }))]), (0,
            Jo.eR)(":leave", [(0,
            Jo.oB)({
                height: "*",
                opacity: 1
            }), (0,
            Jo.jt)("0.2s ease-in", (0,
            Jo.oB)({
                height: 0,
                opacity: 0
            }))])])
              , Sb = (0,
            Jo.X$)("slideDownUpBoolean", [(0,
            Jo.SB)("true", (0,
            Jo.oB)({
                height: "*",
                opacity: 1,
                visibility: "visible"
            })), (0,
            Jo.SB)("false", (0,
            Jo.oB)({
                height: "0px",
                opacity: 0,
                visibility: "hidden"
            })), (0,
            Jo.eR)("false <=> true", [(0,
            Jo.jt)(200)])])
              , Cb = (0,
            Jo.X$)("openClose", [(0,
            Jo.eR)(":enter", [(0,
            Jo.oB)({
                height: 0
            }), (0,
            Jo.jt)("0.2s ease-out", (0,
            Jo.oB)({
                height: "*"
            }))]), (0,
            Jo.eR)(":leave", [(0,
            Jo.oB)({
                height: "*"
            }), (0,
            Jo.jt)("0.2s ease-in", (0,
            Jo.oB)({
                height: 0
            }))])])
              , wb = (0,
            Jo.X$)("slideInLeft", [(0,
            Jo.eR)(":enter", [(0,
            Jo.oB)({
                transform: "translateX(-100%)"
            }), (0,
            Jo.jt)("0.3s ease-out", (0,
            Jo.oB)({
                transform: "translateX(0%)"
            }))])])
              , Ib = (0,
            Jo.X$)("slideInRight", [(0,
            Jo.eR)(":enter", [(0,
            Jo.oB)({
                transform: "translateX(+100%)"
            }), (0,
            Jo.jt)("0.3s ease-out", (0,
            Jo.oB)({
                transform: "translateX(0%)"
            }))])]);
            (0,
            Jo.X$)("blockInitialRenderAnimation", [(0,
            Jo.eR)(":enter", [])]);
            var Tb, Eb, _b, xb, Db, Ob, Ab, Rb, Pb, kb;
            let Mb = class {
                constructor(e, t) {
                    this._changeDetector = e,
                    this._brandService = t,
                    this.users = [],
                    this.groups = [],
                    this.orchids = [],
                    this.plugins = [],
                    this.externalProviders = [],
                    this.processing = !1,
                    this.selectedOrchids = [],
                    this.appName = "",
                    this.icons = Object.assign(Object.assign(Object.assign(Object.assign({}, Ht), Wt), zt), Yt),
                    this.adminPrivilege = ke,
                    this.manageRecordersOptions = Pe,
                    this.msgs = {},
                    this.Type = Me,
                    this.rules = [],
                    this.domainData = [],
                    this.domainFormGroup = new p.cw({
                        domain: new p.NI("",[p.kI.required]),
                        group: new p.NI("",[p.kI.required])
                    }),
                    this.selectedTabIndex = 0,
                    this.matChipCtrl = new p.NI,
                    this.appsFormCtrl = new p.NI,
                    this.selectedManageOption = Pe.SELECTION,
                    this.SAMLProviders = [],
                    this.appName = this._brandService.brand.APP_NAME
                }
                get hasDeprecatedAttributes() {
                    return 0 !== this.SAMLProviders.length && this.SAMLProviders.some((e => {
                        const t = this.externalGroupForm.controls.attributeMapping.value[e.externalProviderId];
                        return (null == t ? void 0 : t.some((t => t.conditions.some((t => t.attributeName.length > 0 && !e.configuration.supportedAttributes.includes(t.attributeName)))))) || !1
                    }
                    ))
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign(Object.assign(Object.assign({
                        name: L.messages.dashboard.name,
                        search: L.messages.dashboard.search
                    }, L.messages.externalProviders), L.messages.dialogs), L.messages.groups), L.messages.chips),
                    this.rules = [L.messages.groups.permissions.all(), L.messages.groups.permissions.export(), L.messages.groups.permissions.live(), L.messages.groups.permissions.playback(), L.messages.groups.permissions.ptz()],
                    this.SAMLProviders = this.externalProviders.filter((e => e.type === De.SAML))
                }
                ngAfterViewInit() {
                    this.checkApps();
                    const e = this.adminForm.value.managementConfig.managedOrchids;
                    e.length > 0 && e.forEach((e => {
                        const t = this.orchids.find((t => t.id === e));
                        t && this.selectedOrchids.push(t)
                    }
                    )),
                    this._changeDetector.detectChanges()
                }
                allAppSelect() {
                    const e = this.othersForm.value.plugins;
                    this._allPlugins.selected ? (e.splice(0, e.length),
                    this.othersForm.value.allPlugins = !0,
                    this.plugins.forEach((t => {
                        e.push(t)
                    }
                    )),
                    this._selectApps.options.forEach((e => e.select()))) : (this.othersForm.value.allPlugins = !1,
                    this._selectApps.options.forEach((e => e.deselect())),
                    e.splice(0, e.length))
                }
                appSelect(e) {
                    const t = this.othersForm.value.plugins.find((t => t.id === e.id))
                      , n = this.othersForm.value.plugins.indexOf(t);
                    t ? (this.othersForm.value.plugins.splice(n, 1),
                    this.othersForm.value.allPlugins = !1,
                    this._allPlugins.deselect()) : (this.othersForm.value.plugins.push(e),
                    this.othersForm.value.plugins.length === this.plugins.length && this.othersForm.value.plugins.length > 0 && (this._allPlugins.select(),
                    this.allAppSelect()))
                }
                checkApps() {
                    this.othersForm.value.allPlugins && (this._allPlugins.select(),
                    this.allAppSelect()),
                    this.othersForm.value.plugins.forEach((e => {
                        var t;
                        null === (t = this._selectApps.options.find((t => t.id === e.id))) || void 0 === t || t.select()
                    }
                    ))
                }
                onAdminRoleChange(e) {
                    var t, n;
                    this.adminForm.controls.admin.setValue(e.value === ke.ADMIN);
                    const i = this.adminForm.value.managementConfig.abilities;
                    e.value === ke.RECORDER_ADMIN ? (i.push(Re.MANAGE_ORCHID),
                    null === (t = this.adminForm.controls.managementConfig.get("abilities")) || void 0 === t || t.setValue(i)) : null === (n = this.adminForm.controls.managementConfig.get("abilities")) || void 0 === n || n.setValue([])
                }
                handleOrchidSelected(e) {
                    var t;
                    this.selectedOrchids = e,
                    null === (t = this.adminForm.controls.managementConfig.get("managedOrchids")) || void 0 === t || t.setValue(this.selectedOrchids.map((e => e.id)))
                }
                onManageOptionChange(e) {
                    var t;
                    const n = e.value === Pe.ALL;
                    null === (t = this.adminForm.controls.managementConfig.get("allOrchids")) || void 0 === t || t.setValue(n)
                }
                getRecorderAdminTabLabel() {
                    return this.adminForm.value.managementConfig.allOrchids ? this.msgs.all() : this.selectedOrchids.length.toString()
                }
                isRegistrar() {
                    return this.adminForm.value.managementConfig.abilities.includes(Re.REGISTER_ORCHID)
                }
                onRegistrarToggle(e) {
                    var t;
                    let n = [];
                    n = e.checked ? [Re.MANAGE_ORCHID, Re.REGISTER_ORCHID] : [Re.MANAGE_ORCHID],
                    null === (t = this.adminForm.controls.managementConfig.get("abilities")) || void 0 === t || t.setValue(n)
                }
            }
            ;
            var Lb, Nb;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], Mb.prototype, "users", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], Mb.prototype, "groups", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], Mb.prototype, "orchids", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], Mb.prototype, "plugins", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Tb = "undefined" != typeof Array && Array) ? Tb : Object)], Mb.prototype, "externalProviders", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Mb.prototype, "processing", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Eb = void 0 !== p.cw && p.cw) ? Eb : Object)], Mb.prototype, "generalForm", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (_b = void 0 !== p.cw && p.cw) ? _b : Object)], Mb.prototype, "externalGroupForm", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (xb = void 0 !== p.cw && p.cw) ? xb : Object)], Mb.prototype, "adminForm", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Db = void 0 !== p.cw && p.cw) ? Db : Object)], Mb.prototype, "cameraPermissionsForm", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Ob = void 0 !== p.cw && p.cw) ? Ob : Object)], Mb.prototype, "othersForm", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("allPlugins"), (0,
            c.w6)("design:type", "function" == typeof (Ab = void 0 !== si.ey && si.ey) ? Ab : Object)], Mb.prototype, "_allPlugins", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("selectApps"), (0,
            c.w6)("design:type", "function" == typeof (Rb = void 0 !== yi.gD && yi.gD) ? Rb : Object)], Mb.prototype, "_selectApps", void 0),
            Mb = (0,
            c.gn)([(0,
            i.Component)({
                selector: "permission-group-form",
                template: n(15673),
                animations: [Cb],
                changeDetection: i.ChangeDetectionStrategy.OnPush
            }), (0,
            c.fM)(0, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.fM)(1, (0,
            i.Inject)(Hm)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Pb = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? Pb : Object, "function" == typeof (kb = void 0 !== Hm && Hm) ? kb : Object])], Mb);
            let Fb = class {
                constructor() {
                    this.externalProviders = [],
                    this.processing = !1,
                    this.hasDeprecatedAttributes = !1,
                    this.SAMLProviders = [],
                    this.icons = Object.assign(Object.assign(Object.assign({}, zt), Yt), Ht),
                    this.msgs = {},
                    this.externalTooltip = () => "",
                    this.externalSamlTooltip = () => ""
                }
                get domainData() {
                    return this.externalGroupForm.controls.domains.value
                }
                get BANNER_TYPE() {
                    return au
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.externalProviders), L.messages.groups), L.messages.groups.extendedSaml),
                    this._setExternalTooltips()
                }
                _setExternalTooltips() {
                    const e = [...new Set(this.externalProviders.map((e => e.type)).filter((e => e !== De.SAML)))].map((e => {
                        switch (e) {
                        case De.ACTIVE_DIRECTORY:
                            return this.msgs.activeDirectory();
                        case De.AZURE:
                            return this.msgs.azureActiveDirectory();
                        case De.FREEIPA:
                            return this.msgs.freeIPA();
                        case De.GOOGLE_OAUTH:
                            return this.msgs.googleOAuth();
                        default:
                            return ""
                        }
                    }
                    )).join(", ").replace(/,(?!.*,)/gim, " " + this.msgs.andSlashOr());
                    this.externalTooltip = L.messages.groups.externalPROVIDERSGroupsCanBeMappedToThisPermissionGroup({
                        PROVIDERS: e
                    }),
                    this.externalSamlTooltip = L.messages.groups.externalPROVIDERSGroupsCanBeMappedToThisPermissionGroup({
                        PROVIDERS: [this.msgs.saml()]
                    })
                }
                addDomainMap() {
                    this.domainData.push({
                        domain: "",
                        group: ""
                    })
                }
                removeDomainMap(e) {
                    this.domainData.splice(e, 1)
                }
            }
            ;
            function Ub(e) {
                const t = {};
                return e.forEach((e => {
                    t[e.externalProviderId] ? t[e.externalProviderId].push(e) : t[e.externalProviderId] = [e]
                }
                )),
                t
            }
            function $b(e) {
                const t = [];
                for (const [n,i] of Object.entries(e))
                    for (let e = 0; e < i.length; e++)
                        t.push({
                            domain: n,
                            group: i[e]
                        });
                return t.sort(( (e, t) => {
                    const n = e.domain.toLowerCase().localeCompare(t.domain.toLowerCase());
                    return 0 !== n ? n : e.group.toLocaleLowerCase().localeCompare(t.group.toLocaleLowerCase())
                }
                ))
            }
            function jb(e) {
                return e.length > 0 ? e.length : L.messages.groups.none()
            }
            var Vb, Gb, Bb, zb, Hb, Wb, qb, Yb;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Lb = void 0 !== p.cw && p.cw) ? Lb : Object)], Fb.prototype, "externalGroupForm", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Nb = "undefined" != typeof Array && Array) ? Nb : Object)], Fb.prototype, "externalProviders", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Fb.prototype, "processing", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], Fb.prototype, "hasDeprecatedAttributes", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], Fb.prototype, "SAMLProviders", void 0),
            Fb = (0,
            c.gn)([(0,
            i.Component)({
                selector: "external-group-mappings",
                template: n(61715)
            })], Fb),
            function(e) {
                e.GENERAL = "general",
                e.EXTERNAL_GROUP = "externalGroupMappings",
                e.ADMIN = "adminSettings",
                e.PERMISSIONS = "cameraPermissions",
                e.OTHERS = "others"
            }(Yb || (Yb = {}));
            let Xb = Vb = class {
                constructor(e, t, n, i, a) {
                    this._fusionDataService = e,
                    this._matDialogRef = t,
                    this._changeDetector = n,
                    this.formBuilder = i,
                    this.data = a,
                    this.processing = !1,
                    this.showError = !1,
                    this.error = "",
                    this.msgs = Object.assign(Object.assign({
                        name: L.messages.dashboard.name,
                        search: L.messages.dashboard.search
                    }, L.messages.dialogs), L.messages.groups),
                    this.log = O("permission-groups"),
                    this.permissionGroupData = a.permissionGroup,
                    this.groupFormGroup = this._initAndGetFormGroup(this.permissionGroupData),
                    this.formBuilder = new p.qu,
                    this.generalForm = this.groupFormGroup.get(Yb.GENERAL),
                    this.externalGroupForm = this.groupFormGroup.get(Yb.EXTERNAL_GROUP),
                    this.adminForm = this.groupFormGroup.get(Yb.ADMIN),
                    this.cameraPermissionsForm = this.groupFormGroup.get(Yb.PERMISSIONS),
                    this.othersForm = this.groupFormGroup.get(Yb.OTHERS)
                }
                ngOnInit() {
                    this.dialogTitle = this._determineDialogTitle()
                }
                _determineDialogTitle() {
                    return this.permissionGroupData ? L.messages.groups.editNamedGroup({
                        VALUE: this.permissionGroupData.name
                    }) : this.msgs.newPermissionGroup()
                }
                _getUserGroupData() {
                    var e, t;
                    this.users = this.data.users.map((e => ({
                        id: e.id,
                        username: e.username
                    })));
                    const n = [...this.data.groups];
                    if (null === (e = this.permissionGroupData) || void 0 === e ? void 0 : e.name) {
                        const e = n.map((e => e.name)).indexOf(null === (t = this.permissionGroupData) || void 0 === t ? void 0 : t.name);
                        n.splice(e, 1)
                    }
                    this.groups = n.map((e => ({
                        id: e.id,
                        name: e.name
                    })))
                }
                _newPermission() {
                    return {
                        id: void 0,
                        rules: [],
                        allOrchids: !0,
                        orchids: [],
                        cameras: []
                    }
                }
                _newPermissionAllData() {
                    return {
                        id: "",
                        general: {
                            name: "",
                            description: this.msgs.aGroupOfUsersForSpecifyingPermissions(),
                            groups: [],
                            users: [],
                            indirectUsers: []
                        },
                        externalGroupMappings: {
                            domains: {},
                            attributeMapping: []
                        },
                        adminSettings: {
                            admin: !1,
                            recorderAdmin: !1,
                            managementConfig: {
                                abilities: [],
                                allOrchids: !1,
                                managedOrchids: [],
                                selectedManageOption: Pe.SELECTION
                            }
                        },
                        cameraPermissions: {
                            permissions: {
                                grant: [],
                                revoke: []
                            }
                        },
                        others: {
                            allPlugins: !1,
                            plugins: [],
                            globalLibraryAccess: !1
                        }
                    }
                }
                _initAndGetFormPermission(e) {
                    let t;
                    return t = e ? {
                        rules: e.rules,
                        allOrchids: e.allOrchids,
                        orchids: e.orchids,
                        cameras: e.cameras,
                        id: e.id
                    } : this._newPermission(),
                    this.formBuilder.group({
                        rules: new p.NI(t.rules),
                        allOrchids: new p.NI(t.allOrchids),
                        orchids: new p.NI(t.orchids),
                        cameras: new p.NI(t.cameras),
                        id: new p.NI(t.id)
                    })
                }
                _initAndGetFormGroup(e) {
                    let t, n = ke.NONE;
                    if (e) {
                        t = {
                            id: e.id,
                            general: {
                                name: e.name,
                                description: e.description,
                                users: e.users,
                                indirectUsers: e.indirectUsers,
                                groups: e.groups
                            },
                            externalGroupMappings: {
                                domains: e.domains,
                                attributeMapping: e.attributeMapping
                            },
                            adminSettings: {
                                admin: e.admin,
                                recorderAdmin: e.managementConfig.abilities.includes(Re.MANAGE_ORCHID),
                                managementConfig: {
                                    abilities: e.managementConfig.abilities,
                                    allOrchids: e.managementConfig.allOrchids,
                                    managedOrchids: e.managementConfig.managedOrchids,
                                    selectedManageOption: e.managementConfig.allOrchids ? Pe.ALL : Pe.SELECTION
                                }
                            },
                            cameraPermissions: {
                                permissions: {
                                    grant: e.permissions.grant,
                                    revoke: e.permissions.revoke
                                }
                            },
                            others: {
                                allPlugins: e.allPlugins,
                                plugins: e.plugins,
                                globalLibraryAccess: e.globalLibraryAccess
                            }
                        };
                        const i = t.adminSettings;
                        i.admin ? n = ke.ADMIN : i.recorderAdmin && (n = ke.RECORDER_ADMIN)
                    } else
                        t = this._newPermissionAllData();
                    return this._getUserGroupData(),
                    this.formBuilder.group({
                        id: [t.id, [p.kI.required]],
                        general: this.formBuilder.group({
                            name: [t.general.name, [p.kI.required]],
                            description: [t.general.description],
                            users: [t.general.users],
                            groups: [t.general.groups]
                        }),
                        externalGroupMappings: this.formBuilder.group({
                            domains: [$b(t.externalGroupMappings.domains)],
                            attributeMapping: [Ub(t.externalGroupMappings.attributeMapping)]
                        }),
                        adminSettings: this.formBuilder.group({
                            role: [n],
                            admin: [t.adminSettings.admin],
                            recorderAdmin: [t.adminSettings.recorderAdmin],
                            managementConfig: this.formBuilder.group({
                                abilities: [t.adminSettings.managementConfig.abilities],
                                allOrchids: [t.adminSettings.managementConfig.allOrchids],
                                managedOrchids: [t.adminSettings.managementConfig.managedOrchids],
                                selectedManageOption: [t.adminSettings.managementConfig.selectedManageOption]
                            })
                        }),
                        cameraPermissions: this.formBuilder.group({
                            permissions: this.formBuilder.group({
                                grant: new p.Oe(t.cameraPermissions.permissions.grant.map((e => this._initAndGetFormPermission(e)))),
                                revoke: new p.Oe(t.cameraPermissions.permissions.revoke.map((e => this._initAndGetFormPermission(e))))
                            })
                        }),
                        others: this.formBuilder.group({
                            allPlugins: [t.others.allPlugins],
                            plugins: [t.others.plugins],
                            globalLibraryAccess: [t.others.globalLibraryAccess]
                        })
                    })
                }
                static showDialog(e, t, n, i, a, r, s) {
                    return t.open(Vb, {
                        minWidth: "300px",
                        width: "80vw",
                        panelClass: "add-perm-dialog-panel",
                        disableClose: !0,
                        data: {
                            permissionGroup: e,
                            users: n,
                            groups: i,
                            orchids: a,
                            plugins: r,
                            externalProviders: s
                        }
                    }).afterClosed()
                }
                addPermissionGroup(e) {
                    if ("" !== e.name) {
                        const t = JSON.parse(JSON.stringify(e));
                        this._fusionDataService.newGroup(t).then(( () => {
                            this.close(Le.NEW)
                        }
                        )).catch((e => {
                            this.handleFormError(e)
                        }
                        ))
                    }
                }
                editPermissionGroup(e) {
                    if ("" !== e.name) {
                        const t = JSON.parse(JSON.stringify(e));
                        this._fusionDataService.updateGroup(t).then(( () => {
                            this.close(Le.EDIT)
                        }
                        )).catch((e => {
                            this.handleFormError(e)
                        }
                        ))
                    }
                }
                close(e) {
                    this._matDialogRef.close(e)
                }
                dismissMe() {
                    this.showError = !1
                }
                handleFormSubmit() {
                    const e = this.groupFormGroup.value;
                    if (this.processing || 0 === e.general.name.trim().length)
                        return;
                    const t = e.adminSettings
                      , n = t.role === ke.RECORDER_ADMIN
                      , i = t.managementConfig.selectedManageOption === Pe.ALL;
                    n ? i && (e.adminSettings.managementConfig.managedOrchids = []) : (e.adminSettings.managementConfig.allOrchids = !1,
                    e.adminSettings.managementConfig.managedOrchids = []),
                    e.externalGroupMappings.domains = function(e) {
                        const t = {};
                        return e.forEach((e => {
                            e.domain = e.domain.trim(),
                            e.group = e.group.trim(),
                            "" !== e.domain && "" !== e.group && (t[e.domain] ? t[e.domain].push(e.group) : t[e.domain] = [e.group])
                        }
                        )),
                        t
                    }(e.externalGroupMappings.domains),
                    e.externalGroupMappings.attributeMapping = function(e) {
                        const t = [];
                        for (const n in e)
                            t.push(...e[n]);
                        return t
                    }(e.externalGroupMappings.attributeMapping),
                    e.externalGroupMappings.attributeMapping.forEach((e => {
                        e.conditions = e.conditions.filter((e => "" !== e.attributeName && "" !== e.attributeValue.trim()))
                    }
                    )),
                    e.externalGroupMappings.attributeMapping = e.externalGroupMappings.attributeMapping.filter((e => e.conditions.length > 0));
                    const a = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({
                        id: e.id
                    }, e.general), e.externalGroupMappings), e.adminSettings), e.cameraPermissions), e.others);
                    this.processing = !0,
                    this.groupFormGroup.disable(),
                    this.permissionGroupData ? this.editPermissionGroup(a) : this.addPermissionGroup(a)
                }
                handleFormError(e) {
                    var t;
                    this.error = (null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.reason) || this.msgs.anUnexpectedErrorHasOccurred(),
                    this.log.error(this.msgs.failedToLoadPermissionGroup(), e),
                    this.showError = !0,
                    this.processing = !1,
                    this.groupFormGroup.enable(),
                    this._changeDetector.detectChanges()
                }
            }
            ;
            var Kb, Zb, Jb, Qb, eS, tS, nS, iS;
            (0,
            c.gn)([(0,
            i.ViewChild)("permissionGroupForm"), (0,
            c.w6)("design:type", "function" == typeof (Gb = void 0 !== Mb && Mb) ? Gb : Object)], Xb.prototype, "permissionGroupForm", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("externalGroupMappings"), (0,
            c.w6)("design:type", "function" == typeof (Bb = void 0 !== Fb && Fb) ? Bb : Object)], Xb.prototype, "externalGroupMappings", void 0),
            Xb = Vb = (0,
            c.gn)([(0,
            i.Component)({
                selector: "add-perm-group-dialog",
                template: n(45363)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Qe)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(2, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.fM)(3, (0,
            i.Inject)(p.qu)), (0,
            c.fM)(4, (0,
            i.Inject)(hn.WI)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (zb = Qe) ? zb : Object, "function" == typeof (Hb = void 0 !== hn.so && hn.so) ? Hb : Object, "function" == typeof (Wb = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? Wb : Object, "function" == typeof (qb = void 0 !== p.qu && p.qu) ? qb : Object, Object])], Xb);
            let aS = class {
                constructor(e, t, n, a) {
                    this._matDialog = e,
                    this.paginator = t,
                    this._FusionDataService = n,
                    this.loaded = !1,
                    this.groups = [],
                    this.groupNamesIds = [],
                    this.users = [],
                    this.orchids = [],
                    this.plugins = [],
                    this.newGroup = new i.EventEmitter,
                    this.groupData = {},
                    this.externalProviders = [],
                    this.expandedPanels = {},
                    this.updating = {},
                    this.failedToUpdate = {},
                    this.refreshingPage = !1,
                    this.failedToLoad = !1,
                    this.pagedGroups = [],
                    this.pageSize = 16,
                    this.pageSizeOptions = [16, 24, 32, 40],
                    this.log = O("permission-groups-page"),
                    this.externalProviders = a.getAuthenticationProviders().filter((e => e.providesGroups))
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign({
                        name: L.messages.dashboard.name,
                        search: L.messages.dashboard.search
                    }, L.messages.dialogs), L.messages.groups, L.messages.navigation, L.messages.bag)
                }
                ngOnChanges(e) {
                    var t, n;
                    e.loaded && !e.loaded.isFirstChange() && (this.groupNames = this.groupNamesIds.map((e => e.name)),
                    this.updateFilteredData(this.groupNames),
                    this.paginator.setLabel(null !== (n = null === (t = this.msgs) || void 0 === t ? void 0 : t.groups()) && void 0 !== n ? n : ""),
                    this.rangeLabel = this.paginator.getRangeLabel(0, this.pageSize, this.filteredGroups.length))
                }
                addPermissionGroup() {
                    Xb.showDialog(void 0, this._matDialog, this.users, this.groupNamesIds, this.orchids, this.plugins, this.externalProviders).subscribe((e => {
                        e !== Le.CANCEL && this.refreshPageData(null, Le.NEW)
                    }
                    ))
                }
                removeGroup(e) {
                    const t = this.groups.indexOf(e);
                    this.refreshPageData(null, Le.DELETE),
                    this.handlePanelChange(void 0, t, !1)
                }
                refreshPageData(e, t) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        t !== Le.CANCEL && (null === e ? this.refreshingPage = !0 : this.updating[e] = !0,
                        this.groupData = {},
                        yield Promise.all([this._FusionDataService.fetchGroupSummaries(1e8, 0), this._FusionDataService.fetchGroupNames()]).then((e => {
                            this.groups = e[0].data.sort(( (e, t) => e.name.toLowerCase().localeCompare(t.name.toLowerCase()))),
                            this.groupNamesIds = e[1].data.sort(( (e, t) => e.name.toLowerCase().localeCompare(t.name.toLowerCase()))),
                            this.groupNames = this.groupNamesIds.map((e => e.name))
                        }
                        )).then(( () => {
                            this.searchBar && this.searchBar.searchTerms.length > 0 ? this.searchBar.applyFilter() : this.updateFilteredData(this.groupNames)
                        }
                        )).catch((e => {
                            var t;
                            this.failedToLoad = !0,
                            this.loaded = !1,
                            this.log.error(null === (t = this.msgs) || void 0 === t ? void 0 : t.failedToLoadPermissionGroups(), e)
                        }
                        )).finally(( () => {
                            if (t === Le.EDIT && e) {
                                const t = this.groups.find((t => t.id === e));
                                t && this._getPermissionGroupData(t).then(( () => {
                                    this.expandedPanels = Object.assign(Object.assign({}, this.expandedPanels), {
                                        [e]: !0
                                    }),
                                    this.updating[e] = !1
                                }
                                ))
                            } else
                                this.expandedPanels = {};
                            null === e && (this.refreshingPage = !1)
                        }
                        )))
                    }
                    ))
                }
                updatePagedData(e) {
                    this.pagedGroups = e
                }
                handlePageEvent(e) {
                    this.pageSize = e.pageSize,
                    this.expandedPanels = {},
                    this.rangeLabel = this.paginator.getRangeLabel(e.pageIndex, this.pageSize, this.filteredGroups.length)
                }
                updateFilteredData(e) {
                    this.filteredGroups = [],
                    this.groups.forEach((t => {
                        e.includes(t.name) && this.filteredGroups.push(t)
                    }
                    )),
                    this.rangeLabel = this.paginator.getRangeLabel(0, this.pageSize, this.filteredGroups.length)
                }
                handlePanelChange(e, t, n) {
                    this.updating = {},
                    this.expandedPanels = {},
                    e && !this.groupData[t] ? (this.updating[t] = !0,
                    this._getPermissionGroupData(e).then(( () => {
                        this.updating[t] && (this.expandedPanels = Object.assign(Object.assign({}, this.expandedPanels), {
                            [t]: n
                        })),
                        this.updating[e.id] = !1
                    }
                    ))) : this.expandedPanels = Object.assign(Object.assign({}, this.expandedPanels), {
                        [t]: n
                    })
                }
                _getPermissionGroupData(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        yield this._FusionDataService.fetchGroup(e.id).then((t => {
                            this.groupData[t.data.id] = t.data,
                            this.failedToUpdate[e.id] = !1
                        }
                        )).catch((t => {
                            var n;
                            this.failedToUpdate[e.id] = !0,
                            this.log.error(null === (n = this.msgs) || void 0 === n ? void 0 : n.failedToLoadPermissionGroup(), t)
                        }
                        ))
                    }
                    ))
                }
            }
            ;
            var rS, sS, oS, cS;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], aS.prototype, "loaded", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], aS.prototype, "groups", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], aS.prototype, "groupNamesIds", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Kb = "undefined" != typeof Array && Array) ? Kb : Object)], aS.prototype, "users", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Zb = "undefined" != typeof Array && Array) ? Zb : Object)], aS.prototype, "orchids", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (Jb = "undefined" != typeof Array && Array) ? Jb : Object)], aS.prototype, "plugins", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], aS.prototype, "newGroup", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("searchBar"), (0,
            c.w6)("design:type", "function" == typeof (Qb = void 0 !== aa && aa) ? Qb : Object)], aS.prototype, "searchBar", void 0),
            aS = (0,
            c.gn)([(0,
            i.Component)({
                selector: "perm-group-page",
                template: n(18104),
                providers: [{
                    provide: pi.ye,
                    useClass: uu
                }],
                animations: [Cb]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(1, (0,
            i.Inject)(pi.ye)), (0,
            c.fM)(2, (0,
            i.Inject)(Qe)), (0,
            c.fM)(3, (0,
            i.Inject)(xe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (eS = void 0 !== hn.uw && hn.uw) ? eS : Object, "function" == typeof (tS = void 0 !== uu && uu) ? tS : Object, "function" == typeof (nS = Qe) ? nS : Object, "function" == typeof (iS = void 0 !== xe && xe) ? iS : Object])], aS);
            let lS = class {
                constructor(e, t) {
                    this._matDialog = e,
                    this._FusionDataService = t,
                    this.users = [],
                    this.orchids = [],
                    this.groups = [],
                    this.externalProviders = [],
                    this.removeGroup = new i.EventEmitter,
                    this.editGroup = new i.EventEmitter,
                    this.msgs = Object.assign(Object.assign(Object.assign({
                        name: L.messages.dashboard.name,
                        search: L.messages.dashboard.search
                    }, L.messages.dialogs), L.messages.library), L.messages.groups, L.messages.bag, L.messages.groups.extendedSaml),
                    this.icons = Object.assign(Object.assign({}, zt), Ht),
                    this.userGroups = [],
                    this.usernames = [],
                    this.domainData = [],
                    this.managedRecorders = [],
                    this.log = O("perm-group-card-content"),
                    this.listingUsers = !1,
                    this.relatedUsers = [],
                    this.permissionRules = [],
                    this.Type = Me,
                    this.CHIPWIDTH = gu,
                    this.SAMLProviders = [],
                    this.attributeMappingsRecord = {},
                    this.attributeGroupMappingsConfigured = !1
                }
                get BANNER_TYPE() {
                    return au
                }
                get hasDeprecatedAttributes() {
                    return 0 !== this.SAMLProviders.length && this.SAMLProviders.some((e => {
                        const t = this.attributeMappingsRecord[e.externalProviderId];
                        return (null == t ? void 0 : t.some((t => t.conditions.some((t => !e.configuration.supportedAttributes.includes(t.attributeName)))))) || !1
                    }
                    ))
                }
                ngOnInit() {
                    this._getData(),
                    this._getPermissionRules(),
                    this.SAMLProviders = this.externalProviders.filter((e => e.type === De.SAML));
                    const e = this.SAMLProviders.map((e => e.externalProviderId));
                    this.attributeMappingsRecord = Ub(this.group.attributeMapping.filter((t => e.includes(t.externalProviderId)))),
                    Object.keys(this.attributeMappingsRecord).length > 0 && (this.attributeGroupMappingsConfigured = !0)
                }
                editPermissionGroup() {
                    const e = xt(this.group);
                    Xb.showDialog(e, this._matDialog, this.users, this.groups, this.orchids, this.plugins, this.externalProviders).subscribe((e => {
                        e === Le.CANCEL ? this.editGroup.emit(Le.CANCEL) : this.editGroup.emit(Le.EDIT)
                    }
                    ))
                }
                getServersCount() {
                    var e;
                    return (null === (e = this.group.managementConfig) || void 0 === e ? void 0 : e.allOrchids) ? this.orchids.length : this.managedRecorders.length
                }
                _getData() {
                    if (this.group.users.forEach((e => {
                        this.usernames.push({
                            name: e.username
                        })
                    }
                    )),
                    this.group.groups.forEach((e => {
                        this.userGroups.push({
                            name: e.name
                        })
                    }
                    )),
                    this.group.indirectUsers.forEach((e => {
                        this.relatedUsers.push({
                            name: e.username
                        })
                    }
                    )),
                    this.group.managementConfig.allOrchids)
                        this.managedRecorders = [{
                            name: this.msgs.recorderAdmin.allRecorders()
                        }];
                    else {
                        const e = this.group.managementConfig.managedOrchids;
                        e.length > 0 && e.map((e => {
                            const t = this.orchids.find((t => t.id === e));
                            t && this.managedRecorders.push(t)
                        }
                        ))
                    }
                    if (Object.keys(this.group.domains).length) {
                        for (let e = 0; e < Object.keys(this.group.domains).length; e++) {
                            const t = Object.keys(this.group.domains)[e];
                            Object.values(this.group.domains)[e].map((e => {
                                this.domainData.push({
                                    bold: t,
                                    name: e
                                })
                            }
                            ))
                        }
                        this.domainData.sort(( (e, t) => e.bold.toLowerCase().localeCompare(t.bold.toLowerCase())))
                    }
                }
                _getPermissionRules() {
                    this.group.admin && this.permissionRules.push({
                        name: this.msgs.administratorGroup()
                    }),
                    this.group.allPlugins && this.permissionRules.push({
                        name: this.msgs.allApps(),
                        bold: this.msgs.app()
                    }),
                    this.group.plugins.length > 0 && this.group.plugins.forEach((e => {
                        this.permissionRules.push({
                            name: e.name,
                            bold: this.msgs.app()
                        })
                    }
                    )),
                    this.group.globalLibraryAccess && this.permissionRules.push({
                        name: this.msgs.libraryAccess()
                    })
                }
                delete(e) {
                    const t = {
                        panelClass: "sing-dialog-panel",
                        data: {
                            message: this.msgs.areYouSureYouWantToDeleteThisGroup(),
                            confirmText: this.msgs.delete(),
                            cancelText: this.msgs.cancel(),
                            confirmCallbackAsync: () => (0,
                            c.mG)(this, void 0, void 0, (function*() {
                                yield this._FusionDataService.deleteGroup(e).then(( () => {
                                    this.removeGroup.emit(e)
                                }
                                )).catch((e => {
                                    this.log.error(this.msgs.failedToLoadPermissionGroup(), e || this.msgs.anUnexpectedErrorHasOccurred());
                                    const t = e && e.reason ? e.reason : this.msgs.anUnexpectedErrorHasOccurred();
                                    throw new Error(t)
                                }
                                ))
                            }
                            ))
                        }
                    };
                    qs.show(this._matDialog, t)
                }
                showUsers() {
                    this.listingUsers = !this.listingUsers
                }
                isRegistrar() {
                    return this.group.managementConfig.abilities.includes(Re.REGISTER_ORCHID)
                }
                getSAMLSummaryBorderClass(e) {
                    if (1 === Object.keys(this.attributeMappingsRecord).length)
                        return "solo-panel-border";
                    const t = this.SAMLProviders.findIndex((t => t === e));
                    return 0 === t ? "first-panel-border" : t === this.SAMLProviders.length - 1 ? "last-panel-border" : ""
                }
            }
            ;
            var dS, uS, mS, hS, pS;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], lS.prototype, "group", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (rS = "undefined" != typeof Array && Array) ? rS : Object)], lS.prototype, "users", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], lS.prototype, "orchids", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], lS.prototype, "plugins", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], lS.prototype, "groups", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (sS = "undefined" != typeof Array && Array) ? sS : Object)], lS.prototype, "externalProviders", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], lS.prototype, "removeGroup", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], lS.prototype, "editGroup", void 0),
            lS = (0,
            c.gn)([(0,
            i.Component)({
                selector: "perm-group-card-content",
                template: n(62266),
                animations: [bb, Sb]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(1, (0,
            i.Inject)(Qe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (oS = void 0 !== hn.uw && hn.uw) ? oS : Object, "function" == typeof (cS = Qe) ? cS : Object])], lS);
            let gS = class {
                constructor(e, t, n) {
                    this.paginator = e,
                    this._renewableService = t,
                    this._changeDetector = n,
                    this.processing = !1,
                    this.deletePerm = new i.EventEmitter,
                    this.msgs = {},
                    this.loaded = !1,
                    this.existingPerm = !1,
                    this.allDataNames = [],
                    this.formDataNames = [],
                    this.cardData = [],
                    this.orchidsEditing = [],
                    this.camerasEditing = [],
                    this.abilities = [],
                    this.rules = [],
                    this.rulesOnly = this.rules.slice(1),
                    this.rulesWarn = {
                        playback: !1,
                        ptz: !1,
                        talk: !1
                    },
                    this.initialEventRules = {
                        source: {
                            value: ""
                        },
                        checked: !1
                    },
                    this.allCameras = "",
                    this.TYPE = Me,
                    this.CHIPWIDTH = gu,
                    this.pagedData = [],
                    this.pageSize = 8,
                    this.pageSizeOptions1 = new mu([12, 24, 32, 52],(e => e >= 2402 || e <= 1e3 && e > 989),{
                        10: 12,
                        12: 12,
                        20: 24,
                        24: 24,
                        30: 32,
                        32: 32,
                        50: 52,
                        51: 52,
                        52: 52
                    }),
                    this.pageSizeOptions2 = new mu([12, 24, 30, 51],(e => 1912 < e && e < 2402 || e <= 989 && e > 788),{
                        10: 12,
                        12: 12,
                        20: 24,
                        24: 24,
                        32: 30,
                        30: 30,
                        50: 51,
                        52: 51,
                        51: 51
                    }),
                    this.pageSizeOptions3 = new mu([10, 20, 30, 50],(e => e <= 1912 && e > 1e3),{
                        12: 10,
                        10: 10,
                        24: 20,
                        20: 20,
                        32: 30,
                        30: 30,
                        51: 50,
                        52: 50,
                        50: 50
                    }),
                    this.pageSizeOptions = [this.pageSizeOptions1, this.pageSizeOptions2, this.pageSizeOptions3],
                    this.pageSizeCameras = 12
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign(Object.assign({
                        name: L.messages.dashboard.name,
                        search: L.messages.dashboard.search
                    }, L.messages.dialogs), L.messages.groups), L.messages.cameras.cameraPicker),
                    this.rules = [L.messages.groups.permissions.all().toLocaleLowerCase(), L.messages.groups.permissions.export().toLocaleLowerCase(), L.messages.groups.permissions.live().toLocaleLowerCase(), L.messages.groups.permissions.playback().toLocaleLowerCase(), L.messages.groups.permissions.ptz().toLocaleLowerCase(), L.messages.groups.permissions.talk().toLocaleLowerCase()],
                    this.rulesOnly = this.rules.slice(1),
                    this.allCameras = this.msgs.allCameras(),
                    this.data && (this.paginator.setLabel(this.msgs.servers()),
                    this._getDataForDisplaying(this.data.orchids, this.data.cameras, this.data.rules)),
                    this.formGroup && (this.formGroup.value.id ? (this.existingPerm = !0,
                    this.formGroup.value.orchids.forEach((e => this.orchidsEditing.push(e))),
                    this.formGroup.value.cameras.forEach((e => this.camerasEditing.push(e))),
                    this._getRulesData(this.formGroup.value.rules)) : this.existingPerm = !1)
                }
                ngOnChanges(e) {
                    e.processing && this.processing && this.formGroup && this.savePermission(this.formGroup),
                    this.formGroup && !this.formGroup.value.admin && this.checkRuleWarning()
                }
                _getDataForDisplaying(e, t, n) {
                    this.allDataNames = [],
                    this.abilities = [],
                    e.forEach((e => {
                        const t = this._renewableService.findOrchid(e).name;
                        this.allDataNames.push({
                            bold: t,
                            name: this.msgs.allCameras()
                        })
                    }
                    )),
                    t.forEach((e => {
                        const t = this._renewableService.findOrchid(e.orchidId).name
                          , n = this._renewableService.findCamera(e.orchidId, e.id).name;
                        this.allDataNames.push({
                            bold: t,
                            name: n
                        })
                    }
                    )),
                    this.allDataNames.sort(( (e, t) => e.bold.toLocaleLowerCase().localeCompare(t.bold.toLocaleLowerCase()))),
                    this.cardData = this._getCardData(this.allDataNames),
                    this.cardType !== Me.READONLY && this.cardType !== Me.COMPLETED || n.forEach((e => {
                        this.abilities.push({
                            name: e
                        })
                    }
                    ))
                }
                _getCardData(e) {
                    const t = e.reduce(( (e, t) => {
                        const n = e.find((e => e.name === t.bold));
                        return n ? n.cameras.push({
                            name: t.name
                        }) : e.push({
                            name: t.bold,
                            cameras: [{
                                name: t.name
                            }],
                            allCameras: !1
                        }),
                        e
                    }
                    ), []);
                    return t.forEach((e => {
                        e.cameras.some((e => e.name === this.allCameras)) && (e.cameras = [{
                            name: this.allCameras
                        }],
                        e.allCameras = !0)
                    }
                    )),
                    t
                }
                _getRulesData(e) {
                    e.forEach((e => {
                        const t = {
                            source: {
                                value: e
                            },
                            checked: !0
                        };
                        this.updateRules(t)
                    }
                    ))
                }
                updateRules(e) {
                    var t;
                    const n = e.source.value.toLocaleLowerCase()
                      , i = null === (t = this.formGroup) || void 0 === t ? void 0 : t.value.rules
                      , a = this.rules.find((t => t === e.source.value));
                    if (e.checked)
                        n === this.rules[0] ? (i.splice(0, i.length),
                        this.rulesOnly.forEach((e => {
                            i.push(e)
                        }
                        ))) : i.includes(a) || i.push(a);
                    else if (n === this.rules[0])
                        i.splice(0, i.length);
                    else if (i.includes(a) && a) {
                        const e = i.indexOf(a);
                        i.splice(e, 1)
                    }
                    this.checkRuleWarning()
                }
                checkRuleWarning() {
                    var e;
                    const t = null === (e = this.formGroup) || void 0 === e ? void 0 : e.value.rules;
                    t.includes(this.rules[4]) && !t.includes(this.rules[2]) ? this.rulesWarn.ptz = !0 : this.rulesWarn.ptz = !1,
                    this.rulesWarn.talk = t.includes(this.rules[5]) && !t.includes(this.rules[2]),
                    t.includes(this.rules[3]) && !t.includes(this.rules[2]) ? this.rulesWarn.playback = !0 : this.rulesWarn.playback = !1
                }
                updateCamerasAndServers(e) {
                    this.formGroup && (this.formGroup.value.orchids = e[0],
                    this.orchidsEditing = e[0],
                    this.camerasEditing = e[1],
                    this.formGroup.value.cameras = e[1])
                }
                deletePermission() {
                    this.deletePerm.emit()
                }
                savePermission(e) {
                    this.cardType = Me.COMPLETED,
                    this._getDataForDisplaying(e.value.orchids, e.value.cameras, e.value.rules),
                    this.existingPerm = !0,
                    this._changeDetector.detectChanges()
                }
                getEditingView() {
                    this.cardType = Me.EDITING
                }
                updatePagedData(e) {
                    this.pagedData = e
                }
                handlePageEvent(e) {
                    this.pageSize = e.pageSize
                }
            }
            ;
            var fS, vS;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], gS.prototype, "columnType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], gS.prototype, "cardType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (dS = "undefined" != typeof Array && Array) ? dS : Object)], gS.prototype, "orchids", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], gS.prototype, "data", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (uS = void 0 !== p.cw && p.cw) ? uS : Object)], gS.prototype, "formGroup", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], gS.prototype, "processing", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], gS.prototype, "deletePerm", void 0),
            gS = (0,
            c.gn)([(0,
            i.Component)({
                selector: "perm-card",
                template: n(6415),
                providers: [{
                    provide: pi.ye,
                    useClass: uu
                }],
                animations: [wb, Ib]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pi.ye)), (0,
            c.fM)(1, (0,
            i.Inject)(Gt)), (0,
            c.fM)(2, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (mS = void 0 !== uu && uu) ? mS : Object, "function" == typeof (hS = Gt) ? hS : Object, "function" == typeof (pS = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? pS : Object])], gS);
            let yS = class {
                constructor() {
                    this.permissions = {
                        grant: [],
                        revoke: []
                    },
                    this.orchids = [],
                    this.processing = !1,
                    this.Type = Me,
                    this.idNumber = 0,
                    this.msgs = {}
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign({
                        name: L.messages.dashboard.name,
                        search: L.messages.dashboard.search
                    }, L.messages.dialogs), L.messages.groups, L.messages.cameras.cameraPicker),
                    this.formGroup && (this.permissionControl = this.formGroup.controls.permissions)
                }
                _initAndGetFormGroup() {
                    const e = {
                        id: void 0,
                        rules: [],
                        allOrchids: !0,
                        orchids: [],
                        cameras: []
                    };
                    return new p.cw({
                        rules: new p.NI(e.rules),
                        allOrchids: new p.NI(e.allOrchids),
                        orchids: new p.NI(e.orchids),
                        cameras: new p.NI(e.cameras),
                        id: new p.NI(e.id)
                    })
                }
                newPermission(e) {
                    "grant" === e && this.permissionControl.controls.grant.push(this._initAndGetFormGroup()),
                    "revoke" === e && this.permissionControl.controls.revoke.push(this._initAndGetFormGroup())
                }
                deletePermission(e, t) {
                    "grant" === e && (this.permissionControl.controls.grant.controls.splice(t, 1),
                    this.permissionControl.controls.grant.value.splice(t, 1)),
                    "revoke" === e && (this.permissionControl.controls.revoke.controls.splice(t, 1),
                    this.permissionControl.controls.revoke.value.splice(t, 1))
                }
            }
            ;
            function bS(e, t) {
                if (!e.selected) {
                    const n = e.cameras.find((e => e.cameraId === t));
                    n.selected = !n.selected
                }
            }
            function SS(e) {
                e.selected = !e.selected,
                e.selected ? e.allCamerasSelected = !0 : e.allCamerasSelected = !1,
                e.cameras.forEach((t => {
                    e.selected ? (t.serverSelected = !0,
                    t.selected = !1) : t.serverSelected = !1
                }
                ))
            }
            function CS(e, t, n, i) {
                if (0 !== e.length) {
                    const a = "servers"
                      , r = "cameras";
                    let s = [];
                    if (n ? e.forEach((e => {
                        const t = i.find((t => t.serverId.includes(e.serverId)));
                        t && s.push(t)
                    }
                    )) : s = e,
                    t.source.name === a && (!0 === t.checked || t.source.indeterminate ? s.forEach(( (t, i) => {
                        t.supported && (t.selected = !1,
                        SS(t),
                        n && (e[i].selected = !1,
                        SS(e[i])))
                    }
                    )) : s.forEach(( (t, i) => {
                        t.supported && (t.selected = !0,
                        SS(t),
                        n && (e[i].selected = !0,
                        SS(e[i])))
                    }
                    ))),
                    t.source.name === r)
                        if (!0 === t.checked || t.source.indeterminate) {
                            if (s.filter((e => !0 === e.selected)).forEach((e => SS(e))),
                            n) {
                                e.filter((e => !0 === e.selected)).forEach((e => SS(e)))
                            }
                            e.forEach(( (e, t) => {
                                e.supported && (e.allCamerasSelected = !0,
                                e.cameras.forEach((e => {
                                    s[t].cameras.find((t => t.id === e.id)) && (e.selected = !0)
                                }
                                )))
                            }
                            ))
                        } else
                            e.forEach(( (e, t) => {
                                e.supported && (e.allCamerasSelected = !0,
                                e.cameras.forEach((e => {
                                    s[t].cameras.find((t => t.id === e.id)) && (e.selected = !1)
                                }
                                )))
                            }
                            ))
                }
            }
            function wS(e, t) {
                return 0 !== t.length && (t.length > 0 && !IS(e, t))
            }
            function IS(e, t) {
                return t.length > 0 && e.length === t.length
            }
            function TS(e) {
                const t = e.cameras.filter((e => e.selected));
                return e.selected ? 0 : t.length
            }
            var ES, _S, xS, DS, OS, AS, RS, PS, kS;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yS.prototype, "permissions", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yS.prototype, "cardType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (fS = "undefined" != typeof Array && Array) ? fS : Object)], yS.prototype, "orchids", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (vS = void 0 !== p.cw && p.cw) ? vS : Object)], yS.prototype, "formGroup", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yS.prototype, "processing", void 0),
            yS = (0,
            c.gn)([(0,
            i.Component)({
                selector: "perm-columns",
                template: n(51911),
                animations: [bb]
            })], yS),
            function(e) {
                e.ALL = "all",
                e.SERVERS = "servers",
                e.CAMERAS = "cameras"
            }(PS || (PS = {})),
            function(e) {
                e.CARDS = "cards",
                e.TABLE = "table"
            }(kS || (kS = {}));
            let MS = class {
                constructor(e, t) {
                    this._changeDetector = e,
                    this._minimumVersionService = t,
                    this.loaded = !1,
                    this.orchids = [],
                    this.cameras = [],
                    this.editing = !1,
                    this.hideSelectAllCameras = !1,
                    this.hideSelectAllServers = !1,
                    this.pageSizeOptions = [],
                    this.pageSizeCameras = 30,
                    this.camerasOnly = !1,
                    this.onTotalDataListChange = new i.EventEmitter,
                    this.onSelectedServersChange = new i.EventEmitter,
                    this.onSelectedCamerasChange = new i.EventEmitter,
                    this.ViewTypes = kS,
                    this.viewType = kS.CARDS,
                    this.selectedData = !1,
                    this.serverData = [],
                    this.serverDataTable = [],
                    this.totalDataList = [],
                    this.messages = L.messages.cameras,
                    this.SearchOptions = PS,
                    this.advancedSearch = PS.ALL,
                    this.allDataNames = [],
                    this.filteredList = [],
                    this.filtering = !1,
                    this._searchResults = [],
                    this.searchingOptions = [],
                    this.pageSize = 16,
                    this.noData = !1,
                    this.building = !0
                }
                _createDataArray(e) {
                    this._sortServers(e),
                    e.forEach(( (e, t) => {
                        const n = this._minimumVersionService.isFeatureSupported(e, Sr.CAMERA_DISABLEMENT)
                          , i = e.cameras.map((i => {
                            var a;
                            return {
                                active: !n || null !== (a = i.active) && void 0 !== a && a,
                                cameraName: i.name,
                                cameraId: i.id,
                                serverId: e.id,
                                serverSelected: !1,
                                selected: !1,
                                orchidName: e.name,
                                orchidVersion: e.version.version,
                                index: t,
                                supported: this.orchidIsSupported(e)
                            }
                        }
                        ));
                        this._sortCameras(i),
                        this.totalDataList.push({
                            serverName: e.name,
                            serverId: e.id,
                            cameras: i,
                            rowSpan: e.cameras.length + 1,
                            index: t,
                            selected: !1,
                            allCamerasSelected: !1,
                            nextPageTotal: 0,
                            supported: this.orchidIsSupported(e),
                            version: e.version.version
                        })
                    }
                    ))
                }
                _sortServers(e) {
                    e.sort(( (e, t) => e.name.toLowerCase().localeCompare(t.name.toLowerCase())))
                }
                _sortCameras(e) {
                    e.sort(( (e, t) => Tt(e.cameraName).toLowerCase().localeCompare(Tt(t.cameraName).toLowerCase())))
                }
                _sortServerObjects(e) {
                    const t = e.filter((e => e.supported))
                      , n = e.filter((e => !e.supported));
                    return [...this._sortSelectedDataToTop(t), ...this._sortSelectedDataToTop(n)]
                }
                _sortSelectedDataToTop(e) {
                    const t = []
                      , n = [];
                    return e.forEach((e => {
                        if (e.selected)
                            t.push(e);
                        else {
                            e.cameras.some((e => e.selected)) ? t.push(e) : n.push(e)
                        }
                    }
                    )),
                    t.sort(( (e, t) => e.serverName.toLowerCase().localeCompare(t.serverName.toLowerCase()))),
                    n.sort(( (e, t) => e.serverName.toLowerCase().localeCompare(t.serverName.toLowerCase()))),
                    [...t, ...n]
                }
                ngOnInit() {
                    this.searchingOptions = [{
                        value: PS.ALL,
                        name: this.messages.cameraPicker.searchAllServersAndCameras()
                    }, {
                        value: PS.SERVERS,
                        name: this.messages.cameraPicker.searchServersOnly()
                    }, {
                        value: PS.CAMERAS,
                        name: this.messages.cameraPicker.searchCamerasOnly()
                    }],
                    this.camerasOnly && (this.advancedSearch = PS.CAMERAS,
                    this.hideSelectAllServers = !0)
                }
                ngOnChanges(e) {
                    e.loaded && e.loaded.isFirstChange() && (void 0 !== this.data && (this._createDataArray(this.data),
                    this._getAllNames(),
                    this.serverData = this.totalDataList,
                    this.serverDataTable = this._getDataTable(this.totalDataList),
                    this._selectAlreadySelected(this.totalDataList, this.orchids, this.cameras),
                    0 === this.totalDataList.length && (this.noData = !0),
                    this.building = !1),
                    this.totalDataList = this._sortServerObjects(this.totalDataList))
                }
                ngAfterViewInit() {
                    this.editing && (this.getSelectedData(),
                    this._changeDetector.detectChanges()),
                    this.camerasOnly && this.updateFilteredData(this.allDataNames)
                }
                _getAllNames() {
                    this.totalDataList.forEach((e => {
                        this.allDataNames.push(e.serverName),
                        e.cameras && e.cameras.forEach((e => this.allDataNames.push(e.cameraName)))
                    }
                    )),
                    this._searchResults = this.allDataNames
                }
                updateFilteredData(e) {
                    if (this.filteredList = [],
                    this._searchResults = e,
                    this.camerasOnly ? this._updateFilteredDataByServerAndCamera(e) : this.advancedSearch === PS.SERVERS ? this._updateFilteredDataByServer(e) : this.advancedSearch === PS.CAMERAS ? this._updateFilteredDataByCamera(e) : this._updateFilteredDataByServerAndCamera(e),
                    this._searchInput.searchTerms.includes(this.messages.cameraPicker.selectedOnly().toLocaleLowerCase())) {
                        const e = this.filteredList.map((e => {
                            if (e.selected)
                                return Object.assign({}, e);
                            {
                                const t = Object.assign(Object.assign({}, e), {
                                    cameras: e.cameras.filter((e => e.selected))
                                });
                                return t.cameras.length > 0 ? t : null
                            }
                        }
                        )).filter((e => null !== e));
                        this.filteredList = e,
                        this.filtering = !0
                    }
                    this.serverData = this.filteredList,
                    this.serverDataTable = this._getDataTable(this.filteredList)
                }
                _updateFilteredDataByServer(e) {
                    if (e.length === this.allDataNames.length)
                        return this.filteredList = this.totalDataList,
                        void (this.filtering = !1);
                    const t = new Set(e);
                    this.filteredList = this.totalDataList.filter((e => t.has(e.serverName))).map((e => Object.assign({}, e))),
                    this.filtering = !0
                }
                _updateFilteredDataByCamera(e) {
                    if (e.length === this.allDataNames.length)
                        return this.filteredList = this.totalDataList,
                        void (this.filtering = !1);
                    const t = new Set(e);
                    this.filteredList = this.totalDataList.reduce(( (e, n) => {
                        const i = n.cameras.filter((e => t.has(e.cameraName)));
                        return i.length > 0 && e.push(Object.assign(Object.assign({}, n), {
                            cameras: i
                        })),
                        e
                    }
                    ), []),
                    this.filtering = !0
                }
                _updateFilteredDataByServerAndCamera(e) {
                    if (e.length === this.allDataNames.length)
                        return this.filteredList = this.totalDataList,
                        void (this.filtering = !1);
                    const t = new Set(e);
                    this.filteredList = this.totalDataList.reduce(( (e, n) => {
                        if (t.has(n.serverName))
                            e.push(n);
                        else {
                            const i = n.cameras.filter((e => t.has(e.cameraName)));
                            i.length > 0 && e.push(Object.assign(Object.assign({}, n), {
                                cameras: i
                            }))
                        }
                        return e
                    }
                    ), []),
                    this.filtering = !0
                }
                _getDataTable(e) {
                    if (this._updateIndex(e),
                    this.advancedSearch === PS.ALL) {
                        const t = [];
                        return e.forEach((e => {
                            t.push(e),
                            e.cameras.forEach((e => {
                                t.push(e)
                            }
                            ))
                        }
                        )),
                        t
                    }
                    if (this.advancedSearch === PS.CAMERAS) {
                        const t = [];
                        return e.forEach((e => {
                            e.cameras.forEach((e => {
                                t.push(e)
                            }
                            ))
                        }
                        )),
                        t
                    }
                    return e
                }
                orchidIsSupported(e) {
                    return !this.requiredOrchidVersion || this._minimumVersionService.isFeatureSupported(e, this.requiredOrchidVersion)
                }
                _updateIndex(e) {
                    let t = 0;
                    e.forEach((e => {
                        e.index = t,
                        e.cameras.forEach((e => {
                            e.index = t
                        }
                        )),
                        t++
                    }
                    ))
                }
                getAdvancedSearchOption(e) {
                    this.advancedSearch = e.value,
                    this.updateFilteredData(this._searchResults)
                }
                getSelectedData() {
                    this._searchInput.searchTerms.includes(this.messages.cameraPicker.selectedOnly().toLocaleLowerCase()) ? this.selectedData = !0 : this.selectedData = !1,
                    this.selectedData = !this.selectedData;
                    const e = {
                        value: this.messages.cameraPicker.selectedOnly()
                    };
                    this.selectedData ? (this._searchInput.onSearchTermAdded(e),
                    this.updateFilteredData(this._searchResults)) : this._searchInput.onSearchTermRemoved(this.messages.cameraPicker.selectedOnly().toLocaleLowerCase())
                }
                _selectAlreadySelected(e, t, n) {
                    t.length > 0 && t.forEach((t => {
                        const n = e.find((e => e.serverId.includes(t)));
                        n && SS(n)
                    }
                    )),
                    n.length > 0 && n.forEach((e => {
                        const t = this.totalDataList.find((t => t.serverId === e.orchidId));
                        t && bS(t, e.id)
                    }
                    ))
                }
                sendSelectedToParent(e) {
                    const t = [[], []]
                      , n = [];
                    e.filter((e => {
                        e.selected && n.push(e.serverId)
                    }
                    ));
                    const i = [];
                    e.forEach((e => {
                        e.selected || e.cameras.filter((e => {
                            e.selected && i.push({
                                orchidId: e.serverId,
                                id: e.cameraId
                            })
                        }
                        ))
                    }
                    )),
                    t[0] = n,
                    this.onSelectedServersChange.emit(n.length),
                    t[1] = i,
                    this.onSelectedCamerasChange.emit(i.length),
                    this.onTotalDataListChange.emit(t)
                }
            }
            ;
            var LS, NS, FS;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], MS.prototype, "loaded", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (ES = "undefined" != typeof Array && Array) ? ES : Object)], MS.prototype, "data", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (_S = "undefined" != typeof Array && Array) ? _S : Object)], MS.prototype, "orchids", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (xS = "undefined" != typeof Array && Array) ? xS : Object)], MS.prototype, "cameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], MS.prototype, "editing", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], MS.prototype, "hideSelectAllCameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], MS.prototype, "hideSelectAllServers", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (DS = "undefined" != typeof Array && Array) ? DS : Object)], MS.prototype, "pageSizeOptions", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], MS.prototype, "pageSizeCameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], MS.prototype, "camerasOnly", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], MS.prototype, "requiredOrchidVersion", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], MS.prototype, "onTotalDataListChange", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], MS.prototype, "onSelectedServersChange", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], MS.prototype, "onSelectedCamerasChange", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("searchChipInput"), (0,
            c.w6)("design:type", "function" == typeof (OS = void 0 !== aa && aa) ? OS : Object)], MS.prototype, "_searchInput", void 0),
            MS = (0,
            c.gn)([(0,
            i.Component)({
                selector: "camera-picker",
                template: n(54312),
                changeDetection: i.ChangeDetectionStrategy.OnPush
            }), (0,
            c.fM)(0, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.fM)(1, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (AS = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? AS : Object, "function" == typeof (RS = void 0 !== Cr && Cr) ? RS : Object])], MS);
            let US = class {
                constructor(e, t, n) {
                    this._dataService = e,
                    this._renewableService = t,
                    this._minimumVersionService = n,
                    this.onServerSelected = new i.EventEmitter,
                    this.onCameraSelected = new i.EventEmitter,
                    this.previewUrl = "",
                    this.isServer = !1,
                    this._cameraDisablementIsSupported = !0,
                    this.messages = L.messages.cameras
                }
                ngOnInit() {
                    this._orchid = this._renewableService.findOrchid(this.dataItem.serverId),
                    !w.isOrchid && this._orchid && (this._cameraDisablementIsSupported = this._minimumVersionService.isFeatureSupported(this._orchid, Sr.CAMERA_DISABLEMENT)),
                    this.isServer = this._checkIfServer(this.dataItem),
                    this.isServer || this.getPreviewImage(this.dataItem)
                }
                _checkIfServer(e) {
                    return !!Object.prototype.hasOwnProperty.call(e, "serverName")
                }
                itemIsEnabled(e) {
                    var t;
                    return !!this.isServer || (!this._cameraDisablementIsSupported || null !== (t = e.active) && void 0 !== t && t)
                }
                getPreviewImage(e) {
                    this.previewUrl = this._dataService.cameraPreviewUrl(e.serverId, e.cameraId, j.SMALL, !0)
                }
                onClickCamera(e) {
                    this.onCameraSelected.emit(e)
                }
                onClickServer(e) {
                    this.onServerSelected.emit(e)
                }
            }
            ;
            var $S, jS;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], US.prototype, "dataItem", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], US.prototype, "onServerSelected", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], US.prototype, "onCameraSelected", void 0),
            US = (0,
            c.gn)([(0,
            i.Component)({
                selector: "preview-tile",
                template: n(6558)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(tt)), (0,
            c.fM)(1, (0,
            i.Inject)(Gt)), (0,
            c.fM)(2, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (LS = tt) ? LS : Object, "function" == typeof (NS = Gt) ? NS : Object, "function" == typeof (FS = void 0 !== Cr && Cr) ? FS : Object])], US);
            let VS = class {
                constructor(e, t) {
                    this._minimumVersionService = e,
                    this._renewableService = t,
                    this.onServerSelected = new i.EventEmitter,
                    this.onCameraSelected = new i.EventEmitter,
                    this.isServer = !1,
                    this._cameraDisablementIsSupported = !0,
                    this.messages = L.messages.cameras,
                    this.playerIcons = qt
                }
                ngOnInit() {
                    if (this.isServer = this._checkIfServer(this.dataItem),
                    !w.isOrchid) {
                        const e = this._renewableService.findOrchid(this.dataItem.serverId);
                        this._cameraDisablementIsSupported = this._minimumVersionService.isFeatureSupported(e, Sr.CAMERA_DISABLEMENT)
                    }
                }
                _checkIfServer(e) {
                    return !!Object.prototype.hasOwnProperty.call(e, "serverName")
                }
                onClickCamera(e) {
                    this.onCameraSelected.emit(e)
                }
                onClickServer(e) {
                    this.onServerSelected.emit(e)
                }
                isCameraEnabled(e) {
                    var t;
                    return !this._cameraDisablementIsSupported || null !== (t = e.active) && void 0 !== t && t
                }
            }
            ;
            var GS, BS, zS, HS, WS, qS;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], VS.prototype, "dataItem", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], VS.prototype, "onServerSelected", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], VS.prototype, "onCameraSelected", void 0),
            VS = (0,
            c.gn)([(0,
            i.Component)({
                selector: "list-item",
                template: n(22718)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Cr)), (0,
            c.fM)(1, (0,
            i.Inject)(Gt)), (0,
            c.w6)("design:paramtypes", ["function" == typeof ($S = void 0 !== Cr && Cr) ? $S : Object, "function" == typeof (jS = Gt) ? jS : Object])], VS);
            let YS = class {
                constructor(e, t) {
                    this.paginator = e,
                    this._changeDetector = t,
                    this.servers = [],
                    this.totalDataList = [],
                    this.noData = !1,
                    this.viewType = kS.CARDS,
                    this.filtering = !1,
                    this.advancedSearch = PS.ALL,
                    this.selectedData = !1,
                    this.hideSelectAllCameras = !1,
                    this.hideSelectAllServers = !1,
                    this.pageSizeOptions = [],
                    this.pageSizeCameras = 30,
                    this.camerasOnly = !1,
                    this.updated = new i.EventEmitter,
                    this.InformationIcons = zt,
                    this.ViewTypes = kS,
                    this.SearchOptions = PS,
                    this.allServers = !1,
                    this.allCameras = !1,
                    this.noCameras = !1,
                    this.showThumbnails = !1,
                    this.separatorKeysCodes = [ia.K5, ia.OC],
                    this.pagedServers = [],
                    this.length = 0,
                    this.pageSizeServers = 10,
                    this.pageSizeOptionsServers = [10, 20, 30, 50],
                    this.messages = Object.assign(Object.assign({}, L.messages.cameras), L.messages.events.orchidSelector)
                }
                ngOnInit() {
                    this.paginator.setLabel(this.messages.cameraPicker.servers())
                }
                ngOnChanges(e) {
                    (e.selectedData || e.filtering || e.servers || e.advancedSearch || e.viewType || e.totalDataList) && this.updateNumSelected()
                }
                changeView() {
                    this.showThumbnails = !this.showThumbnails
                }
                onClickServer(e) {
                    if (this.camerasOnly)
                        this.someCamerasAreSelected(e) ? e.cameras.forEach((t => {
                            t.selected || this.onClickCamera(e, t)
                        }
                        )) : e.cameras.forEach((t => {
                            this.onClickCamera(e, t)
                        }
                        ));
                    else {
                        const t = this.totalDataList.find((t => t.serverId === e.serverId));
                        t && SS(t),
                        this.updateNumSelected()
                    }
                    this._changeDetector.detectChanges()
                }
                onClickCamera(e, t) {
                    const n = this.totalDataList.find((t => t.serverId === e.serverId));
                    n && bS(n, t.cameraId),
                    this.updateNumSelected()
                }
                getTotalCamerasSelected(e) {
                    return TS(e)
                }
                onClickBulkSelect(e) {
                    CS(this.servers, e, this.filtering, this.totalDataList),
                    this.updateNumSelected()
                }
                updateNumSelected() {
                    this.allCameras = this.servers.every((e => {
                        if (0 === e.cameras.length)
                            return !0;
                        return IS(e.cameras.filter((e => e.selected)), e.cameras)
                    }
                    ));
                    const e = this.servers.every((e => 0 === e.cameras.length));
                    (0 === this.servers.length || e) && (this.allCameras = !1,
                    this.noCameras = !0),
                    e || (this.noCameras = !1),
                    this.allCameras && (this.allServers = !1);
                    const t = this.servers.filter((e => e.selected));
                    this.allServers = IS(this.servers, t),
                    this.allServers && (this.allCameras = !1),
                    this.updated.emit()
                }
                updatePagedServers(e) {
                    this.pagedServers = e
                }
                handlePageEventServers(e) {
                    this.pageSizeServers = e.pageSize
                }
                allCamerasAreSelected(e) {
                    return this.getTotalCamerasSelected(e) === e.cameras.length && e.cameras.length > 0
                }
                someCamerasAreSelected(e) {
                    const t = this.getTotalCamerasSelected(e);
                    return t < e.cameras.length && t > 0
                }
            }
            ;
            var XS, KS, ZS, JS, QS, eC, tC, nC, iC, aC, rC, sC;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (GS = "undefined" != typeof Array && Array) ? GS : Object)], YS.prototype, "servers", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (BS = "undefined" != typeof Array && Array) ? BS : Object)], YS.prototype, "totalDataList", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], YS.prototype, "noData", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], YS.prototype, "viewType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], YS.prototype, "filtering", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], YS.prototype, "advancedSearch", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], YS.prototype, "selectedData", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], YS.prototype, "hideSelectAllCameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], YS.prototype, "hideSelectAllServers", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (zS = "undefined" != typeof Array && Array) ? zS : Object)], YS.prototype, "pageSizeOptions", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], YS.prototype, "pageSizeCameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], YS.prototype, "camerasOnly", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], YS.prototype, "updated", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(ci.pp), (0,
            c.w6)("design:type", "function" == typeof (HS = void 0 !== ci.pp && ci.pp) ? HS : Object)], YS.prototype, "accordion", void 0),
            YS = (0,
            c.gn)([(0,
            i.Component)({
                selector: "picker-cards",
                template: n(69215),
                providers: [{
                    provide: pi.ye,
                    useClass: uu
                }]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pi.ye)), (0,
            c.fM)(1, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (WS = void 0 !== uu && uu) ? WS : Object, "function" == typeof (qS = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? qS : Object])], YS),
            function(e) {
                e.SERVERS = "servers",
                e.SERVERSCHECKBOX = "servers-checkbox",
                e.CAMERAS = "cameras",
                e.CAMERASCHECKBOX = "cameras-checkbox"
            }(sC || (sC = {}));
            let oC = class {
                constructor(e, t, n, a) {
                    this.paginator = e,
                    this._changeDetector = t,
                    this._minimumVersionService = n,
                    this._renewableService = a,
                    this.data = [],
                    this.servers = [],
                    this.totalDataList = [],
                    this.noData = !1,
                    this.filtering = !1,
                    this.viewType = kS.CARDS,
                    this.advancedSearch = PS.ALL,
                    this.selectedData = !1,
                    this.hideSelectAllCameras = !1,
                    this.hideSelectAllServers = !1,
                    this.updated = new i.EventEmitter,
                    this.dataSource = new Ei.by(this.data),
                    this.newData = [],
                    this.uneditedData = [],
                    this.ViewTypes = kS,
                    this.selected = "selected",
                    this.SearchOptions = PS,
                    this.messages = Object.assign(Object.assign({}, L.messages.cameras), L.messages.library),
                    this.DisplayColumns = sC,
                    this.displayedColumns = [sC.SERVERSCHECKBOX, sC.SERVERS, sC.CAMERASCHECKBOX, sC.CAMERAS],
                    this.allServers = !1,
                    this.someServers = !1,
                    this.allCameras = !1,
                    this.someCameras = !1,
                    this.allCamsDisabled = !1,
                    this.serversSelected = [],
                    this.camerasSelected = [],
                    this.loading = !0,
                    this.pageSizeOptions = [10, 20, 30, 50],
                    this.length = 0,
                    this.pageEvent = {
                        pageIndex: 0,
                        pageSize: 10,
                        length: 42
                    },
                    this.isPaginationVisible = !0,
                    this.pagedData = [],
                    this.pagedDataTotal = [],
                    this.playerIcons = qt,
                    this.sort = {
                        active: sC.SERVERS,
                        direction: "asc"
                    }
                }
                set matPaginator(e) {
                    e && this.dataSource && (this.dataSource.paginator = e)
                }
                set matSort(e) {
                    e && this.dataSource && (this.sort = e,
                    this.dataSource.sort = this.sort)
                }
                ngOnInit() {
                    this.loading = !0,
                    this._getItemsPerPageLabel(this.advancedSearch)
                }
                ngAfterViewInit() {
                    this.updateNumSelected()
                }
                ngOnChanges(e) {
                    (e.advancedSearch || e.viewType || e.selectedData || e.data) && (e.viewType ? this.loading = !1 : this.loading = !0,
                    setTimeout(( () => {
                        this.dataSource.data = this.data,
                        this._testPaginationVisible(),
                        this.newData = this.dataSource.data,
                        this.advancedSearch === PS.ALL && (this.uneditedData = [...new Set(this.dataSource.data)],
                        this.newData = this._determineServerAdded(this.newData, this.pageEvent)),
                        this.clickPaginator(this.pageEvent),
                        this.loading = !1
                    }
                    ))),
                    this._firstPage(),
                    this._displayColumnsChoice(),
                    this._getItemsPerPageLabel(this.advancedSearch)
                }
                _displayColumnsChoice() {
                    this.advancedSearch === PS.SERVERS ? this.displayedColumns = [sC.SERVERSCHECKBOX, sC.SERVERS] : this.advancedSearch === PS.CAMERAS ? this.displayedColumns = [sC.CAMERASCHECKBOX, sC.SERVERS, sC.CAMERAS] : this.displayedColumns = [sC.SERVERSCHECKBOX, sC.SERVERS, sC.CAMERASCHECKBOX, sC.CAMERAS],
                    this._testPaginationVisible()
                }
                _getItemsPerPageLabel(e) {
                    void 0 !== this.messages.cameraPicker && (e === PS.CAMERAS ? this.paginator.setLabel(this.messages.cameraPicker.cameras()) : e === PS.SERVERS ? this.paginator.setLabel(this.messages.cameraPicker.servers()) : this.paginator.setLabel(this.messages.cameraPicker.items()))
                }
                sortData(e) {
                    this._firstPage();
                    const t = [...new Set(this.newData)].slice();
                    this.newData = t.sort(( (t, n) => {
                        const i = "asc" === e.direction;
                        switch (e.active) {
                        case sC.SERVERS:
                            return this._compare(t.index, n.index, i);
                        case sC.CAMERAS:
                            return this.advancedSearch !== PS.CAMERAS ? t.serverId === n.serverId ? !t.serverName && n.serverName ? 1 : t.serverName && !n.serverName ? 0 : t.cameraName && n.cameraName ? this._compare(Tt(t.cameraName), Tt(n.cameraName), i) : 0 : 0 : this._compare(Tt(t.cameraName), Tt(n.cameraName), i);
                        default:
                            return this._compare(t.index, n.index, i)
                        }
                    }
                    )),
                    this.sort.active = e.active,
                    this.sort.direction = e.direction,
                    this.advancedSearch === PS.ALL && (this.newData = this._determineServerAdded(this.newData, this.pageEvent))
                }
                _compare(e, t, n) {
                    return e < t ? -1 * (n ? 1 : -1) : e > t ? 1 * (n ? 1 : -1) : 0 * (n ? 1 : -1)
                }
                onClickCamera(e, t) {
                    const n = this.totalDataList.find((t => t.serverId === e));
                    n && bS(n, t),
                    this.updateNumSelected()
                }
                onClickServer(e) {
                    const t = this.totalDataList.find((t => t.serverId === e.serverId));
                    t && (SS(t),
                    this.filtering && SS(e)),
                    this._changeDetector.detectChanges(),
                    this.updateNumSelected()
                }
                onClickBulkSelect(e) {
                    CS(this.servers, e, this.filtering, this.totalDataList),
                    this.updateNumSelected(),
                    e.source.name === sC.SERVERS && (this.allCameras = !1),
                    e.source.name === sC.CAMERAS && (this.allServers = !1)
                }
                getTotalCamerasSelected(e) {
                    return TS(e)
                }
                updateNumSelected() {
                    let e, t;
                    [t,this.serversSelected,e,this.camerasSelected] = this._getSelectedData(this.dataSource.data),
                    this._updateIndeterminateCheckbox(t, e),
                    this._updateSelectAll(t, e),
                    this.updated.emit()
                }
                _getSelectedData(e) {
                    const t = e.filter((e => e.serverName))
                      , n = e.filter((e => !e.serverName))
                      , i = t.filter((e => e.selected))
                      , a = n.filter((e => e.selected));
                    return [t, i, n, a]
                }
                _updateIndeterminateCheckbox(e, t) {
                    this.someServers = wS(e, this.serversSelected),
                    this.someCameras = wS(t, this.camerasSelected)
                }
                _updateSelectAll(e, t) {
                    this.allServers = IS(e, this.serversSelected),
                    this.allCameras = IS(t, this.camerasSelected),
                    this.allCamsDisabled = this.totalDataList.every((e => e.selected))
                }
                _testPaginationVisible() {
                    this.dataSource.data.length <= this.pageEvent.pageSize ? this.isPaginationVisible = !1 : this.isPaginationVisible = !0
                }
                _firstPage() {
                    this.advancedSearch === PS.ALL && (this.pageEvent.pageIndex = 0),
                    this.dataSource.paginator && (this.pageEvent.pageIndex = 0,
                    this.dataSource.paginator.firstPage())
                }
                clickPaginator(e) {
                    e.pageSize !== this.pageEvent.pageSize ? (this.uneditedData = [...new Set(this.dataSource.data)],
                    this.newData = [...new Set(this.dataSource.data)],
                    this.advancedSearch !== PS.ALL && this.advancedSearch !== PS.SERVERS || (this.loading = !0,
                    this.newData = this._determineServerAdded(this.newData, e)),
                    this.onChangePage(e),
                    this._firstPage(),
                    this.loading = !1) : this.onChangePage(e)
                }
                onChangePage(e) {
                    if (0 === this.newData.length)
                        return void (this.pagedData = []);
                    this.pageEvent = e;
                    const t = this.pageEvent.pageIndex * this.pageEvent.pageSize
                      , n = t + e.pageSize;
                    this.pagedDataTotal = this.newData,
                    this.pagedData = this.newData.slice(t, n),
                    this.advancedSearch === PS.ALL && this.pagedData.length > 0 && (this._updateRowSpan(this.pagedData),
                    this.pagedData.filter((e => e.serverName)).forEach((e => this._calcExtraCameras(e)))),
                    this.updateNumSelected(),
                    this.dataSource.data = this.newData
                }
                _updateRowSpan(e) {
                    e.filter((e => e.serverName)).forEach((t => {
                        const n = e.filter((e => e.serverId === t.serverId)).length;
                        t.rowSpan = n
                    }
                    ))
                }
                _calcExtraCameras(e) {
                    const t = this.pageEvent.pageIndex * this.pageEvent.pageSize
                      , n = this.newData.slice(0, t)
                      , i = this._filterDataByCamerasInServer(n, e).length
                      , a = this._filterDataByCamerasInServer(this.pagedData, e).length
                      , r = this._filterDataByCamerasInServer(this.newData, e).length;
                    e.rowSpan && (e.rowSpan < r ? e.nextPageTotal = r - i - a : e.nextPageTotal = 0)
                }
                _filterDataByCamerasInServer(e, t) {
                    return e.filter((e => e.serverId === t.serverId))
                }
                _determineServerAdded(e, t) {
                    let n = e.length;
                    const i = t.pageSize;
                    let a = 0;
                    for (; a < n; ) {
                        if (!e[a].serverName) {
                            const t = e[a]
                              , i = this.servers.find((e => e.serverId === t.serverId));
                            e.splice(a, 0, i),
                            n += 1
                        }
                        a += i
                    }
                    return e
                }
                isCameraEnabled(e) {
                    var t, n;
                    if (!w.isOrchid) {
                        const n = this._renewableService.findOrchid(e.serverId);
                        return !this._minimumVersionService.isFeatureSupported(n, Sr.CAMERA_DISABLEMENT) || null !== (t = e.active) && void 0 !== t && t
                    }
                    return null !== (n = e.active) && void 0 !== n && n
                }
            }
            ;
            var cC, lC;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (XS = "undefined" != typeof Array && Array) ? XS : Object)], oC.prototype, "data", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (KS = "undefined" != typeof Array && Array) ? KS : Object)], oC.prototype, "servers", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (ZS = "undefined" != typeof Array && Array) ? ZS : Object)], oC.prototype, "totalDataList", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], oC.prototype, "noData", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], oC.prototype, "filtering", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], oC.prototype, "viewType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], oC.prototype, "advancedSearch", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], oC.prototype, "selectedData", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], oC.prototype, "hideSelectAllCameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], oC.prototype, "hideSelectAllServers", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], oC.prototype, "updated", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW, {
                static: !1
            }), (0,
            c.w6)("design:type", "function" == typeof (JS = void 0 !== pi.NW && pi.NW) ? JS : Object), (0,
            c.w6)("design:paramtypes", ["function" == typeof (QS = void 0 !== pi.NW && pi.NW) ? QS : Object])], oC.prototype, "matPaginator", null),
            (0,
            c.gn)([(0,
            i.ViewChild)(Ii.YE, {
                static: !1
            }), (0,
            c.w6)("design:type", "function" == typeof (eC = void 0 !== Ii.YE && Ii.YE) ? eC : Object), (0,
            c.w6)("design:paramtypes", ["function" == typeof (tC = void 0 !== Ii.YE && Ii.YE) ? tC : Object])], oC.prototype, "matSort", null),
            oC = (0,
            c.gn)([(0,
            i.Component)({
                selector: "picker-table",
                template: n(82816),
                providers: [{
                    provide: pi.ye,
                    useClass: uu
                }]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pi.ye)), (0,
            c.fM)(1, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.fM)(2, (0,
            i.Inject)(Cr)), (0,
            c.fM)(3, (0,
            i.Inject)(Gt)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (nC = void 0 !== uu && uu) ? nC : Object, "function" == typeof (iC = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? iC : Object, "function" == typeof (aC = void 0 !== Cr && Cr) ? aC : Object, "function" == typeof (rC = Gt) ? rC : Object])], oC);
            let dC = class {
                constructor(e) {
                    this.paginator = e,
                    this.showThumbnails = !1,
                    this.advancedSearch = PS.ALL,
                    this.pageSizeOptions = [],
                    this.pageSizeCameras = 30,
                    this.serverClicked = new i.EventEmitter,
                    this.cameraClicked = new i.EventEmitter,
                    this.cameraNames = [],
                    this.filteredCameras = [],
                    this.pagedCamerasArray = [],
                    this.pageSizeOptionsCameras = [10, 20, 30, 50],
                    this.messages = L.messages.cameras
                }
                ngOnInit() {
                    this.paginator.setLabel(this.messages.cameraPicker.cameras()),
                    this._getCameraNames(this.server);
                    const e = {
                        target: {
                            innerWidth: window.innerWidth
                        }
                    };
                    this.onResize(e)
                }
                ngOnChanges(e) {
                    e.advancedSearch && (this.advancedSearch === PS.CAMERAS ? this.filteredCameras = this.server.cameras : this.filteredCameras = [this.server].concat(this.server.cameras))
                }
                _getCameraNames(e) {
                    e.cameras.map((e => {
                        this.cameraNames.push(e.cameraName)
                    }
                    )),
                    this.cameraNames.unshift(this.messages.motionStyles.server())
                }
                updateFilteredData(e) {
                    this.filteredCameras = [],
                    e.includes(this.messages.motionStyles.server()) && this.advancedSearch !== PS.CAMERAS && this.filteredCameras.push(this.server),
                    this.server.cameras.forEach((t => {
                        e.includes(t.cameraName) && this.filteredCameras.push(t)
                    }
                    ))
                }
                updatePagedCameras(e) {
                    this.pagedCamerasArray = e
                }
                handlePageEventCameras(e) {
                    this.pageSizeCameras = e.pageSize
                }
                onClickCamera(e) {
                    this.cameraClicked.emit(e)
                }
                onClickServer(e) {
                    this.serverClicked.emit(e)
                }
                getPageSizeOptions() {
                    return [new mu([10, 20, 30, 50],(e => e > 1362),{
                        10: 10,
                        12: 10,
                        24: 20,
                        20: 20,
                        32: 30,
                        30: 30,
                        51: 50,
                        52: 50,
                        50: 50
                    }), new mu([12, 24, 32, 52],(e => e <= 1362 && 1117 <= e || e <= 1e3 && e > 880),{
                        10: 12,
                        12: 12,
                        20: 24,
                        24: 24,
                        30: 32,
                        32: 32,
                        50: 52,
                        51: 52,
                        52: 52
                    }), new mu([12, 24, 30, 51],(e => e <= 880 && e > 680 || e < 1117 && e > 1e3),{
                        10: 12,
                        12: 12,
                        20: 24,
                        24: 24,
                        32: 30,
                        30: 30,
                        50: 51,
                        52: 51,
                        51: 51
                    }), new mu([10, 20, 30, 50],(e => e <= 680),{
                        12: 10,
                        10: 10,
                        24: 20,
                        20: 20,
                        32: 30,
                        30: 30,
                        51: 50,
                        52: 50,
                        50: 50
                    })]
                }
                onResize(e) {
                    const t = e.target.innerWidth;
                    0 === this.pageSizeOptions.length && (this.pageSizeOptions = this.getPageSizeOptions()),
                    this.pageSizeOptions.forEach((e => {
                        e.test(t) && (this.pageSizeOptionsCameras = e.options,
                        this.pageSizeCameras = e.pageMap[this.pageSizeCameras])
                    }
                    ))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], dC.prototype, "showThumbnails", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], dC.prototype, "server", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], dC.prototype, "advancedSearch", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (cC = "undefined" != typeof Array && Array) ? cC : Object)], dC.prototype, "pageSizeOptions", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], dC.prototype, "pageSizeCameras", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], dC.prototype, "serverClicked", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], dC.prototype, "cameraClicked", void 0),
            dC = (0,
            c.gn)([(0,
            i.Component)({
                selector: "picker-card-contents",
                template: n(66475),
                providers: [{
                    provide: pi.ye,
                    useClass: uu
                }]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pi.ye)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (lC = void 0 !== uu && uu) ? lC : Object])], dC);
            let uC = class {
                constructor() {
                    this.msgs = L.messages.userManager
                }
            }
            ;
            var mC, hC, pC, gC, fC;
            uC = (0,
            c.gn)([(0,
            i.Component)({
                selector: "orchid-roles",
                template: n(65993)
            })], uC);
            const vC = O("PlayerFrameDownloader");
            let yC = class {
                constructor(e, t, n, i) {
                    this._datePipe = e,
                    this._downloaderService = t,
                    this._matDialog = n,
                    this._timeService = i,
                    this.msgs = L.messages.player,
                    this.formats = L.formats.library,
                    this.time = Date.now()
                }
                _formatFileName(e) {
                    const t = this.cameraName.replace(/ /g, "_")
                      , n = this._datePipe.transform(new Date(this.time - e), this.formats.fileName, "+0000");
                    return this.msgs.cameraCAMERANAMEfromTIMESTAMPdotEXTENSION({
                        CAMERANAME: t,
                        TIMESTAMP: n,
                        EXTENSION: "jpeg"
                    })
                }
                downloadFrame() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        try {
                            const e = yield this._timeService.getOrchidTimeOffsetPromise(this.orchid.id)
                              , t = this.image.toDataURL("image/jpeg", 1)
                              , n = () => this._formatFileName(e);
                            this._downloaderService.createDownloader(n).download(t)
                        } catch (e) {
                            vC.error(`Failed to download player frame: ${e}`);
                            const t = {
                                data: {
                                    title: this.msgs.error(),
                                    message: this.msgs.failedToDownloadImageFromPlayer(),
                                    okText: this.msgs.ok()
                                }
                            };
                            this._matDialog.open(Id, t)
                        }
                    }
                    ))
                }
            }
            ;
            function bC(e, t, i, a) {
                return {
                    restrict: "E",
                    scope: {
                        forceBreak: "=",
                        orchid: "=",
                        loading: "="
                    },
                    template: n(93898),
                    link: function(n) {
                        n.diskUtilization = {
                            animate: !1,
                            active: !0,
                            type: "info",
                            usedByOrchid: 0,
                            usedByOthers: 0,
                            percentageUsedByOrchid: 100,
                            percentageUsedOthers: 0,
                            thresholdPercentage: 100,
                            error: "",
                            loadingUtesBar: !0
                        },
                        n.diskUtilization.msgs = L.messages,
                        n.freeOutOf = function(e, t) {
                            if (void 0 !== e && void 0 !== t)
                                return n.diskUtilization.msgs.system.freeOutOf({
                                    FREE: i.transform(e),
                                    CAPACITY: i.transform(t)
                                })
                        }
                        ,
                        n.hasSessionId = function(e) {
                            return a.hasSessionId(e)
                        }
                        ,
                        t.getDiskUtilization(n.orchid).then((function(t) {
                            n.diskUtilization.capacity = t.data.storage.capacity,
                            n.diskUtilization.free = t.data.storage.free,
                            n.diskUtilization.threshold = i.transform(t.data.cleanerThreshold + t.data.storage.unavailable),
                            n.diskUtilization.usedByOrchid = i.transform(t.data.archivesSize),
                            n.diskUtilization.usedByOthers = i.transform(t.data.storage.unavailable),
                            n.diskUtilization.animate = !0,
                            e((function() {
                                n.diskUtilization.type = "success",
                                n.diskUtilization.percentageUsedByOrchid = t.data.archivesSize / t.data.storage.capacity * 100,
                                n.diskUtilization.percentageUsedByOthers = t.data.storage.unavailable / t.data.storage.capacity * 100,
                                n.diskUtilization.thresholdPercentage = (t.data.cleanerThreshold + t.data.storage.unavailable) / t.data.storage.capacity * 100,
                                n.diskUtilization.animate = !1,
                                n.diskUtilization.active = !1,
                                n.loading = !1
                            }
                            ), 150)
                        }
                        )).catch((function(e) {
                            e.data && e.data.reason ? n.diskUtilization.error = e.data.reason : n.diskUtilization.error = n.diskUtilization.msgs.system.failedToLoadDiskUtilization()
                        }
                        )).finally((function() {
                            n.diskUtilization.loadingUtesBar = !1
                        }
                        ))
                    }
                }
            }
            var SC, CC, wC, IC, TC, EC, _C, xC, DC, OC, AC;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], yC.prototype, "cameraName", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], yC.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (mC = "undefined" != typeof HTMLCanvasElement && HTMLCanvasElement) ? mC : Object)], yC.prototype, "image", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Number)], yC.prototype, "time", void 0),
            yC = (0,
            c.gn)([(0,
            i.Component)({
                selector: "player-frame-downloader",
                template: n(37407)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(l.uU)), (0,
            c.fM)(1, (0,
            i.Inject)(ih)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(3, (0,
            i.Inject)(ug)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (hC = void 0 !== l.uU && l.uU) ? hC : Object, "function" == typeof (pC = void 0 !== ih && ih) ? pC : Object, "function" == typeof (gC = void 0 !== hn.uw && hn.uw) ? gC : Object, "function" == typeof (fC = void 0 !== ug && ug) ? fC : Object])], yC),
            o().module("ipconfigure.orchid.singularity").directive("diskUtesBar", bC),
            bC.$inject = ["$timeout", "OrchidDataService", "BytesPipe", "SessionIdService"];
            const RC = O("SystemStatus");
            var PC, kC;
            !function(e) {
                e.CHEVRON = "chevron",
                e.NAME = "name",
                e.BITRATE = "bitrate",
                e.STATUS = "status",
                e.LAST_ARCHIVE = "lastArchive",
                e.ACTIONS = "actions"
            }(PC || (PC = {})),
            function(e) {
                e.NORMAL = "normal",
                e.DEGRADED = "degraded",
                e.PENDING_CHANGE = "pending_change"
            }(kC || (kC = {}));
            let MC = class {
                constructor(e, t, n, i, a, r, s, o) {
                    this._authService = e,
                    this._matDialog = t,
                    this._orchidDataService = n,
                    this._renewableService = i,
                    this._timeDurationPipe = a,
                    this._timeService = r,
                    this._sessionIdService = s,
                    this._minimumVersionService = o,
                    this.msgs = Object.assign(Object.assign({}, L.messages.system), L.messages.common),
                    this.statusMsgs = L.messages.statuses,
                    this.defaultSort = {
                        id: PC.NAME,
                        start: "asc",
                        disableClear: !0
                    },
                    this.displayedColumns = [PC.CHEVRON, PC.NAME, PC.BITRATE, PC.STATUS, PC.LAST_ARCHIVE, PC.ACTIONS],
                    this.isOrchid = w.isOrchid,
                    this.cameraMeta = [],
                    this.dataSource = new Ei.by,
                    this.loading = !1,
                    this.utesLoading = !1,
                    this.streamTableError = !1,
                    this.orchidLicenseIsDegraded = !1,
                    this.cameraDisablementIsSupported = !0,
                    this.isAdmin = this._authService.getAuthenticationData().isAdministrator(),
                    this.playerIcons = qt,
                    this._updatingStreams = !1,
                    this.orchidCameraChangeSub = Ql.E.subscribe(),
                    this.updateStreamsTimerSub = Ql.E.subscribe(),
                    this.updateStreamsInterval = (0,
                    Jl.F)(1e3)
                }
                get SystemStatusTableColumns() {
                    return PC
                }
                get failedToLoadStreams() {
                    return !this.orchidLicenseIsDegraded && this.orchid.cameras && this.orchid.cameras.length > 0 && !this.loading && !this.utesLoading && this.streamTableError || void 0 === this.orchid.cameras
                }
                get orchidHasNoActiveStreams() {
                    return this.orchid.cameras && 0 === this.orchid.cameras.length && !this.loading && !this.utesLoading
                }
                statusTrans(e) {
                    const t = this.statusMsgs[e];
                    return t ? t() : e
                }
                fetchActiveStreams() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        return this._orchidDataService.getStreams(this.orchid).then((e => {
                            if (e.data && e.data.streams) {
                                this.cameraMeta = [];
                                const t = e.data.streams;
                                this.orchid.cameras.forEach((e => {
                                    const n = [];
                                    void 0 !== e.primaryStream && Object.keys(e.primaryStream).length > 0 && n.push(Object.assign(Object.assign({}, e.primaryStream), {
                                        streamStatus: this.isCameraEnabled(e) ? "?" : "-",
                                        processingStatus: !1,
                                        processStatusAfter: Date.now(),
                                        isPrimaryStream: !0
                                    })),
                                    e.secondaryStreams && e.secondaryStreams.length > 0 && e.secondaryStreams.forEach((i => {
                                        n.push(Object.assign(Object.assign({}, t.find((e => e.id === i.id))), {
                                            streamStatus: this.isCameraEnabled(e) ? "?" : "-",
                                            processingStatus: !1,
                                            processStatusAfter: Date.now(),
                                            isPrimaryStream: !1
                                        }))
                                    }
                                    )),
                                    this.cameraMeta.push(Object.assign(Object.assign({}, e), {
                                        streamBitrateSum: 0,
                                        streamBitrateSumHumanized: "-",
                                        activeStreams: n,
                                        processingVerify: !1,
                                        verifyResult: void 0,
                                        rowExpanded: !1,
                                        runningStreams: 0,
                                        lastArchiveWrittenIssue: !0,
                                        allStreamsAreProxyOnly: !0
                                    }))
                                }
                                ))
                            }
                            this.refreshTableView()
                        }
                        ))
                    }
                    ))
                }
                updateStreams() {
                    if (!this._updatingStreams) {
                        this._updatingStreams = !0;
                        const e = {}
                          , t = {}
                          , n = this._orchidDataService.getStreamStati(this.orchid)
                          , i = this._orchidDataService.getStreams(this.orchid);
                        Promise.all([n, i]).then((n => {
                            n[0].data.streams.forEach((t => {
                                e[t.id] = t
                            }
                            )),
                            n[1].data.streams.forEach((e => {
                                t[e.id] = e
                            }
                            )),
                            this.cameraMeta.forEach((n => {
                                n.activeStreams.forEach((i => {
                                    (i.isPrimaryStream && "PROXY_ONLY_MODE" !== i.recordingConfiguration.mode || !i.isPrimaryStream && !0 === i.recordWhenSecondary) && (n.allStreamsAreProxyOnly = !1),
                                    !0 !== i.processingStatus && i.processStatusAfter < Date.now() && e[i.id] && this.updateStreamStatus(i, t[i.id], e[i.id], n)
                                }
                                ))
                            }
                            ))
                        }
                        )).catch((e => {
                            e.data && e.data.reason ? RC.error(`Failed to update streams: ${e.data.reason}`) : RC.error("Failed to update streams: Unknown error.")
                        }
                        )).finally(( () => {
                            this._updatingStreams = !1
                        }
                        ))
                    }
                }
                _streamCannotHaveArchives(e, t, n) {
                    return this.cameraDisablementIsSupported ? e.active && t.isPrimaryStream && "PROXY_ONLY_MODE" === n.recordingConfiguration.mode || !t.isPrimaryStream && !1 === n.recordWhenSecondary : t.isPrimaryStream && "PROXY_ONLY_MODE" === n.recordingConfiguration.mode || !t.isPrimaryStream && !1 === n.recordWhenSecondary
                }
                isCameraEnabled(e) {
                    var t;
                    return !this.cameraDisablementIsSupported || null !== (t = e.active) && void 0 !== t && t
                }
                updateStreamStatus(e, t, n, i) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this.isCameraEnabled(i) && void 0 !== n.streamStatistics[2].video && (e.averageBitrate = n.streamStatistics[2].video.averageBitsPerSecond,
                        e.averageBitrateHumanized = (new Ja).transform(e.averageBitrate.toString())),
                        e.streamStatus = n.streamState,
                        e.retryCount = "number" == typeof n.retryCount ? n.retryCount : "?",
                        this._streamCannotHaveArchives(i, e, t))
                            e.lastArchiveWrittenIssue = !1,
                            e.lastArchiveWrittenHumanized = this.msgs.na();
                        else if (n.lastArchiveWritten)
                            try {
                                const t = yield this._timeService.getOrchidTimeOffsetPromise(this.orchid.id);
                                e.lastArchiveWritten = Date.now() - t - n.lastArchiveWritten,
                                e.lastArchiveWrittenIssue = n.lastArchiveWritten <= Date.now() - t - 6e4,
                                e.lastArchiveWrittenHumanized = this._timeDurationPipe.transform(e.lastArchiveWritten, !0)
                            } catch (t) {
                                t instanceof Error ? RC.error(`Failed to update last archive for stream ${e.name}: ${t.message}`) : RC.error(`Failed to update last archive for stream ${e.name}: Unknown error.`)
                            }
                        else
                            e.lastArchiveWrittenIssue = !0,
                            e.lastArchiveWrittenHumanized = this.msgs.never();
                        e.processingStatus = !1,
                        e.processStatusAfter = Date.now() + ("running" === e.streamStatus ? 3e4 : 2e3),
                        this.updateCameraMeta(i)
                    }
                    ))
                }
                updateCameraMeta(e) {
                    if (e.activeStreams.length > 0) {
                        let t, n = 0, i = 0;
                        e.activeStreams.forEach((e => {
                            e.averageBitrate && (n += e.averageBitrate),
                            "running" === e.streamStatus && i++,
                            e.lastArchiveWritten && (void 0 === t || e.lastArchiveWritten < t) && (t = e.lastArchiveWritten)
                        }
                        )),
                        e.activeStreams.length > 0 && e.activeStreams.filter((e => !0 === e.lastArchiveWrittenIssue)).length > 0 ? e.lastArchiveWrittenIssue = !0 : e.lastArchiveWrittenIssue = !1,
                        e.streamBitrateSum = n,
                        e.streamBitrateSumHumanized = (new Ja).transform(n.toString()),
                        e.runningStreams = i,
                        this.refreshTableView()
                    }
                }
                previewStream(e, t) {
                    const n = {
                        panelClass: "custom-stream-preview-dialog-container",
                        data: {
                            camera: e,
                            orchid: this.orchid,
                            streamId: t
                        }
                    };
                    this._matDialog.open(ss, n)
                }
                restartStream(e, t) {
                    const n = {
                        primaryStream: {
                            id: e.id
                        }
                    };
                    e.streamStatus = "restarting",
                    e.processStatusAfter = Date.now() + 6e4;
                    (this.isOrchid ? this._orchidDataService.fetchVersionInfo().then((e => e.data.version)) : Promise.resolve(this.orchid.version.version)).then((i => {
                        const [a,r] = i.split(".");
                        0 === parseInt(a) ? this._newRestartStream(e, t) : parseInt(a) <= 21 && parseInt(r) < 12 || parseInt(a) < 21 && parseInt(r) <= 12 ? this._oldRestartStream(e, t, n) : this._newRestartStream(e, t)
                    }
                    ))
                }
                _newRestartStream(e, t) {
                    this._orchidDataService.restartStream(this.orchid, t, e).then(( () => {
                        e.processStatusAfter = Date.now() + 500
                    }
                    )).catch((t => {
                        t.data && t.data.reason ? RC.error(`Failed to restart stream ${e.name}: ${t.data.reason}`) : RC.error(`Failed to restart stream ${e.name}: Unknown error.`),
                        e.streamStatus = "unableToRetrieve"
                    }
                    ))
                }
                _oldRestartStream(e, t, n) {
                    this._orchidDataService.updateCamera(this.orchid, t, n).then(( () => {
                        e.processStatusAfter = Date.now() + 500
                    }
                    )).catch((t => {
                        t.data && t.data.reason ? RC.error(`Failed to restart stream ${e.name}: ${t.data.reason}`) : RC.error(`Failed to restart stream ${e.name}: Unknown error.`),
                        e.streamStatus = "unableToRetrieve"
                    }
                    ))
                }
                _showVerifyCameraErrorDialog(e) {
                    const t = {
                        data: {
                            title: this.msgs.verifyCameraVALUE({
                                VALUE: e
                            }),
                            message: this.msgs.failedToVerifyVALUE({
                                VALUE: e
                            }),
                            okText: this.msgs.ok()
                        }
                    };
                    this._matDialog.open(Id, t)
                }
                verifyCamera(e, t) {
                    t.stopPropagation(),
                    e.verifyResult = void 0,
                    e.processingVerify = !0,
                    this._orchidDataService.verifyCamera(this.orchid, e).then((t => {
                        void 0 !== t.success ? ("string" == typeof t.success && (t.success = "true" === t.success),
                        e.verifyResult = t.success) : this._showVerifyCameraErrorDialog(e.name)
                    }
                    )).catch(( () => {
                        this._showVerifyCameraErrorDialog(e.name)
                    }
                    )).finally(( () => {
                        e.processingVerify = !1
                    }
                    ))
                }
                refreshTableView() {
                    this.dataSource.data = this.cameraMeta,
                    this.table && this.table.renderRows()
                }
                _sortStreams(e) {
                    return function(t, n) {
                        return e.active === PC.NAME ? (t.name.toUpperCase() < n.name.toUpperCase() ? -1 : 1) * ("asc" === e.direction ? 1 : -1) : e.active === PC.BITRATE ? t.averageBitrate && n.averageBitrate ? (t.averageBitrate < n.averageBitrate ? -1 : 1) * ("asc" === e.direction ? 1 : -1) : void 0 === t.averageBitrate && void 0 !== n.averageBitrate ? -1 * ("asc" === e.direction ? 1 : -1) : void 0 !== t.averageBitrate && void 0 === n.averageBitrate ? 1 * ("asc" === e.direction ? 1 : -1) : (void 0 === t.averageBitrate && n.averageBitrate,
                        0) : e.active === PC.LAST_ARCHIVE ? t.lastArchiveWritten && n.lastArchiveWritten ? (t.lastArchiveWritten < n.lastArchiveWritten ? -1 : 1) * ("asc" === e.direction ? 1 : -1) : void 0 === t.lastArchiveWritten && void 0 !== n.lastArchiveWritten ? -1 * ("asc" === e.direction ? 1 : -1) : void 0 !== t.lastArchiveWritten && void 0 === n.lastArchiveWritten ? 1 * ("asc" === e.direction ? 1 : -1) : (void 0 === t.lastArchiveWritten && n.lastArchiveWritten,
                        0) : (t.name.toUpperCase() < n.name.toUpperCase() ? -1 : 1) * ("asc" === e.direction ? 1 : -1)
                    }
                }
                toggleCameraExpanded(e) {
                    e.activeStreams.length > 0 && (!1 === e.rowExpanded ? (e.activeStreams.sort(this._sortStreams(this.sort)),
                    e.rowExpanded = !0) : e.rowExpanded = !1)
                }
                onSortChange(e) {
                    this.cameraMeta.forEach((t => {
                        !0 === t.rowExpanded && t.activeStreams.sort(this._sortStreams(e))
                    }
                    )),
                    this.refreshTableView(),
                    this.nestedTable && this.nestedTable.renderRows()
                }
                _initSorting() {
                    setTimeout(( () => {
                        this.dataSource.sort = this.sort,
                        this.dataSource.sortingDataAccessor = (e, t) => t === PC.NAME ? Tt(e.name) : t === PC.BITRATE ? e.streamBitrateSum : t === PC.LAST_ARCHIVE ? e.lastArchiveWrittenIssue ? -1 : 1 : t === PC.STATUS ? e.activeStreams.length : e.name.toUpperCase()
                    }
                    ))
                }
                ngOnInit() {
                    this.loading = !0,
                    this.utesLoading = !0;
                    const e = this.orchid.discoverableOrchid;
                    this.orchidLicenseIsDegraded = e.licenseSession.state.status === kC.DEGRADED,
                    this.isOrchid || (this.cameraDisablementIsSupported = this._minimumVersionService.isFeatureSupported(this.orchid, Sr.CAMERA_DISABLEMENT),
                    this.orchidCameraChangeSub = this._renewableService.messages$.pipe((0,
                    ra.h)(( () => !this.loading)), (0,
                    ra.h)((e => ("CAMERA_ADDED" === e.eventType || "CAMERA_REMOVED" === e.eventType || "CAMERA_MODIFIED" === e.eventType) && e.cameraResponse.orchidId === this.orchid.id))).subscribe(( () => {
                        this.fetchActiveStreams().then(( () => {
                            this.updateStreams()
                        }
                        ))
                    }
                    ))),
                    this.fetchActiveStreams().then(( () => {
                        this.updateStreams(),
                        this._initSorting(),
                        this.updateStreamsTimerSub = this.updateStreamsInterval.subscribe(( () => {
                            this.updateStreams()
                        }
                        )),
                        this.loading = !1,
                        this.utesLoading = !1
                    }
                    )).catch(( () => {
                        this.loading = !1,
                        this.utesLoading = !1,
                        this.streamTableError = !0
                    }
                    ))
                }
                getVerifyStatus(e) {
                    return e ? "success" : !1 === e ? "fail" : "primary"
                }
                hasSessionId() {
                    return this._sessionIdService.hasSessionId(this.orchid.id)
                }
                ngOnDestroy() {
                    this.orchidCameraChangeSub.unsubscribe(),
                    this.updateStreamsTimerSub.unsubscribe()
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], MC.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(Ii.YE), (0,
            c.w6)("design:type", "function" == typeof (SC = void 0 !== Ii.YE && Ii.YE) ? SC : Object)], MC.prototype, "sort", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("systemStatusTable"), (0,
            c.w6)("design:type", "function" == typeof (CC = void 0 !== Ei.BZ && Ei.BZ) ? CC : Object)], MC.prototype, "table", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("nestedStreamsTable"), (0,
            c.w6)("design:type", "function" == typeof (wC = void 0 !== Ei.BZ && Ei.BZ) ? wC : Object)], MC.prototype, "nestedTable", void 0),
            MC = (0,
            c.gn)([(0,
            i.Component)({
                selector: "system-status",
                template: n(33931)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(xe)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(2, (0,
            i.Inject)(pt)), (0,
            c.fM)(3, (0,
            i.Inject)(Gt)), (0,
            c.fM)(4, (0,
            i.Inject)(yl)), (0,
            c.fM)(5, (0,
            i.Inject)(ug)), (0,
            c.fM)(6, (0,
            i.Inject)(ur)), (0,
            c.fM)(7, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (IC = void 0 !== xe && xe) ? IC : Object, "function" == typeof (TC = void 0 !== hn.uw && hn.uw) ? TC : Object, "function" == typeof (EC = pt) ? EC : Object, "function" == typeof (_C = Gt) ? _C : Object, "function" == typeof (xC = void 0 !== yl && yl) ? xC : Object, "function" == typeof (DC = void 0 !== ug && ug) ? DC : Object, "function" == typeof (OC = void 0 !== ur && ur) ? OC : Object, "function" == typeof (AC = void 0 !== Cr && Cr) ? AC : Object])], MC);
            let LC = class {
                constructor() {
                    this.volume = 0,
                    this.onVolumeChange = new i.EventEmitter,
                    this.buttonClass = "fa-volume-off"
                }
                ngOnInit() {
                    this.buttonClass = 0 === this.volume ? "fa-volume-off" : .5 === this.volume ? "fa-volume-down" : "fa-volume-up"
                }
                doVolumeChange() {
                    switch (this.volume) {
                    case 0:
                        this.volume = .5,
                        this.buttonClass = "fa-volume-down";
                        break;
                    case .5:
                        this.volume = 1,
                        this.buttonClass = "fa-volume-up";
                        break;
                    case 1:
                        this.volume = 0,
                        this.buttonClass = "fa-volume-off"
                    }
                    this.onVolumeChange.emit(this.volume)
                }
            }
            ;
            var NC, FC;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], LC.prototype, "volume", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], LC.prototype, "onVolumeChange", void 0),
            LC = (0,
            c.gn)([(0,
            i.Component)({
                selector: "volume-button",
                template: n(47847)
            })], LC);
            let UC = class {
                constructor(e, t) {
                    this._brandService = e,
                    this._appService = t,
                    this.appName = this._brandService.brand.APP_LOGO_TEXT,
                    this.logoUrl = "./images/header_logo.svg"
                }
                ngOnInit() {
                    this.licenseSub = this._appService.license$.subscribe((e => this.appLicense = e))
                }
                ngOnDestroy() {
                    this.licenseSub && this.licenseSub.unsubscribe()
                }
            }
            ;
            var $C;
            UC = (0,
            c.gn)([(0,
            i.Component)({
                selector: "logo",
                template: n(25379)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Hm)), (0,
            c.fM)(1, (0,
            i.Inject)(tf)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (NC = void 0 !== Hm && Hm) ? NC : Object, "function" == typeof (FC = void 0 !== tf && tf) ? FC : Object])], UC);
            let jC = class {
                constructor(e) {
                    this._renewableService = e,
                    this.msgs = L.messages.userManager,
                    this.log = O("users"),
                    this.loading = !0,
                    this.failedToLoad = !1
                }
                ngOnInit() {
                    this._getOrchidData()
                }
                _getOrchidData() {
                    this._renewableService.orchidsPromise().then((e => {
                        this.orchid = e[0],
                        this.loading = !1
                    }
                    )).catch((e => {
                        this.log.error("Failed to get Orchid Data", e),
                        this.failedToLoad = !0
                    }
                    ))
                }
            }
            ;
            var VC;
            jC = (0,
            c.gn)([(0,
            i.Component)({
                selector: "orchid-users",
                template: n(29525)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Gt)), (0,
            c.w6)("design:paramtypes", ["function" == typeof ($C = Gt) ? $C : Object])], jC);
            let GC = class {
                constructor(e) {
                    this._fusionDataService = e,
                    this.msgs = L.messages.userManager,
                    this.log = O("users"),
                    this.groups = [],
                    this.loading = !0,
                    this.failedToLoad = !1
                }
                ngOnInit() {
                    this._getGroupsData()
                }
                _getGroupsData() {
                    this._fusionDataService.fetchGroupSummaries(1e6, 0).then((e => {
                        this.groups = e.data,
                        this.loading = !1
                    }
                    )).catch((e => {
                        this.log.error("Failed to Get User Groups"),
                        this.failedToLoad = !0
                    }
                    ))
                }
            }
            ;
            var BC, zC;
            GC = (0,
            c.gn)([(0,
            i.Component)({
                selector: "fusion-users",
                template: n(80620)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Qe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (VC = Qe) ? VC : Object])], GC);
            const HC = "https://www.orchidsecurity.com/activation/"
              , WC = "application/x-www-form-urlencoded";
            let qC = class {
                constructor(e, t) {
                    this._orchidDataService = e,
                    this._http = t
                }
                activate(e, t) {
                    return this._orchidDataService.createLicense(e, {
                        license: t
                    })
                }
                getActivatedLicense(e, t, n) {
                    const i = {
                        activation_code: e,
                        machine_id: t,
                        location_description: n,
                        headless: 1
                    };
                    return (0,
                    dt.z)(this._http.post(HC, this._transformRequest(i), {
                        headers: {
                            "Content-Type": WC
                        }
                    })).then((e => "success" === e.status ? e : Promise.reject(e)))
                }
                getUpgradedLicense(e, t) {
                    const n = {
                        renewal_code: e,
                        activation_code: t,
                        headless: 1
                    };
                    return (0,
                    dt.z)(this._http.post("https://www.orchidsecurity.com/activation?action=renew", this._transformRequest(n), {
                        headers: {
                            "Content-Type": WC
                        }
                    })).then((e => "success" === e.status ? e : Promise.reject(e)))
                }
                pingOrchidSecurity() {
                    return (0,
                    dt.z)(this._http.get(HC, {
                        observe: "body",
                        responseType: "text"
                    }).pipe((0,
                    ut.V)(5e3)))
                }
                _transformRequest(e) {
                    const t = [];
                    for (const n in e)
                        t.push(encodeURIComponent(n) + "=" + encodeURIComponent(e[n]));
                    return t.join("&")
                }
            }
            ;
            var YC, XC, KC, ZC, JC;
            qC = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.fM)(0, (0,
            i.Inject)(pt)), (0,
            c.fM)(1, (0,
            i.Inject)(lt.eN)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (BC = pt) ? BC : Object, "function" == typeof (zC = void 0 !== lt.eN && lt.eN) ? zC : Object])], qC);
            let QC = YC = class {
                constructor(e, t, n, i) {
                    this._activationService = e,
                    this._dialogData = t,
                    this._matDialogRef = n,
                    this._appService = i,
                    this.dialogMsgs = L.messages.dialogs,
                    this.msgs = Object.assign(Object.assign({}, L.messages.dialogs.licenseDialog), L.messages.errors),
                    this.orchid = this._dialogData.orchid,
                    this.license = this._dialogData.license,
                    this.silentActivation = !0,
                    this.orchidSecurityUnreachable = !1,
                    this.checkingForConnectivity = !1,
                    this._pingActivationService(),
                    this.isActivated = "trial" !== this.license.edition,
                    this.error = void 0,
                    this.processing = !1,
                    this.currentTabIndex = 0,
                    this.activationKey = "",
                    this.ACTIVATION_CODE_PATTERN = "^[a-zA-Z0-9]{5}(?:-[a-zA-Z0-9]{5}){3}$",
                    this.ACTIVATION_OR_UPGRADE_CODE_PATTERN = "^([a-zA-Z0-9]{5}(?:-[a-zA-Z0-9]{5}){3}|[a-zA-Z0-9]{4}(?:-[a-zA-Z0-9]{4}){3})$",
                    this.activationForm = new p.cw({
                        activationCode: new p.NI(void 0,[p.kI.pattern(this.isActivated ? this.ACTIVATION_OR_UPGRADE_CODE_PATTERN : this.ACTIVATION_CODE_PATTERN), p.kI.required]),
                        location: new p.NI(void 0,[p.kI.pattern(/\S/)])
                    })
                }
                static show(e, t) {
                    return e.open(YC, {
                        data: t,
                        disableClose: !0,
                        panelClass: "add-license-dialog-custom-panel-class"
                    }).afterClosed().pipe((0,
                    pn.q)(1))
                }
                onTabChange(e) {
                    this.error = void 0,
                    this.currentTabIndex = e.index,
                    1 === e.index ? (this.activationForm.markAsUntouched(),
                    this.silentActivation = !1) : this.silentActivation = !0
                }
                onAnimationDone() {
                    var e;
                    1 === this.currentTabIndex ? this._licenseKey.nativeElement.focus() : null === (e = document.getElementById("formFocus1")) || void 0 === e || e.focus()
                }
                activate() {
                    this.processing = !0,
                    this._getLicense().then((e => {
                        e.license && this._activationService.activate(this.orchid, e.license).then(( () => this._matDialogRef.close(!0))).then(( () => {
                            void 0 !== e.license && this._appService.getAppInfo()
                        }
                        )).catch((e => {
                            this._formatErrorResponse(e),
                            this.processing = !1
                        }
                        ))
                    }
                    )).catch((e => {
                        this._formatErrorResponse(e),
                        this.processing = !1
                    }
                    ))
                }
                cancel() {
                    this._matDialogRef.close(!1)
                }
                get formIsInvalid() {
                    return !!this.silentActivation && this.activationForm.controls.activationCode.invalid
                }
                _getLicense() {
                    return this.silentActivation ? !1 === new RegExp(this.ACTIVATION_CODE_PATTERN).test(this.activationForm.value.activationCode) ? this._activationService.getUpgradedLicense(this.activationForm.value.activationCode, this.license.activationCode) : this._activationService.getActivatedLicense(this.activationForm.value.activationCode, this.orchid.discoverableOrchid.mid, this.activationForm.value.location) : Promise.resolve({
                        license: this.activationKey
                    })
                }
                _formatErrorResponse(e) {
                    let t = this.msgs.unexpectedErrorOccurred();
                    if (e) {
                        const n = e.data ? e.data : e;
                        n.reason && (t = n.code ? `${n.code}: ${n.reason}` : n.reason)
                    }
                    this.error = t
                }
                _pingActivationService() {
                    this.checkingForConnectivity = !0,
                    this._activationService.pingOrchidSecurity().then(( () => {
                        this.silentActivation = !0
                    }
                    )).catch(( () => {
                        this.silentActivation = !1,
                        this.orchidSecurityUnreachable = !0
                    }
                    )).finally(( () => {
                        this.checkingForConnectivity = !1
                    }
                    ))
                }
            }
            ;
            var ew, tw, nw, iw, aw, rw, sw, ow, cw, lw;
            (0,
            c.gn)([(0,
            i.ViewChild)("licenseKey"), (0,
            c.w6)("design:type", "function" == typeof (XC = void 0 !== i.ElementRef && i.ElementRef) ? XC : Object)], QC.prototype, "_licenseKey", void 0),
            QC = YC = (0,
            c.gn)([(0,
            i.Component)({
                selector: "add-license-dialog",
                template: n(35962)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(qC)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(3, (0,
            i.Inject)(tf)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (KC = void 0 !== qC && qC) ? KC : Object, Object, "function" == typeof (ZC = void 0 !== hn.so && hn.so) ? ZC : Object, "function" == typeof (JC = void 0 !== tf && tf) ? JC : Object])], QC),
            function(e) {
                e.EDITION = "edition",
                e.CAMERAS = "cameras",
                e.RETENTION = "retention",
                e.SUPPORT = "support",
                e.ACTIVATION = "activation"
            }(lw || (lw = {}));
            let dw = class {
                constructor(e, t, n, i, a, r, s, o, c) {
                    this._brandService = e,
                    this._dataService = t,
                    this._datePipe = n,
                    this._matDialog = i,
                    this._orchidDataService = a,
                    this._renewableService = r,
                    this._timeService = s,
                    this._appService = o,
                    this._minimumVersionService = c,
                    this.msgs = Object.assign(Object.assign({}, L.messages.activation), {
                        dialogs: L.messages.dialogs,
                        remove: L.messages.bag.remove,
                        update: L.messages.bag.update,
                        add: L.messages.groups.add
                    }),
                    this.isOrchid = w.isOrchid,
                    this.errorHelpHTML = null,
                    this._brandService.brand.SUPPORT_URL && (this.errorHelpHTML = L.messages.errors.errorHelp({
                        VALUE: this._brandService.brand.SUPPORT_URL
                    })),
                    this.processing = !1,
                    this.loading = !1,
                    this.trustedIssuer = void 0,
                    this.processingDetach = !1,
                    this.refreshOrchidFailed = !1,
                    this._licenseCountdownInterval = (0,
                    Jl.F)(1e3),
                    this._remainingTimeClock = Ql.E.subscribe(),
                    this.displayedColumns = [lw.EDITION, lw.CAMERAS, lw.RETENTION, lw.SUPPORT, lw.ACTIVATION],
                    this.dataSource = new Ei.by,
                    this.cameraDisablementIsSupported = !0
                }
                get TableColumns() {
                    return lw
                }
                get LicenseStateStatus() {
                    return V
                }
                get licenseIsTimed() {
                    return void 0 !== this.licenseSession && this.licenseSession.state.status !== V.DEGRADED && void 0 !== this.licenseSession.license.activationTimeRange && void 0 !== this.formattedLicenseTimeRemaining
                }
                _updateTableData() {
                    this.licenseSession && (this.dataSource.data = [{
                        activation: this.licenseSession.license.activationCode,
                        cameras: this.licenseSession.license.cameras,
                        edition: this.licenseSession.license.brandedEdition,
                        retention: this.licenseSession.retentionDescription,
                        support: this.licenseSession.expiresDescription
                    }])
                }
                addLicense() {
                    (0,
                    dt.z)(QC.show(this._matDialog, {
                        orchid: this.orchid,
                        license: this.orchid.discoverableOrchid.licenseSession.license
                    })).then((e => {
                        e && (w.isOrchid ? this._orchidDataService.refreshDiscoverable(this.orchid).then((e => {
                            this._updateLicenseSessionInfo(e.discoverableOrchid.licenseSession).then(( () => {
                                this._updateTableData(),
                                this._appService.getAppInfo().subscribe()
                            }
                            ))
                        }
                        )).catch(( () => {
                            this.refreshOrchidFailed = !0
                        }
                        )) : this._dataService.purgeOrchid(this.orchid).then(( () => {
                            this._updateLicenseSessionInfo(this.orchid.discoverableOrchid.licenseSession).then(( () => {
                                this._updateTableData()
                            }
                            ))
                        }
                        )))
                    }
                    )).catch(( () => {}
                    ))
                }
                detach() {
                    const e = {
                        panelClass: "sing-dialog-panel",
                        data: {
                            cancelText: L.messages.dialogs.cancel(),
                            confirmText: L.messages.dialogs.detach(),
                            message: L.messages.activation.areYouSureYouWantToDetachThisCHILDFromPARENT()
                        }
                    };
                    (0,
                    dt.z)(qs.show(this._matDialog, e)).then((e => {
                        e && (this.processingDetach = !0,
                        this._orchidDataService.deleteTrustedIssuer(this.orchid).then(( () => {
                            this.trustedIssuer = void 0
                        }
                        )).catch(( () => {
                            this.failureDetach = L.messages.errors.unexpectedErrorOccurred()
                        }
                        )).finally(( () => {
                            this.processingDetach = !1
                        }
                        )))
                    }
                    ))
                }
                removeLicense() {
                    const e = {
                        cancelText: L.messages.dialogs.cancel(),
                        confirmText: L.messages.dialogs.removeLicenseDialog.removeLicense(),
                        message: L.messages.dialogs.removeLicenseDialog.areYouSure(),
                        customErrorText: L.messages.dialogs.removeLicenseDialog.failedToRemoveLicense(),
                        confirmCallbackAsync: () => (0,
                        c.mG)(this, void 0, void 0, (function*() {
                            try {
                                yield this._orchidDataService.deleteLicense(this.orchid)
                            } catch (e) {
                                if (e.data && e.data.reason)
                                    throw {
                                        message: e.data.reason
                                    }
                            }
                        }
                        ))
                    };
                    (0,
                    dt.z)(qs.show(this._matDialog, {
                        data: e
                    })).then((e => (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        e && (w.isOrchid ? this._orchidDataService.refreshDiscoverable(this.orchid).then((e => {
                            this._updateLicenseSessionInfo(e.discoverableOrchid.licenseSession).then(( () => {
                                this._updateTableData()
                            }
                            ))
                        }
                        )).then(( () => {
                            this._appService.getAppInfo().subscribe()
                        }
                        )).catch(( () => {
                            this.refreshOrchidFailed = !0
                        }
                        )) : this._dataService.purgeOrchid(this.orchid).then(( () => {
                            this._updateLicenseSessionInfo(this.orchid.discoverableOrchid.licenseSession).then(( () => {
                                this._updateTableData()
                            }
                            ))
                        }
                        )))
                    }
                    ))))
                }
                get hasLicense() {
                    return void 0 === this.licenseSession || this.licenseSession.license && "trial" !== this.licenseSession.license.edition
                }
                get licenseButtonText() {
                    return this.hasLicense ? L.messages.activation.updateLicense() : L.messages.activation.addLicense()
                }
                get licenseButtonTextShort() {
                    return this.hasLicense ? L.messages.dashboard.update() : L.messages.groups.add()
                }
                get licensedCameraCount() {
                    return this.orchid.cameras.filter((e => !this.cameraDisablementIsSupported || e.active)).length
                }
                _updateLicenseSessionInfo(e) {
                    return this.licenseSession = Object.assign(Object.assign({}, xt(e)), {
                        expiresDescription: "",
                        retentionDescription: ""
                    }),
                    this._remainingTimeClock.unsubscribe(),
                    this.licenseSession.retentionDescription = "number" == typeof this.licenseSession.license.retention ? er.transform(this.licenseSession.license.retention) : this.msgs.unlimited(),
                    this.licenseSession.expiresDescription = this.licenseSession.license.expires > 8623372036854776 ? this.msgs.na() : Intl.DateTimeFormat(L.locale, {
                        dateStyle: "full",
                        timeZone: "UTC"
                    }).format(this.licenseSession.license.expires) + " UTC",
                    void 0 !== this.licenseSession.license.activationCode && 0 !== this.licenseSession.license.activationCode.length || (this.licenseSession.license.activationCode = this.msgs.na()),
                    this.licenseSession.license.activationTimeRange && (this._remainingTimeClock = this._licenseCountdownInterval.subscribe(( () => {
                        this._timeService.getOrchidTimeOffsetPromise(this.orchid.id).then((e => {
                            const t = Date.now() - e;
                            let n = 0;
                            this.licenseSession && this.licenseSession.license.activationTimeRange && (n = this.licenseSession.license.activationTimeRange.stop - t),
                            this.formattedLicenseTimeRemaining = yl.transform(Math.max(n, 0), !0)
                        }
                        ))
                    }
                    ))),
                    Promise.resolve()
                }
                _initFunc() {
                    this._orchidDataService.getTrustedIssuer(this.orchid).then((e => {
                        this.trustedIssuer = e.data
                    }
                    )).catch(( () => {}
                    )).finally(( () => {
                        this._updateLicenseSessionInfo(this.orchid.discoverableOrchid.licenseSession).then(( () => {
                            this.licenseSession && (this.dataSource.data = [{
                                activation: this.licenseSession.license.activationCode,
                                cameras: this.licenseSession.license.cameras,
                                edition: this.licenseSession.license.brandedEdition,
                                retention: this.licenseSession.retentionDescription,
                                support: this.licenseSession.expiresDescription
                            }])
                        }
                        )).finally(( () => {
                            this.loading = !1
                        }
                        ))
                    }
                    ))
                }
                ngOnInit() {
                    this.loading = !0,
                    this.isOrchid ? this._renewableService.orchidsPromise().then((e => {
                        this.orchid = e[0],
                        this._initFunc()
                    }
                    )).catch(( () => {}
                    )) : (this.cameraDisablementIsSupported = this._minimumVersionService.isFeatureSupported(this.orchid, Sr.CAMERA_DISABLEMENT),
                    this._initFunc())
                }
                ngOnDestroy() {
                    this._remainingTimeClock.unsubscribe()
                }
            }
            ;
            function uw(e, t, n) {
                const i = n ? `: ${n}` : "";
                switch (e) {
                case Z.LOCAL:
                    return L.messages.auditLogs.table.userType.local();
                case Z.REMOTE:
                    return t ? `${t}${i}` : L.messages.auditLogs.table.userType.remote();
                case K.USER_SESSION:
                    return L.messages.auditLogs.table.authType.userSession();
                case K.REMOTE_SESSION:
                    return t ? `${t}${i}` : L.messages.auditLogs.table.authType.remoteSession();
                case K.BASIC:
                    return L.messages.auditLogs.table.authType.basic();
                case K.JWT:
                    return L.messages.auditLogs.table.authType.jwt();
                default:
                    return ""
                }
            }
            function mw(e) {
                switch (e) {
                case J.FUSION:
                    return L.messages.auditLogs.table.remoteAuthProvider.fusion();
                case J.GOOGLE_SIGN_IN:
                    return L.messages.auditLogs.table.remoteAuthProvider.googleSignIn();
                case J.GOOGLE_OAUTH:
                    return L.messages.auditLogs.table.remoteAuthProvider.googleOAuth();
                case J.ACTIVE_DIRECTORY:
                    return L.messages.auditLogs.table.remoteAuthProvider.activeDirectory();
                case J.FREEIPA:
                    return L.messages.auditLogs.table.remoteAuthProvider.freeipa();
                case J.AZURE_ACTIVE_DIRECTORY:
                    return L.messages.auditLogs.table.remoteAuthProvider.azureActiveDirectory();
                case J.SAML:
                    return L.messages.auditLogs.table.remoteAuthProvider.saml()
                }
                return ""
            }
            function hw(e, t) {
                var n;
                return e && e === X.SERVER ? L.messages.auditLogs.table.userType.local() : (null === (n = t.request.resource) || void 0 === n ? void 0 : n.name) || ""
            }
            var pw, gw;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], dw.prototype, "orchid", void 0),
            dw = (0,
            c.gn)([(0,
            i.Component)({
                selector: "activation",
                template: n(49802)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Hm)), (0,
            c.fM)(1, (0,
            i.Inject)(tt)), (0,
            c.fM)(2, (0,
            i.Inject)(l.uU)), (0,
            c.fM)(3, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(4, (0,
            i.Inject)(pt)), (0,
            c.fM)(5, (0,
            i.Inject)(Gt)), (0,
            c.fM)(6, (0,
            i.Inject)(ug)), (0,
            c.fM)(7, (0,
            i.Inject)(tf)), (0,
            c.fM)(8, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (ew = void 0 !== Hm && Hm) ? ew : Object, "function" == typeof (tw = tt) ? tw : Object, "function" == typeof (nw = void 0 !== l.uU && l.uU) ? nw : Object, "function" == typeof (iw = void 0 !== hn.uw && hn.uw) ? iw : Object, "function" == typeof (aw = pt) ? aw : Object, "function" == typeof (rw = Gt) ? rw : Object, "function" == typeof (sw = void 0 !== ug && ug) ? sw : Object, "function" == typeof (ow = void 0 !== tf && tf) ? ow : Object, "function" == typeof (cw = void 0 !== Cr && Cr) ? cw : Object])], dw);
            let fw = class {
                constructor(e, t) {
                    this.dialogRef = e,
                    this.data = t,
                    this.msgs = {},
                    this.selectedRangeValue = new oi.C0(new Date(Date.now()),new Date(Date.now())),
                    this.maxDate = new Date(Date.now()),
                    this._isStartTimeInputValid = !0,
                    this._isEndTimeInputValid = !0;
                    let n = new Date(Date.now())
                      , i = new Date(Date.now())
                      , a = {
                        date: n,
                        hours: 0,
                        minutes: 0,
                        seconds: 0
                    }
                      , r = {
                        date: i,
                        hours: 24,
                        minutes: 59,
                        seconds: 59
                    };
                    t && (n = new Date(t.start.timestamp),
                    i = new Date(t.end.timestamp),
                    a = {
                        date: n,
                        hours: n.getHours(),
                        minutes: n.getMinutes(),
                        seconds: n.getSeconds()
                    },
                    r = {
                        date: i,
                        hours: i.getHours(),
                        minutes: i.getMinutes(),
                        seconds: i.getSeconds()
                    }),
                    this.startTimeFG = new p.cw({
                        date: new p.NI(a.date),
                        hours: new p.NI(a.hours),
                        minutes: new p.NI(a.minutes),
                        seconds: new p.NI(a.seconds)
                    }),
                    this.endTimeFG = new p.cw({
                        date: new p.NI(r.date),
                        hours: new p.NI(r.hours),
                        minutes: new p.NI(r.minutes),
                        seconds: new p.NI(r.seconds)
                    }),
                    this.selectedRangeValue = new oi.C0(n,i)
                }
                ngOnInit() {
                    this.msgs = Object.assign({}, L.messages.events.eventsFilters.dateRangeDialog)
                }
                selectedChange(e) {
                    var t, n;
                    if (!(null === (t = this.selectedRangeValue) || void 0 === t ? void 0 : t.start) || (null === (n = this.selectedRangeValue) || void 0 === n ? void 0 : n.end))
                        this.selectedRangeValue = new oi.C0(e,null);
                    else {
                        const t = this.selectedRangeValue.start
                          , n = e;
                        this.selectedRangeValue = n && n < t ? new oi.C0(n,t) : new oi.C0(t,n)
                    }
                    this.startTimeFG.controls.date.setValue(this.selectedRangeValue.start),
                    this.endTimeFG.controls.date.setValue(this.selectedRangeValue.end)
                }
                onCancelClick() {
                    this.dialogRef.close()
                }
                onOkClick() {
                    const e = this.getDateTimeRangeObject("start")
                      , t = this.getDateTimeRangeObject("end")
                      , n = {
                        start: {
                            timestamp: Math.floor(e.getTime()),
                            label: e.toLocaleDateString()
                        },
                        end: {
                            timestamp: Math.floor(t.getTime()),
                            label: t.toLocaleDateString()
                        }
                    };
                    this.dialogRef.close(n)
                }
                getStartDateLabel() {
                    return this.startTimeFG.controls.date.value ? this.startTimeFG.controls.date.value.toLocaleDateString() : "---"
                }
                getEndDateLabel() {
                    return this.endTimeFG.controls.date.value ? this.endTimeFG.controls.date.value.toLocaleDateString() : "---"
                }
                isDateRangeValid() {
                    const e = this.selectedRangeValue.start
                      , t = this.selectedRangeValue.end;
                    return null !== e && null !== t
                }
                isDateTimeRangeValid() {
                    if (this.isDateRangeValid() && this._isStartTimeInputValid && this._isEndTimeInputValid) {
                        const e = this.getDateTimeRangeObject("start");
                        return this.getDateTimeRangeObject("end") > e
                    }
                    return !1
                }
                isStartTimeInputValid(e) {
                    this._isStartTimeInputValid = e
                }
                isEndTimeInputValid(e) {
                    this._isEndTimeInputValid = e
                }
                getDateTimeRangeObject(e) {
                    const t = "start" === e ? this.startTimeFG : this.endTimeFG
                      , n = new Date(t.controls.date.value);
                    return n.setHours(t.controls.hours.value),
                    n.setMinutes(t.controls.minutes.value),
                    n.setSeconds(t.controls.seconds.value),
                    n
                }
            }
            ;
            var vw, yw, bw;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (pw = void 0 !== oi.C0 && oi.C0) ? pw : Object)], fw.prototype, "selectedRangeValue", void 0),
            fw = (0,
            c.gn)([(0,
            i.Component)({
                selector: "date-range-filter-dialog",
                template: n(81896)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.WI)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (gw = void 0 !== hn.so && hn.so) ? gw : Object, Object])], fw);
            let Sw = class {
                constructor(e, t) {
                    this.dateRangeDialog = e,
                    this.datePipe = t,
                    this._trustedIssuerName = "",
                    this.chipUsersData = [],
                    this.chipCamerasData = [],
                    this.chipAuthTypesData = [],
                    this.activeCameras = [],
                    this.activeUsers = [],
                    this._defaultStartDate = Date.now() - 864e5,
                    this.search = new i.EventEmitter,
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.auditLogs), L.messages.common), {
                        filters: L.messages.auditLogs.filters
                    }),
                    this.dateFormat = {},
                    this.selectedDateRange = this.getInitialDateRange(),
                    this.isDateRangeDirty = !1,
                    this.defaultAuthTypes = [{
                        id: K.USER_SESSION,
                        name: L.messages.auditLogs.filters.authType.userSession()
                    }, {
                        id: K.REMOTE_SESSION,
                        name: this._trustedIssuerName || L.messages.auditLogs.filters.authType.remoteSession()
                    }, {
                        id: K.BASIC,
                        name: L.messages.auditLogs.filters.authType.basic()
                    }];
                    const n = new p.qu;
                    this.selectedFilters = n.group({
                        users: new p.NI([]),
                        cameras: new p.NI([]),
                        authTypes: new p.NI([])
                    }),
                    this.selectedFilters.controls.authTypes.setValue([...this.defaultAuthTypes])
                }
                set cameras(e) {
                    this.chipCamerasData = e.map((e => ({
                        name: e.name,
                        id: e.id
                    })))
                }
                set trustedIssuerName(e) {
                    this._trustedIssuerName = e,
                    void 0 !== this.msgs.filters && (this.defaultAuthTypes = [{
                        id: K.USER_SESSION,
                        name: this.msgs.filters.authType.userSession()
                    }, {
                        id: K.REMOTE_SESSION,
                        name: this._trustedIssuerName || this.msgs.filters.authType.remoteSession()
                    }, {
                        id: K.BASIC,
                        name: this.msgs.filters.authType.basic()
                    }],
                    this.chipAuthTypesData = [...this.defaultAuthTypes, {
                        id: K.JWT,
                        name: this.msgs.filters.authType.jwt()
                    }],
                    this.selectedFilters.controls.authTypes.setValue([...this.defaultAuthTypes]))
                }
                set users(e) {
                    this.chipUsersData = e.map((e => {
                        const t = e.remoteAuthProvider ? mw(e.remoteAuthProvider) : "";
                        return {
                            id: e.userId,
                            name: e.username,
                            title: uw(e.userType, this._trustedIssuerName, t)
                        }
                    }
                    ))
                }
                ngOnInit() {
                    this.chipAuthTypesData = [...this.defaultAuthTypes, {
                        id: K.JWT,
                        name: this.msgs.filters.authType.jwt()
                    }],
                    this.selectedDateRange = this.getInitialDateRange(),
                    this.dateButtonLabel = this.msgs.filters.searchDateRange(),
                    this.defaultAuthTypes = [{
                        id: K.USER_SESSION,
                        name: this.msgs.filters.authType.userSession()
                    }, {
                        id: K.REMOTE_SESSION,
                        name: this._trustedIssuerName || this.msgs.filters.authType.remoteSession()
                    }, {
                        id: K.BASIC,
                        name: this.msgs.filters.authType.basic()
                    }],
                    this.dateFormat = L.formats.auditLogs
                }
                getInitialDateRange() {
                    return {
                        start: {
                            timestamp: this._defaultStartDate,
                            label: L.messages.auditLogs.filters.fromDate()
                        },
                        end: {
                            timestamp: Date.now(),
                            label: L.messages.auditLogs.filters.toDate()
                        }
                    }
                }
                updateDateButtonLabel() {
                    if (!this.isDateRangeDirty)
                        return void (this.dateButtonLabel = this.msgs.filters.searchDateRange());
                    if (void 0 === this.selectedDateRange)
                        return;
                    const e = this.selectedDateRange.start.timestamp
                      , t = this.selectedDateRange.end.timestamp
                      , n = new Date(e)
                      , i = new Date(t);
                    if (n.toDateString() === i.toDateString()) {
                        const n = this.datePipe.transform(e, this.dateFormat.short)
                          , i = this.datePipe.transform(e, "shortTime")
                          , a = this.datePipe.transform(t, "shortTime");
                        return void (this.dateButtonLabel = `${n}: ${i} - ${a}`)
                    }
                    const a = this.datePipe.transform(this.selectedDateRange.start.timestamp, this.dateFormat.short)
                      , r = this.datePipe.transform(this.selectedDateRange.end.timestamp, this.dateFormat.short);
                    this.dateButtonLabel = `${a} - ${r}`
                }
                removeUser(e) {
                    this.selectedFilters.controls.users.setValue(this.selectedFilters.controls.users.value.filter((t => t.name !== e.name || t.title !== e.title))),
                    this.doSearch()
                }
                removeCamera(e) {
                    this.selectedFilters.controls.cameras.setValue(this.selectedFilters.controls.cameras.value.filter((t => t.name !== e.name || t.id !== e.id))),
                    this.doSearch()
                }
                doSearch() {
                    this.activeUsers = [...this.selectedFilters.controls.users.value],
                    this.activeCameras = [...this.selectedFilters.controls.cameras.value],
                    this.search.emit()
                }
                resetDateRange() {
                    this.isDateRangeDirty = !1,
                    this.selectedDateRange = this.getInitialDateRange(),
                    this.updateDateButtonLabel()
                }
                handleDateRangeClick(e) {
                    e.stopPropagation();
                    this.dateRangeDialog.open(fw, {
                        width: "500px",
                        data: this.selectedDateRange
                    }).afterClosed().pipe((0,
                    pn.q)(1)).subscribe((e => {
                        e && e.start.timestamp < e.end.timestamp && (this.selectedDateRange.start = e.start,
                        this.selectedDateRange.end = e.end,
                        this.isDateRangeDirty = !0,
                        this.updateDateButtonLabel(),
                        this.doSearch())
                    }
                    ))
                }
                handleDateRangeReset(e) {
                    e.stopPropagation(),
                    this.resetDateRange(),
                    this.doSearch()
                }
                handleResetClick() {
                    this.selectedFilters.controls.users.setValue([]),
                    this.selectedFilters.controls.cameras.setValue([]),
                    this.selectedFilters.controls.authTypes.setValue([...this.defaultAuthTypes]),
                    this.authTypeChips && this.authTypeChips.clearAllChip(),
                    this.resetDateRange(),
                    this.doSearch()
                }
                handleSearchClick() {
                    this.doSearch()
                }
            }
            ;
            var Cw, ww, Iw, Tw, Ew;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array), (0,
            c.w6)("design:paramtypes", [Array])], Sw.prototype, "cameras", null),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String), (0,
            c.w6)("design:paramtypes", [String])], Sw.prototype, "trustedIssuerName", null),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array), (0,
            c.w6)("design:paramtypes", [Array])], Sw.prototype, "users", null),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], Sw.prototype, "search", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("authTypeChips"), (0,
            c.w6)("design:type", "function" == typeof (vw = void 0 !== wu && wu) ? vw : Object)], Sw.prototype, "authTypeChips", void 0),
            Sw = (0,
            c.gn)([(0,
            i.Component)({
                selector: "audit-logs-filters",
                template: n(10719)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(1, (0,
            i.Inject)(l.uU)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (yw = void 0 !== hn.uw && hn.uw) ? yw : Object, "function" == typeof (bw = void 0 !== l.uU && l.uU) ? bw : Object])], Sw),
            function(e) {
                e.INITIALIZING = "initializing",
                e.LOADING = "loading",
                e.LOADED = "loaded"
            }(Ew || (Ew = {}));
            let _w = class {
                constructor(e, t, n) {
                    this._authService = e,
                    this._auditLogsService = t,
                    this._downloaderService = n,
                    this.auditServices = [],
                    this.auditLogs = [],
                    this.cameras = [],
                    this.users = [],
                    this.trustedIssuer = {
                        description: "",
                        href: "",
                        id: "",
                        uri: "",
                        name: ""
                    },
                    this.servicesActionsMap = new Map,
                    this.servicesDescriptionsMap = new Map,
                    this.servicesResourcesMap = new Map,
                    this._resourceServicesMap = new Map,
                    this.error = {
                        type: db.NONE
                    },
                    this.trustedIssuerName = "",
                    this.isOrchid = w.isOrchid,
                    this.msgs = Object.assign(Object.assign({}, L.messages.auditLogs), L.messages.common),
                    this.statusMsgs = L.messages.statuses,
                    this.backToTopTooltip = () => "",
                    this.refreshTooltip = () => "",
                    this.isAdmin = this._authService.getAuthenticationData().isAdministrator(),
                    this._unsubscribe$ = new St.x,
                    this.state = Ew.INITIALIZING,
                    this.pageSize = w.isOrchid ? 1e3 : 200,
                    this._currentOffset = 0,
                    this._sort = {
                        active: "date",
                        direction: "desc"
                    },
                    this.handleError = e => {
                        this.error = e
                    }
                    ,
                    this.handleTrustedIssuerResponse = e => {
                        this.state !== Ew.INITIALIZING && (this.trustedIssuerName = e.name || "",
                        this._auditLogsService.getCamerasList(this.orchid),
                        this._auditLogsService.getUsersList(this.orchid),
                        this.getServices())
                    }
                    ,
                    this.handleServicesResponse = e => {
                        this.state !== Ew.INITIALIZING && (e.length && this.getLogs(),
                        this.auditServices = e)
                    }
                    ,
                    this.handleLogsResponse = e => {
                        this.state !== Ew.INITIALIZING && (this.state = Ew.LOADED,
                        this.auditLogs = e)
                    }
                    ,
                    this._scrollThreshold = 500
                }
                ngOnInit() {
                    this.backToTopTooltip = this.msgs.backToTop(),
                    this.refreshTooltip = this.msgs.refreshResults(),
                    this._auditLogsService.error$.pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe(this.handleError),
                    this._auditLogsService.services$.pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe(this.handleServicesResponse),
                    this._auditLogsService.logs$.pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe(this.handleLogsResponse),
                    this._auditLogsService.servicesActionsMap$.pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe((e => this.servicesActionsMap = e)),
                    this._auditLogsService.servicesDescriptionsMap$.pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe((e => this.servicesDescriptionsMap = e)),
                    this._auditLogsService.servicesResourcesMap$.pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe((e => this.servicesResourcesMap = e)),
                    this._auditLogsService.resourceServicesMap$.pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe((e => this._resourceServicesMap = e)),
                    this._auditLogsService.cameras$.pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe((e => this.cameras = e)),
                    this._auditLogsService.users$.pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe((e => this.users = e)),
                    this._auditLogsService.trustedIssuer$.pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe(this.handleTrustedIssuerResponse),
                    this.state = Ew.LOADING,
                    this._auditLogsService.getTrustedIssuer(this.orchid)
                }
                ngOnDestroy() {
                    this._unsubscribe$.next(!0),
                    this._unsubscribe$.complete(),
                    this._auditLogsService.clearData()
                }
                getServices() {
                    this.state = Ew.LOADING,
                    this._auditLogsService.getServices(this.orchid)
                }
                getLogs(e=!1) {
                    this.error = {
                        type: db.NONE
                    },
                    this.state = Ew.LOADING;
                    const t = this._getAuditLogsOptions(e);
                    this._auditLogsService.getAuditLogs(this.orchid, t)
                }
                _getAuditLogsOptions(e=!1, t=!1) {
                    var n, i, a, r, s, o, c;
                    const l = (null === (n = this.auditFilters) || void 0 === n ? void 0 : n.selectedFilters.value.users.length) > 0 || !1
                      , d = (null === (i = this.auditFilters) || void 0 === i ? void 0 : i.selectedFilters.value.cameras.length) > 0 || !1
                      , u = (null === (a = this.auditFilters) || void 0 === a ? void 0 : a.selectedFilters.value.cameras.map((e => e.id)).join(",")) || void 0
                      , m = (null === (r = this.auditFilters.selectedDateRange) || void 0 === r ? void 0 : r.start.timestamp) || void 0
                      , h = this.auditFilters.isDateRangeDirty ? null === (s = this.auditFilters.selectedDateRange) || void 0 === s ? void 0 : s.end.timestamp : void 0
                      , p = d ? X.CAMERA : void 0
                      , g = d ? u : void 0
                      , f = "desc" === this._sort.direction ? -1 : 1
                      , v = t ? void 0 : this.pageSize * f
                      , y = t ? void 0 : this._currentOffset
                      , b = l ? null === (o = this.auditFilters) || void 0 === o ? void 0 : o.selectedFilters.value.users.map((e => e.id)).join(",") : void 0
                      , S = `${K.USER_SESSION},${K.BASIC},${K.REMOTE_SESSION}`;
                    return {
                        start: m,
                        stop: h,
                        serviceIds: undefined,
                        userIds: b,
                        resource: p,
                        resourceIds: g,
                        includeChildren: !0,
                        count: v,
                        more: e,
                        offset: y,
                        authTypes: (null === (c = this.auditFilters) || void 0 === c ? void 0 : c.selectedFilters.value.authTypes.map((e => e.id)).join(",")) || S
                    }
                }
                _getResourceServicesCSV(e) {
                    return e.map((e => this._resourceServicesMap.get(e))).join(",")
                }
                handleFiltersSearch() {
                    this.getLogs()
                }
                handleExportButtonClick() {
                    const e = this._getAuditLogsOptions(!1, !0)
                      , t = this._auditLogsService.getLogsExportUrl(this.orchid, e);
                    this._downloaderService.createDownloader().download(t)
                }
                handleMoreClick() {
                    this._currentOffset += this.pageSize,
                    this.getLogs(!0)
                }
                get showTopButton() {
                    return this.isOrchid && this.state !== Ew.INITIALIZING && this.auditLogs.length > 0 && window.scrollY > this._scrollThreshold
                }
                top() {
                    window.scrollTo({
                        top: 0,
                        left: 0,
                        behavior: "smooth"
                    })
                }
                refresh() {
                    this._currentOffset = 0,
                    this.getLogs()
                }
                handleSort(e) {
                    this._sort = e,
                    this._currentOffset = 0,
                    this.getLogs()
                }
                get showTable() {
                    return this.state !== Ew.INITIALIZING && this.auditLogs.length > 0
                }
                get showFilters() {
                    var e;
                    return ((null === (e = this.error) || void 0 === e ? void 0 : e.type) === db.NONE && 0 === this.auditLogs.length || this.auditLogs.length > 0) && (this.state === Ew.LOADED || this.state === Ew.LOADING)
                }
                get showNoResults() {
                    return this.state === Ew.LOADED && 0 === this.auditLogs.length
                }
                get showSpinner() {
                    var e;
                    return (this.state === Ew.INITIALIZING || this.state === Ew.LOADING) && (null === (e = this.error) || void 0 === e ? void 0 : e.type) === db.NONE && 0 === this.auditLogs.length
                }
                get showError() {
                    var e;
                    return (null === (e = this.error) || void 0 === e ? void 0 : e.type) && this.error.type !== db.NONE
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], _w.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("auditFilters"), (0,
            c.w6)("design:type", "function" == typeof (Cw = void 0 !== Sw && Sw) ? Cw : Object)], _w.prototype, "auditFilters", void 0),
            _w = (0,
            c.gn)([(0,
            i.Component)({
                selector: "audit-logs",
                template: n(36768),
                animations: [(0,
                Jo.X$)("fadeIn", [(0,
                Jo.eR)(":enter", [(0,
                Jo.oB)({
                    opacity: 0
                }), (0,
                Jo.jt)("225ms 225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
                Jo.oB)({
                    opacity: 1
                }))])]), (0,
                Jo.X$)("fadeOut", [(0,
                Jo.eR)(":leave", [(0,
                Jo.jt)("225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
                Jo.oB)({
                    opacity: 0
                }))])]), (0,
                Jo.X$)("fadeInOut", [(0,
                Jo.eR)(":enter", [(0,
                Jo.oB)({
                    opacity: 0,
                    transform: "translateY(10px)"
                }), (0,
                Jo.jt)("225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
                Jo.oB)({
                    opacity: 1,
                    transform: "translateY(0)"
                }))]), (0,
                Jo.eR)(":leave", [(0,
                Jo.jt)("225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
                Jo.oB)({
                    opacity: 0
                }))])])]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(xe)), (0,
            c.fM)(1, (0,
            i.Inject)(ub)), (0,
            c.fM)(2, (0,
            i.Inject)(ih)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (ww = void 0 !== xe && xe) ? ww : Object, "function" == typeof (Iw = void 0 !== ub && ub) ? Iw : Object, "function" == typeof (Tw = void 0 !== ih && ih) ? Tw : Object])], _w);
            const xw = O("WebRTCUtils");
            function Dw(e) {
                if ("object" != typeof e || null === e || void 0 === e.port || void 0 === e.protocol || void 0 === e.candidateType)
                    return xw("warn", "Invalid WebRTC Stats ICE candidate"),
                    "-";
                if (!e.ip && !e.address) {
                    return `${L.messages.statisticKeys.webrtc.HIDDEN()}:${e.port} (${e.protocol}, ${e.candidateType})`
                }
                return `${e.ip ? e.ip : e.address}:${e.port} (${e.protocol}, ${e.candidateType})`
            }
            function Ow(e, t, n) {
                var i;
                if ("number" != typeof e)
                    throw new Error("currentAvg must be a number");
                if (!Array.isArray(t))
                    throw new Error("values must be an array");
                if (0 === t.length)
                    throw new Error("values must be > 0");
                if ("number" != typeof n)
                    throw new Error("newValue must be a number");
                const a = null !== (i = t.shift()) && void 0 !== i ? i : 0;
                return t.push(n),
                e + (n - a) / t.length
            }
            function Aw(e, t) {
                return void 0 !== t && (!("number" != typeof t || !isFinite(t) || t < 0) || (xw("warn", `${e} (${t}) is expected to be a positive number`),
                !1))
            }
            function Rw(e, t) {
                return void 0 !== t && ("string" == typeof t || (xw("warn", `${e} (${t}) is expected to be a string`),
                !1))
            }
            const Pw = "ice-failed"
              , kw = "ice-closed"
              , Mw = "ice-timeout"
              , Lw = "packet-loss"
              , Nw = "no-packets-received"
              , Fw = "no-frames-decoded"
              , Uw = "unknown";
            const $w = O("FramerateMonitor");
            class jw {
                constructor(e, t) {
                    this._prevTime = t,
                    this._currentTimeMs = t,
                    this._numFramesProcessed = 0,
                    this._timeWindowMs = e,
                    this._framerateQueue = [60, 60, 60, 60, 60],
                    this._framerateAvg = 60,
                    this.onAverageFramerateChange = null
                }
                reset(e) {
                    this._prevTime = e,
                    this._currentTimeMs = e,
                    this._numFramesProcessed = 0,
                    this._framerateQueue = [60, 60, 60, 60, 60],
                    this._framerateAvg = 60
                }
                collectFrame(e) {
                    if (e < this._currentTimeMs)
                        $w("error", `Time should be monotonically increasing. Ignoring frame (${e} < ${this._currentTimeMs})`);
                    else {
                        for (this._currentTimeMs = e; this._currentTimeMs - this._prevTime > this._timeWindowMs; )
                            this._framerateAvg = Ow(this._framerateAvg, this._framerateQueue, 1e3 * this._numFramesProcessed / this._timeWindowMs),
                            $w("debug", `Current Framerate Avg : ${this._framerateAvg}`),
                            null !== this.onAverageFramerateChange && this.onAverageFramerateChange(this._framerateAvg),
                            this._numFramesProcessed = 0,
                            this._prevTime += this._timeWindowMs;
                        this._numFramesProcessed++
                    }
                }
                getFramerateAverage() {
                    return this._framerateAvg
                }
            }
            const Vw = "critical"
              , Gw = "normal";
            class Bw {
                constructor(e, t) {
                    this._currentFramerateLevel = Gw,
                    this._handleVisibilityChange = () => {
                        "visible" === document.visibilityState ? ($w("log", "Document is now visible. Resuming performance monitor"),
                        this._resume()) : ($w("log", "Document is no longer visible. Pausing performance monitor"),
                        this._pause())
                    }
                    ,
                    this._updateFramerateLevel = e => {
                        e < this._framerateThreshold ? this._setFramerateLevel(Vw) : e >= this._framerateThreshold && this._setFramerateLevel(Gw)
                    }
                    ,
                    this._framerateDataCollector = e,
                    this._framerateDataCollector.onAverageFramerateChange = this._updateFramerateLevel,
                    this._framerateThreshold = t,
                    this._currentFramerateLevel = Gw,
                    this.onFramerateLevelChange = null,
                    this._startInterval(),
                    document.addEventListener("visibilitychange", this._handleVisibilityChange)
                }
                stop() {
                    clearInterval(this._interval),
                    this._framerateDataCollector.onAverageFramerateChange = null,
                    document.removeEventListener("visibilitychange", this._handleVisibilityChange)
                }
                _pause() {
                    clearInterval(this._interval)
                }
                _startInterval() {
                    this._interval = setInterval(( () => {
                        this._framerateDataCollector.collectFrame(performance.now())
                    }
                    ), 33)
                }
                _resume() {
                    clearInterval(this._interval),
                    this._setFramerateLevel(Gw),
                    this._framerateDataCollector.reset(performance.now()),
                    this._startInterval()
                }
                _setFramerateLevel(e) {
                    e !== this._currentFramerateLevel && (this._currentFramerateLevel = e,
                    $w("warn", `Framerate level changed to : ${e}`),
                    null !== this.onFramerateLevelChange && this.onFramerateLevelChange(e))
                }
            }
            function zw(e, t) {
                return new Bw(new jw(e,performance.now()),t)
            }
            let Hw = class {
                constructor() {
                    this._createFramerateMonitor = zw
                }
                create(e, t) {
                    return this._createFramerateMonitor(e, t)
                }
            }
            ;
            var Ww, qw, Yw;
            Hw = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.w6)("design:paramtypes", [])], Hw);
            const Xw = O("framerateAlert");
            let Kw = class {
                constructor(e, t, n) {
                    this._matDialog = e,
                    this._framerateMonitorFactory = t,
                    this._router = n,
                    this.framerateThreshold = 20,
                    this.msgs = Object.assign(Object.assign({}, L.messages.app.errors.framerate), L.messages.dialogs),
                    this._startMonitoring = () => {
                        this._framerateMonitor || (Xw("debug", "Start framerate monitoring"),
                        this._framerateMonitor = this._framerateMonitorFactory.create(1e3, this.framerateThreshold),
                        this._framerateMonitor.onFramerateLevelChange = e => {
                            this.isFramerateCritical = e === Vw
                        }
                        )
                    }
                    ,
                    this._stopMonitoring = () => {
                        this._framerateMonitor && (Xw("debug", "Stop framerate monitoring"),
                        this._framerateMonitor.stop(),
                        delete this._framerateMonitor),
                        this.isFramerateCritical = !1
                    }
                    ;
                    const i = "/stage";
                    this._router.url === i && this._startMonitoring(),
                    this.stageTransitionSub = this._router.events.subscribe((e => {
                        e instanceof Bt.m2 && (e.urlAfterRedirects === i ? this._startMonitoring() : this._stopMonitoring())
                    }
                    )),
                    this.isFramerateCritical = !1
                }
                ngOnDestroy() {
                    this.stageTransitionSub.unsubscribe(),
                    this._stopMonitoring()
                }
                showNotification() {
                    const e = `\n            <p>${this.msgs.weveNoticedYourBrowserIsRunningSlowly()}</p>\n            <ul>\n                <li>${this.msgs.tooManyDewarpedCameras()}</li>\n                <li>${this.msgs.tooManyHighResolutionCameras()}</li>\n                <li>${this.msgs.tooManyWebRTCPlayers()}</li>\n                <li>${this.msgs.anOlderPCOrVideoCard()}</li>\n            </ul>\n        `
                      , t = {
                        data: {
                            title: this.msgs.title(),
                            message: e,
                            okText: this.msgs.ok()
                        },
                        ariaLabel: this.msgs.title(),
                        autoFocus: !1
                    };
                    this._matDialog.open(Id, t)
                }
            }
            ;
            var Zw;
            Kw = (0,
            c.gn)([(0,
            i.Component)({
                selector: "framerate-alert",
                template: n(89547)
            }), (0,
            c.fM)(1, (0,
            i.Inject)(Hw)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Ww = void 0 !== hn.uw && hn.uw) ? Ww : Object, "function" == typeof (qw = void 0 !== Hw && Hw) ? qw : Object, "function" == typeof (Yw = void 0 !== Bt.F0 && Bt.F0) ? Yw : Object])], Kw);
            let Jw = class {
                constructor() {
                    this.activate = new i.EventEmitter
                }
                clickThumbnailSearchControl() {
                    this.activate.emit()
                }
            }
            ;
            var Qw, eI, tI, nI, iI, aI, rI, sI, oI;
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (Zw = void 0 !== i.EventEmitter && i.EventEmitter) ? Zw : Object)], Jw.prototype, "activate", void 0),
            Jw = (0,
            c.gn)([(0,
            i.Component)({
                selector: "thumbnail-search-control",
                template: n(86781)
            }), (0,
            c.w6)("design:paramtypes", [])], Jw),
            function(e) {
                e[e.HOUR = 0] = "HOUR",
                e[e.MINUTE = 1] = "MINUTE"
            }(Qw || (Qw = {})),
            function(e) {
                e[e.HOURLY = 0] = "HOURLY",
                e[e.MINUTELY = 1] = "MINUTELY"
            }(eI || (eI = {})),
            function(e) {
                e[e.LARGE = 0] = "LARGE",
                e[e.SMALL = 1] = "SMALL"
            }(tI || (tI = {})),
            function(e) {
                e.HOUR = "hour",
                e.MINUTE = "minute",
                e.VOID = "void"
            }(nI || (nI = {}));
            class cI {
                constructor() {
                    this._items = []
                }
                prioritize(e) {
                    this._items.unshift(e)
                }
                enqueue(e) {
                    this._items.push(e)
                }
                dequeue(e) {
                    if (e && e > 1) {
                        const t = this._items.slice(0, e);
                        return e < this._items.length ? this._items = this._items.slice(e, this._items.length) : this._items = [],
                        t
                    }
                    return this._items.shift()
                }
                clear() {
                    this._items.splice(0, this._items.length)
                }
                isEmpty() {
                    return 0 === this._items.length
                }
                size() {
                    return this._items.length
                }
            }
            !function(e) {
                e[e.DISPLAY = 0] = "DISPLAY",
                e[e.HEIGHT = 1] = "HEIGHT",
                e[e.OPACITY = 2] = "OPACITY",
                e[e.SCROLL_TOP = 3] = "SCROLL_TOP"
            }(iI || (iI = {})),
            function(e) {
                e[e.APPLY = 0] = "APPLY",
                e[e.REMOVE = 1] = "REMOVE"
            }(aI || (aI = {}));
            class lI {
                static generatePopulatedHourThumbnailsArray(e) {
                    const t = [];
                    return e.forEach((e => {
                        const n = {
                            time: e.hourStart,
                            timeToJumpTo: e.motionMinutes[0].earliestMotionStart - 500,
                            type: Qw.HOUR,
                            numEvents: e.motionMinutes.length,
                            numMinutePreviews: e.motionMinutes.length
                        };
                        t.push(n)
                    }
                    )),
                    t
                }
                static generatePopulatedMinuteThumbnailsArray(e) {
                    const t = [];
                    for (let n = 0; n < e.motionMinutes.length; ++n)
                        t.push({
                            time: e.motionMinutes[n].minuteStart,
                            timeToJumpTo: e.motionMinutes[n].earliestMotionStart - 500,
                            type: Qw.MINUTE,
                            numEvents: 1,
                            numMinutePreviews: 0
                        });
                    return t
                }
                static getSmartSearchRegionMappings(e, t, n) {
                    const i = e.map(( (e, t) => ({
                        vertices: e.map((e => ({
                            x: e.x,
                            y: e.y
                        })))
                    })));
                    return {
                        canvasHeight: t.height,
                        canvasWidth: t.width,
                        searchRegions: i,
                        streamId: n
                    }
                }
                static searchRegionsHaveChanged(e, t) {
                    if (e.length !== t.length)
                        return !0;
                    for (let n = 0; n < e.length; ++n) {
                        if (e[n].length !== t[n].length)
                            return !0;
                        for (let i = 0; i < e[n].length; ++i)
                            if (e[n][i].x !== t[n][i].x || e[n][i].y !== t[n][i].y)
                                return !0
                    }
                    return !1
                }
                static setElementProperty(e, t, n) {
                    this._configureElementProperty(e, t, {
                        value: n,
                        action: aI.APPLY
                    })
                }
                static removeElementProperty(e, t) {
                    this._configureElementProperty(e, t, {
                        action: aI.REMOVE
                    })
                }
                static _configureElementProperty(e, t, n) {
                    if (e && n.value && n.action === aI.APPLY)
                        switch (t) {
                        case iI.DISPLAY:
                            e.style.display = n.value;
                            break;
                        case iI.HEIGHT:
                            e.style.height = n.value;
                            break;
                        case iI.OPACITY:
                            e.style.opacity = n.value;
                            break;
                        case iI.SCROLL_TOP:
                            e.scrollTop = n.value
                        }
                    else if (e && n.action === aI.REMOVE)
                        switch (t) {
                        case iI.DISPLAY:
                            e.style.removeProperty("display");
                            break;
                        case iI.HEIGHT:
                            e.style.removeProperty("height");
                            break;
                        case iI.OPACITY:
                            e.style.removeProperty("opacity");
                            break;
                        case iI.SCROLL_TOP:
                            e.scrollTop = 0
                        }
                }
            }
            let dI = class {
                constructor(e, t, n, i) {
                    this._calendar = e,
                    this._dateAdapter = t,
                    this._dateFormats = n,
                    this._changeDetectorRef = i,
                    this._destroyed = new St.x,
                    this._calendar.stateChanges.pipe((0,
                    oa.R)(this._destroyed)).subscribe(( () => i.markForCheck()))
                }
                get periodLabel() {
                    return this._dateAdapter.format(this._calendar.activeDate, this._dateFormats.display.monthYearLabel).toLocaleUpperCase()
                }
                ngOnDestroy() {
                    this._destroyed.next(),
                    this._destroyed.complete()
                }
                previousClicked() {
                    this._calendar.activeDate = this._dateAdapter.addCalendarMonths(this._calendar.activeDate, -1),
                    this._calendar.monthSelected.emit(this._calendar.activeDate)
                }
                nextClicked() {
                    this._calendar.activeDate = this._dateAdapter.addCalendarMonths(this._calendar.activeDate, 1),
                    this._calendar.monthSelected.emit(this._calendar.activeDate)
                }
            }
            ;
            var uI, mI, hI, pI, gI;
            dI = (0,
            c.gn)([(0,
            i.Component)({
                selector: "month-navigation-calendar-header",
                template: n(26858)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(oi._H)), (0,
            c.fM)(1, (0,
            i.Inject)(si._A)), (0,
            c.fM)(2, (0,
            i.Inject)(si.sG)), (0,
            c.fM)(3, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (rI = void 0 !== oi._H && oi._H) ? rI : Object, "function" == typeof (sI = void 0 !== si._A && si._A) ? sI : Object, Object, "function" == typeof (oI = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? oI : Object])], dI),
            function(e) {
                e[e.LOADING = 0] = "LOADING",
                e[e.LOADED = 1] = "LOADED",
                e[e.ERROR = 2] = "ERROR"
            }(gI || (gI = {}));
            let fI = class {
                constructor(e) {
                    this._elementRef = e,
                    this.clickThumbnail = new i.EventEmitter,
                    this.onLoad = new i.EventEmitter,
                    this.PreviewType = Qw,
                    this.ComponentState = gI,
                    this.time = 0,
                    this.timeToJumpTo = 0,
                    this.numEvents = 1,
                    this.numMinutePreviews = 1,
                    this.type = Qw.HOUR,
                    this.state = gI.LOADING
                }
                ngOnInit() {
                    this._imageObject = this._elementRef.nativeElement.querySelector(".preview-image"),
                    this._imageObject ? this._setUpEventListeners(this._imageObject) : this.state = gI.ERROR
                }
                _setUpEventListeners(e) {
                    e.addEventListener("load", this._loadedComponent.bind(this)),
                    e.addEventListener("error", this._errorComponent.bind(this))
                }
                _loadedComponent() {
                    this.state = gI.LOADED,
                    this.onLoad.emit()
                }
                _errorComponent() {
                    this.state = gI.ERROR,
                    this.onLoad.emit()
                }
                clickPreview() {
                    this.clickThumbnail.emit({
                        time: this.time,
                        timeToJumpTo: this.timeToJumpTo,
                        numEvents: this.numEvents,
                        type: this.type,
                        numMinutePreviews: this.numMinutePreviews
                    })
                }
                thumbnailIsReady() {
                    return this.state !== gI.LOADING
                }
                hideThumbnailImage() {
                    return this.state === gI.ERROR || !this.thumbnailIsReady()
                }
                hideFrownyFace() {
                    return this.state !== gI.ERROR && !this.thumbnailIsReady()
                }
                ngOnDestroy() {
                    this._imageObject && (this._imageObject.removeEventListener("load", this._loadedComponent),
                    this._imageObject.removeEventListener("error", this._errorComponent))
                }
                getImageObject() {
                    return this._imageObject
                }
                getNativeElement() {
                    return this._elementRef.nativeElement
                }
            }
            ;
            var vI, yI, bI, SI, CI, wI, II, TI, EI, _I, xI, DI, OI, AI;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Number)], fI.prototype, "time", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Number)], fI.prototype, "numEvents", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Number)], fI.prototype, "numMinutePreviews", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (uI = void 0 !== Qw && Qw) ? uI : Object)], fI.prototype, "type", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Number)], fI.prototype, "timeToJumpTo", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (mI = void 0 !== i.EventEmitter && i.EventEmitter) ? mI : Object)], fI.prototype, "clickThumbnail", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (hI = void 0 !== i.EventEmitter && i.EventEmitter) ? hI : Object)], fI.prototype, "onLoad", void 0),
            fI = (0,
            c.gn)([(0,
            i.Component)({
                selector: "thumbnail",
                template: n(79549)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(i.ElementRef)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (pI = void 0 !== i.ElementRef && i.ElementRef) ? pI : Object])], fI);
            const RI = {
                height: "500",
                width: "500"
            };
            let PI = class {
                constructor(e, t, n, a) {
                    this._orchidDataService = e,
                    this._motionRequestService = t,
                    this._elementRef = n,
                    this._timeService = a,
                    this.msgs = L.messages.thumbnailSearch.overlay,
                    this.thumbnailSearchCalendarHeader = dI,
                    this.ThumbnailSearchState = eI,
                    this.ThumbnailSize = tI,
                    this.PreviewType = Qw,
                    this.dateClass = (e, t) => {
                        var n, i;
                        const a = []
                          , r = Ns(e);
                        let s;
                        return s = this.smartSearchActive ? null !== (n = this._smartSearchMotionMap.get(r)) && void 0 !== n ? n : 0 : null !== (i = this._motionMap.get(r)) && void 0 !== i ? i : 0,
                        "month" === t && (a.push("thumbnail-search-default-date-cell"),
                        s > 0 && !this.smartSearchActive ? (a.push("has-normal-motion"),
                        a.push(this._getMotionIndicatorClass(s))) : s > 0 && this.smartSearchActive && (a.push("has-smart-search-motion"),
                        a.push(this._getMotionIndicatorClass(s))),
                        Ns(e) === Ns(this.selectedDate) && this.smartSearchActive && s > 0 && a.push("is-selected-date")),
                        a.join(" ")
                    }
                    ,
                    this._thumbnailChildren = new i.QueryList,
                    this._currentThumbnailElementsBeingObserved = [],
                    this._thumbnailsToLoad = new cI,
                    this.selectedDate = new Date,
                    this._previousValidDate = new Date,
                    this._monthInView = new Date(Ls(this.selectedDate)),
                    this.previewsReady = !1,
                    this._previewsAreLoading = !0,
                    this.thumbnailSearchState = eI.HOURLY,
                    this.thumbnailSizeState = tI.LARGE,
                    this.hourThumbnailsToRender = [],
                    this.minuteThumbnailsToRender = [],
                    this.minuteThumbnailsMap = new Map,
                    this.minutePreviewClick = new i.EventEmitter,
                    this.close = new i.EventEmitter,
                    this.smartSearchActive = !1,
                    this._lastSearchRegionBounds = [[]],
                    this._motionMap = new Map,
                    this._smartSearchMotionMap = new Map,
                    this._motionFetchingRecord = [],
                    this._smartMotionFetchingRecord = [],
                    this._mostMotionEvents = 0,
                    this._mostSmartSearchMotionEvents = 0,
                    this._intersectionObserver$ = new IntersectionObserver(this._handleChildIntersect.bind(this),{
                        root: this._elementRef.nativeElement.parentElement,
                        rootMargin: "0px"
                    })
                }
                ngOnChanges(e) {
                    e.searchRegionBounds && this.smartSearchActive && !e.searchRegionBounds.firstChange ? (lI.searchRegionsHaveChanged(this._lastSearchRegionBounds, e.searchRegionBounds.currentValue) && this.stream && this.orchid && (this._disableAllPreviews(),
                    this._cleanUpSmartSearchRequester(),
                    this._activateSmartSearchRequester(this.searchRegionBounds, this.smartSearchCanvasSize, this.stream.id),
                    this._handleSearchRegionChanges(e).then(( () => {
                        this._enableAllPreviews()
                    }
                    ))),
                    this._lastSearchRegionBounds = xt(e.searchRegionBounds.currentValue)) : !e.smartSearchActive || this.smartSearchActive || e.smartSearchActive.firstChange || (this._disableAllPreviews(),
                    this._cleanUpSmartSearchRequester(),
                    this._handleSmartSearchStateChanges(e).then(( () => {
                        this._enableAllPreviews()
                    }
                    )))
                }
                ngOnInit() {
                    this.timelineValue && (this.selectedDate = new Date(this.timelineValue),
                    this._previousValidDate = new Date(Ns(new Date(this.timelineValue)))),
                    this.smartSearchActive && this._activateSmartSearchRequester(this.searchRegionBounds, this.smartSearchCanvasSize, this.stream.id),
                    this._fetchMonthlyMotionEvents(this.selectedDate).then(( () => {
                        this.setSelectedDate(this.selectedDate)
                    }
                    ))
                }
                ngAfterViewInit() {
                    this._thumbnailChildren.changes.subscribe((e => {
                        this._setUpIntersectionSubscriptions(e),
                        this._handleThumbnailLoadQueue(e)
                    }
                    ))
                }
                _setUpIntersectionSubscriptions(e) {
                    this._cleanUpInsersectionSubscriptions(),
                    e.toArray().forEach((e => {
                        this._currentThumbnailElementsBeingObserved.push(e.getNativeElement()),
                        this._intersectionObserver$.observe(e.getNativeElement())
                    }
                    ))
                }
                _cleanUpInsersectionSubscriptions() {
                    this._currentThumbnailElementsBeingObserved.forEach((e => {
                        this._intersectionObserver$.unobserve(e)
                    }
                    )),
                    this._currentThumbnailElementsBeingObserved = []
                }
                _handleThumbnailLoadQueue(e) {
                    this._thumbnailsToLoad.clear();
                    const t = this.thumbnailSearchState === eI.HOURLY ? Qw.HOUR : Qw.MINUTE
                      , n = this._extractSpecficThumbnailTypes(t, e);
                    n.forEach((e => {
                        n.indexOf(e) < 8 ? this._configureImageSource({
                            image: e.getImageObject(),
                            timestamp: e.timeToJumpTo
                        }) : this._thumbnailsToLoad.enqueue({
                            image: e.getImageObject(),
                            timestamp: e.timeToJumpTo
                        })
                    }
                    ))
                }
                _cleanUpSmartSearchRequester() {
                    this._smartMotionFetchingRecord = [],
                    this._smartSearchRequester && this._smartSearchRequester.complete()
                }
                _activateSmartSearchRequester(e, t, n) {
                    this._smartSearchRequester = this._motionRequestService.createSmartSearchMotionRequest(this.orchid, [lI.getSmartSearchRegionMappings(e, t, n)])
                }
                _extractSpecficThumbnailTypes(e, t) {
                    return t.toArray().filter((t => t.type === e))
                }
                ngOnDestroy() {
                    this._cleanUpSmartSearchRequester(),
                    this._cleanUpInsersectionSubscriptions()
                }
                _getMotionIndicatorClass(e) {
                    let t;
                    return t = this.smartSearchActive ? e / this._mostSmartSearchMotionEvents : e / this._mostMotionEvents,
                    t > .9 ? "has-high-motion" : t < .5 ? "has-low-motion" : "has-mid-motion"
                }
                _fetchMonthlyMotionEvents(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const t = new Date(e)
                          , n = new Date(t.getFullYear(),t.getMonth() + 1,1)
                          , i = new Date(t.getFullYear(),t.getMonth() - 1,1);
                        return this.smartSearchActive ? Promise.all([this._getSmartSearchMotionEventsForMonth(i), this._getSmartSearchMotionEventsForMonth(t), this._getSmartSearchMotionEventsForMonth(n)]).then(( ([e,t,n]) => [...e, ...t, ...n])) : Promise.all([this._getMotionEventsForMonth(i), this._getMotionEventsForMonth(t), this._getMotionEventsForMonth(n)]).then(( ([e,t,n]) => [...e, ...t, ...n]))
                    }
                    ))
                }
                _getSmartSearchMotionEventsForMonth(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const t = new Date(Ls(e));
                        if (this._smartMotionFetchingRecord.includes(t.getTime()))
                            return Promise.resolve([]);
                        const n = Ls(e)
                          , i = Ms(e);
                        if (this._smartSearchRequester) {
                            const e = yield this._smartSearchRequester.fetch(n, i, 0, void 0, Rs);
                            return this._populateSmartSearchMotionMap(e),
                            this._smartMotionFetchingRecord.push(t.getTime()),
                            e
                        }
                        return Promise.resolve([])
                    }
                    ))
                }
                _getMotionEventsForMonth(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const t = new Date(Ls(e));
                        if (this._motionFetchingRecord.includes(t.getTime()))
                            return Promise.resolve([]);
                        const n = Ls(e)
                          , i = Ms(e);
                        if (this.stream && this.orchid) {
                            const e = yield this._motionRequestService.createMotionRequest(this.orchid, [this.stream.id]).fetch(n, i, 0, void 0, Rs);
                            return this._populateMotionMap(e),
                            this._motionFetchingRecord.push(t.getTime()),
                            e
                        }
                        return Promise.resolve([])
                    }
                    ))
                }
                _populateMotionMap(e) {
                    e.forEach((e => {
                        e.count && this._motionMap.set(Ns(new Date(e.start)), e.count),
                        e.count && e.count > this._mostMotionEvents && (this._mostMotionEvents = e.count)
                    }
                    ))
                }
                _populateSmartSearchMotionMap(e) {
                    e.forEach((e => {
                        e.count && this._smartSearchMotionMap.set(Ns(new Date(e.start)), e.count),
                        e.count && e.count > this._mostSmartSearchMotionEvents && (this._mostSmartSearchMotionEvents = e.count)
                    }
                    ))
                }
                setSelectedDate(e) {
                    var t, n;
                    Us(e) ? (this._previousValidDate = e,
                    this._disablePreviews(null === (t = this.hoursContainer) || void 0 === t ? void 0 : t.nativeElement, null === (n = this.hoursSpinner) || void 0 === n ? void 0 : n.nativeElement),
                    this.thumbnailSearchState = eI.HOURLY,
                    this._handleDateChange(e).then(( () => {
                        var e, t, n;
                        this._enablePreviews(null === (e = this.hoursContainer) || void 0 === e ? void 0 : e.nativeElement, null === (t = this.hoursSpinner) || void 0 === t ? void 0 : t.nativeElement, this.thumbnailSizeState),
                        lI.setElementProperty(null === (n = this.minutesContainer) || void 0 === n ? void 0 : n.nativeElement, iI.HEIGHT, 0)
                    }
                    ))) : this.setSelectedDate(this._previousValidDate)
                }
                handlePreviewClick(e) {
                    var t, n;
                    e.type === Qw.HOUR ? (this._thumbnailsToLoad.clear(),
                    this.currentSelectedHourToRender = e,
                    this._renderMinutePreviews(this.currentSelectedHourToRender.time),
                    this._enablePreviews(null === (t = this.minutesContainer) || void 0 === t ? void 0 : t.nativeElement, null === (n = this.minutesSpinner) || void 0 === n ? void 0 : n.nativeElement, this.thumbnailSizeState)) : e.type === Qw.MINUTE && this.minutePreviewClick.emit(e.timeToJumpTo)
                }
                _handleSearchRegionChanges(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this._fetchMonthlyMotionEvents(this._monthInView),
                        !e.searchRegionBounds.firstChange)
                            switch (this.thumbnailSearchState) {
                            case eI.HOURLY:
                                yield this._getSmartSearchMotionEventsForDay(this.selectedDate);
                                break;
                            case eI.MINUTELY:
                                yield this._getSmartSearchMotionEventsForDay(this.selectedDate),
                                this.currentSelectedHourToRender && this._renderMinutePreviews(this.currentSelectedHourToRender.time)
                            }
                        return Promise.resolve()
                    }
                    ))
                }
                _handleSmartSearchStateChanges(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this._smartMotionFetchingRecord = [],
                        this._fetchMonthlyMotionEvents(this._monthInView),
                        this.smartSearchActive && !e.smartSearchActive.firstChange)
                            switch (this.thumbnailSearchState) {
                            case eI.HOURLY:
                                yield this._getSmartSearchMotionEventsForDay(this.selectedDate);
                                break;
                            case eI.MINUTELY:
                                yield this._getSmartSearchMotionEventsForDay(this.selectedDate),
                                this.currentSelectedHourToRender && this._renderMinutePreviews(this.currentSelectedHourToRender.time)
                            }
                        else if (!this.smartSearchActive && !e.smartSearchActive.firstChange)
                            switch (this.thumbnailSearchState) {
                            case eI.HOURLY:
                                yield this._getMotionEventsForDay(this.selectedDate);
                                break;
                            case eI.MINUTELY:
                                yield this._getMotionEventsForDay(this.selectedDate),
                                this.currentSelectedHourToRender && this._renderMinutePreviews(this.currentSelectedHourToRender.time)
                            }
                    }
                    ))
                }
                _handleDateChange(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this.smartSearchActive) {
                            const t = yield this._getSmartSearchMotionEventsForDay(e);
                            if (this.thumbnailSearchState === eI.MINUTELY) {
                                const t = Fs(e, this._getCurrentSelectedHourThumbnail().time).getTime();
                                this._renderMinutePreviews(t)
                            }
                            return this.selectedDate = e,
                            t
                        }
                        {
                            const t = yield this._getMotionEventsForDay(e);
                            if (this.thumbnailSearchState === eI.MINUTELY) {
                                const t = Fs(e, this._getCurrentSelectedHourThumbnail().time).getTime();
                                this._renderMinutePreviews(t)
                            }
                            return this.selectedDate = e,
                            t
                        }
                    }
                    ))
                }
                _getMotionEventsForDay(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this.orchid && this.stream && Us(e)) {
                            const t = Ns(e)
                              , n = yield this._motionRequestService.createMotionRequest(this.orchid, [this.stream.id]).fetchMotionReport(t, this.stream.id);
                            return this.eventsInformation = n,
                            this._initializeHourPreviews(),
                            this._initializeMinutePreviews(),
                            n
                        }
                        return Promise.resolve({
                            hours: [],
                            href: ""
                        })
                    }
                    ))
                }
                _getSmartSearchMotionEventsForDay(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this._smartSearchRequester && this.stream && Us(e)) {
                            const t = Ns(e)
                              , n = yield this._smartSearchRequester.fetchMotionReport(t, this.stream.id);
                            return this.eventsInformation = n,
                            this._initializeHourPreviews(),
                            this._initializeMinutePreviews(),
                            n
                        }
                        return Promise.resolve({
                            hours: [],
                            href: ""
                        })
                    }
                    ))
                }
                _initializeHourPreviews() {
                    this.eventsInformation && this.orchid && this.stream && (this.hourThumbnailsToRender = lI.generatePopulatedHourThumbnailsArray(this.eventsInformation.hours))
                }
                _initializeMinutePreviews() {
                    this.eventsInformation && this.orchid && this.stream && (this.minuteThumbnailsMap.clear(),
                    this.eventsInformation.hours.forEach((e => {
                        const t = lI.generatePopulatedMinuteThumbnailsArray(e);
                        this.minuteThumbnailsMap.set(e.hourStart, t)
                    }
                    )))
                }
                _renderMinutePreviews(e) {
                    var t, n, i;
                    this.minuteThumbnailsToRender = null !== (t = this.minuteThumbnailsMap.get(e)) && void 0 !== t ? t : [],
                    this._disablePreviews(null === (n = this.minutesContainer) || void 0 === n ? void 0 : n.nativeElement, null === (i = this.minutesSpinner) || void 0 === i ? void 0 : i.nativeElement),
                    this.thumbnailSearchState = eI.MINUTELY
                }
                _getCurrentSelectedHourThumbnail() {
                    return this.currentSelectedHourToRender ? this.currentSelectedHourToRender : {
                        time: 0,
                        type: Qw.HOUR,
                        timeToJumpTo: 0,
                        numEvents: 0,
                        numMinutePreviews: 0
                    }
                }
                backButtonClick() {
                    var e, t;
                    this._thumbnailsToLoad.clear(),
                    this._disablePreviews(null === (e = this.hoursContainer) || void 0 === e ? void 0 : e.nativeElement, null === (t = this.hoursSpinner) || void 0 === t ? void 0 : t.nativeElement),
                    this.thumbnailSearchState = eI.HOURLY,
                    this._handleDateChange(this.selectedDate).then(( () => {
                        var e, t;
                        this._enablePreviews(null === (e = this.hoursContainer) || void 0 === e ? void 0 : e.nativeElement, null === (t = this.hoursSpinner) || void 0 === t ? void 0 : t.nativeElement, this.thumbnailSizeState),
                        this._handleOverlayScroll(nI.MINUTE)
                    }
                    ))
                }
                _getScrollPosition(e) {
                    var t;
                    const n = document.getElementById(`thumbnail-hour-${e}`);
                    return null !== (t = null == n ? void 0 : n.offsetTop) && void 0 !== t ? t : 0
                }
                closeButtonClick() {
                    this.close.emit()
                }
                showNoPreviewsMessage(e) {
                    return this._noPreviewsAvailable() && !this._previewsAreLoading && this.thumbnailSearchState === e
                }
                getHintText() {
                    if (this._noPreviewsAvailable() || this._previewsAreLoading)
                        return "";
                    switch (this.thumbnailSearchState) {
                    case eI.HOURLY:
                        return this.msgs.selectAnHourToViewItsEvents();
                    case eI.MINUTELY:
                        return this.msgs.selectAnEventToStartPlayback();
                    default:
                        return ""
                    }
                }
                _noPreviewsAvailable() {
                    switch (this.thumbnailSearchState) {
                    case eI.HOURLY:
                        return this.previewsReady && 0 === this.hourThumbnailsToRender.length;
                    case eI.MINUTELY:
                        return 0 === this.minuteThumbnailsToRender.length
                    }
                }
                _disablePreviews(e, t) {
                    lI.setElementProperty(e, iI.DISPLAY, "none"),
                    lI.setElementProperty(t, iI.DISPLAY, "flex"),
                    this._previewsAreLoading = !0
                }
                _disableAllPreviews() {
                    var e, t, n, i;
                    this._disablePreviews(null === (e = this.hoursContainer) || void 0 === e ? void 0 : e.nativeElement, null === (t = this.hoursSpinner) || void 0 === t ? void 0 : t.nativeElement),
                    this._disablePreviews(null === (n = this.minutesContainer) || void 0 === n ? void 0 : n.nativeElement, null === (i = this.minutesSpinner) || void 0 === i ? void 0 : i.nativeElement)
                }
                _enableAllPreviews() {
                    var e, t, n, i;
                    this._enablePreviews(null === (e = this.hoursContainer) || void 0 === e ? void 0 : e.nativeElement, null === (t = this.hoursSpinner) || void 0 === t ? void 0 : t.nativeElement, this.thumbnailSizeState),
                    this._enablePreviews(null === (n = this.minutesContainer) || void 0 === n ? void 0 : n.nativeElement, null === (i = this.minutesSpinner) || void 0 === i ? void 0 : i.nativeElement, this.thumbnailSizeState)
                }
                _enablePreviews(e, t, n) {
                    this.previewsReady = !0,
                    this._previewsAreLoading = !1;
                    const i = n === tI.LARGE ? "flex" : "grid";
                    lI.setElementProperty(e, iI.DISPLAY, i),
                    lI.setElementProperty(t, iI.DISPLAY, "none")
                }
                toggleThumbnailSize(e) {
                    var t, n;
                    lI.removeElementProperty(null === (t = this.hoursContainer) || void 0 === t ? void 0 : t.nativeElement, iI.DISPLAY),
                    lI.removeElementProperty(null === (n = this.minutesContainer) || void 0 === n ? void 0 : n.nativeElement, iI.DISPLAY),
                    this.thumbnailSizeState = e
                }
                handleMonthChange(e) {
                    this._monthInView = new Date(Ls(e)),
                    this._fetchMonthlyMotionEvents(this._monthInView)
                }
                handleStartOfSlideAnimation(e) {
                    var t, n, i, a, r, s;
                    e.fromState === nI.HOUR ? (lI.setElementProperty(null === (t = this.hoursContainer) || void 0 === t ? void 0 : t.nativeElement, iI.OPACITY, "0"),
                    lI.setElementProperty(null === (n = this.minutesContainer) || void 0 === n ? void 0 : n.nativeElement, iI.HEIGHT, "auto"),
                    lI.setElementProperty(null === (i = this.minutesContainer) || void 0 === i ? void 0 : i.nativeElement, iI.OPACITY, "1")) : e.fromState !== nI.VOID && e.fromState !== nI.MINUTE || (lI.setElementProperty(null === (a = this.minutesContainer) || void 0 === a ? void 0 : a.nativeElement, iI.OPACITY, "0"),
                    lI.setElementProperty(null === (r = this.hoursContainer) || void 0 === r ? void 0 : r.nativeElement, iI.HEIGHT, "auto"),
                    lI.setElementProperty(null === (s = this.hoursContainer) || void 0 === s ? void 0 : s.nativeElement, iI.OPACITY, "1")),
                    this._handleOverlayScroll(e.fromState)
                }
                _handleOverlayScroll(e) {
                    var t, n, i, a;
                    const r = this._elementRef.nativeElement.parentElement;
                    if (r.clientHeight <= 600) {
                        if (e === nI.HOUR)
                            r.scrollTop = 0;
                        else if (e === nI.MINUTE) {
                            const e = null !== (i = this._getScrollPosition(this._getCurrentSelectedHourThumbnail().timeToJumpTo) + (null === (n = null === (t = this.overlayHeader) || void 0 === t ? void 0 : t.nativeElement) || void 0 === n ? void 0 : n.offsetHeight)) && void 0 !== i ? i : 0;
                            lI.setElementProperty(r, iI.SCROLL_TOP, e)
                        }
                    } else if (e === nI.MINUTE || e === nI.VOID) {
                        const e = this._getScrollPosition(this._getCurrentSelectedHourThumbnail().timeToJumpTo);
                        lI.setElementProperty(null === (a = this.hoursContainer) || void 0 === a ? void 0 : a.nativeElement, iI.SCROLL_TOP, e)
                    }
                }
                handleEndOfSlideAnimation(e) {
                    var t, n, i, a;
                    e.fromState === nI.HOUR ? this._scrollToTopAndShrinkContainerHeight(null === (t = this.hoursContainer) || void 0 === t ? void 0 : t.nativeElement) : e.fromState === nI.MINUTE ? this._scrollToTopAndShrinkContainerHeight(null === (n = this.minutesContainer) || void 0 === n ? void 0 : n.nativeElement) : e.fromState === nI.VOID && this.thumbnailSearchState === eI.HOURLY ? this._scrollToTopAndShrinkContainerHeight(null === (i = this.minutesContainer) || void 0 === i ? void 0 : i.nativeElement) : e.fromState === nI.VOID && this.thumbnailSearchState === eI.MINUTELY && this._scrollToTopAndShrinkContainerHeight(null === (a = this.hoursContainer) || void 0 === a ? void 0 : a.nativeElement)
                }
                _scrollToTopAndShrinkContainerHeight(e) {
                    lI.removeElementProperty(e, iI.SCROLL_TOP),
                    lI.setElementProperty(e, iI.HEIGHT, "0px")
                }
                getAnimationState() {
                    return this.thumbnailSearchState === eI.HOURLY ? nI.HOUR : nI.MINUTE
                }
                _handleChildIntersect(e) {
                    e.forEach((e => {
                        e.isIntersecting && (e.target.classList.contains("fade-in") || e.target.classList.add("fade-in"))
                    }
                    ))
                }
                _configureImageSource(e) {
                    (null == e ? void 0 : e.image) && 0 === e.image.src.length && (e.image.src = this._orchidDataService.frameUrl(this.orchid, this.stream, e.timestamp + 500 - this._timeService.getOrchidTimeOffset(this.orchid.id), RI, !1))
                }
                handleThumbnailLoad() {
                    this._thumbnailsToLoad.size() > 0 && this._configureImageSource(this._thumbnailsToLoad.dequeue())
                }
            }
            ;
            var kI, MI;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Number)], PI.prototype, "timelineValue", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], PI.prototype, "stream", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], PI.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], PI.prototype, "smartSearchActive", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], PI.prototype, "searchRegionBounds", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], PI.prototype, "smartSearchCanvasSize", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (vI = void 0 !== i.EventEmitter && i.EventEmitter) ? vI : Object)], PI.prototype, "minutePreviewClick", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (yI = void 0 !== i.EventEmitter && i.EventEmitter) ? yI : Object)], PI.prototype, "close", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("hoursContainer"), (0,
            c.w6)("design:type", "function" == typeof (bI = void 0 !== i.ElementRef && i.ElementRef) ? bI : Object)], PI.prototype, "hoursContainer", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("minutesContainer"), (0,
            c.w6)("design:type", "function" == typeof (SI = void 0 !== i.ElementRef && i.ElementRef) ? SI : Object)], PI.prototype, "minutesContainer", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("overlayCard"), (0,
            c.w6)("design:type", "function" == typeof (CI = void 0 !== i.ElementRef && i.ElementRef) ? CI : Object)], PI.prototype, "overlayCard", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("overlayHeader"), (0,
            c.w6)("design:type", "function" == typeof (wI = void 0 !== i.ElementRef && i.ElementRef) ? wI : Object)], PI.prototype, "overlayHeader", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("hoursSpinner"), (0,
            c.w6)("design:type", "function" == typeof (II = void 0 !== i.ElementRef && i.ElementRef) ? II : Object)], PI.prototype, "hoursSpinner", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("minutesSpinner"), (0,
            c.w6)("design:type", "function" == typeof (TI = void 0 !== i.ElementRef && i.ElementRef) ? TI : Object)], PI.prototype, "minutesSpinner", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("picker"), (0,
            c.w6)("design:type", "function" == typeof (EI = void 0 !== oi.Mq && oi.Mq) ? EI : Object)], PI.prototype, "datepicker", void 0),
            (0,
            c.gn)([(0,
            i.ViewChildren)(fI), (0,
            c.w6)("design:type", "function" == typeof (_I = void 0 !== i.QueryList && i.QueryList) ? _I : Object)], PI.prototype, "_thumbnailChildren", void 0),
            PI = (0,
            c.gn)([(0,
            i.Component)({
                selector: "thumbnail-search-overlay",
                template: n(36311),
                animations: [(0,
                Jo.X$)("hourlyMinutely", [(0,
                Jo.SB)("hour", (0,
                Jo.oB)({
                    transform: "translateX(0)"
                })), (0,
                Jo.SB)("minute", (0,
                Jo.oB)({
                    transform: "translateX(-50%)"
                })), (0,
                Jo.eR)("hour => minute, minute => hour", [(0,
                Jo.jt)("0.3s 0.05s cubic-bezier(0.4, 0.0, 0.2, 1)")])])]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pt)), (0,
            c.fM)(1, (0,
            i.Inject)(Tg)), (0,
            c.fM)(2, (0,
            i.Inject)(i.ElementRef)), (0,
            c.fM)(3, (0,
            i.Inject)(ug)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (xI = pt) ? xI : Object, "function" == typeof (DI = void 0 !== Tg && Tg) ? DI : Object, "function" == typeof (OI = void 0 !== i.ElementRef && i.ElementRef) ? OI : Object, "function" == typeof (AI = void 0 !== ug && ug) ? AI : Object])], PI);
            const LI = O("RecorderPermGroups");
            let NI = class {
                constructor(e, t) {
                    this._managedRecordersService = e,
                    this._cdr = t,
                    this.msgs = Object.assign({}, L.messages.recorderPermGroups),
                    this.editable = !1,
                    this.preselectUserGroups = !1,
                    this._recorderId = "",
                    this.selectionChange = new i.EventEmitter,
                    this._unsubscribe$ = new St.x,
                    this._loading = {
                        userManagementGroups: !0,
                        recorderManagementGroups: !0
                    },
                    this.loading = !0,
                    this._userManagementGroups = [],
                    this._recorderManagementGroups = [],
                    this.groups = [],
                    this.valid = !0,
                    this.groupIdsControl = new p.NI([],this._createPermGroupValidator())
                }
                set recorderId(e) {
                    this._recorderId = e
                }
                get recorderId() {
                    return this._recorderId
                }
                ngOnInit() {
                    this._getUserManagementGroups(),
                    this.recorderId ? this._getRecorderManagementGroups() : (this._loading.recorderManagementGroups = !1,
                    this._checkLoading()),
                    this.groupIdsControl.valueChanges.pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe((e => {
                        this._handleSelectionChange(e)
                    }
                    ))
                }
                ngOnDestroy() {
                    this._unsubscribe$.next(!0),
                    this._unsubscribe$.complete()
                }
                _createPermGroupValidator() {
                    return e => e.value.length > 0 ? null : {
                        required: !0
                    }
                }
                _getUserManagementGroups() {
                    this._managedRecordersService.getUserManagementGroups().pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe({
                        next: e => {
                            this._handleUserManagementGroupsResponse(e)
                        }
                        ,
                        error: e => {
                            LI("error", e),
                            this._handleUserManagementGroupsResponse([])
                        }
                    })
                }
                _handleUserManagementGroupsResponse(e) {
                    this._userManagementGroups = e,
                    this._loading.userManagementGroups = !1,
                    this._checkLoading()
                }
                _getRecorderManagementGroups() {
                    this.recorderId || this._handleRecorderManagementGroupsResponse([]),
                    this._managedRecordersService.getRecorderManagementGroups(this.recorderId).pipe((0,
                    oa.R)(this._unsubscribe$)).subscribe({
                        next: e => {
                            this._handleRecorderManagementGroupsResponse(e)
                        }
                        ,
                        error: e => {
                            LI("error", e),
                            this._handleRecorderManagementGroupsResponse([])
                        }
                    })
                }
                _handleRecorderManagementGroupsResponse(e) {
                    this._recorderManagementGroups = e,
                    this._loading.recorderManagementGroups = !1,
                    this._checkLoading()
                }
                _checkLoading() {
                    if (!1 === this._loading.userManagementGroups && !1 === this._loading.recorderManagementGroups) {
                        if (this.groups = [],
                        !this.editable)
                            return this.groups = this.groups.concat(this._recorderManagementGroups),
                            this._handleSelectionChange(this._recorderManagementGroups),
                            this.loading = !1,
                            void this._cdr.detectChanges();
                        const e = this.parseAllOrchidsGroups(this._recorderManagementGroups)
                          , t = this.parseAllOrchidsGroups(this._userManagementGroups);
                        this.groups = this.groups.concat(t),
                        this.loading = !1,
                        this.preselectUserGroups ? (this.groupIdsControl.setValue(t),
                        this._handleSelectionChange(t)) : (this.groupIdsControl.setValue(e),
                        this._handleSelectionChange(e)),
                        this._cdr.detectChanges()
                    }
                }
                parseAllOrchidsGroups(e) {
                    const t = [];
                    return e.forEach((e => {
                        t.push(e.allOrchids ? Object.assign(Object.assign({}, e), {
                            readonly: !0
                        }) : Object.assign({}, e))
                    }
                    )),
                    t.sort(( (e, t) => e.readonly && !t.readonly ? -1 : !e.readonly && t.readonly ? 1 : 0)),
                    t
                }
                _handleSelectionChange(e) {
                    const t = e.map((e => e.id));
                    this.valid = this._checkValidity(t),
                    this.selectionChange.emit({
                        value: t,
                        valid: this.valid
                    }),
                    this._cdr.detectChanges()
                }
                _checkValidity(e) {
                    return e.some((e => this._userManagementGroups.find((t => t.id === e))))
                }
                handleKeydownEnter(e) {
                    e.stopPropagation()
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], NI.prototype, "editable", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], NI.prototype, "preselectUserGroups", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String), (0,
            c.w6)("design:paramtypes", [String])], NI.prototype, "recorderId", null),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], NI.prototype, "selectionChange", void 0),
            NI = (0,
            c.gn)([(0,
            i.Component)({
                selector: "recorder-perm-groups",
                template: n(8703),
                changeDetection: i.ChangeDetectionStrategy.OnPush
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pb)), (0,
            c.fM)(1, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (kI = void 0 !== pb && pb) ? kI : Object, "function" == typeof (MI = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? MI : Object])], NI);
            let FI = class {
                constructor() {
                    this.onDismiss = new i.EventEmitter,
                    this.msgs = Object.assign({}, L.messages.recorderRecovery.dialogs.refreshNotification)
                }
                reload() {
                    window.location.reload()
                }
            }
            ;
            var UI, $I;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], FI.prototype, "title", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], FI.prototype, "onDismiss", void 0),
            FI = (0,
            c.gn)([(0,
            i.Component)({
                selector: "refresh-alert",
                template: n(65704)
            })], FI);
            let jI = class {
                constructor(e, t) {
                    this.router = e,
                    this.overlayService = t,
                    this.msgs = Object.assign({}, L.messages.recorderRecovery.dialogs.refreshNotification),
                    this.destroyed$ = new St.x
                }
                alert(e) {
                    "recovery" === e.reason && this.showAlertOverlay(this.msgs.recorderVALUEHasBeenRecovered({
                        VALUE: e.recoveredOrchid.name
                    }))
                }
                isRecoveryRefreshNeeded() {
                    var e, t;
                    const n = null === (t = null === (e = this.router.parseUrl(this.router.url).root.children.primary) || void 0 === e ? void 0 : e.segments) || void 0 === t ? void 0 : t[0].path;
                    return ["camera-groups", "permission-groups", "system-alerts", "motion-alerts", "events-subscriptions", "events-viewer", "library"].includes(n)
                }
                showAlertOverlay(e) {
                    this.refreshAlertOverlayRef && this.destroyAlertOverlay();
                    const t = this.overlayService.position().global().centerHorizontally().top("10px")
                      , n = this.overlayService.scrollStrategies.reposition({
                        autoClose: !1
                    });
                    this.refreshAlertOverlayRef = this.overlayService.create({
                        positionStrategy: t,
                        scrollStrategy: n,
                        hasBackdrop: !1,
                        disposeOnNavigation: !0
                    });
                    const i = new xf.C5(FI)
                      , a = this.refreshAlertOverlayRef.attach(i);
                    a.instance.title = e,
                    a.instance.onDismiss.pipe((0,
                    pn.q)(1)).subscribe(( () => this.destroyAlertOverlay())),
                    this.router.events.pipe((0,
                    ra.h)((e => e instanceof Bt.jw)), (0,
                    ra.h)(( () => !this.isRecoveryRefreshNeeded())), (0,
                    oa.R)(this.destroyed$)).subscribe(( () => this.destroyAlertOverlay()))
                }
                destroyAlertOverlay() {
                    var e;
                    null === (e = this.refreshAlertOverlayRef) || void 0 === e || e.dispose(),
                    this.refreshAlertOverlayRef = void 0
                }
                ngOnDestroy() {
                    this.destroyed$.next(),
                    this.destroyed$.complete()
                }
            }
            ;
            jI = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (UI = void 0 !== Bt.F0 && Bt.F0) ? UI : Object, "function" == typeof ($I = void 0 !== Zn.aV && Zn.aV) ? $I : Object])], jI);
            const VI = O("AudioInput.service")
              , GI = new i.InjectionToken("audioContext",{
                providedIn: "root",
                factory: () => new AudioContext
            });
            let BI = class {
                constructor() {
                    this._microphonePermissionState = new P.X(void 0),
                    this.micPermissionState$ = this._microphonePermissionState.asObservable(),
                    this._selectedInputDeviceId = new P.X("uninitialized"),
                    this.selectedDeviceId$ = this._selectedInputDeviceId.asObservable(),
                    this._audioDevices$ = new P.X(void 0),
                    this.audioDevices$ = this._audioDevices$.asObservable()
                }
                get micPermissionState() {
                    return this._microphonePermissionState.value
                }
                set micPermissionState(e) {
                    this._microphonePermissionState.next(e)
                }
                get selectedInputDeviceId() {
                    return this._selectedInputDeviceId.value
                }
                set selectedInputDeviceId(e) {
                    this._selectedInputDeviceId.next(e)
                }
                get audioDevices() {
                    return this._audioDevices$.value
                }
                set audioDevices(e) {
                    this._audioDevices$.next(e)
                }
                get supportsUserMedia() {
                    return !(!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia)
                }
                get supportsEnumerateDevices() {
                    return !(!navigator.mediaDevices || !navigator.mediaDevices.enumerateDevices)
                }
                _storeAudioDevices(e) {
                    const t = e.filter((e => "audioinput" === e.kind));
                    this.audioDevices = t
                }
                _validateSelectedDeviceId() {
                    var e;
                    if (this.audioDevices && 0 !== this.audioDevices.length) {
                        const t = this.audioDevices.find((e => e.deviceId === this.selectedInputDeviceId));
                        if (t)
                            this.selectedInputDeviceId = t.deviceId;
                        else {
                            const t = null === (e = this.audioDevices.find((e => "default" === e.deviceId))) || void 0 === e ? void 0 : e.deviceId;
                            this.selectedInputDeviceId = null != t ? t : this.audioDevices[0].deviceId
                        }
                    } else
                        this.selectedInputDeviceId = void 0
                }
                initializeAudioDevices() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (!this.supportsEnumerateDevices)
                            throw new Error("This browser does not support enumerateDevices");
                        try {
                            const e = yield navigator.mediaDevices.getUserMedia({
                                audio: !0,
                                video: !1
                            })
                              , t = yield navigator.mediaDevices.enumerateDevices();
                            navigator.mediaDevices.ondevicechange || (navigator.mediaDevices.ondevicechange = () => {
                                navigator.mediaDevices.getUserMedia({
                                    audio: !0,
                                    video: !1
                                }).then((e => {
                                    navigator.mediaDevices.enumerateDevices().then((e => {
                                        this._storeAudioDevices(e),
                                        this._validateSelectedDeviceId()
                                    }
                                    )).catch((e => {
                                        this.audioDevices = [],
                                        VI.error("Error fetching media devices: ", e)
                                    }
                                    )).finally(( () => {
                                        e.getTracks().forEach((e => e.stop()))
                                    }
                                    ))
                                }
                                )).catch(( () => {
                                    this._storeAudioDevices([]),
                                    this._validateSelectedDeviceId()
                                }
                                ))
                            }
                            ),
                            this._storeAudioDevices(t),
                            e.getTracks().forEach((e => e.stop()))
                        } catch (e) {
                            Promise.reject(e)
                        }
                    }
                    ))
                }
                getAudioStream(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (!this.supportsUserMedia)
                            throw new Error("This browser does not support getUserMedia");
                        try {
                            return yield navigator.mediaDevices.getUserMedia({
                                audio: {
                                    deviceId: {
                                        exact: e
                                    }
                                }
                            })
                        } catch (e) {
                            return Promise.reject(e)
                        }
                    }
                    ))
                }
                requestMicrophonePermission() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (!this.supportsUserMedia)
                            throw new Error("This browser does not support getUserMedia");
                        return navigator.mediaDevices.getUserMedia({
                            audio: !0,
                            video: !1
                        }).then((e => (this.micPermissionState = "granted",
                        e.getTracks().forEach((e => e.stop())),
                        "granted"))).catch((e => "NotFoundError" === e.name ? (this.micPermissionState = void 0,
                        "prompt") : (this.micPermissionState = "denied",
                        "denied")))
                    }
                    ))
                }
                queryMicrophonePermission() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        return navigator.permissions.query({
                            name: "microphone"
                        }).then((e => (this.micPermissionState = e.state,
                        e.state))).catch(( () => this.requestMicrophonePermission()))
                    }
                    ))
                }
                fetchAndStoreAudioDevices() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (!this.supportsEnumerateDevices)
                            throw new Error("This browser does not support enumerateDevices");
                        try {
                            const e = yield navigator.mediaDevices.enumerateDevices();
                            this._storeAudioDevices(e)
                        } catch (e) {
                            Promise.reject(e)
                        }
                    }
                    ))
                }
                initializeSelectedDeviceId() {
                    var e;
                    if (this.audioDevices && 0 !== this.audioDevices.length) {
                        const t = null === (e = this.audioDevices.find((e => "default" === e.deviceId))) || void 0 === e ? void 0 : e.deviceId;
                        this.selectedInputDeviceId = null != t ? t : this.audioDevices[0].deviceId
                    } else
                        this.selectedInputDeviceId = void 0
                }
            }
            ;
            BI = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            })], BI);
            var zI, HI, WI, qI = n(82976);
            const YI = O("bidirectionalAudioOverlay.component");
            let XI = class {
                constructor(e) {
                    this._audioInputService = e,
                    this.isEnabled = !1,
                    this.talk = new i.EventEmitter,
                    this.mute = new i.EventEmitter,
                    this.micSelect = new i.EventEmitter,
                    this.close = new i.EventEmitter,
                    this.mediaStreamChange = new i.EventEmitter,
                    this.isMuted = !0,
                    this.noMicrophonePermission = !0,
                    this.inputDeviceUnavailable = !0,
                    this.msgs = L.messages.player.bidirectionalAudio,
                    this.fetchingTrack = !1,
                    this.destroyed = !1,
                    this.destroy$ = new St.x
                }
                get selectorWarningTooltip() {
                    return this.noMicrophonePermission ? this.msgs.microphonePermissionRequired() : this.inputDeviceUnavailable ? this.msgs.noDeviceFound() : ""
                }
                get microphoneIconClass() {
                    return this.fetchingTrack ? "fa-solid" : this.isEnabled ? this.isMuted ? this.noMicrophonePermission || this.inputDeviceUnavailable ? "fa-solid" : "fa-regular" : "fa-solid" : "fa-regular"
                }
                get canUnmute() {
                    return this.isMuted && !this.noMicrophonePermission && !this.inputDeviceUnavailable
                }
                ngOnInit() {
                    this.muteByPlayer.pipe((0,
                    oa.R)(this.destroy$)).subscribe(( () => {
                        this.onMute()
                    }
                    ));
                    const e = this._audioInputService.micPermissionState$.pipe((0,
                    sa.b)((e => {
                        this.noMicrophonePermission = "granted" !== e,
                        this.noMicrophonePermission && !this.isMuted && this.onMute()
                    }
                    )), (0,
                    oa.R)(this.destroy$))
                      , t = this._audioInputService.audioDevices$.pipe((0,
                    ra.h)(( () => "granted" === this._audioInputService.micPermissionState)), (0,
                    sa.b)((e => {
                        this.inputDeviceUnavailable = void 0 === e || 0 === e.length
                    }
                    )), (0,
                    oa.R)(this.destroy$))
                      , n = this._audioInputService.selectedDeviceId$.pipe((0,
                    ra.h)(( () => "granted" === this._audioInputService.micPermissionState)), (0,
                    sa.b)((e => (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        var t;
                        e ? "uninitialized" !== e && (this.inputDeviceUnavailable = !1,
                        this.isEnabled && !this.isMuted && (null === (t = this._audioStream) || void 0 === t || t.getAudioTracks().forEach((e => e.stop())),
                        this._audioStream = yield this._audioInputService.getAudioStream(e),
                        this._fetchTrackAndAddToSource(),
                        this.mediaStreamChange.emit({
                            stream: this._audioStream
                        }))) : (this.onMute(),
                        this.inputDeviceUnavailable = !0)
                    }
                    )))), (0,
                    oa.R)(this.destroy$))
                      , i = (0,
                    Be.P)(( () => this._audioInputService.queryMicrophonePermission()))
                      , a = (0,
                    Be.P)(( () => this._audioInputService.audioDevices ? Promise.resolve() : this._audioInputService.initializeAudioDevices()))
                      , r = (0,
                    sa.b)(( () => "uninitialized" === this._audioInputService.selectedInputDeviceId ? this._audioInputService.initializeSelectedDeviceId() : Promise.resolve()));
                    i.pipe((0,
                    Ks.w)((e => (0,
                    qI.s)(( () => "granted" === e), a.pipe(r), (0,
                    ze.of)(null)))), (0,
                    oa.R)(this.destroy$)).pipe((0,
                    Ks.w)(( () => (0,
                    Sy.a)([e, t, n]))), (0,
                    oa.R)(this.destroy$)).subscribe()
                }
                ngOnDestroy() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.onMute(),
                        this.destroyed = !0,
                        this.destroy$.next(),
                        this.destroy$.complete()
                    }
                    ))
                }
                onTalk() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (!this.fetchingTrack)
                            if (this.isEnabled)
                                try {
                                    this.fetchingTrack = !0,
                                    this._audioStream || (this._audioStream = yield this._audioInputService.getAudioStream(this._audioInputService.selectedInputDeviceId)),
                                    yield this._fetchTrackAndAddToSource(),
                                    this.destroyed || (this.isMuted = !1,
                                    this.talk.emit({
                                        stream: this._audioStream
                                    }))
                                } catch (e) {
                                    YI.error("Error getting audio input stream:", e),
                                    this.onMute()
                                } finally {
                                    this.fetchingTrack = !1
                                }
                            else
                                this._audioInputService.queryMicrophonePermission().then(( () => {
                                    this.isEnabled = !0
                                }
                                ))
                    }
                    ))
                }
                onMute() {
                    var e, t;
                    this.isMuted = !0,
                    null === (e = this.source) || void 0 === e || e.replaceAudioInputTrack(null),
                    null === (t = this._audioStream) || void 0 === t || t.getAudioTracks().forEach((e => e.stop())),
                    this._audioStream = void 0,
                    this.mute.emit()
                }
                onMicrophoneSelect() {
                    this.micSelect.emit()
                }
                disableOverlay() {
                    this.onMute(),
                    this.close.emit()
                }
                _fetchTrackAndAddToSource() {
                    var e;
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const t = this._audioStream.getAudioTracks()[0];
                        yield null === (e = this.source) || void 0 === e ? void 0 : e.replaceAudioInputTrack(t)
                    }
                    ))
                }
            }
            ;
            var KI;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], XI.prototype, "isEnabled", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (zI = void 0 !== Ln.y && Ln.y) ? zI : Object)], XI.prototype, "muteByPlayer", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], XI.prototype, "talk", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], XI.prototype, "mute", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], XI.prototype, "micSelect", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], XI.prototype, "close", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], XI.prototype, "mediaStreamChange", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (HI = void 0 !== zl && zl) ? HI : Object)], XI.prototype, "source", void 0),
            XI = (0,
            c.gn)([(0,
            i.Component)({
                selector: "bidirectional-audio-overlay",
                template: n(93936)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(BI)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (WI = void 0 !== BI && BI) ? WI : Object])], XI);
            let ZI = class {
                constructor(e) {
                    this._audioInputService = e,
                    this.onClose = new i.EventEmitter,
                    this.onSelect = new i.EventEmitter,
                    this.selectedMicrophone = new p.NI,
                    this.micOptions = [],
                    this.loading = !0,
                    this.msgs = Object.assign(Object.assign({}, L.messages.player.bidirectionalAudio), {
                        ok: L.messages.player.ok
                    }),
                    this.destroy$ = new St.x
                }
                ngOnInit() {
                    const e = this._audioInputService.micPermissionState$.pipe((0,
                    sa.b)((e => {
                        "granted" !== e && (this._handlePermissionDenied(),
                        this.loading = !1)
                    }
                    )), (0,
                    oa.R)(this.destroy$))
                      , t = this._audioInputService.audioDevices$.pipe((0,
                    ra.h)(( () => "granted" === this._audioInputService.micPermissionState)), (0,
                    sa.b)((e => {
                        e && e.length > 0 ? (this.micOptions = [...e],
                        this.selectedMicrophone.disabled && this.selectedMicrophone.enable()) : this._handleNoDevicesFound()
                    }
                    )), (0,
                    oa.R)(this.destroy$))
                      , n = this._audioInputService.selectedDeviceId$.pipe((0,
                    ra.h)(( () => "granted" === this._audioInputService.micPermissionState)), (0,
                    sa.b)((e => {
                        e ? "uninitialized" !== e && (this.selectedMicrophone.setValue(this.micOptions.find((t => t.deviceId === e))),
                        this.selectedMicrophone.disabled && this.selectedMicrophone.enable(),
                        this.loading = !1) : (this._handleNoDevicesFound(),
                        this.loading = !1)
                    }
                    )), (0,
                    oa.R)(this.destroy$))
                      , i = (0,
                    Be.P)(( () => this._audioInputService.queryMicrophonePermission()))
                      , a = (0,
                    Be.P)(( () => this._audioInputService.audioDevices ? Promise.resolve() : this._audioInputService.fetchAndStoreAudioDevices()))
                      , r = (0,
                    sa.b)(( () => "uninitialized" === this._audioInputService.selectedInputDeviceId ? this._audioInputService.initializeSelectedDeviceId() : Promise.resolve()));
                    i.pipe((0,
                    Ks.w)((e => (0,
                    qI.s)(( () => "granted" === e), a.pipe(r), (0,
                    ze.of)(null)))), (0,
                    oa.R)(this.destroy$)).pipe((0,
                    Ks.w)(( () => (0,
                    Sy.a)([e, t, n]))), (0,
                    oa.R)(this.destroy$)).subscribe()
                }
                ngOnDestroy() {
                    this.destroy$.next(),
                    this.destroy$.complete()
                }
                close() {
                    this.onClose.emit()
                }
                setNewMicrophone(e) {
                    this._audioInputService.selectedInputDeviceId = e.deviceId
                }
                onSelectOpenedChange(e) {
                    this.onSelect.emit(e)
                }
                _handleNoDevicesFound() {
                    this.micOptions = [{
                        label: this.msgs.noDeviceFound()
                    }],
                    this.selectedMicrophone.setValue(this.micOptions[0]),
                    this.selectedMicrophone.disable()
                }
                _handlePermissionDenied() {
                    this.micOptions = [{
                        label: this.msgs.permissionRequired()
                    }],
                    this.selectedMicrophone.setValue(this.micOptions[0]),
                    this.selectedMicrophone.disable()
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], ZI.prototype, "onClose", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], ZI.prototype, "onSelect", void 0),
            ZI = (0,
            c.gn)([(0,
            i.Component)({
                selector: "microphone-selector",
                template: n(52515)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(BI)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (KI = void 0 !== BI && BI) ? KI : Object])], ZI);
            const JI = O("WebRTCPlayingSource")
              , QI = {
                [Pw]: L.messages.errors.couldNotEstablishIceConnection(),
                [kw]: L.messages.errors.iceConnectionClosed(),
                [Mw]: L.messages.errors.timedOutWaitingForIceConnection(),
                [Lw]: L.messages.errors.poorConnectionPacketLoss(),
                [Nw]: L.messages.errors.poorConnectionNoDataReceived(),
                [Fw]: L.messages.errors.poorConnectionUnableToDecode(),
                [Uw]: L.messages.errors.timedOutWaitingForStreamToPlay()
            };
            class eT extends zl {
                constructor(e, t, n, i, a, r, s) {
                    if (super(e, s, "video"),
                    this._webRTCPeerConnectionFactory = t,
                    this._webRTCSignalerFactory = n,
                    this._streamId = a,
                    this._videoElement = r,
                    this._webRTCPeerConnection = null,
                    this._webRTCSignaler = null,
                    this._streamResolution = {
                        width: 0,
                        height: 0
                    },
                    this._offerResolve = null,
                    this._newStreamResolve = null,
                    this._framesDecodedSinceLastCheck = !0,
                    this._lastFrameReceivedAt = Date.now(),
                    this.framerateIssues = !1,
                    this._frameInterval = null,
                    !this._videoElement || this._videoElement instanceof HTMLVideoElement == !1)
                        throw new Error("videoElement must be an HTML video tag");
                    this._iceServers = function(e) {
                        const t = [];
                        return e && !0 === Array.isArray(e) ? (e.forEach((e => {
                            if (e.type && e.host && e.port)
                                if ("stun" === e.type)
                                    t.push({
                                        urls: "stun:" + e.host + ":" + e.port
                                    });
                                else if ("turn" === e.type) {
                                    const n = {
                                        urls: `turn:${e.host}:${e.port}`
                                    };
                                    n.urls = `turn:${e.host}:${e.port}`,
                                    e.credential && e.username && (n.credential = e.credential,
                                    n.username = e.username),
                                    t.push(n)
                                } else
                                    xw("error", "Invalid ICE entry type : " + e.type + ". Skipping...");
                            else
                                xw("error", "Invalid ICE server entry. Skipping...")
                        }
                        )),
                        t) : (xw("error", "Invalid ICE server configuration"),
                        t)
                    }(i)
                }
                isAdaptive() {
                    return !1
                }
                setContainerSize(e) {}
                setVolume(e) {
                    this._videoElement.muted = 0 === e,
                    this._videoElement.volume = e
                }
                replaceAudioInputTrack(e) {
                    var t;
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        yield null === (t = this._webRTCPeerConnection) || void 0 === t ? void 0 : t.replaceAudioInputTrack(e)
                    }
                    ))
                }
                _finalPlayingCheck() {
                    if (this._currentState === Ll)
                        return;
                    const e = (t = this._latestStats) ? "failed" === t.iceConnectionState || "disconnected" === t.iceConnectionState ? Pw : "closed" === t.iceConnectionState ? kw : "connected" !== t.iceConnectionState && "completed" !== t.iceConnectionState ? Mw : t.packetsLost > 0 ? Lw : t.packetsReceived <= 0 ? Nw : t.framesDecoded <= 0 ? Fw : Uw : Uw;
                    var t;
                    e === Uw && JI("warn", "Could not infer WebRTC failure reason"),
                    this._notifyError(new Rl(!0,QI[e]))
                }
                _getVideoFrame() {
                    return {
                        target: this._videoElement,
                        resolution: this._streamResolution
                    }
                }
                _createPlayPromise(e) {
                    this._clear();
                    const t = new Promise(( (e, t) => {
                        this._offerResolve = e
                    }
                    ))
                      , n = new Promise(( (e, t) => {
                        this._newStreamResolve = e
                    }
                    ));
                    return e.then(( () => (this._checkPlayCancel(),
                    this._initiatePlayRequest()))).then(( () => (this._checkPlayCancel(),
                    t))).then((e => {
                        var t;
                        return this._checkPlayCancel(),
                        null === (t = this._webRTCPeerConnection) || void 0 === t ? void 0 : t.generateAnswer(e)
                    }
                    )).then((e => {
                        var t;
                        this._checkPlayCancel(),
                        null === (t = this._webRTCSignaler) || void 0 === t || t.sendAnswer(e)
                    }
                    )).then(( () => (this._checkPlayCancel(),
                    n))).then((e => (this._checkPlayCancel(),
                    this._configureAndPlayVideoSrc(e)))).then((e => {
                        this._checkPlayCancel(),
                        this._frameInterval = setInterval(this._processFrame.bind(this), 33)
                    }
                    )).catch((e => {
                        throw "NotAllowedError" === e.name ? new Rl(!1,L.messages.errors.theBrowserIsPreventingTheMediaFromAutoplaying()) : "NotSupportedError" === e.name ? new Rl(!1,L.messages.errors.theBrowserDoesNotSupportThisMediaFormat()) : "AbortError" === e.name ? new Rl(!0,L.messages.errors.playRequestCancelled()) : new Rl(!0,e.message)
                    }
                    ))
                }
                _createStopPromise(e) {
                    this._frameInterval && clearInterval(this._frameInterval),
                    this._clearWebRTCPeerConnectionHandlers(),
                    this._resetWebRTCSignaler(),
                    this._videoElement.onloadedmetadata = null,
                    this._videoElement.onloadeddata = null,
                    this._resolveOfferPromise(),
                    this._resolveNewStreamPromise();
                    const t = e.then(( () => {
                        null !== this._webRTCPeerConnection && (this._webRTCPeerConnection.close(),
                        this._webRTCPeerConnection = null)
                    }
                    ));
                    return this._videoElement.pause(),
                    t
                }
                _cancelPlayRequest() {
                    super._cancelPlayRequest(),
                    this._resolveOfferPromise(void 0),
                    this._resolveNewStreamPromise(void 0),
                    this._videoElement.pause()
                }
                _clearWebRTCPeerConnectionHandlers() {
                    null !== this._webRTCPeerConnection && (delete this._webRTCPeerConnection.onLocalIceCandidate,
                    delete this._webRTCPeerConnection.onNewStream,
                    delete this._webRTCPeerConnection.onStats,
                    delete this._webRTCPeerConnection.onError,
                    delete this._webRTCPeerConnection.onMotionRegions)
                }
                _resetWebRTCSignaler() {
                    null !== this._webRTCSignaler && (this._webRTCSignaler.onError = null,
                    this._webRTCSignaler.onIncompatible = null,
                    this._webRTCSignaler.onOffer = null,
                    this._webRTCSignaler.onIceCandidate = null,
                    this._webRTCSignaler.onClose = null,
                    this._webRTCSignaler.stopStream(),
                    this._webRTCSignaler = null)
                }
                _pause() {
                    this._videoElement.pause()
                }
                _clear() {
                    this._videoElement.src = ""
                }
                _initiatePlayRequest() {
                    return this._webRTCSignaler = this._webRTCSignalerFactory.create(),
                    this._webRTCSignaler.onOffer = this._resolveOfferPromise.bind(this),
                    this._webRTCSignaler.onError = e => {
                        const t = e || L.messages.errors.websocketError();
                        this._notifyError(new Rl(!0,t))
                    }
                    ,
                    this._webRTCSignaler.onIncompatible = this._onIncompatible.bind(this),
                    this._webRTCSignaler.onIceCandidate = e => {
                        var t;
                        return null === (t = this._webRTCPeerConnection) || void 0 === t ? void 0 : t.addRemoteIceCandidate(e)
                    }
                    ,
                    this._webRTCSignaler.onClose = () => this._notifyError(new Rl(!0,L.messages.errors.connectionRemotelyEnded())),
                    this._webRTCPeerConnection = this._webRTCPeerConnectionFactory.create(this._iceServers, 1e3),
                    this._webRTCPeerConnection.onLocalIceCandidate = e => {
                        var t;
                        return null === (t = this._webRTCSignaler) || void 0 === t ? void 0 : t.sendICECandidate(e)
                    }
                    ,
                    this._webRTCPeerConnection.onNewStream = this._resolveNewStreamPromise.bind(this),
                    this._webRTCPeerConnection.onStats = this._processWebrtcStats.bind(this),
                    this._webRTCPeerConnection.onError = e => this._notifyError(new Rl(!0,e)),
                    this._webRTCPeerConnection.onMotionRegions = this._handleMotionRegions.bind(this),
                    this._webRTCSignaler.requestStream(this._streamId, this._currentPlayRequest.time, this._currentPlayRequest.rate, this._currentPlayRequest.waitThres),
                    Promise.resolve()
                }
                _configureAndPlayVideoSrc(e) {
                    if (e.RTCTrackEvent.streams) {
                        this._videoElement.srcObject = e.RTCTrackEvent.streams[0];
                        e.RTCTrackEvent.streams[0].getVideoTracks().length > 0 && this._notifyTrack({
                            type: "video",
                            supportsBidirectionalAudio: e.supportsBidirectionalAudio
                        });
                        e.RTCTrackEvent.streams[0].getAudioTracks().length > 0 ? this._notifyTrack({
                            type: "audio",
                            supportsBidirectionalAudio: e.supportsBidirectionalAudio
                        }) : this._notifyTrack({
                            type: "no_audio",
                            supportsBidirectionalAudio: e.supportsBidirectionalAudio
                        })
                    }
                    return this._videoElement.onloadedmetadata = e => {
                        JI("debug", "Metadata loaded. Resolution : " + this._videoElement.videoWidth + " x " + this._videoElement.videoHeight),
                        this._streamResolution && this._streamResolution.width === this._videoElement.videoWidth && this._streamResolution.height === this._videoElement.videoHeight || (this._streamResolution = {
                            width: this._videoElement.videoWidth,
                            height: this._videoElement.videoHeight
                        },
                        this._notifyResize(this._streamResolution))
                    }
                    ,
                    this._videoElement.onloadeddata = () => {
                        this._streamResolution && this._streamResolution.width === this._videoElement.videoWidth && this._streamResolution.height === this._videoElement.videoHeight || (this._streamResolution = {
                            width: this._videoElement.videoWidth,
                            height: this._videoElement.videoHeight
                        },
                        this._notifyResize(this._streamResolution))
                    }
                    ,
                    this._videoElement.play()
                }
                _resolveOfferPromise(e) {
                    null !== this._offerResolve && (this._offerResolve(e),
                    this._offerResolve = null)
                }
                _resolveNewStreamPromise(e) {
                    null !== this._newStreamResolve && (this._newStreamResolve(e),
                    this._newStreamResolve = null)
                }
                _processWebrtcStats(e) {
                    var t, n;
                    this._latestStats = e;
                    const i = this._framesDecodedSinceLastCheck;
                    let a = !1;
                    e.timeToWebSocket = null !== (n = null === (t = this._webRTCSignaler) || void 0 === t ? void 0 : t.connectionTime) && void 0 !== n ? n : 0,
                    this._notifyStats(e.generateSummaryObject()),
                    null !== e.framesDecoded && e.framesDecoded > 0 ? this._framesDecodedSinceLastCheck = !0 : this._framesDecodedSinceLastCheck = !1,
                    a = !i && !this._framesDecodedSinceLastCheck,
                    Date.now() - this._lastFrameReceivedAt > 7e3 && this._notifyPacketLoss(L.messages.errors.highPacketLossDetected()),
                    !0 === a ? this._notifyPacketLoss(L.messages.errors.problemsDecodingVideoFrames()) : null !== e.framerate && e.framerate > 0 && (this._lastFrameReceivedAt = Date.now())
                }
                _processFrame() {
                    this._streamResolution ? this._notifyVideoFrame({
                        target: this._videoElement,
                        resolution: this._streamResolution
                    }) : JI("error", "_processFrame() called before the streamResolution is set!")
                }
                _onIncompatible(e) {
                    if (!e)
                        return;
                    const t = e.match(/media type \((.*)\)/)
                      , n = null !== t ? t[1] : void 0
                      , i = new Rl(!1,e);
                    i.name = "IncompatibleError",
                    i.mediaType = n,
                    this._notifyError(i)
                }
                _handleMotionRegions(e) {
                    this._notifyRegions(e)
                }
            }
            class tT {
                constructor(e) {
                    this._requestedSize = e,
                    this._resolution = null,
                    this._totalBytesReceived = 0,
                    this._totalFramesReceived = 0,
                    this._totalFramesRendered = 0,
                    this._prevTotalFramesRendered = 0,
                    this._prevTotalBytesReceived = 0,
                    this._prevTimestamp = null,
                    this._bitrateQueue = [0, 0, 0, 0, 0],
                    this._bitrateAvg = 0,
                    this._timeToWebSocket = 0,
                    this._startTime = Date.now(),
                    this._translatedStatKeys = Wl(L.messages.statisticKeys.websocket)
                }
                generateStats() {
                    let e = 0;
                    const t = Date.now();
                    if (null !== this._prevTimestamp && this._prevTimestamp < t) {
                        e = 1e3 * (this._totalFramesRendered - this._prevTotalFramesRendered) / (t - this._prevTimestamp);
                        const n = (this._totalBytesReceived - this._prevTotalBytesReceived) / (t - this._prevTimestamp);
                        this._bitrateAvg = Ow(this._bitrateAvg, this._bitrateQueue, n)
                    }
                    return this._prevTimestamp = t,
                    this._prevTotalBytesReceived = this._totalBytesReceived,
                    this._prevTotalFramesRendered = this._totalFramesRendered,
                    {
                        [this._translatedStatKeys.requestedSize]: `${this._requestedSize.width} x ${this._requestedSize.height}`,
                        [this._translatedStatKeys.resolution]: null === this._resolution ? "" : `${this._resolution.width} x ${this._resolution.height}`,
                        [this._translatedStatKeys.framerate]: e.toFixed(2),
                        [this._translatedStatKeys.bitrate]: this._bitrateAvg.toFixed(2) + " kbps",
                        [this._translatedStatKeys.bytesReceived]: this._totalBytesReceived,
                        [this._translatedStatKeys.framesReceived]: this._totalFramesReceived,
                        [this._translatedStatKeys.framesRendered]: this._totalFramesRendered,
                        [this._translatedStatKeys.timeToWebSocket]: this._timeToWebSocket
                    }
                }
                updateTimeToWebsocket() {
                    this._timeToWebSocket = Date.now() - this._startTime
                }
                incrementFrameReceived(e) {
                    this._totalFramesReceived++,
                    this._totalBytesReceived += e
                }
                incrementFrameRendered() {
                    this._totalFramesRendered++
                }
                setResolution(e) {
                    this._resolution = e
                }
            }
            const nT = O("WebSocketPlayingSource");
            class iT extends zl {
                constructor(e, t, n, i, a, r, s) {
                    if (super(e, 18e5, "canvas"),
                    this._websocketFactory = t,
                    this._orchidDataService = n,
                    this._orchid = i,
                    this._streamId = a,
                    this._canvasElement = r,
                    this._containerSize = s,
                    this._webSocket = null,
                    this._resolution = null,
                    this._imageElement = new Image,
                    this._playCompleteResolve = null,
                    this._statsCollector = null,
                    this._statsInterval = null,
                    this._currentSessionId = null,
                    this._loading = !1,
                    !this._canvasElement || this._canvasElement instanceof HTMLCanvasElement == !1)
                        throw new Error("canvasElement must be an HTML canvas tag")
                }
                isAdaptive() {
                    return !0
                }
                setVolume(e) {}
                _getVideoFrame() {
                    if (null === this._resolution)
                        throw new Error("Resolution is null");
                    return {
                        target: this._canvasElement,
                        resolution: this._resolution
                    }
                }
                _createPlayPromise(e) {
                    const t = new Promise((e => {
                        this._playCompleteResolve = e
                    }
                    ));
                    return e.then(( () => (this._currentSessionId = null,
                    this._resolution = null,
                    this._checkPlayCancel(),
                    this._startStatsCollector(),
                    this._createLowBandwidthStream()))).then((e => (this._currentSessionId = e.data.id,
                    this._checkPlayCancel(),
                    this._pollStreamReady(e.data.id)))).then((e => {
                        this._checkPlayCancel(),
                        this._loading = !1,
                        this._initializeWebSocket(e),
                        this._configureImageEvents()
                    }
                    )).then(( () => {
                        var e;
                        return this._checkPlayCancel(),
                        null === (e = this._statsCollector) || void 0 === e || e.updateTimeToWebsocket(),
                        t
                    }
                    )).catch((e => {
                        throw new Rl(!0,e.message)
                    }
                    ))
                }
                _createStopPromise(e) {
                    return this._resolvePlayCompletePromise(),
                    this._destroyWebSocket(),
                    this._resetImageEvents(),
                    e.then(( () => {
                        if (null !== this._currentSessionId) {
                            nT("debug", "Delete LBM stream");
                            const e = this._orchidDataService.deleteLowBandwidthStream(this._orchid, this._currentSessionId).catch(( () => {
                                nT("debug", "Failed to delete LBM stream")
                            }
                            ));
                            return this._currentSessionId = null,
                            e
                        }
                        return Promise.resolve()
                    }
                    )).then(( () => {
                        null !== this._statsInterval && (clearInterval(this._statsInterval),
                        this._statsInterval = null)
                    }
                    ))
                }
                _pause() {
                    this.stop()
                }
                _clear() {
                    var e;
                    null === (e = this._canvasElement.getContext("2d")) || void 0 === e || e.clearRect(0, 0, this._canvasElement.width, this._canvasElement.height)
                }
                _startStatsCollector() {
                    this._statsCollector = new tT(this._containerSize),
                    this._statsInterval = setInterval(( () => {
                        this._notifyStats(this._statsCollector.generateStats())
                    }
                    ), 1e3)
                }
                _createLowBandwidthStream() {
                    nT("debug", "Create LBM stream with resolution " + this._containerSize.width + " x " + this._containerSize.height);
                    const e = {
                        streamId: this._streamId,
                        resolution: {
                            height: this._containerSize.height,
                            width: this._containerSize.width
                        },
                        startTime: this._currentPlayRequest.time,
                        rate: this._currentPlayRequest.rate,
                        waitThres: this._currentPlayRequest.waitThres,
                        transport: "websocket-base64"
                    };
                    return this._orchidDataService.createLowBandwidthStream(this._orchid, e).catch((e => {
                        throw new Rl(!0,L.messages.errors.failedToCreateLowBandwidthStream({
                            VALUE: e.status
                        }))
                    }
                    ))
                }
                _initializeWebSocket(e) {
                    this._webSocket = this._websocketFactory.create(e),
                    this._webSocket.onmessage = this._processWebSocketMessage.bind(this),
                    this._webSocket.onerror = () => this._notifyError(new Rl(!0,L.messages.errors.websocketError())),
                    this._webSocket.onclose = () => this._notifyError(new Rl(!0,L.messages.errors.websocketClosedUnexpectedly())),
                    this._webSocket.onopen = this._sendFrameRequest.bind(this)
                }
                _destroyWebSocket() {
                    this._webSocket && null !== this._webSocket && (this._webSocket.onmessage = null,
                    this._webSocket.onerror = null,
                    this._webSocket.onclose = null,
                    this._webSocket.close(),
                    this._webSocket = null)
                }
                _configureImageEvents() {
                    this._imageElement.onload = this._processNewImage.bind(this),
                    this._imageElement.onerror = () => this._notifyError(new Rl(!0,L.messages.errors.errorRenderingImage()))
                }
                _resetImageEvents() {
                    this._imageElement.onload = null,
                    this._imageElement.onerror = null
                }
                _pollStreamReady(e) {
                    const t = (n, i) => {
                        this._orchidDataService.getLowBandwidthStream(this._orchid, e).then((e => {
                            nT("debug", "ready state: " + e.data.state.status, e.data.state.description),
                            null === this._currentPlayRequest ? i(new Rl(!0,L.messages.errors.playRequestCancelled())) : "failed" === e.data.state.status ? e.data.state.description ? i(new Rl(!0,e.data.state.description)) : i(new Rl(!0,L.messages.errors.lowBandwidthStreamFailedToStart())) : "ready" === e.data.state.status ? n(this._orchidDataService.lowbandwidthSocketUrl(this._orchid, e.data.id)) : setTimeout(t.bind(this), 200, n, i)
                        }
                        )).catch((e => {
                            i(new Rl(!0,L.messages.errors.failedToGetLowBandwidthStream({
                                VALUE: e.status
                            })))
                        }
                        ))
                    }
                    ;
                    return new Promise(t)
                }
                _processWebSocketMessage(e) {
                    var t;
                    null === (t = this._statsCollector) || void 0 === t || t.incrementFrameReceived(e.data.length),
                    !1 === this._loading && (this._loading = !0,
                    this._imageElement.src = "",
                    this._imageElement.src = e.data)
                }
                _processNewImage() {
                    var e, t, n;
                    this._resolvePlayCompletePromise();
                    const i = {
                        height: this._imageElement.naturalHeight,
                        width: this._imageElement.naturalWidth
                    };
                    (null === this._resolution || i.width !== this._resolution.width && i.height !== this._resolution.height) && (null === (e = this._statsCollector) || void 0 === e || e.setResolution(i),
                    this._resolution = i,
                    this._notifyResize(i)),
                    this._canvasElement.height = i.height,
                    this._canvasElement.width = i.width,
                    null === (t = this._canvasElement.getContext("2d")) || void 0 === t || t.drawImage(this._imageElement, 0, 0),
                    this._notifyVideoFrame({
                        target: this._canvasElement,
                        resolution: i
                    }),
                    null === (n = this._statsCollector) || void 0 === n || n.incrementFrameRendered(),
                    this._loading = !1,
                    this._sendFrameRequest()
                }
                _resolvePlayCompletePromise() {
                    null !== this._playCompleteResolve && (this._playCompleteResolve(void 0),
                    this._playCompleteResolve = null)
                }
                _sendFrameRequest() {
                    try {
                        this._webSocket && 1 === this._webSocket.readyState ? this._webSocket.send(JSON.stringify({
                            type: "requestFrame"
                        })) : nT("log", "WebSocket has been destroyed or is not in the connected state.")
                    } catch (e) {
                        this._notifyError(new Rl(!0,L.messages.errors.websocketFailedSend()))
                    }
                }
            }
            let aT = function() {
                function e() {
                    (0,
                    S.Z)(this, e)
                }
                return (0,
                b.Z)(e, [{
                    key: "create",
                    value: function(e, t) {
                        return new WebSocket(e,t)
                    }
                }]),
                e
            }();
            const rT = O("WebRTCSignaler");
            class sT {
                constructor(e, t, n) {
                    this._websocketFactory = e,
                    this._orchidDataService = t,
                    this._orchid = n,
                    this._messageIndex = 0,
                    this._sock = null,
                    this._startTime = 0,
                    this.streamId = 0,
                    this.time = 0,
                    this.rate = 0,
                    this.waitThres = 0,
                    this.connectionTime = 0,
                    this.onError = null,
                    this.onIncompatible = null,
                    this.onOffer = null,
                    this.onIceCandidate = null,
                    this.onClose = null
                }
                requestStream(e, t=0, n=1, i=2e3 * n) {
                    if (null !== this._sock)
                        throw Error("A stream request is already active. Stop the stream before requesting a new one.");
                    if (this._startTime = Date.now(),
                    this.streamId = e,
                    this.time = t,
                    this.rate = n,
                    this.waitThres = i || 2e3 * this.rate,
                    this._sock = this._websocketFactory.create(this._orchidDataService.webrtcSocketUrl(this._orchid)),
                    null === this._sock || void 0 === this._sock)
                        throw Error("Failed to create websocket");
                    this._sock.onopen = this._onWebSocketOpen.bind(this),
                    this._sock.onmessage = this._onWebSocketMessage.bind(this),
                    this._sock.onclose = this._onWebSocketClose.bind(this),
                    this._sock.onerror = this._onWebSocketError.bind(this)
                }
                stopStream() {
                    this._sock && (this._sock.onopen = null,
                    this._sock.onopen = null,
                    this._sock.onmessage = null,
                    this._sock.onclose = null,
                    this._sock.onerror = null,
                    this._sock.close(),
                    this._sock = null)
                }
                sendAnswer(e) {
                    if (!this._sock)
                        throw Error(L.messages.errors.requestStreamFunctionMustBeCalledBeforeAnswerSdp());
                    if (!e || "answer" !== e.type || !e.sdp)
                        throw Error(L.messages.errors.invalidAnswerSessionDescription());
                    this._sendMessage({
                        type: "answer",
                        sdp: e.sdp
                    })
                }
                sendICECandidate(e) {
                    if (!this._sock)
                        throw Error(L.messages.errors.requestStreamFunctionMustBeCalledBeforeSendIcecandidate());
                    if (!e || !e.candidate)
                        throw Error(L.messages.errors.invalidIceCandidate());
                    this._sendMessage({
                        type: "ice_candidate",
                        candidate: "a=" + e.candidate
                    })
                }
                _sendMessage(e) {
                    var t;
                    e.messageId = "" + this._messageIndex++,
                    null === (t = this._sock) || void 0 === t || t.send(JSON.stringify(e))
                }
                _onWebSocketOpen() {
                    this.connectionTime = Date.now() - this._startTime,
                    this._sendMessage({
                        type: "create",
                        streamId: this.streamId,
                        time: this.time,
                        rate: this.rate,
                        waitThres: this.waitThres
                    })
                }
                _onWebSocketMessage(e) {
                    const t = JSON.parse(e.data);
                    switch (t.type) {
                    case "error":
                        this.onError && this.onError(t.error);
                        break;
                    case "incompatible":
                        this.onIncompatible && this.onIncompatible(t.error);
                        break;
                    case "offer":
                        {
                            const e = new RTCSessionDescription({
                                type: "offer",
                                sdp: t.sdp
                            });
                            this.onOffer && this.onOffer(e);
                            break
                        }
                    case "ice_candidate":
                        t.sdpMLineIndex || (t.sdpMLineIndex = 0),
                        this.onIceCandidate && this.onIceCandidate(new RTCIceCandidate(t));
                        break;
                    default:
                        rT("error", "Received unknown message type:", t)
                    }
                }
                _onWebSocketClose() {
                    this._sock = null,
                    this.onClose && this.onClose()
                }
                _onWebSocketError() {
                    this._sock = null,
                    this.onError && this.onError()
                }
            }
            class oT {
                constructor(e, t, n) {
                    this._websocketFactory = e,
                    this._orchidDataService = t,
                    this._orchid = n
                }
                create() {
                    return new sT(this._websocketFactory,this._orchidDataService,this._orchid)
                }
            }
            const cT = "Timestamp"
              , lT = "Resolution"
              , dT = "Framerate"
              , uT = "Bitrate"
              , mT = "ICE Connection State"
              , hT = "Connection State"
              , pT = "Packets Received"
              , gT = "Packets Lost"
              , fT = "Fraction Packet Loss"
              , vT = "Frames Received"
              , yT = "Frames Decoded"
              , bT = "Frames Dropped"
              , ST = "Bytes Received"
              , CT = "Connection"
              , wT = "DTLS State"
              , IT = "Sample Rate"
              , TT = "Samples Received"
              , ET = "Encoder"
              , _T = "codec"
              , xT = "inbound-rtp"
              , DT = "transport"
              , OT = "candidate-pair"
              , AT = "local-candidate"
              , RT = "remote-candidate"
              , PT = O("WebRTCStatsContainer");
            Object.keys(L.messages.statisticKeys.webrtc).reduce(( (e, t) => (e[t] = L.messages.statisticKeys.webrtc[t](),
            e)), {});
            class kT {
                constructor() {
                    this._timestamp = null,
                    this._resolution = null,
                    this._framerate = 0,
                    this._bitrate = 0,
                    this._iceConnectionState = null,
                    this._connectionState = null,
                    this._packetsReceived = 0,
                    this._packetsLost = 0,
                    this._fractionPacketLoss = 0,
                    this._framesReceived = 0,
                    this._framesDecoded = 0,
                    this._framesDropped = 0,
                    this._bytesReceived = 0,
                    this._connection = null,
                    this._dtlsState = null,
                    this._localCandidates = [],
                    this._remoteCandidates = [],
                    this._advanced = {},
                    this._nackCount = 0,
                    this._audioBitrate = null,
                    this._sampleRate = 0,
                    this._audioEncoder = null,
                    this._samplesReceived = null,
                    this._audioBytesReceived = null,
                    this._timeToWebSocket = 0,
                    this._timeToChosenPair = 0
                }
                set timestamp(e) {
                    !0 === Aw(cT, e) && (this._timestamp = e)
                }
                get timestamp() {
                    return this._timestamp
                }
                set resolution(e) {
                    null !== e && !0 === Aw(lT + " Width", e.width) && !0 === Aw(lT + " Height", e.height) && (this._resolution = {
                        width: e.width,
                        height: e.height
                    })
                }
                get resolution() {
                    return this._resolution
                }
                set framerate(e) {
                    !0 === Aw(dT, e) && (this._framerate = e)
                }
                get framerate() {
                    return this._framerate
                }
                set bitrate(e) {
                    !0 === Aw(uT, e) && (this._bitrate = e)
                }
                get bitrate() {
                    return this._bitrate
                }
                set iceConnectionState(e) {
                    !0 === Rw(mT, e) && (this._iceConnectionState = e)
                }
                get iceConnectionState() {
                    return this._iceConnectionState
                }
                set connectionState(e) {
                    !0 === Rw(hT, e) && (this._connectionState = e)
                }
                get connectionState() {
                    return this._connectionState
                }
                set packetsReceived(e) {
                    !0 === Aw(pT, e) && (this._packetsReceived = e)
                }
                get packetsReceived() {
                    return this._packetsReceived
                }
                set packetsLost(e) {
                    !0 === Aw(gT, e) && (this._packetsLost = e)
                }
                get packetsLost() {
                    return this._packetsLost
                }
                set fractionPacketLoss(e) {
                    e && !1 !== Aw(fT, e) && (e > 1 ? PT("warn", `Fraction Packet Loss (${e}) is expected to be (0,1]`) : this._fractionPacketLoss = e)
                }
                get fractionPacketLoss() {
                    return this._fractionPacketLoss
                }
                set framesReceived(e) {
                    !0 === Aw(vT, e) && (this._framesReceived = e)
                }
                get framesReceived() {
                    return this._framesReceived
                }
                set framesDecoded(e) {
                    !0 === Aw(yT, e) && (this._framesDecoded = e)
                }
                get framesDecoded() {
                    return this._framesDecoded
                }
                set framesDropped(e) {
                    !0 === Aw(bT, e) && (this._framesDropped = e)
                }
                get framesDropped() {
                    return this._framesDropped
                }
                set bytesReceived(e) {
                    !0 === Aw(ST, e) && (this._bytesReceived = e)
                }
                get bytesReceived() {
                    return this._bytesReceived
                }
                set connection(e) {
                    !0 === Rw(CT, e) && (this._connection = e)
                }
                get connection() {
                    return this._connection
                }
                set dtlsState(e) {
                    !0 === Rw(wT, e) && (this._dtlsState = e)
                }
                get dtlsState() {
                    return this._dtlsState
                }
                addLocalCandidate(e) {
                    null !== e && !0 === Rw("Candidate", e) && this._localCandidates.push(e)
                }
                get localCandidates() {
                    return this._localCandidates
                }
                addRemoteCandidate(e) {
                    null !== e && !0 === Rw("Candidate", e) && this._remoteCandidates.push(e)
                }
                get remoteCandidates() {
                    return this._remoteCandidates
                }
                addAdvancedStat(e, t) {
                    "string" == typeof e ? void 0 !== t && "function" != typeof t ? this._advanced[e] = t : PT("warn", "Invalid Advanced Stat Value") : PT("warn", "Invalid Advanced Stat Id")
                }
                get advanced() {
                    return this._advanced
                }
                get nackCount() {
                    return this._nackCount
                }
                set nackCount(e) {
                    this._nackCount = e
                }
                get audioBitrate() {
                    return this._audioBitrate
                }
                set audioBitrate(e) {
                    !0 === Aw(uT, e) && (this._audioBitrate = e)
                }
                get sampleRate() {
                    return this._sampleRate
                }
                set sampleRate(e) {
                    !0 === Aw(IT, e) && (this._sampleRate = e)
                }
                get audioEncoder() {
                    return this._audioEncoder
                }
                set audioEncoder(e) {
                    !0 === Rw(ET, e) && (this._audioEncoder = e)
                }
                get audioBytesReceived() {
                    return this._audioBytesReceived
                }
                set audioBytesReceived(e) {
                    !0 === Aw(ST, e) && (this._audioBytesReceived = e)
                }
                get samplesReceived() {
                    return this._samplesReceived
                }
                set samplesReceived(e) {
                    !0 === Aw(TT, e) && (this._samplesReceived = e)
                }
                get timeToWebSocket() {
                    return this._timeToWebSocket
                }
                set timeToWebSocket(e) {
                    this._timeToWebSocket = e
                }
                get timeToChosenPair() {
                    return this._timeToChosenPair
                }
                set timeToChosenPair(e) {
                    this._timeToChosenPair = e
                }
                _generateVideoObject(e) {
                    const t = {};
                    return t[e.RESOLUTION] = null === this._resolution ? "" : `${this._resolution.width} x ${this._resolution.height}`,
                    t[e.FRAMERATE] = null === this._framerate ? "" : this._framerate.toFixed(2),
                    t[e.BITRATE] = null === this._bitrate ? "" : this._bitrate.toFixed(2) + " kbps",
                    t[e.FRAMES_RECEIVED] = null === this._framesReceived ? "" : this._framesReceived,
                    t[e.FRAMES_DECODED] = null === this._framesDecoded ? "" : this._framesDecoded,
                    t[e.FRAMES_DROPPED] = null === this._framesDropped ? "" : this._framesDropped,
                    t[e.BYTES_RECEIVED] = null === this._bytesReceived ? "" : this._bytesReceived,
                    t
                }
                _generateConnectionObject(e) {
                    const t = {};
                    return t[e.TIME_TO_WS] = this._timeToWebSocket,
                    t[e.TIME_TO_CHOSEN_PAIR] = this._timeToChosenPair,
                    t[e.ICE_CONNECTION_STATE] = null === this._iceConnectionState ? "" : this._iceConnectionState,
                    t[e.CONNECTION_STATE] = null === this._connectionState ? "" : this._connectionState,
                    t[e.PACKETS_RECEIVED] = null === this._packetsReceived ? "" : this._packetsReceived,
                    t[e.PACKETS_LOST] = null === this._packetsLost ? "" : this._packetsLost,
                    t[e.FRACTION_PACKET_LOSS] = null === this._fractionPacketLoss ? "" : this._fractionPacketLoss.toFixed(2),
                    t[e.NACK_COUNT] = null === this._nackCount ? "" : this._nackCount,
                    t[e.CONNECTION] = null === this._connection ? "" : this._connection,
                    t[e.DTLS_STATE] = null === this._dtlsState ? "" : this._dtlsState,
                    t[e.LOCAL_CANDIDATES] = this._localCandidates,
                    t[e.REMOTE_CANDIDATES] = this._remoteCandidates,
                    t[e.ADVANCED] = this._advanced,
                    t
                }
                _generateAudioObject(e) {
                    const t = {};
                    return t[e.ENCODER] = this._audioEncoder,
                    t[e.BITRATE] = null === this._audioBitrate ? "" : this._audioBitrate.toFixed(2) + " kbps",
                    t[e.SAMPLE_RATE] = null === this._sampleRate ? "" : this._sampleRate.toFixed(2) + " kHz",
                    t[e.BYTES_RECEIVED] = this._audioBytesReceived,
                    t[e.SAMPLES_RECEIVED] = this._samplesReceived,
                    t
                }
                generateSummaryObject() {
                    {
                        const e = Object.keys(L.messages.statisticKeys.webrtc).reduce(( (e, t) => (e[t] = L.messages.statisticKeys.webrtc[t](),
                        e)), {})
                          , t = {};
                        return t[L.messages.statisticKeys.webrtc.VIDEO()] = this._generateVideoObject(e),
                        null === this._audioBytesReceived && null === this._samplesReceived || (t[L.messages.statisticKeys.webrtc.AUDIO()] = this._generateAudioObject(e)),
                        t[L.messages.statisticKeys.webrtc.CONNECTION()] = this._generateConnectionObject(e),
                        t
                    }
                }
            }
            class MT {
                constructor() {
                    this._prevStats = null,
                    this._bitrateQueue = [0, 0, 0, 0, 0],
                    this._bitrateAvg = 0,
                    this._audioBitrateQueue = [0, 0, 0, 0, 0],
                    this._audioBitrateAvg = 0,
                    this._sampleRateQueue = [0, 0, 0, 0, 0],
                    this._sampleRateAvg = 0
                }
                generateStats(e) {
                    const t = new kT;
                    return e.forEach((n => {
                        this._processStat(t, e, n)
                    }
                    )),
                    this._calculateTimeBasedStats(t),
                    this._prevStats = t,
                    t
                }
                _calculateTimeBasedStats(e) {
                    if (null !== this._prevStats && null !== e.timestamp && null !== this._prevStats.timestamp) {
                        const t = e.timestamp - this._prevStats.timestamp;
                        if (t > 0) {
                            if (null !== e.framesDecoded && null !== this._prevStats.framesDecoded) {
                                const n = e.framesDecoded - this._prevStats.framesDecoded;
                                e.framerate = 1e3 * n / t
                            }
                            if (null !== e.bytesReceived && null !== this._prevStats.bytesReceived) {
                                const n = e.bytesReceived - this._prevStats.bytesReceived;
                                this._bitrateAvg = Ow(this._bitrateAvg, this._bitrateQueue, 8 * n / t),
                                e.bitrate = this._bitrateAvg
                            }
                            if (null !== e.packetsReceived && null !== this._prevStats.packetsReceived && null !== e.packetsLost && null !== this._prevStats.packetsLost) {
                                const t = e.packetsReceived - this._prevStats.packetsReceived
                                  , n = e.packetsLost - this._prevStats.packetsLost
                                  , i = n + t;
                                0 !== i && (e.fractionPacketLoss = n / i)
                            }
                            if (null !== e.audioBytesReceived && null !== this._prevStats.audioBytesReceived) {
                                const n = e.audioBytesReceived - this._prevStats.audioBytesReceived;
                                this._audioBitrateAvg = Ow(this._audioBitrateAvg, this._audioBitrateQueue, 8 * n / t),
                                e.audioBitrate = this._audioBitrateAvg
                            }
                            if (null !== e.samplesReceived && null !== this._prevStats.samplesReceived) {
                                const n = e.samplesReceived - this._prevStats.samplesReceived;
                                this._sampleRateAvg = Ow(this._sampleRateAvg, this._sampleRateQueue, n / t),
                                e.sampleRate = this._sampleRateAvg
                            }
                        }
                    }
                }
                _processStat(e, t, n) {
                    switch ((n.id && "string" == typeof n || "object" == typeof n) && e.addAdvancedStat(n.id, n),
                    n.type) {
                    case _T:
                        if (n.mimeType) {
                            const [t,i] = n.mimeType.split("/");
                            "audio" === t && (e.audioEncoder = i)
                        }
                        break;
                    case OT:
                        if (!0 === n.nominated && !1 !== n.selected) {
                            let i, a;
                            if (n.localCandidateId && !0 === t.has(n.localCandidateId)) {
                                i = Dw(t.get(n.localCandidateId))
                            }
                            if (n.remoteCandidateId && !0 === t.has(n.remoteCandidateId)) {
                                a = Dw(t.get(n.remoteCandidateId))
                            }
                            const r = (a || "-") + " -> " + (i || "-");
                            e.connection = r
                        }
                        break;
                    case AT:
                        e.addLocalCandidate(Dw(n));
                        break;
                    case RT:
                        e.addRemoteCandidate(Dw(n));
                        break;
                    case xT:
                        if ("number" == typeof n.timestamp && (e.timestamp = n.timestamp),
                        "audio" === n.kind) {
                            "number" == typeof n.bytesReceived && (e.audioBytesReceived = n.bytesReceived),
                            "number" == typeof n.totalSamplesReceived && (e.samplesReceived = n.totalSamplesReceived);
                            break
                        }
                        "number" == typeof n.packetsReceived && (e.packetsReceived = n.packetsReceived),
                        "number" == typeof n.packetsLost && (e.packetsLost = n.packetsLost),
                        "number" == typeof n.framesDecoded && (e.framesDecoded = n.framesDecoded),
                        "number" == typeof n.bytesReceived && (e.bytesReceived = n.bytesReceived),
                        "number" == typeof n.nackCount && (e.nackCount = n.nackCount),
                        "number" == typeof n.framesDropped && (e.framesDropped = n.framesDropped),
                        "number" == typeof n.framesReceived && (e.framesReceived = n.framesReceived),
                        "number" == typeof n.frameWidth && "number" == typeof n.frameHeight && (e.resolution = {
                            width: n.frameWidth,
                            height: n.frameHeight
                        });
                        break;
                    case DT:
                        "string" == typeof n.dtlsState && (e.dtlsState = n.dtlsState)
                    }
                }
            }
            const LT = O("WebRTCPeerConnection");
            class NT {
                constructor(e, t, n) {
                    this._startTime = Date.now(),
                    this.connectionTime = 0,
                    this._webRTCStats = new MT;
                    const i = {
                        iceServers: e
                    };
                    this._peerConnection = t.create(i),
                    this._peerConnection.onicecandidate = this._postLocalIceCandidate.bind(this),
                    this._peerConnection.ontrack = this._postNewTrack.bind(this),
                    this._peerConnection.onconnectionstatechange = this._updateConnectionState.bind(this),
                    this._peerConnection.ondatachannel = this._receiveDataChannel.bind(this),
                    this._statsInterval = setInterval(this._collectStats.bind(this), n || 1e3),
                    this._hasRemoteDescription = !1,
                    this._earlyCandidates = []
                }
                generateAnswer(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this._hasRemoteDescription)
                            return Promise.reject(L.messages.errors.thePeerConnectionAlreadyHasARemoteDescriptionSet());
                        if ("offer" !== e.type)
                            return Promise.reject(L.messages.errors.invalidWebRtcOffer());
                        return ["a=sendrecv", "a=recvonly"].some((t => {
                            var n;
                            return null === (n = null == e ? void 0 : e.sdp) || void 0 === n ? void 0 : n.includes(t)
                        }
                        )) && (LT.info("Adding audio track to peer connection."),
                        this._audioSender = this._peerConnection.addTrack(function() {
                            const e = new AudioContext
                              , t = e.createOscillator().connect(e.createMediaStreamDestination());
                            return Object.assign(t.stream.getAudioTracks()[0], {
                                enabled: !1
                            })
                        }()),
                        yield this._audioSender.replaceTrack(null)),
                        this._peerConnection.setRemoteDescription(new RTCSessionDescription(e)).then(( () => {
                            this._hasRemoteDescription = !0,
                            this._earlyCandidates.forEach((e => this.addRemoteIceCandidate(e))),
                            this._earlyCandidates = []
                        }
                        )).then(( () => this._peerConnection.createAnswer())).then((e => this._peerConnection.setLocalDescription(e).then(( () => e))))
                    }
                    ))
                }
                addRemoteIceCandidate(e) {
                    !0 === this._hasRemoteDescription ? this._peerConnection.addIceCandidate(e).catch((e => LT("error", "Failed to add ice candidate: " + e))) : this._earlyCandidates.push(e)
                }
                replaceAudioInputTrack(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this._audioSender)
                            try {
                                yield this._audioSender.replaceTrack(null != e ? e : null)
                            } catch (e) {
                                LT.error("Failed to replace audio track: ", e)
                            }
                    }
                    ))
                }
                close() {
                    this._statsInterval && clearInterval(this._statsInterval),
                    this._peerConnection.onicecandidate = null,
                    this._peerConnection.ontrack = null,
                    this._peerConnection.oniceconnectionstatechange = null,
                    this._peerConnection.close()
                }
                _postError(e) {
                    var t;
                    LT("error", e),
                    null === (t = this.onError) || void 0 === t || t.call(this, e)
                }
                _postLocalIceCandidate(e) {
                    e.candidate && e.candidate.candidate && this.onLocalIceCandidate && this.onLocalIceCandidate(e.candidate)
                }
                _postNewTrack(e) {
                    var t;
                    null === (t = this.onNewStream) || void 0 === t || t.call(this, {
                        RTCTrackEvent: e,
                        supportsBidirectionalAudio: !!this._audioSender
                    })
                }
                _updateConnectionState() {
                    const e = this._peerConnection.connectionState;
                    this._collectStats(),
                    "disconnected" === e ? this._postError(L.messages.errors.peerConnectionDisconnected()) : "failed" === e ? this._postError(L.messages.errors.iceConnectionFailed()) : "closed" === e ? this._postError(L.messages.errors.peerConnectionClosed()) : "connected" === e && (this.connectionTime = Date.now() - this._startTime)
                }
                _receiveDataChannel(e) {
                    const t = e.channel;
                    "regions" === t.label && (t.onmessage = e => {
                        const t = JSON.parse(e.data);
                        t && t.regions && t.timeEpochMs ? this._postMotionRegions(t) : O.error("Invalid regions data:", t)
                    }
                    )
                }
                _postMotionRegions(e) {
                    this.onMotionRegions && this.onMotionRegions(e)
                }
                _collectStats() {
                    this._peerConnection.getStats().then((e => {
                        const t = this._webRTCStats.generateStats(e);
                        t.iceConnectionState = this._peerConnection.iceConnectionState,
                        t.connectionState = this._peerConnection.connectionState,
                        t.timeToChosenPair = this.connectionTime,
                        this.onStats && this.onStats(t)
                    }
                    )).catch((e => {
                        LT("error", "Error getting webRTC stats: " + e)
                    }
                    ))
                }
            }
            class FT {
                constructor(e) {
                    this._peerConnectionFactory = e
                }
                create(e, t) {
                    return new NT(e,this._peerConnectionFactory,t)
                }
            }
            class UT {
                create(e) {
                    return new RTCPeerConnection(e)
                }
            }
            const $T = O("WebRTCPlayingSource")
              , jT = "rip"
              , VT = "lowbandwidth"
              , GT = "webrtc";
            let BT = class {
                create(e, t, n, i, a, r) {
                    if ($T.info("Using TypeScript PlayingSource"),
                    e === jT) {
                        if (t instanceof HTMLCanvasElement == !1)
                            throw new Error("HTTPRippingSource only supports canvas element");
                        return new Td(new wn,r,n,i,t,new Image,a)
                    }
                    if (e === GT) {
                        if (t instanceof HTMLVideoElement == !1)
                            throw new Error("WebRTCPlayingSource only supports video element");
                        return new eT(new wn,new FT(new UT),new oT(new aT,r,n),n.discoverableOrchid.iceServers,i.id,t,1e4)
                    }
                    if (e === VT) {
                        if (t instanceof HTMLCanvasElement == !1)
                            throw new Error("WebSocketPlayingSource only supports canvas");
                        return new iT(new wn,new aT,r,n,i.id,t,a)
                    }
                    throw `Type ${e} not supported`
                }
            }
            ;
            var zT, HT, WT, qT, YT, XT;
            BT = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            })], BT);
            let KT = class {
                constructor(e) {
                    this._audioContext = e,
                    this._requestId = 0
                }
                _createAudioAnalyser(e) {
                    this._mediaStreamSource = this._audioContext.createMediaStreamSource(e),
                    this._analyser = this._audioContext.createAnalyser(),
                    this._mediaStreamSource.connect(this._analyser),
                    this._analyser.fftSize = 2048
                }
                _renderFrame() {
                    var e, t, n;
                    const i = null !== (t = null === (e = this._analyser) || void 0 === e ? void 0 : e.frequencyBinCount) && void 0 !== t ? t : 0
                      , a = new Uint8Array(i);
                    null === (n = this._analyser) || void 0 === n || n.getByteFrequencyData(a);
                    const r = Math.floor(85)
                      , s = [this.middle, this.left, this.right];
                    for (let e = 0; e < 3; e++) {
                        const t = a.slice(e * r, (e + 1) * r).reduce(( (e, t) => e + t), 0) / r
                          , n = this._getPercentInRange(.2, .6, t / 255);
                        s[e].nativeElement.style.transform = `scaleY(${n})`
                    }
                    this._requestId = window.requestAnimationFrame(this._renderFrame.bind(this))
                }
                _getPercentInRange(e, t, n) {
                    if (e >= t)
                        throw new Error("Minimum value must be less than maximum value.");
                    const i = function(e, t, n) {
                        if (e >= n)
                            throw new Error("Minimum value must be less than maximum value.");
                        return Math.min(Math.max(t, e), n)
                    }(e, n, t);
                    return function(e, t, n) {
                        if (e >= n)
                            throw new Error("Minimum value must be less than maximum value.");
                        return (t - e) / (n - e)
                    }(e, i, t)
                }
                ngOnChanges(e) {
                    var t, n, i, a, r;
                    (null === (t = e.mediaStream) || void 0 === t ? void 0 : t.currentValue) ? (null === (n = this._analyser) || void 0 === n || n.disconnect(),
                    null === (i = this._mediaStreamSource) || void 0 === i || i.disconnect(),
                    this._createAudioAnalyser(e.mediaStream.currentValue),
                    this._requestId = window.requestAnimationFrame(this._renderFrame.bind(this))) : e.mediaStream || (null === (a = this._analyser) || void 0 === a || a.disconnect(),
                    null === (r = this._mediaStreamSource) || void 0 === r || r.disconnect(),
                    this._reset(),
                    window.cancelAnimationFrame(this._requestId),
                    this._requestId = 0)
                }
                ngOnDestroy() {
                    var e, t;
                    null === (e = this._analyser) || void 0 === e || e.disconnect(),
                    null === (t = this._mediaStreamSource) || void 0 === t || t.disconnect(),
                    window.cancelAnimationFrame(this._requestId)
                }
                _reset() {
                    this.left && (this.left.nativeElement.style.transform = ""),
                    this.middle && (this.middle.nativeElement.style.transform = ""),
                    this.right && (this.right.nativeElement.style.transform = "")
                }
            }
            ;
            var ZT;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (zT = "undefined" != typeof MediaStream && MediaStream) ? zT : Object)], KT.prototype, "mediaStream", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("meter"), (0,
            c.w6)("design:type", "function" == typeof (HT = void 0 !== i.ElementRef && i.ElementRef) ? HT : Object)], KT.prototype, "meter", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("left"), (0,
            c.w6)("design:type", "function" == typeof (WT = void 0 !== i.ElementRef && i.ElementRef) ? WT : Object)], KT.prototype, "left", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("middle"), (0,
            c.w6)("design:type", "function" == typeof (qT = void 0 !== i.ElementRef && i.ElementRef) ? qT : Object)], KT.prototype, "middle", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("right"), (0,
            c.w6)("design:type", "function" == typeof (YT = void 0 !== i.ElementRef && i.ElementRef) ? YT : Object)], KT.prototype, "right", void 0),
            KT = (0,
            c.gn)([(0,
            i.Component)({
                selector: "decibel-meter",
                template: n(21766)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(GI)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (XT = "undefined" != typeof AudioContext && AudioContext) ? XT : Object])], KT);
            let JT = class {
                constructor() {
                    this._destroy$ = new St.x,
                    this.disabled = !1,
                    this.bulkUpdate = new i.EventEmitter,
                    this.dropdownState = void 0,
                    this.customRetentionVal = void 0,
                    this.retentionAmtUpdater$ = new St.x,
                    this.msgs = Object.assign(Object.assign({}, L.messages.retentionPolicy), L.messages.timeUnitsPlural)
                }
                ngOnInit() {
                    this.resetter.pipe((0,
                    oa.R)(this._destroy$)).subscribe(( () => this.dropdownState = void 0)),
                    this.retentionAmtUpdater$.pipe((0,
                    Zl.b)(200), (0,
                    oa.R)(this._destroy$)).subscribe(( () => this.emitUpdate()))
                }
                onDropdownStateChange(e) {
                    "automatic" === e ? this.emitUpdate() : "custom" === e && (this.customRetentionVal = void 0)
                }
                setRetentionToAutomaticIfZero() {
                    "custom" === this.dropdownState && 0 === this.customRetentionVal && (this.dropdownState = "automatic",
                    this.emitUpdate())
                }
                emitUpdate() {
                    this.dropdownState && this.bulkUpdate.emit({
                        updateType: this.dropdownState,
                        updateVal: this.customRetentionVal
                    })
                }
                captureCustomFormClick(e) {
                    e.stopPropagation()
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
            }
            ;
            var QT, eE;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], JT.prototype, "disabled", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (ZT = void 0 !== St.x && St.x) ? ZT : Object)], JT.prototype, "resetter", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], JT.prototype, "bulkUpdate", void 0),
            JT = (0,
            c.gn)([(0,
            i.Component)({
                selector: "retention-bulk-update",
                template: n(52939)
            })], JT);
            let tE = class {
                constructor() {
                    this.filterLabel = "",
                    this.filters = [],
                    this.addFilter = new i.EventEmitter,
                    this.removeFilter = new i.EventEmitter,
                    this.msgs = Object.assign(Object.assign({}, L.messages.common), L.messages.resourceTagging),
                    this.activeFilters = [],
                    this.MAX_ITEMS = 5,
                    this.ERROR_TYPE = wr,
                    this.hiddenFilterCount = 0,
                    this.filterSearchForm = new p.NI(""),
                    this.filterSearchForm.valueChanges.subscribe(( () => this.handleSearch()))
                }
                ngOnChanges(e) {
                    e.filters && this.filters.sort(( (e, t) => {
                        var n, i;
                        const a = _t(e.data.label, t.data.label);
                        if (0 !== a)
                            return a;
                        return _t(null !== (n = e.data.value) && void 0 !== n ? n : "", null !== (i = t.data.value) && void 0 !== i ? i : "")
                    }
                    ))
                }
                handleSearch() {
                    const e = this.filterSearchForm.value;
                    this.activeFilters = this.filters.filter((t => {
                        const n = t.data.label ? t.data.label.toLowerCase() : ""
                          , i = t.data.value ? t.data.value.toLowerCase() : ""
                          , a = e ? e.toLowerCase() : "";
                        return n.includes(a) || i.includes(a)
                    }
                    )),
                    this.hiddenFilterCount = this.activeFilters.length - hs,
                    this.activeFilters.length > hs && (this.activeFilters = this.activeFilters.slice(0, hs))
                }
                toggleFilter(e, t) {
                    e.stopPropagation();
                    const n = this.filters.findIndex((e => e.id === t.id));
                    this.filters[n] = Object.assign(Object.assign({}, this.filters[n]), {
                        value: !t.value
                    });
                    this.filters[n].value ? this.addFilter.emit(t) : this.removeFilter.emit(t),
                    this.handleSearch()
                }
                isGenericLabel(e) {
                    return e.type !== ls.RESOURCE_TAG && e.type !== ls.EVENT_TYPE
                }
                clearSearchInput() {
                    this.filterSearchForm.setValue("")
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], tE.prototype, "filterLabel", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], tE.prototype, "filters", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (QT = void 0 !== i.EventEmitter && i.EventEmitter) ? QT : Object)], tE.prototype, "addFilter", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (eE = void 0 !== i.EventEmitter && i.EventEmitter) ? eE : Object)], tE.prototype, "removeFilter", void 0),
            tE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "filter-button-menu",
                template: n(89966),
                changeDetection: i.ChangeDetectionStrategy.OnPush
            }), (0,
            c.w6)("design:paramtypes", [])], tE);
            var nE, iE, aE = n(42034), rE = n(68515);
            const sE = O("BulkServerTaggingDialog");
            let oE = class {
                constructor(e, t) {
                    this._requestBuilder = e,
                    this._renewableService = t,
                    this._destroy$ = new St.x;
                    const n = this._renewableService.messages$.pipe((0,
                    ra.h)((e => Cs(e) || Ss(e))));
                    this.bulkOperationInProgress$ = (0,
                    Be.P)(( () => (0,
                    aE.z)((0,
                    ze.of)(!1), this.fetchTagOperationStatus().pipe((0,
                    He.U)((e => e.status === fs.BUSY)))).pipe((0,
                    Ks.w)((e => this._handleBulkTagMessage(n).pipe((0,
                    lu.O)(e))))))).pipe((0,
                    rE.d)({
                        bufferSize: 1,
                        refCount: !0
                    }), (0,
                    oa.R)(this._destroy$))
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                fetchCameraTags(e) {
                    return this._requestBuilder.createRequest(e.uri + "/service/cameras/tags").with(Ch.authorizeRecorder(e.id), Ch.proxy(e), Ch.cacheBust()).get()
                }
                fetchSubscriptionTags(e) {
                    return this._requestBuilder.createRequest(e.uri + "/service/events/metadata/subscriptions/tags").with(Ch.authorizeRecorder(e.id), Ch.proxy(e), Ch.cacheBust()).get()
                }
                fetchAllRecorderTags() {
                    return this._requestBuilder.createRequest(w.baseUrl + "/service/orchids/tags").with(lo.authorizeFusion(), lo.cacheBust()).get().pipe((0,
                    He.U)((e => e.tags)))
                }
                fetchAllCameraTags() {
                    return this._requestBuilder.createRequest(w.baseUrl + "/service/orchids/cameras/tags").with(lo.authorizeFusion(), lo.cacheBust()).get().pipe((0,
                    He.U)((e => e.tags)))
                }
                fetchRecorderTagDetails(e) {
                    const t = {
                        orchidTagKey: e.key
                    };
                    return e.value && (t.orchidTagValue = e.value),
                    this._requestBuilder.createRequest(w.baseUrl + "/service/orchids/ids").with(lo.applySearchParams(t), lo.cacheBust(), lo.authorizeFusion()).get()
                }
                fetchCameraTagDetails(e) {
                    const t = {
                        cameraTagKey: e.key
                    };
                    return e.value && (t.cameraTagValue = e.value),
                    this._requestBuilder.createRequest(w.baseUrl + "/service/orchids/cameras/ids").with(lo.applySearchParams(t), lo.cacheBust(), lo.authorizeFusion()).get().pipe((0,
                    He.U)((e => e.cameras)))
                }
                bulkAddCameraTags(e, t) {
                    return this._requestBuilder.createRequest(w.baseUrl + "/service/orchids/cameras/tags").with(lo.authorizeFusion()).post({
                        tags: e,
                        cameras: t
                    }).pipe((0,
                    He.U)((e => e.results)), (0,
                    lr.K)((e => {
                        const n = t.map((t => ({
                            resource: {
                                cameraId: t.cameraId,
                                orchidId: t.orchidId,
                                type: "CAMERA"
                            },
                            status: e.status
                        })));
                        return (0,
                        ze.of)(n)
                    }
                    )))
                }
                bulkDeleteCameraTags(e, t) {
                    return this._requestBuilder.createRequest(w.baseUrl + "/service/orchids/cameras/tags").with(lo.authorizeFusion()).delete({
                        tags: e,
                        cameras: t
                    }).pipe((0,
                    He.U)((e => e.results)), (0,
                    lr.K)((e => {
                        const n = t.map((t => ({
                            resource: {
                                cameraId: t.cameraId,
                                orchidId: t.orchidId,
                                type: "CAMERA"
                            },
                            status: e.status
                        })));
                        return (0,
                        ze.of)(n)
                    }
                    )))
                }
                bulkAddRecorderTags(e, t) {
                    return this._requestBuilder.createRequest(w.baseUrl + "/service/orchids/tags").with(lo.authorizeFusion()).post({
                        tags: e,
                        recorders: t
                    }).pipe((0,
                    He.U)((e => e.results)), (0,
                    lr.K)((e => {
                        const n = t.map((t => ({
                            resource: {
                                orchidId: t,
                                type: "ORCHID"
                            },
                            status: e.status
                        })));
                        return (0,
                        ze.of)(n)
                    }
                    )))
                }
                bulkDeleteRecorderTags(e, t) {
                    return this._requestBuilder.createRequest(w.baseUrl + "/service/orchids/tags").with(lo.authorizeFusion()).delete({
                        tags: e,
                        recorders: t
                    }).pipe((0,
                    He.U)((e => e.results)), (0,
                    lr.K)((e => {
                        const n = t.map((t => ({
                            resource: {
                                orchidId: t,
                                type: "ORCHID"
                            },
                            status: e.status
                        })));
                        return (0,
                        ze.of)(n)
                    }
                    )))
                }
                cancelBulkOperation() {
                    return this._requestBuilder.createRequest(w.baseUrl + "/service/orchids/tags/cancel").with(lo.authorizeFusion()).put()
                }
                fetchTagOperationStatus() {
                    return this._requestBuilder.createRequest(w.baseUrl + "/service/orchids/tags/status").with(lo.cacheBust(), lo.authorizeFusion()).get().pipe((0,
                    lr.K)((e => (sE.error(`Failed to fetch bulk operation status: ${e.statusText}`),
                    (0,
                    ze.of)({
                        status: fs.IDLE
                    })))))
                }
                _handleBulkTagMessage(e) {
                    return e.pipe((0,
                    ra.h)((e => Cs(e) || Ss(e))), (0,
                    Ks.w)((t => Cs(t) ? (0,
                    Kl.H)(1e3).pipe((0,
                    He.U)(( () => !0)), (0,
                    oa.R)(e.pipe((0,
                    ra.h)((e => Ss(e)))))) : (0,
                    ze.of)(!1))))
                }
            }
            ;
            var cE, lE, dE, uE, mE;
            oE = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(gr)), (0,
            c.fM)(1, (0,
            i.Inject)(Gt)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (nE = void 0 !== gr && gr) ? nE : Object, "function" == typeof (iE = Gt) ? iE : Object])], oE);
            let hE = cE = class {
                constructor(e, t, n, i, a) {
                    this.dialogData = e,
                    this._matDialogRef = t,
                    this._resourceTaggingService = n,
                    this._orchidDataService = i,
                    this._versionService = a,
                    this.icons = Object.assign({}, Ht),
                    this.processing = !1,
                    this.tags = [],
                    this.newTags = [],
                    this.destroy$ = new St.x,
                    this.nonAlphanumericTagValuesSupported = !0,
                    this.msgs = Object.assign(Object.assign({}, L.messages.resourceTagging), {
                        cancel: L.messages.dialogs.cancel,
                        close: L.messages.maps.close,
                        save: L.messages.propertyEditor.save,
                        unexpectedErrorOccurred: L.messages.errors.unexpectedErrorOccurred
                    }),
                    this.tags = xt(this.dialogData.tags),
                    this.resourceType = this.dialogData.resourceType,
                    this.existingTags = xt(this.dialogData.existingTags),
                    w.isOrchid || (this.nonAlphanumericTagValuesSupported = this._versionService.isFeatureSupported(this.dialogData.stubRecorder, Sr.BULK_TAGGING))
                }
                get dialogTitle() {
                    switch (this.dialogData.resourceType) {
                    case ps.SERVER:
                        return this.msgs.editServerTags();
                    case ps.CAMERA:
                        return this.msgs.editCameraTags()
                    }
                }
                get oneOrMoreTagsAreInvalid() {
                    return this.newTags.some((e => null !== e.controls.key.errors || null !== e.controls.value.errors || !1 === e.controls.selected.value))
                }
                ngOnDestroy() {
                    this.destroy$.next(),
                    this.destroy$.complete()
                }
                save() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this.processing || this.oneOrMoreTagsAreInvalid)
                            return;
                        this.processing = !0;
                        const e = [...this.tags, ...ys(this.newTags, !this.nonAlphanumericTagValuesSupported)];
                        switch (this.dialogData.resourceType) {
                        case ps.SERVER:
                            this._orchidDataService.updateServerTags(this.dialogData.stubRecorder, this.dialogData.discoverableRecorderId, {
                                tags: e
                            }).then((e => {
                                this._matDialogRef.close(e),
                                this.processing = !1
                            }
                            )).catch((e => {
                                var t;
                                this.error = null !== (t = e.statusText) && void 0 !== t ? t : this.msgs.unexpectedErrorOccurred(),
                                this.processing = !1
                            }
                            ));
                            break;
                        case ps.CAMERA:
                            this._orchidDataService.updateCameraTags(this.dialogData.stubRecorder, this.dialogData.cameraId, {
                                tags: e
                            }).then((e => {
                                this._matDialogRef.close(e.camera),
                                this.processing = !1
                            }
                            )).catch((e => {
                                var t;
                                this.error = null !== (t = e.statusText) && void 0 !== t ? t : this.msgs.unexpectedErrorOccurred(),
                                this.processing = !1
                            }
                            ))
                        }
                    }
                    ))
                }
                static editServerTags(e, t) {
                    const n = {
                        data: t,
                        disableClose: !0,
                        panelClass: "tag-list-editor-dialog-panel"
                    };
                    return e.open(cE, n).afterClosed().pipe((0,
                    pn.q)(1))
                }
                static editCameraTags(e, t) {
                    const n = {
                        data: t,
                        disableClose: !0,
                        panelClass: "tag-list-editor-dialog-panel"
                    };
                    return e.open(cE, n).afterClosed().pipe((0,
                    pn.q)(1))
                }
            }
            ;
            var pE, gE;
            hE = cE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "tag-list-editor-dialog",
                template: n(47587)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(2, (0,
            i.Inject)(oE)), (0,
            c.fM)(3, (0,
            i.Inject)(pt)), (0,
            c.fM)(4, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (lE = void 0 !== hn.so && hn.so) ? lE : Object, "function" == typeof (dE = void 0 !== oE && oE) ? dE : Object, "function" == typeof (uE = pt) ? uE : Object, "function" == typeof (mE = void 0 !== Cr && Cr) ? mE : Object])], hE);
            let fE = class {
                constructor(e, t) {
                    this._dialog = e,
                    this._versionService = t,
                    this.tags = [],
                    this.onTagsChanged = new i.EventEmitter,
                    this.loadingTagEditor = !1,
                    this.supportsResourceTags = !1,
                    this.icons = Object.assign({}, zt),
                    this.msgs = Object.assign(Object.assign({}, L.messages.resourceTagging), {
                        serverSettings: L.messages.propertyEditor.serverSettings,
                        serverTags: L.messages.propertyEditor.serverTags,
                        notAvailable: L.messages.events.orchidSelector.notAvailable
                    })
                }
                ngOnInit() {
                    w.isOrchid ? this.supportsResourceTags = !0 : this.supportsResourceTags = this._versionService.isFeatureSupported({
                        version: this.recorderVersion
                    }, Sr.RESOURCE_TAGGING)
                }
                editTags() {
                    if (this.loadingTagEditor)
                        return;
                    this.loadingTagEditor = !0;
                    const e = {
                        discoverableRecorderId: this.discoverableOrchidId,
                        existingTags: this.tags,
                        resourceType: ps.SERVER,
                        stubRecorder: {
                            id: this.recorderId,
                            uri: this.recorderUri,
                            version: this.recorderVersion
                        },
                        tags: this.tags
                    };
                    hE.editServerTags(this._dialog, e).pipe((0,
                    pn.q)(1)).subscribe((e => {
                        e && this.onTagsChanged.emit(e.tags)
                    }
                    )),
                    this.loadingTagEditor = !1
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], fE.prototype, "discoverableOrchidId", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], fE.prototype, "recorderId", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], fE.prototype, "recorderUri", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], fE.prototype, "recorderVersion", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], fE.prototype, "tags", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], fE.prototype, "onTagsChanged", void 0),
            fE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "server-tagging",
                template: n(41092)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(1, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (pE = void 0 !== hn.uw && hn.uw) ? pE : Object, "function" == typeof (gE = void 0 !== Cr && Cr) ? gE : Object])], fE);
            let vE = class {
                constructor() {
                    this.relativeContainer = !1
                }
            }
            ;
            var yE, bE;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Number)], vE.prototype, "aspectRatio", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], vE.prototype, "relativeContainer", void 0),
            vE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "video-overlay-sizer",
                template: n(5333)
            })], vE);
            let SE = class {
                constructor(e, t) {
                    this._dialog = e,
                    this._resourceTaggingService = t,
                    this.tags = [],
                    this.onTagsChange = new i.EventEmitter,
                    this.loadingTagEditor = !1,
                    this.destroy$ = new St.x
                }
                ngOnDestroy() {
                    this.destroy$.next(),
                    this.destroy$.complete()
                }
                editCameraTags() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this.loadingTagEditor)
                            return;
                        this.loadingTagEditor = !0;
                        const e = yield(0,
                        dt.z)(this._resourceTaggingService.fetchCameraTags({
                            id: this.recorderId,
                            uri: this.recorderUri
                        })).catch(( () => ({
                            tags: []
                        })))
                          , t = {
                            cameraId: this.cameraId,
                            existingTags: e.tags,
                            resourceType: ps.CAMERA,
                            stubRecorder: {
                                id: this.recorderId,
                                uri: this.recorderUri,
                                version: this.recorderVersion
                            },
                            tags: this.tags
                        };
                        hE.editCameraTags(this._dialog, t).pipe((0,
                        pn.q)(1), (0,
                        oa.R)(this.destroy$)).subscribe({
                            next: e => {
                                e && this.onTagsChange.emit(e)
                            }
                        }),
                        this.loadingTagEditor = !1
                    }
                    ))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], SE.prototype, "tags", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], SE.prototype, "cameraId", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], SE.prototype, "recorderId", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], SE.prototype, "recorderUri", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], SE.prototype, "recorderVersion", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], SE.prototype, "onTagsChange", void 0),
            SE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "camera-tagging",
                template: n(85368)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(1, (0,
            i.Inject)(oE)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (yE = void 0 !== hn.uw && hn.uw) ? yE : Object, "function" == typeof (bE = void 0 !== oE && oE) ? bE : Object])], SE);
            let CE = class {
                constructor() {
                    this.onEditTags = new i.EventEmitter,
                    this.tags = [],
                    this.viewOnly = !0,
                    this.maxTagsVisible = 15,
                    this.msgs = Object.assign({}, L.messages.common),
                    this.icons = Object.assign({}, Ht)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], CE.prototype, "onEditTags", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], CE.prototype, "tags", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], CE.prototype, "viewOnly", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], CE.prototype, "maxTagsVisible", void 0),
            CE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "resource-tag-list",
                template: n(68264)
            })], CE);
            let wE = class {
            }
            ;
            var IE, TE, EE, _E, xE, DE, OE;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], wE.prototype, "tag", void 0),
            wE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "resource-tag",
                template: n(35737)
            })], wE);
            let AE = class {
                constructor(e, t, n, a) {
                    this._minimumVersionService = e,
                    this._renewableService = t,
                    this._formBuilder = n,
                    this._cameraManagementService = a,
                    this.cameraConnectionPreferenceIsSupported = !0,
                    this.defaultOnvifURL = "http://192.168.1.1/onvif/device_service",
                    this.defaultGenericURL = "rtsp://192.168.1.1/axis-media/media.amp",
                    this.msgs = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, L.messages.cameras), L.messages.common), {
                        errors: L.messages.errors,
                        credentialErrors: L.messages.credentialsForm.errors
                    }), L.messages.cameras.cameraManualAdd), L.messages.cameras.connectionPreference), {
                        cancel: L.messages.common.cancel
                    }),
                    this.formMsgs = L.messages.credentialsForm,
                    this.CameraDriverType = Q,
                    this.currentDriver = Q.ONVIF,
                    this.showTlsIgnoreCheckbox = !1,
                    this.processing = !1,
                    this.errorMessage = "",
                    this.ignoreTlsCerts = !1,
                    this._destroy$ = new St.x,
                    this.onClose = new i.EventEmitter,
                    this.onRegistrationStart = new i.EventEmitter,
                    this.onRegistrationEnd = new i.EventEmitter,
                    this.addCameraForm = this._formBuilder.group({
                        driver: new p.NI(Q.ONVIF,[p.kI.required]),
                        discoveryUrl: new p.NI(this.defaultOnvifURL,[p.kI.required]),
                        name: new p.NI("",[p.kI.required]),
                        username: new p.NI("",[p.kI.required]),
                        password: new p.NI("",[p.kI.required]),
                        ignoreTlsCerts: new p.NI(!1)
                    })
                }
                ngOnInit() {
                    var e, t;
                    w.isOrchid || (this.cameraConnectionPreferenceIsSupported = this._minimumVersionService.isFeatureSupported(this.orchid, Sr.CAMERA_CONNECTION_PREFERENCE)),
                    this.cameraConnectionPreferenceIsSupported && (null === (e = this.addCameraForm.get("discoveryUrl")) || void 0 === e || e.valueChanges.pipe((0,
                    oa.R)(this._destroy$)).subscribe({
                        next: e => {
                            var t;
                            const n = null === (t = e.split(":").at(0)) || void 0 === t ? void 0 : t.toLowerCase();
                            this.showTlsIgnoreCheckbox = !!n && (n === jr.HTTPS && this.currentDriver === Q.ONVIF)
                        }
                    }),
                    null === (t = this.addCameraForm.get("ignoreTlsCerts")) || void 0 === t || t.valueChanges.pipe((0,
                    oa.R)(this._destroy$)).subscribe({
                        next: e => {
                            this.ignoreTlsCerts = e
                        }
                    }))
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                handleDriverSelectChange(e) {
                    switch (this.currentDriver = e.value,
                    e.value) {
                    case Q.ONVIF:
                        this.addCameraForm.controls.discoveryUrl.setValue(this.defaultOnvifURL);
                        break;
                    case Q.RTSP:
                        this.addCameraForm.controls.discoveryUrl.setValue(this.defaultGenericURL)
                    }
                }
                formHasErrors() {
                    return this.addCameraForm.controls.driver.hasError("required") || this.addCameraForm.controls.discoveryUrl.hasError("required") || this.addCameraForm.controls.name.hasError("required") || this.addCameraForm.controls.username.hasError("required") || this.addCameraForm.controls.password.hasError("required")
                }
                handleClosingErrorMessage() {
                    this.errorMessage = ""
                }
                cancelManualRegistration() {
                    this.onClose.emit()
                }
                registerCameraManually() {
                    this.onRegistrationStart.emit(),
                    this.errorMessage = "",
                    this.processing = !0;
                    const e = {
                        driver: this.addCameraForm.controls.driver.value,
                        name: this.addCameraForm.controls.name.value,
                        connection: {
                            verifySslCerts: !!this.cameraConnectionPreferenceIsSupported && !this.ignoreTlsCerts,
                            uri: this.addCameraForm.controls.discoveryUrl.value,
                            username: this.addCameraForm.controls.username.value,
                            password: this.addCameraForm.controls.password.value
                        }
                    };
                    (w.isOrchid ? this._cameraManagementService.registerCamera(e) : this._cameraManagementService.registerCamera(e, this.orchid)).pipe((0,
                    Ir.x)(( () => {
                        this.processing = !1,
                        this.onRegistrationEnd.emit()
                    }
                    ))).subscribe({
                        next: () => {
                            this._renewableService.refreshCameras(this.orchid),
                            this.onClose.emit()
                        }
                        ,
                        error: e => {
                            e.error.reason ? this.errorMessage = e.error.reason : this.errorMessage = this.msgs.anUnexpectedErrorOccurred()
                        }
                    })
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], AE.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (IE = void 0 !== i.EventEmitter && i.EventEmitter) ? IE : Object)], AE.prototype, "onClose", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (TE = void 0 !== i.EventEmitter && i.EventEmitter) ? TE : Object)], AE.prototype, "onRegistrationStart", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (EE = void 0 !== i.EventEmitter && i.EventEmitter) ? EE : Object)], AE.prototype, "onRegistrationEnd", void 0),
            AE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "camera-manual-add",
                template: n(70160)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Cr)), (0,
            c.fM)(1, (0,
            i.Inject)(Gt)), (0,
            c.fM)(2, (0,
            i.Inject)(p.qu)), (0,
            c.fM)(3, (0,
            i.Inject)(br)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (_E = void 0 !== Cr && Cr) ? _E : Object, "function" == typeof (xE = Gt) ? xE : Object, "function" == typeof (DE = void 0 !== p.qu && p.qu) ? DE : Object, "function" == typeof (OE = void 0 !== br && br) ? OE : Object])], AE);
            let RE = class {
                parsePoints(e) {
                    return e.map((e => `${e.x},${e.y}`)).join(" ")
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], RE.prototype, "regionsData", void 0),
            RE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "motion-regions-overlay",
                template: n(95642)
            })], RE),
            o().module("ipconfigure.orchid.singularity").directive("advancedSettings", (0,
            r.ke)({
                component: zm
            })).directive("ambulance", (0,
            r.ke)({
                component: qm
            })).directive("appRoot", (0,
            r.ke)({
                component: lf
            })).directive("library", (0,
            r.ke)({
                component: hh
            })).directive("licensing", (0,
            r.ke)({
                component: wf
            })).directive("logo", (0,
            r.ke)({
                component: UC
            })).directive("cell", (0,
            r.ke)({
                component: Cf
            })).directive("map", (0,
            r.ke)({
                component: Xv
            })).directive("mapCell", (0,
            r.ke)({
                component: Av
            })).directive("mapConfiguration", (0,
            r.ke)({
                component: tc
            })).directive("orchidRoles", (0,
            r.ke)({
                component: uC
            })).directive("onvifBulkRegistration", (0,
            r.ke)({
                component: Vr
            })).directive("permissionGroups", (0,
            r.ke)({
                component: yb
            })).directive("permGroupPage", (0,
            r.ke)({
                component: aS
            })).directive("permGroupCardContent", (0,
            r.ke)({
                component: lS
            })).directive("permCardRead", (0,
            r.ke)({
                component: gS
            })).directive("addPermGroupDialog", (0,
            r.ke)({
                component: Xb
            })).directive("permissionGroupForm", (0,
            r.ke)({
                component: Mb
            })).directive("permColumns", (0,
            r.ke)({
                component: yS
            })).directive("autocompleteChipInput", (0,
            r.ke)({
                component: du
            })).directive("chipList", (0,
            r.ke)({
                component: yu
            })).directive("searchBar", (0,
            r.ke)({
                component: aa
            })).directive("cameraPicker", (0,
            r.ke)({
                component: MS
            })).directive("pickerCards", (0,
            r.ke)({
                component: YS
            })).directive("pickerCardContents", (0,
            r.ke)({
                component: dC
            })).directive("previewTile", (0,
            r.ke)({
                component: US
            })).directive("listItem", (0,
            r.ke)({
                component: VS
            })).directive("pickerTable", (0,
            r.ke)({
                component: oC
            })).directive("iconTotal", (0,
            r.ke)({
                component: Vu
            })).directive("spinnerButton", (0,
            r.ke)({
                component: em
            })).directive("circleHint", (0,
            r.ke)({
                component: Iu
            })).directive("pagination", (0,
            r.ke)({
                component: Xu
            })).directive("version", (0,
            r.ke)({
                component: Rh
            })).directive("appLogExport", (0,
            r.ke)({
                component: vh
            })).directive("bagRender", (0,
            r.ke)({
                component: pf
            })).directive("motionAlertsList", (0,
            r.ke)({
                component: Iy
            })).directive("smartSearchOverlay", (0,
            r.ke)({
                component: ib
            })).directive("smartSearchControl", (0,
            r.ke)({
                component: ab
            })).directive("systemStatus", (0,
            r.ke)({
                component: MC
            })).directive("streamPreview", (0,
            r.ke)({
                component: Jd
            })).directive("matSpinner", (0,
            r.ke)({
                component: fi.$g
            })).directive("matPaginator", (0,
            r.ke)({
                component: pi.NW
            })).directive("playerFrameDownloader", (0,
            r.ke)({
                component: yC
            })).directive("errorPage", (0,
            r.ke)({
                component: Lu
            })).directive("expandButton", (0,
            r.ke)({
                component: ju
            })).directive("volumeButton", (0,
            r.ke)({
                component: LC
            })).directive("orchidUsers", (0,
            r.ke)({
                component: jC
            })).directive("fusionUsers", (0,
            r.ke)({
                component: GC
            })).directive("activation", (0,
            r.ke)({
                component: dw
            })).directive("auditLogs", (0,
            r.ke)({
                component: _w
            })).directive("framerateAlert", (0,
            r.ke)({
                component: Kw
            })).directive("recorderPermGroups", (0,
            r.ke)({
                component: NI
            })).directive("thumbnailSearchControl", (0,
            r.ke)({
                component: Jw
            })).directive("thumbnailSearchOverlay", (0,
            r.ke)({
                component: PI
            })).directive("decibelMeter", (0,
            r.ke)({
                component: KT
            })).directive("errorBanner", (0,
            r.ke)({
                component: _r
            })).directive("tag", (0,
            r.ke)({
                component: im
            })).directive("bidirectionalAudioOverlay", (0,
            r.ke)({
                component: XI
            })).directive("microphoneSelector", (0,
            r.ke)({
                component: ZI
            })).directive("singDialogErrors", (0,
            r.ke)({
                component: Ru
            })).directive("retentionBulkUpdate", (0,
            r.ke)({
                component: JT
            })).directive("filterChip", (0,
            r.ke)({
                component: ds
            })).directive("filterButtonMenu", (0,
            r.ke)({
                component: tE
            })).directive("serverTagging", (0,
            r.ke)({
                component: fE
            })).directive("cameraTagging", (0,
            r.ke)({
                component: SE
            })).directive("resourceTagList", (0,
            r.ke)({
                component: CE
            })).directive("resourceTag", (0,
            r.ke)({
                component: wE
            })).directive("videoOverlaySizer", (0,
            r.ke)({
                component: vE
            })).directive("cameraManualAddAngular", (0,
            r.ke)({
                component: AE
            })).directive("cameraAddDialog", (0,
            r.ke)({
                component: cs
            })).directive("recoverCamderaDialog", (0,
            r.ke)({
                component: Xr
            })).directive("motionRegionsOverlay", (0,
            r.ke)({
                component: RE
            })).service("cameraManagementService", (0,
            r.dV)(br)).service("PlayingSourceFactory", (0,
            r.dV)(BT)).service("WebSocketSubjectFactory", (0,
            r.dV)(sg)).service("WebSocketEventsService", (0,
            r.dV)(og)).service("TimelineEventService", (0,
            r.dV)(Rg)).service("NotificationsService", (0,
            r.dV)(ry)).service("BrandService", (0,
            r.dV)(Hm)).service("PlayerModeService", (0,
            r.dV)(Lm)).service("ThemeService", (0,
            r.dV)(sf)).service("AuditLogsService", (0,
            r.dV)(ub)).service("Platform", (0,
            r.dV)(g.t4)).factory("MatDialog", (0,
            r.dV)(hn.uw)).factory("Router", (0,
            r.dV)(Bt.F0)).service("FusionConfigService", (0,
            r.dV)(cc)).service("FeatureFlagService", (0,
            r.dV)(Ye)).service("MinimumVersionService", (0,
            r.dV)(Cr)).service("ResourceTaggingService", (0,
            r.dV)(oE)).service("ManagedRecordersService", (0,
            r.dV)(pb)).service("AppRefreshAlertService", (0,
            r.dV)(jI)).service("AudioInputService", (0,
            r.dV)(BI));
            let PE = class {
            }
            ;
            PE = (0,
            c.gn)([(0,
            i.NgModule)({
                providers: [Gg, jg, qg, Xg, Pg, Bg, Hg, zg, Jg, kg, Kg, Yg, $g, Fg, Mg, Zg, Wg, Lg, Ug, Vg, Ng, zg, Hg],
                declarations: [Ap, Rp, Pp, kp, Mp, Hp, Lp, Up, Np, Fp, zp, $p, jp, Vp, Gp, Bp, qp],
                exports: [Ap, Rp, Pp, kp, Mp, Hp, Lp, Up, Np, Fp, zp, $p, jp, Vp, Gp, Bp, qp],
                imports: [l.ez],
                entryComponents: [pi.NW, fi.$g, _r, Lu, ju, Qu, Xu, im, Ru, em, aa]
            })], PE);
            let kE = class {
            }
            ;
            kE = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [Gh, Hh, Lh],
                entryComponents: [Gh, Hh, Lh],
                exports: [Gh, Hh, Lh],
                imports: [l.ez, ym, p.u5, Ai, p.UX, PE],
                providers: []
            })], kE);
            let ME = class {
            }
            ;
            ME = (0,
            c.gn)([(0,
            i.NgModule)({
                imports: [l.ez, ym, p.u5, Ai, p.UX, PE],
                declarations: [QC, dw],
                exports: [dw],
                entryComponents: [QC, dw]
            })], ME);
            let LE = class {
                constructor() {
                    this.msgs = Object.assign(Object.assign({}, L.messages.cameraSelection), {
                        unknown: L.messages.library.unknown
                    }),
                    this.cameras = [],
                    this.selectedCameras = [],
                    this.checkboxText = "",
                    this.onCameraOrStreamSelect = new i.EventEmitter,
                    this.initiallySelectedCameraIds = new Set
                }
                get hasCameras() {
                    return this.cameras.length > 0
                }
                ngOnInit() {
                    this.selectedCameras.forEach((e => {
                        this.initiallySelectedCameraIds.add(e.id)
                    }
                    ))
                }
                ngOnChanges(e) {
                    e.cameras && (this.cameras = [...e.cameras.currentValue].sort(( (e, t) => {
                        const n = e.name.toLocaleLowerCase()
                          , i = t.name.toLocaleLowerCase();
                        return n.localeCompare(i)
                    }
                    )))
                }
                onStateChange(e) {
                    if (e.checked) {
                        !1 === this.selectedCameras.some((t => t.id === e.camera.id)) && this.selectedCameras.push(e.camera)
                    } else {
                        const t = this.selectedCameras.findIndex((t => t.id === e.camera.id));
                        -1 !== t && this.selectedCameras.splice(t, 1)
                    }
                    this.onCameraOrStreamSelect.emit(e)
                }
            }
            ;
            var NE;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], LE.prototype, "hideStreamSelect", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], LE.prototype, "enableMotionWarning", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], LE.prototype, "cameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], LE.prototype, "selectedCameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], LE.prototype, "checkboxText", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], LE.prototype, "onCameraOrStreamSelect", void 0),
            LE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "camera-selection",
                template: n(47666)
            })], LE);
            const FE = O("MotionAlertsComponent");
            let UE = class {
                constructor(e) {
                    this._notificationsService = e,
                    this.msgs = {},
                    this.loading = !1,
                    this.errorLoadingData = !1,
                    this.schedules = [],
                    this.motionAlertNotifications = [],
                    this.subscriptions = Ql.E.subscribe()
                }
                ngOnInit() {
                    this.loading = !0,
                    this.msgs = Object.assign(Object.assign({}, L.messages.motionAlerts), {
                        motionAlertsCOUNT: L.messages.notifications.motionAlertsCOUNT
                    }),
                    this.subscriptions = (0,
                    Sy.a)([this._notificationsService.getNotifications({
                        reload: !0
                    }), this._notificationsService.getSchedules()]).subscribe({
                        next: e => {
                            const [t,n] = e;
                            this.motionAlertNotifications = t.filter((e => e.conditions.some((e => e.type === W.MOTION_ALERT_CONDITION)))),
                            this.schedules = n,
                            this.loading = !1
                        }
                        ,
                        error: e => {
                            FE.error(e),
                            this.errorLoadingData = !0,
                            this.loading = !1
                        }
                    })
                }
                ngOnDestroy() {
                    this.subscriptions.unsubscribe()
                }
            }
            ;
            var $E, jE, VE;
            UE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "motion-alerts",
                template: n(12344)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(ry)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (NE = void 0 !== ry && ry) ? NE : Object])], UE);
            let GE = class {
                constructor() {
                    this.msgs = {
                        notifications: L.messages.notifications,
                        recipients: L.messages.recipients,
                        users: L.messages.dashboard.users
                    },
                    this.separatorKeysCodes = [ia.K5, ia.OC],
                    this.allUsers = [],
                    this.allGroups = [],
                    this.allSmtpServers = [],
                    this.usersWithoutEmails = [],
                    this.usersWithoutEmailsStr = "",
                    this.usersInputCtrl = new p.NI,
                    this.filteredSortedSelectableUsers$ = (0,
                    ze.of)([]),
                    this.groupsWithoutEmailsList = [],
                    this.groupsWithoutEmailsStr = "",
                    this.groupsInputCtrl = new p.NI,
                    this.filteredSortedSelectableGroups$ = (0,
                    ze.of)([]),
                    this.emailsInputCtrl = new p.NI
                }
                get selectedFormUsers() {
                    return this.recipientsForm.controls.users.value
                }
                get selectedFormGroups() {
                    return this.recipientsForm.controls.groups.value
                }
                get selectedFormEmails() {
                    return this.recipientsForm.controls.emailAddresses.value
                }
                get selectedSmtpFromAddress() {
                    return this.recipientsForm.controls.smtpFromAddress.value
                }
                get smtpServerSelectionError() {
                    return this.recipientsForm.controls.smtpServer.touched && null === this.recipientsForm.controls.smtpServer.value
                }
                _initValidation() {
                    this.recipientsForm.controls.smtpFromAddress.setValidators([p.kI.required, p.kI.email]),
                    this.recipientsForm.controls.smtpFromAddress.value || this.recipientsForm.controls.smtpFromAddress.setValue("noreply@example.com")
                }
                ngOnInit() {
                    this._updateUsersWithoutEmails(),
                    this._updateGroupsWithoutEmails(),
                    this._initValidation(),
                    this.filteredSortedSelectableUsers$ = this.usersInputCtrl.valueChanges.pipe((0,
                    lu.O)(""), (0,
                    He.U)((e => e ? this._getSortedSelectableUsers(this._filterUsers(e)) : this._getSortedSelectableUsers(this.allUsers)))),
                    this.filteredSortedSelectableGroups$ = this.groupsInputCtrl.valueChanges.pipe((0,
                    lu.O)(""), (0,
                    He.U)((e => e ? this._getSortedSelectableGroups(this._filterGroups(e)) : this._getSortedSelectableGroups(this.allGroups))))
                }
                onUserSelected(e) {
                    const t = e.option.value
                      , n = {
                        id: t.id,
                        username: t.username,
                        emailaddress: t.emailAddress
                    };
                    this.selectedFormUsers.push(n),
                    this.usersInput.nativeElement.value = "",
                    this.usersInputCtrl.setValue(""),
                    null === n.emailaddress && this._updateUsersWithoutEmails(),
                    this.recipientsForm.controls.users.updateValueAndValidity()
                }
                onUserRemoved(e) {
                    this.selectedFormUsers.splice(this.selectedFormUsers.findIndex((t => t.id === e.id)), 1),
                    this.usersInput.nativeElement.value = "",
                    this.usersInputCtrl.setValue(""),
                    null === e.emailaddress && this._updateUsersWithoutEmails(),
                    this.recipientsForm.controls.users.updateValueAndValidity()
                }
                _filterUsers(e) {
                    if ("string" == typeof e) {
                        const t = e.toLowerCase();
                        return this.allUsers.filter((e => e.username.toLowerCase().indexOf(t) > -1))
                    }
                    return [e]
                }
                _getSortedSelectableUsers(e) {
                    return e.filter((e => -1 === this.selectedFormUsers.findIndex((t => t.id === e.id)))).sort(( (e, t) => {
                        const n = e.username.toLowerCase()
                          , i = t.username.toLowerCase();
                        return n < i ? -1 : n > i ? 1 : 0
                    }
                    ))
                }
                _updateUsersWithoutEmails() {
                    void 0 !== this.selectedFormUsers && (this.usersWithoutEmails = this.selectedFormUsers.filter((e => null === e.emailaddress))),
                    this.usersWithoutEmailsStr = this.usersWithoutEmails.map((e => e.username)).join(", ")
                }
                onGroupSelected(e) {
                    const t = e.option.value
                      , n = {
                        id: t.id,
                        name: t.name
                    };
                    this.selectedFormGroups.push(n),
                    this.groupsInput.nativeElement.value = "",
                    this.groupsInputCtrl.setValue(""),
                    this._updateGroupsWithoutEmails(),
                    this.recipientsForm.controls.groups.updateValueAndValidity()
                }
                onGroupRemoved(e) {
                    this.selectedFormGroups.splice(this.selectedFormGroups.findIndex((t => t.id === e.id)), 1),
                    this.groupsInput.nativeElement.value = "",
                    this.groupsInputCtrl.setValue(""),
                    this._updateGroupsWithoutEmails(),
                    this.recipientsForm.controls.groups.updateValueAndValidity()
                }
                _filterGroups(e) {
                    if ("string" == typeof e) {
                        const t = e.toLowerCase();
                        return this.allGroups.filter((e => e.name.toLowerCase().indexOf(t) > -1))
                    }
                    return [e]
                }
                _getSortedSelectableGroups(e) {
                    return e.filter((e => -1 === this.selectedFormGroups.findIndex((t => t.id === e.id)))).sort(( (e, t) => {
                        const n = e.name.toLowerCase()
                          , i = t.name.toLowerCase();
                        return n < i ? -1 : n > i ? 1 : 0
                    }
                    ))
                }
                _updateGroupsWithoutEmails() {
                    this.groupsWithoutEmailsList = Lc(this.selectedFormGroups, this.allUsers, this.allGroups),
                    this.groupsWithoutEmailsStr = this.groupsWithoutEmailsList.join(", ")
                }
                onEmailSelected(e) {
                    var t;
                    const n = (e.value || "").trim()
                      , i = null === p.kI.email(new p.NI(n))
                      , a = this.selectedFormEmails.includes(e.value);
                    n && i && !a && this.selectedFormEmails.push(e.value),
                    null === (t = e.chipInput) || void 0 === t || t.clear(),
                    this.recipientsForm.controls.emailAddresses.updateValueAndValidity()
                }
                onEmailRemoved(e) {
                    this.selectedFormEmails.splice(this.selectedFormEmails.findIndex((t => t === e)), 1),
                    this.recipientsForm.controls.emailAddresses.updateValueAndValidity()
                }
                smtpServerComparator(e, t) {
                    return e && t && e.id === t.id
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof ($E = void 0 !== p.cw && p.cw) ? $E : Object)], GE.prototype, "recipientsForm", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], GE.prototype, "allUsers", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], GE.prototype, "allGroups", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], GE.prototype, "allSmtpServers", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("usersInput"), (0,
            c.w6)("design:type", "function" == typeof (jE = void 0 !== i.ElementRef && i.ElementRef) ? jE : Object)], GE.prototype, "usersInput", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("groupsInput"), (0,
            c.w6)("design:type", "function" == typeof (VE = void 0 !== i.ElementRef && i.ElementRef) ? VE : Object)], GE.prototype, "groupsInput", void 0),
            GE = (0,
            c.gn)([(0,
            i.Component)({
                selector: "recipients",
                template: n(63003)
            })], GE);
            O("ScheduleData");
            const BE = 1440
              , zE = 10080;
            var HE, WE, qE, YE, XE;
            !function(e) {
                e.INVALID_VALUE = "Input value is negative or exceeds the number of minutes in a day",
                e.INVALID_RANGE = "Interval.start would be greater than or equal to Interval.stop"
            }(HE || (HE = {}));
            class KE {
                constructor(e=0, t=60) {
                    this.start = e,
                    this.stop = t
                }
                static fromTimeSlot(e) {
                    return new KE(e.start,e.stop)
                }
                toTimeSlot() {
                    return {
                        start: this.start,
                        stop: this.stop
                    }
                }
                setTime(e, t) {
                    if (e < 0 || e > BE)
                        throw Error(HE.INVALID_VALUE);
                    if ("start" === t) {
                        if (e >= this.stop)
                            throw Error(HE.INVALID_RANGE);
                        this.start = e
                    } else if ("stop" === t) {
                        if (e <= this.start)
                            throw Error(HE.INVALID_RANGE);
                        this.stop = e
                    }
                }
                static minutesToTwentyFour(e, {zeroPad: t=!0}={}) {
                    const n = e % BE == 0 && e > 0 ? BE : (e % (i = BE) + i) % i;
                    var i;
                    const a = n % 60
                      , r = Math.trunc(n / 60)
                      , s = o(a);
                    return `${t ? o(r) : String(r)}:${s}`;
                    function o(e) {
                        return String(e).padStart(2, "0")
                    }
                }
                static twentyFourToMinutes(e) {
                    const t = e.match(/^(\d{1,2}):(\d{2})$/);
                    if (null === t)
                        return;
                    const [n,i,a] = t.map((e => parseInt(e)));
                    if (i < 0 || i > 24 || a < 0 || a > 59)
                        return;
                    let r = 0;
                    return r += 60 * i,
                    r += a,
                    r
                }
                static inferMinutesFromTwentyFour(e) {
                    const t = KE.twentyFourToMinutes
                      , n = t(e);
                    if (void 0 !== n)
                        return n;
                    const i = e.match(/^\s*(\d{1,2}:?(?:\d{1,2})?).*/)
                      , a = i && i[1].includes(":");
                    if (null !== i) {
                        if (a) {
                            const e = i[1].split(":");
                            return t(`${e[0]}:${e[1].padStart(2, "0")}`)
                        }
                        {
                            const e = i[1];
                            let n, a;
                            switch (e.length) {
                            case 1:
                            case 2:
                                return t(`${e}:00`);
                            case 3:
                                return n = e.slice(0, 1),
                                a = e.slice(1),
                                t(`${n}:${a}`);
                            case 4:
                                return n = e.slice(0, 2),
                                a = e.slice(2),
                                t(`${n}:${a}`)
                            }
                        }
                    }
                }
                static mergeOverlappingSlots(e) {
                    if (0 === e.length)
                        return [];
                    const t = []
                      , n = (e = e.map((e => {
                        const {start: t, stop: n} = e;
                        return {
                            start: t,
                            stop: n
                        }
                    }
                    ))).sort(( (e, t) => e.start - t.start));
                    let i = n[0]
                      , a = 1;
                    for (; a < n.length; ) {
                        const e = n[a];
                        e.start <= i.stop ? i.stop = Math.max(i.stop, e.stop) : (t.push(i),
                        i = e),
                        a += 1
                    }
                    return t.push(i),
                    t
                }
                static normalizeEndpoints(e) {
                    if (e.start === e.stop)
                        return [{
                            start: 0,
                            stop: zE
                        }];
                    if (e.start > e.stop) {
                        let t = [{
                            start: 0,
                            stop: e.stop
                        }, {
                            start: e.start,
                            stop: zE
                        }];
                        return t = t.filter((e => e.start !== e.stop)),
                        t
                    }
                    return [e]
                }
                static normalizeSlots(e) {
                    let t = [...e];
                    return t = t.flatMap((e => KE.normalizeEndpoints(e))),
                    t = KE.mergeOverlappingSlots(t),
                    t.sort(( (e, t) => e.start - t.start)),
                    t
                }
            }
            class ZE {
                constructor(e, t, n, i) {
                    this.name = e,
                    this.initial = t,
                    this.start = n,
                    this.stop = i,
                    this.slots = []
                }
                static fromTimeSlots(e) {
                    const t = [L.messages.monday(), L.messages.tuesday(), L.messages.wednesday(), L.messages.thursday(), L.messages.friday(), L.messages.saturday(), L.messages.sunday()]
                      , n = [L.messages.mondayInitial(), L.messages.tuesdayInitial(), L.messages.wednesdayInitial(), L.messages.thursdayInitial(), L.messages.fridayInitial(), L.messages.saturdayInitial(), L.messages.sundayInitial()]
                      , i = L.formats.weekDayOrder.map((e => new ZE(t[e - 1],n[e - 1],(e - 1) * BE,e * BE)));
                    return (e = KE.normalizeSlots(e)).forEach((e => {
                        i.forEach((t => {
                            const n = t.getOverlap(e);
                            if (n) {
                                const e = KE.fromTimeSlot(n);
                                e.start -= t.start,
                                e.stop -= t.start,
                                t.slots.push(e)
                            }
                        }
                        ))
                    }
                    )),
                    i
                }
                toTimeSlots() {
                    return this.slots.map((e => {
                        const t = e.toTimeSlot();
                        return t.start += this.start,
                        t.stop += this.start,
                        t
                    }
                    ))
                }
                addSlot() {
                    const e = function(e) {
                        if (0 === e.slots.length)
                            return 360;
                        const t = e.slots[e.slots.length - 1].toTimeSlot()
                          , n = 60 * Math.round(t.stop / 60);
                        return n % BE
                    }(this)
                      , t = e + 60;
                    this.slots.push(new KE(e,t))
                }
                removeSlot(e) {
                    this.slots.splice(e, 1)
                }
                getOverlap(e) {
                    if (e.stop < this.start)
                        return;
                    if (e.start > this.stop)
                        return;
                    const t = i(e.start, this.start, this.stop)
                      , n = i(e.stop, this.start, this.stop);
                    if (t !== n)
                        return {
                            start: t,
                            stop: n
                        };
                    function i(e, t, n) {
                        return e = Math.max(e, t),
                        e = Math.min(e, n)
                    }
                }
            }
            class JE {
                constructor(e, t) {
                    this.name = e,
                    this.id = t,
                    this.days = ZE.fromTimeSlots([])
                }
                static fromSchedule(e) {
                    const t = KE.normalizeSlots(e.timeSlots)
                      , n = new JE(e.name,e.id);
                    return n.days = ZE.fromTimeSlots(t),
                    n
                }
                toSchedule() {
                    let e = this.days.flatMap((e => e.toTimeSlots()));
                    e = KE.mergeOverlappingSlots(e);
                    const t = e[0]
                      , n = e[e.length - 1];
                    return 0 === (null == t ? void 0 : t.start) && (null == n ? void 0 : n.stop) === zE && (e = e.slice(1, -1),
                    e.push({
                        start: n.start,
                        stop: t.stop
                    })),
                    e = e.map((e => (e.stop === zE && (e.stop = 0),
                    e))),
                    {
                        id: this.id,
                        name: this.name || "",
                        timeSlots: e
                    }
                }
            }
            const QE = O("ScheduleFormDialog");
            let e_ = class {
                constructor() {
                    this.autoCompleteIncrement = 30
                }
                transform(e, t) {
                    const n = [];
                    let i = Math.ceil(e / this.autoCompleteIncrement) * this.autoCompleteIncrement;
                    for (; i < t; )
                        n.push(i),
                        i += this.autoCompleteIncrement;
                    return n
                }
            }
            ;
            e_ = (0,
            c.gn)([(0,
            i.Pipe)({
                name: "timeHint",
                pure: !0
            })], e_);
            let t_ = WE = class {
                constructor(e, t, n, i) {
                    this.changeDetectorRef = e,
                    this.matDialogRef = t,
                    this.notificationsService = n,
                    this.options = i,
                    this.data = this.options.data,
                    this.isProcessing = !1,
                    this.msgs = Object.assign(Object.assign({}, L.messages.notifications), {
                        anUnexpectedErrorHasOccurred: L.messages.dialogs.anUnexpectedErrorHasOccurred
                    }),
                    this.placeholderSlot = new KE,
                    this.title = this.options.title
                }
                static show(e, t) {
                    return e.open(WE, {
                        disableClose: !0,
                        panelClass: "schedule-dialog-panel",
                        data: t
                    }).afterClosed().pipe((0,
                    pn.q)(1))
                }
                save() {
                    let e = "create" === this.options.type ? this.notificationsService.addSchedule : this.notificationsService.updateSchedule;
                    e = e.bind(this.notificationsService),
                    this.isProcessing = !0,
                    e(this.data.toSchedule()).subscribe({
                        next: e => {
                            this.matDialogRef.close(e)
                        }
                        ,
                        error: e => {
                            var t;
                            QE.error(e),
                            this.error = (null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.reason) || this.msgs.anUnexpectedErrorHasOccurred(),
                            this.isProcessing = !1,
                            this.changeDetectorRef.detectChanges()
                        }
                    })
                }
                cancel() {
                    this.matDialogRef.close(void 0)
                }
                onTimeInputFocusOut(e, t, n, i, a) {
                    const r = () => {
                        i.value = KE.minutesToTwentyFour(t.start),
                        a.value = KE.minutesToTwentyFour(t.stop),
                        this.changeDetectorRef.markForCheck()
                    }
                    ;
                    let s = KE.inferMinutesFromTwentyFour(e);
                    if (void 0 !== s)
                        try {
                            t.setTime(s, n)
                        } catch (e) {
                            e.message === HE.INVALID_RANGE && ("start" === n ? (s = Math.min(s, 1439),
                            t.start = s,
                            t.stop = s + 1) : (s = Math.max(s, 1),
                            t.start = s - 1,
                            t.stop = s))
                        } finally {
                            r()
                        }
                    else
                        r()
                }
                onTimeInputKeydownEnter(e, t, n, i) {
                    t.blur(),
                    null !== n.activeOption && e.setTime(n.activeOption.value, i),
                    n.closePanel()
                }
                clearErrors() {
                    delete this.error
                }
                onEsc() {
                    this.cancel()
                }
                get allSlots() {
                    return this.data.days.flatMap((e => e.toTimeSlots()))
                }
                getSlotsWithDefault(e) {
                    return e.slots.length ? e.slots : [this.placeholderSlot]
                }
                get Interval() {
                    return KE
                }
                trackSlotBy(e, t) {
                    return e
                }
            }
            ;
            var n_, i_, a_, r_, s_;
            (0,
            c.gn)([(0,
            i.HostListener)("keydown.esc"), (0,
            c.w6)("design:type", Function), (0,
            c.w6)("design:paramtypes", []), (0,
            c.w6)("design:returntype", void 0)], t_.prototype, "onEsc", null),
            t_ = WE = (0,
            c.gn)([(0,
            i.Component)({
                template: n(80722),
                changeDetection: i.ChangeDetectionStrategy.OnPush
            }), (0,
            c.fM)(0, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(2, (0,
            i.Inject)(ry)), (0,
            c.fM)(3, (0,
            i.Inject)(hn.WI)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (qE = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? qE : Object, "function" == typeof (YE = void 0 !== hn.so && hn.so) ? YE : Object, "function" == typeof (XE = void 0 !== ry && ry) ? XE : Object, Object])], t_);
            O("ScheduleList");
            let o_ = class {
                constructor(e, t, n) {
                    this.changeDetectorRef = e,
                    this.matDialog = t,
                    this.notificationsService = n,
                    this.schedules = [],
                    this.RETRY_DELAY = 5e3,
                    this.dataSource = new Ei.by,
                    this.defaultSort = {
                        id: "name",
                        start: "asc",
                        disableClear: !0
                    },
                    this.pageSizeOptions = [10, 20, 50],
                    this.msgs = {},
                    this.isLoading = !0,
                    this.scheduleSub = this.fetchSchedules()
                }
                ngOnInit() {
                    this.msgs = L.messages.notifications
                }
                ngAfterViewInit() {
                    this.dataSource.sortingDataAccessor = this.sortingDataAccessor.bind(this),
                    this.refreshTableView()
                }
                ngOnDestroy() {
                    this.scheduleSub.unsubscribe()
                }
                updateSchedule(e) {
                    const t = {
                        data: JE.fromSchedule(e),
                        title: this.msgs.editSchedule(),
                        type: "update"
                    };
                    t_.show(this.matDialog, t).subscribe()
                }
                addSchedule() {
                    const e = {
                        data: new JE,
                        title: this.msgs.createSchedule(),
                        type: "create"
                    };
                    t_.show(this.matDialog, e).subscribe()
                }
                deleteSchedule(e) {
                    const t = {
                        panelClass: "sing-dialog-panel",
                        data: {
                            message: this.msgs.areYouSureYouWantToDeleteTheValueSchedule({
                                VALUE: e.name
                            }),
                            confirmText: this.msgs.delete(),
                            cancelText: this.msgs.cancel(),
                            confirmCallbackAsync: () => (0,
                            dt.z)(this.notificationsService.deleteSchedule(e.id))
                        }
                    };
                    qs.show(this.matDialog, t).subscribe()
                }
                fetchSchedules() {
                    return this.notificationsService.getSchedules().subscribe((e => {
                        this.schedules = e,
                        this.isLoading = !1,
                        this.refreshTableView()
                    }
                    ))
                }
                sortingDataAccessor(e, t) {
                    return "name" === t ? e[t].toLocaleLowerCase() : e[t]
                }
                refreshTableView() {
                    this.dataSource.data = this.schedules,
                    this.dataSource.paginator = this.paginator,
                    this.dataSource.sort = this.sort,
                    this.changeDetectorRef.markForCheck()
                }
                getRowId(e) {
                    return e.id
                }
                get hidePaginator() {
                    return this.schedules.length <= this.pageSizeOptions[0]
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW), (0,
            c.w6)("design:type", "function" == typeof (n_ = void 0 !== pi.NW && pi.NW) ? n_ : Object)], o_.prototype, "paginator", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(Ii.YE), (0,
            c.w6)("design:type", "function" == typeof (i_ = void 0 !== Ii.YE && Ii.YE) ? i_ : Object)], o_.prototype, "sort", void 0),
            o_ = (0,
            c.gn)([(0,
            i.Component)({
                selector: "schedule-list",
                template: n(2660),
                changeDetection: i.ChangeDetectionStrategy.OnPush
            }), (0,
            c.fM)(0, (0,
            i.Inject)(i.ChangeDetectorRef)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(2, (0,
            i.Inject)(ry)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (a_ = void 0 !== i.ChangeDetectorRef && i.ChangeDetectorRef) ? a_ : Object, "function" == typeof (r_ = void 0 !== hn.uw && hn.uw) ? r_ : Object, "function" == typeof (s_ = void 0 !== ry && ry) ? s_ : Object])], o_);
            let c_ = class {
                constructor() {
                    this.msgs = L.messages.scheduleSummary,
                    this.slots = []
                }
                ngOnChanges(e) {
                    void 0 !== e.slots && (this.Weekdays = ZE.fromTimeSlots(e.slots.currentValue).map((e => ({
                        initial: e.initial,
                        name: e.name,
                        slots: this._formatSlots(e.slots)
                    }))))
                }
                _formatSlots(e) {
                    return e.map((e => ({
                        left: 2 * Math.min(e.start / 60, 22),
                        width: 2 * Math.max((e.stop - e.start) / 60, 2)
                    })))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], c_.prototype, "slots", void 0),
            c_ = (0,
            c.gn)([(0,
            i.Component)({
                selector: "schedule-summary",
                template: n(9376)
            })], c_);
            var l_, d_, u_, m_, h_, p_, g_, f_ = n(86223);
            !function(e) {
                e.NAME = "name",
                e.SERVER = "server",
                e.ICONS = "icons"
            }(g_ || (g_ = {}));
            let v_ = class {
                constructor(e, t, n, i) {
                    this._breakpointObserver = e,
                    this._NotificationsService = t,
                    this._legacyDialogService = n,
                    this._matDialog = i,
                    this.msgs = L.messages.notifications,
                    this.loading = !0,
                    this.defaultSort = {
                        id: g_.NAME,
                        start: "asc",
                        disableClear: !0
                    },
                    this.dataSource = new Ei.by([]),
                    this.displayedColumns = [g_.NAME, g_.SERVER, g_.ICONS]
                }
                get TableColumns() {
                    return g_
                }
                ngOnInit() {
                    this._breakpointSubscription = this._breakpointObserver.observe(["(max-width: 550px)"]).subscribe((e => {
                        e.matches ? this.displayedColumns = [g_.NAME, g_.ICONS] : this.displayedColumns = [g_.NAME, g_.SERVER, g_.ICONS]
                    }
                    )),
                    this.dataSource.sortingDataAccessor = (e, t) => {
                        const n = e[t];
                        return "string" == typeof n ? n.toUpperCase() : n
                    }
                    ,
                    this._smtpServersSubscription = this._NotificationsService.getSmtpServers().subscribe((e => {
                        this.loading = !1,
                        this.dataSource.data = e
                    }
                    ), ( () => {
                        this.loading = !1,
                        this.error = this.msgs.failedToLoadSmtpServers()
                    }
                    ))
                }
                ngAfterViewInit() {
                    this.dataSource.sort = this.sort
                }
                ngOnDestroy() {
                    var e, t;
                    null === (e = this._breakpointSubscription) || void 0 === e || e.unsubscribe(),
                    null === (t = this._smtpServersSubscription) || void 0 === t || t.unsubscribe()
                }
                addSmtpServer(e) {
                    const t = {
                        template: n(11210),
                        controller: "SmtpDialogController as smtpDialog",
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        escapeToClose: !1,
                        locals: {
                            smtpServer: void 0
                        }
                    };
                    return this._legacyDialogService.openDialog(t)
                }
                editSmtpServer(e, t) {
                    e.stopPropagation();
                    const i = {
                        template: n(11210),
                        controller: "SmtpDialogController as smtpDialog",
                        targetEvent: e,
                        clickOutsideToClose: !1,
                        escapeToClose: !1,
                        locals: {
                            smtpServer: t
                        }
                    };
                    return this._legacyDialogService.openDialog(i)
                }
                deleteSmtpServer(e, t) {
                    e.stopPropagation();
                    const n = {
                        panelClass: "sing-dialog-panel",
                        data: {
                            message: this.msgs.areYouSureYouWantToDeleteThisSmtpServer(),
                            confirmText: this.msgs.delete(),
                            cancelText: this.msgs.cancel(),
                            confirmCallbackAsync: () => (0,
                            c.mG)(this, void 0, void 0, (function*() {
                                yield(0,
                                dt.z)(this._NotificationsService.deleteSmtpServer(t.id))
                            }
                            ))
                        }
                    };
                    qs.show(this._matDialog, n)
                }
            }
            ;
            function y_() {
                const e = new pi.ye;
                return e.firstPageLabel = L.messages.licensing.paginator.firstPage(),
                e.lastPageLabel = L.messages.licensing.paginator.lastPage(),
                e.nextPageLabel = L.messages.licensing.paginator.nextPage(),
                e.previousPageLabel = L.messages.licensing.paginator.previousPage(),
                e.itemsPerPageLabel = L.messages.licensing.paginator.itemsPerPage(),
                e.getRangeLabel = b_,
                e
            }
            function b_(e, t, n) {
                const i = e * t + 1
                  , a = Math.min(n, (e + 1) * t);
                return L.messages.licensing.paginator.countOfTotal({
                    COUNT: `${i}  ${a}`,
                    TOTAL: n
                })
            }
            (0,
            c.gn)([(0,
            i.ViewChild)(Ii.YE), (0,
            c.w6)("design:type", "function" == typeof (l_ = void 0 !== Ii.YE && Ii.YE) ? l_ : Object)], v_.prototype, "sort", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(Ei.BZ), (0,
            c.w6)("design:type", "function" == typeof (d_ = void 0 !== Ei.BZ && Ei.BZ) ? d_ : Object)], v_.prototype, "table", void 0),
            v_ = (0,
            c.gn)([(0,
            i.Component)({
                selector: "smtpServers",
                template: n(8205)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(f_.Yg)), (0,
            c.fM)(1, (0,
            i.Inject)(ry)), (0,
            c.fM)(2, (0,
            i.Inject)($d)), (0,
            c.fM)(3, (0,
            i.Inject)(hn.uw)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (u_ = void 0 !== f_.Yg && f_.Yg) ? u_ : Object, "function" == typeof (m_ = void 0 !== ry && ry) ? m_ : Object, "function" == typeof (h_ = $d) ? h_ : Object, "function" == typeof (p_ = void 0 !== hn.uw && hn.uw) ? p_ : Object])], v_);
            let S_ = class {
            }
            ;
            S_ = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [LE, hy, UE, Iy, GE, t_, o_, c_, v_, e_],
                entryComponents: [hy, UE, Iy, t_, c_],
                exports: [UE],
                imports: [l.ez, ym, p.u5, lt.JF, Ai, p.UX, uf.Cl, bm, PE],
                providers: [ry, {
                    provide: pi.ye,
                    useFactory: y_
                }]
            })], S_);
            var C_ = n(22719);
            let w_ = class {
                ngOnInit() {
                    (0,
                    C_.Z)({
                        dom_id: "#swagger-ui",
                        url: `${w.baseUrl}/openapi-spec/hybrid_swagger.yaml`
                    });
                    this.isPWA = w.isPWA
                }
            }
            ;
            var I_, T_;
            w_ = (0,
            c.gn)([(0,
            i.Component)({
                selector: "sing-swagger",
                template: n(40984)
            })], w_);
            let E_ = class {
                constructor(e, t) {
                    const n = e.snapshot.params;
                    this.plugin = n.plugin,
                    this.extension = n.extension,
                    this.routeChangeSub = e.params.pipe((0,
                    dr.T)(1)).subscribe(( () => {
                        const e = t.url;
                        t.navigateByUrl("/", {
                            skipLocationChange: !0
                        }).then(( () => {
                            t.navigateByUrl(e)
                        }
                        ))
                    }
                    ))
                }
                ngOnDestroy() {
                    this.routeChangeSub.unsubscribe()
                }
            }
            ;
            E_ = (0,
            c.gn)([(0,
            i.Component)({
                template: n(26979)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Bt.gz)), (0,
            c.fM)(1, (0,
            i.Inject)(Bt.F0)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (I_ = void 0 !== Bt.gz && Bt.gz) ? I_ : Object, "function" == typeof (T_ = void 0 !== Bt.F0 && Bt.F0) ? T_ : Object])], E_);
            let __ = class {
                constructor() {
                    this.msgs = L.messages.accessDenied
                }
            }
            ;
            var x_, D_, O_;
            __ = (0,
            c.gn)([(0,
            i.Component)({
                selector: "access-denied",
                template: n(14789)
            })], __);
            let A_ = class {
                constructor(e, t, n) {
                    this._playerModeService = e,
                    this._router = t,
                    this._route = n,
                    this.msgs = L.messages.dinosaur,
                    this.showWSMsg = !1,
                    this._route.data.subscribe((e => {
                        this.showWSMsg = "ws" === e.reason
                    }
                    ))
                }
                forceCompatibility() {
                    this._playerModeService.setDefaultPlayerMode(tn),
                    this._router.navigateByUrl("/sign-in")
                }
            }
            ;
            A_ = (0,
            c.gn)([(0,
            i.Component)({
                selector: "dinosaur",
                template: n(39864)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Lm)), (0,
            c.fM)(1, (0,
            i.Inject)(Bt.F0)), (0,
            c.fM)(2, (0,
            i.Inject)(Bt.gz)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (x_ = void 0 !== Lm && Lm) ? x_ : Object, "function" == typeof (D_ = void 0 !== Bt.F0 && Bt.F0) ? D_ : Object, "function" == typeof (O_ = void 0 !== Bt.gz && Bt.gz) ? O_ : Object])], A_);
            var R_, P_, k_, M_, L_, N_, F_, U_, $_, j_ = n(68067);
            !function(e) {
                e.NAME = "name",
                e.CATEGORY = "category",
                e.TYPE = "type",
                e.CAMERA = "camera",
                e.TOPIC = "topic"
            }($_ || ($_ = {}));
            let V_ = R_ = class {
                constructor(e, t, n, i, a, r) {
                    var s, o;
                    this._clipboard = e,
                    this._dataService = t,
                    this.dialogData = n,
                    this._matDialogRef = i,
                    this._orchidDataService = a,
                    this._minimumVersionService = r,
                    this.msgs = {},
                    this.dialogTitle = "",
                    this.subscriptionTypes = [],
                    this.selectedCameraOnvifTopics = [],
                    this.processing = !1,
                    this.apiUrlCardExpanded = !1,
                    this.copyUrlSuccess = void 0,
                    this.currentStepperStep = 0,
                    this.pageSizeOptions = [8, 12, 24, 48],
                    this.pageSize = 8,
                    this.getStreamDetails = ee,
                    this.cameraPreviewUrlDict = {},
                    this.selectedSourceCamera = [],
                    this.allCamerasMetadata = [],
                    this.associatedCamerasMetadata = [],
                    this.onvifCamerasMetadata = [],
                    this.isCameraDisablementSupported = !0,
                    this.supportsResourceTagging = !0,
                    this.nonAlphanumericTagValuesSupported = !0,
                    this.onvifColumns = [$_.NAME, $_.CATEGORY, $_.TYPE, $_.CAMERA, $_.TOPIC],
                    this.externalColumns = [$_.NAME, $_.CATEGORY, $_.TYPE],
                    this.newTags = [],
                    this.tags = [],
                    this.existingTags = [],
                    this.existingAndNewTags = [],
                    this.existingTags = xt(null !== (s = this.dialogData.existingTags) && void 0 !== s ? s : []),
                    (null === (o = this.dialogData.subscription) || void 0 === o ? void 0 : o.tags) && (this.tags = xt(this.dialogData.subscription.tags)),
                    this.existingAndNewTags = [...this.tags, ...this.newTags.map((e => ({
                        key: e.controls.key.value,
                        value: e.controls.value.value
                    })))]
                }
                get oneOrMoreTagsAreInvalid() {
                    return this.newTags.some((e => null !== e.controls.key.errors || null !== e.controls.value.errors || !1 === e.controls.selected.value))
                }
                get ResourceType() {
                    return ps
                }
                get displayedColumns() {
                    var e;
                    return "onvif" === (null === (e = this.formType) || void 0 === e ? void 0 : e.value) ? this.onvifColumns : this.externalColumns
                }
                get TableColumns() {
                    return $_
                }
                get CategoryIcons() {
                    return cd
                }
                get showExternalEventInstruction() {
                    var e;
                    return void 0 !== this.dialogData.subscription && (null === (e = this.formType) || void 0 === e ? void 0 : e.value) === tm.EXTERNAL && 4 === this.currentStepperStep
                }
                get externalEventUrl() {
                    var e;
                    return void 0 === this.dialogData.subscription ? this.msgs.urlAvailableAfterSaving() : this.dialogData.orchid.uri + `/service/events/metadata/external/${null === (e = this.dialogData.subscription) || void 0 === e ? void 0 : e.id}`
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.events.eventsSubscriptions), L.messages.common), {
                        tags: L.messages.resourceTagging.tags
                    }),
                    this.subscriptionTypes = [this.msgs.onvif(), this.msgs.external()],
                    w.isOrchid || (this.isCameraDisablementSupported = this._minimumVersionService.isFeatureSupported(this.dialogData.orchid, Sr.CAMERA_DISABLEMENT),
                    this.supportsResourceTagging = this._minimumVersionService.isFeatureSupported(this.dialogData.orchid, Sr.RESOURCE_TAGGING),
                    this.nonAlphanumericTagValuesSupported = this._minimumVersionService.isFeatureSupported(this.dialogData.orchid, Sr.BULK_TAGGING));
                    const e = {
                        target: {
                            innerWidth: window.innerWidth
                        }
                    };
                    if (this.onWindowResize(e),
                    this.dialogData.orchid.cameras.forEach((e => {
                        var t;
                        const n = "number" == typeof e.id ? e.id : parseInt(e.id)
                          , i = {
                            active: !this.isCameraDisablementSupported || null !== (t = e.active) && void 0 !== t && t,
                            cameraId: n,
                            cameraName: e.name,
                            previewUrl: this._dataService.cameraPreviewUrl(e.orchidId, e.id, j.LARGE, !0)
                        };
                        this.allCamerasMetadata.push(i);
                        const a = this.dialogData.onvifTopicCameraMap.find((t => t.cameraId === e.id));
                        a && a.onvifTopics.length > 0 && this.onvifCamerasMetadata.push(i),
                        void 0 !== this.dialogData.subscription && (this.dialogData.subscription.associatedCameraIds.includes(n) && this.associatedCamerasMetadata.push(i),
                        this.dialogData.subscription.cameraId === n && (this.selectedSourceCamera = [i]))
                    }
                    )),
                    void 0 !== this.dialogData.subscription) {
                        this.currentStepperStep = 4,
                        this.dialogTitle = this.dialogData.subscription.name;
                        const e = this.dialogData.onvifTopicCameraMap.find((e => {
                            var t;
                            return (null === (t = this.dialogData.subscription) || void 0 === t ? void 0 : t.cameraId) === e.cameraId
                        }
                        ));
                        this.selectedCameraOnvifTopics = void 0 === e ? [] : e.onvifTopics
                    } else
                        this.dialogTitle = this.msgs.newSubscription();
                    this.subscriptionForm = this._initializeFormGroup()
                }
                ngAfterViewInit() {
                    void 0 === this.dialogData.subscription && 0 !== this.currentStepperStep || document.getElementsByClassName("mat-horizontal-stepper-header-container")[0].classList.add("hidden")
                }
                get formName() {
                    return this.subscriptionForm.get("name")
                }
                get formCategory() {
                    return this.subscriptionForm.get("category")
                }
                get formType() {
                    return this.subscriptionForm.get("type")
                }
                get formCamera() {
                    return this.subscriptionForm.get("camera")
                }
                get formOnvifTopic() {
                    return this.subscriptionForm.get("onvifTopic")
                }
                get formIsInvalid() {
                    var e, t, n;
                    return "onvif" === (null === (e = this.formType) || void 0 === e ? void 0 : e.value) ? this.subscriptionForm.invalid || this.oneOrMoreTagsAreInvalid : !0 !== (null === (t = this.formName) || void 0 === t ? void 0 : t.valid) || !0 !== (null === (n = this.formCategory) || void 0 === n ? void 0 : n.valid) || this.oneOrMoreTagsAreInvalid
                }
                copyUrlToClipboard(e) {
                    void 0 === this.copyUrlSuccess && (this.copyUrlSuccess = this._clipboard.copy(this.externalEventUrl),
                    e.message = this.copyUrlSuccess ? this.msgs.copiedExclamation() : this.msgs.copyFailed(),
                    e.show(),
                    setTimeout(( () => {
                        this.copyUrlSuccess = void 0,
                        e.hide(),
                        e.message = ""
                    }
                    ), 3e3))
                }
                navigateStepper(e) {
                    this.currentStepperStep = e,
                    e < 4 && (document.getElementsByClassName("mat-horizontal-stepper-header-container")[0].classList.remove("hidden"),
                    this.dialogTitle = this.msgs.editSubscription()),
                    this.stepper.selectedIndex = e
                }
                saveSubscription() {
                    var e, t, n, i, a, r;
                    this.processing = !0;
                    const s = [...this.tags, ...ys(this.newTags, !this.nonAlphanumericTagValuesSupported)]
                      , o = {
                        associatedCameraIds: [],
                        cameraId: null === (null === (e = this.formCamera) || void 0 === e ? void 0 : e.value) ? null : null === (t = this.formCamera) || void 0 === t ? void 0 : t.value.cameraId,
                        categoryId: null === (n = this.formCategory) || void 0 === n ? void 0 : n.value.id,
                        name: null === (i = this.formName) || void 0 === i ? void 0 : i.value,
                        onvifTopic: null === (a = this.formOnvifTopic) || void 0 === a ? void 0 : a.value,
                        type: null === (r = this.formType) || void 0 === r ? void 0 : r.value,
                        tags: s
                    };
                    this.associatedCamerasMetadata.forEach((e => {
                        o.associatedCameraIds.push(e.cameraId)
                    }
                    )),
                    o.associatedCameraIds.sort(( (e, t) => e - t)),
                    null !== o.cameraId && o.associatedCameraIds.includes(o.cameraId) && (o.associatedCameraIds.splice(o.associatedCameraIds.indexOf(o.cameraId), 1),
                    o.associatedCameraIds.unshift(o.cameraId)),
                    void 0 === this.dialogData.subscription ? this._orchidDataService.postEventSubscription(this.dialogData.orchid, o).then((e => {
                        this._matDialogRef.close(e)
                    }
                    )).catch((e => {
                        e.data && e.data.reason ? this.error = e.data.reason : this.error = this.msgs.anUnexpectedErrorOccurred()
                    }
                    )).finally(( () => {
                        this.processing = !1
                    }
                    )) : this._orchidDataService.putEventSubscription(this.dialogData.orchid, this.dialogData.subscription.id, o).then((e => {
                        this._matDialogRef.close(e)
                    }
                    )).catch((e => {
                        e.data && e.data.reason ? this.error = e.data.reason : this.error = this.msgs.anUnexpectedErrorOccurred()
                    }
                    )).finally(( () => {
                        this.processing = !1
                    }
                    ))
                }
                onPrimaryCameraSelected(e) {
                    var t, n, i, a, r;
                    if (0 === e.length)
                        this.selectedCameraOnvifTopics = [],
                        null === (t = this.formOnvifTopic) || void 0 === t || t.disable(),
                        null === (n = this.formCamera) || void 0 === n || n.setValue(null);
                    else {
                        const t = this.dialogData.onvifTopicCameraMap.find((t => t.cameraId === e[0].cameraId));
                        this.selectedCameraOnvifTopics = void 0 === t ? [] : t.onvifTopics,
                        void 0 === this.dialogData.subscription && (this.associatedCamerasMetadata = [...e],
                        this.allCamerasMetadata = [...this.allCamerasMetadata]),
                        null === (i = this.formCamera) || void 0 === i || i.setValue(e[0]),
                        null === (a = this.formOnvifTopic) || void 0 === a || a.enable()
                    }
                    null === (r = this.formOnvifTopic) || void 0 === r || r.reset()
                }
                onAssociatedCameraSelected(e) {
                    this.associatedCamerasMetadata = [...e]
                }
                onStepperStepChange(e) {
                    this.currentStepperStep = e.selectedIndex,
                    1 === e.previouslySelectedIndex && (this.existingAndNewTags = [...this.tags, ...this.newTags.map((e => ({
                        key: e.controls.key.value,
                        value: e.controls.value.value
                    })))])
                }
                onStepperAnimationComplete() {
                    var e;
                    null === (e = document.getElementById(`formFocus${this.stepper.selectedIndex}`)) || void 0 === e || e.focus()
                }
                onWindowResize(e) {
                    const t = e.target.innerWidth
                      , n = new mu([8, 12, 24, 48],(e => e >= 800),{
                        4: 8,
                        8: 8,
                        9: 8,
                        12: 12,
                        24: 24,
                        48: 48
                    });
                    n.test(t) && (this.pageSizeOptions = [...n.options],
                    this.pageSize = n.pageMap[this.pageSize]);
                    const i = new mu([9, 12, 24, 48],(e => e < 800 && e >= 622),{
                        4: 9,
                        8: 9,
                        9: 9,
                        12: 12,
                        24: 24,
                        48: 48
                    });
                    i.test(t) && (this.pageSizeOptions = [...i.options],
                    this.pageSize = i.pageMap[this.pageSize]);
                    const a = new mu([8, 12, 24, 48],(e => e < 622 && e >= 443),{
                        4: 8,
                        8: 8,
                        9: 8,
                        12: 12,
                        24: 24,
                        48: 48
                    });
                    a.test(t) && (this.pageSizeOptions = [...a.options],
                    this.pageSize = a.pageMap[this.pageSize]);
                    const r = new mu([4, 8, 12, 24, 48],(e => e < 443),{
                        4: 4,
                        8: 4,
                        9: 8,
                        12: 12,
                        24: 24,
                        48: 48
                    });
                    r.test(t) && (this.pageSizeOptions = [...r.options],
                    this.pageSize = r.pageMap[this.pageSize])
                }
                selectEventType(e) {
                    var t;
                    if (e !== tm.ONVIF && e !== tm.EXTERNAL)
                        throw new Error(`Unknown event type: ${e}!`);
                    null === (t = this.formType) || void 0 === t || t.setValue(e),
                    this.stepper.steps.first.completed = !0,
                    document.getElementsByClassName("mat-horizontal-stepper-header-container")[0].classList.remove("hidden"),
                    this.stepper.next()
                }
                _initializeFormGroup() {
                    const e = this.dialogData.subscription;
                    let t = ""
                      , n = null
                      , i = null
                      , a = null
                      , r = null;
                    return e && (t = e.name,
                    n = this.dialogData.eventCategories.find((t => t.id === e.categoryId)) || null,
                    i = e.type,
                    a = this.onvifCamerasMetadata.find((t => t.cameraId === e.cameraId)) || null,
                    r = e.onvifTopic),
                    new p.cw({
                        name: new p.NI(t,[p.kI.required]),
                        category: new p.NI(n,[p.kI.required]),
                        type: new p.NI(i,[p.kI.required]),
                        camera: new p.NI(a,[p.kI.required]),
                        onvifTopic: new p.NI({
                            value: r,
                            disabled: void 0 === e || null === e.cameraId
                        },[p.kI.required])
                    })
                }
                static show(e, t) {
                    return e.open(R_, {
                        panelClass: "add-edit-subscription-dialog-custom-panel-class",
                        data: t,
                        disableClose: !0
                    }).afterClosed().pipe((0,
                    pn.q)(1))
                }
                cancel() {
                    this._matDialogRef.close(void 0)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.ViewChild)("stepper"), (0,
            c.w6)("design:type", "function" == typeof (P_ = void 0 !== Ti.Vq && Ti.Vq) ? P_ : Object)], V_.prototype, "stepper", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("informationStep"), (0,
            c.w6)("design:type", "function" == typeof (k_ = void 0 !== Ti.C0 && Ti.C0) ? k_ : Object)], V_.prototype, "informationStep", void 0),
            V_ = R_ = (0,
            c.gn)([(0,
            i.Component)({
                selector: "add-edit-subscription-dialog",
                template: n(52592),
                animations: [(0,
                Jo.X$)("openClose", [(0,
                Jo.eR)(":enter", [(0,
                Jo.oB)({
                    height: 0
                }), (0,
                Jo.jt)("0.2s ease-out", (0,
                Jo.oB)({
                    height: "*"
                }))]), (0,
                Jo.eR)(":leave", [(0,
                Jo.oB)({
                    height: "*"
                }), (0,
                Jo.jt)("0.2s ease-in", (0,
                Jo.oB)({
                    height: 0
                }))])])]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(j_.TU)), (0,
            c.fM)(1, (0,
            i.Inject)(tt)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(3, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(4, (0,
            i.Inject)(pt)), (0,
            c.fM)(5, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (M_ = void 0 !== j_.TU && j_.TU) ? M_ : Object, "function" == typeof (L_ = tt) ? L_ : Object, Object, "function" == typeof (N_ = void 0 !== hn.so && hn.so) ? N_ : Object, "function" == typeof (F_ = pt) ? F_ : Object, "function" == typeof (U_ = void 0 !== Cr && Cr) ? U_ : Object])], V_);
            let G_ = class {
                constructor() {
                    this.icon = "",
                    this.label = ""
                }
                ngOnChanges() {
                    this.category && (this.icon = cd[this.category.id],
                    this.label = w.isOrchid ? this.category.translatedName : this.category.name)
                }
            }
            ;
            function B_(e) {
                if (e) {
                    let t = "";
                    const n = e.split("/");
                    return n.forEach(( (e, i) => {
                        t += e.split(":").pop(),
                        i !== n.length - 1 && (t += "/")
                    }
                    )),
                    t
                }
                return e
            }
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], G_.prototype, "category", void 0),
            G_ = (0,
            c.gn)([(0,
            i.Component)({
                selector: "orchid-event-category",
                template: n(17943)
            })], G_);
            let z_ = class {
                transform(e) {
                    return B_(e)
                }
            }
            ;
            var H_, W_, q_, Y_, X_, K_, Z_, J_, Q_, ex;
            z_ = (0,
            c.gn)([(0,
            i.Pipe)({
                name: "onvifTopic"
            })], z_);
            const tx = O("onvifBulkRegistrationComponent");
            var nx;
            !function(e) {
                e.CAMERAS = "cameras",
                e.CATEGORY = "category",
                e.DELETE = "delete",
                e.NAME = "name",
                e.TOPIC = "topic",
                e.TYPE = "type"
            }(nx || (nx = {}));
            const ix = Object.assign(Object.assign({}, ls), {
                CATEGORY: "category"
            });
            let ax = class {
                constructor(e, t, n, i, a, r, s, o) {
                    this._authService = e,
                    this._managedRecordersService = t,
                    this._matDialog = n,
                    this._versionService = i,
                    this._orchidDataService = a,
                    this._renewableService = r,
                    this._resourceTaggingService = s,
                    this._sessionIdService = o,
                    this.msgs = {},
                    this.loadingOrchidsPromise = uh.Loading,
                    this.loadingSubscriptionData = uh.Loading,
                    this.eventLoading = !1,
                    this.separatorKeyCodes = [ia.K5, ia.OC],
                    this.searchTerms = [],
                    this.events = [],
                    this.eventTags = [],
                    this.eventCategoryIndex = {},
                    this.cameraOnvifTopicMappings = [],
                    this.activeFilters = [],
                    this.initialTypeFiltersData = [],
                    this.eventTypeFilters = [],
                    this.eventCategoryFilters = [],
                    this.eventTagFilters = [],
                    this.EventCategoryComponent = G_,
                    this.MIN_TAG_LIST_LENGTH = 2,
                    this.searchField = new p.NI({
                        value: "",
                        disabled: !0
                    }),
                    this.displayedColumns = [nx.NAME, nx.CATEGORY, nx.TYPE, nx.CAMERAS, nx.TOPIC, nx.DELETE],
                    this.tableData = new Ei.by,
                    this.pageSizeOptions = [10, 20, 50],
                    this.pageSize = 20,
                    this.currentSort = {
                        active: nx.NAME,
                        direction: "asc"
                    },
                    this.defaultSort = {
                        id: nx.NAME,
                        start: "asc",
                        disableClear: !0
                    },
                    this.minimumVersionFeature = Sr.EVENT_SUBSCRIPTIONS,
                    this.orchid = null,
                    this.orchids = [],
                    this.eventCategories = [],
                    this.orchidSelected = !1,
                    this.isAdmin = this._authService.getAuthenticationData().isAdministrator(),
                    this.isRecorderAdmin = this._authService.getAuthenticationData().isRecorderAdministrator(),
                    this.canManageAllRecorders = this._authService.getAuthenticationData().canManageAllRecorders(),
                    this._unsubscribe$ = new St.x,
                    this._finishInit = e => {
                        this.orchids = e,
                        this.isOrchid ? (this.orchidSelected = !0,
                        this.orchid = e[0],
                        this.fetchOrchidSubscriptionData(this.orchids[0])) : (this.searchField.disable(),
                        this.loadingSubscriptionData = uh.Loaded),
                        this.loadingOrchidsPromise = uh.Loaded
                    }
                }
                get categoryIcons() {
                    return cd
                }
                get ComponentState() {
                    return uh
                }
                get isOrchid() {
                    return w.isOrchid
                }
                set matPaginator(e) {
                    e && this.tableData && (this.tableData.paginator = e)
                }
                get TableColumns() {
                    return nx
                }
                addEvent() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        (0,
                        dt.z)(V_.show(this._matDialog, {
                            eventCategories: this.eventCategories,
                            onvifTopicCameraMap: this.cameraOnvifTopicMappings,
                            subscription: void 0,
                            orchid: this.orchid,
                            existingTags: this.eventTags
                        })).then((e => {
                            e && (this.events.push(e),
                            this.getAllTags(),
                            this.eventCategoryFilters = this.getCategoryFilters(),
                            this._resetPaginator())
                        }
                        )),
                        this.eventLoading = !1
                    }
                    ))
                }
                editSubscription(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.eventLoading || (this.eventLoading = !0,
                        (0,
                        dt.z)(V_.show(this._matDialog, {
                            eventCategories: this.eventCategories,
                            onvifTopicCameraMap: this.cameraOnvifTopicMappings,
                            subscription: e,
                            orchid: this.orchid,
                            existingTags: this.eventTags
                        })).then((t => {
                            if (t) {
                                const n = this.events.findIndex((t => t.id === e.id));
                                this.events[n] = t,
                                this.eventCategoryFilters = this.getCategoryFilters(),
                                this.getAllTags().then(( () => {
                                    this._cleanUpActiveFilters()
                                }
                                )),
                                this._resetPaginator()
                            }
                        }
                        )),
                        this.eventLoading = !1)
                    }
                    ))
                }
                deleteSubscription(e, t) {
                    t.stopPropagation();
                    const n = {
                        panelClass: "external-events-manager-custom-delete-confirmation-dialog-panel-class",
                        data: {
                            cancelText: this.msgs.cancel(),
                            confirmText: this.msgs.delete(),
                            message: this.msgs.deleteSubscriptionVALUE({
                                VALUE: e.name
                            }),
                            confirmCallbackAsync: () => (0,
                            c.mG)(this, void 0, void 0, (function*() {
                                yield this._orchidDataService.deleteEventSubscription(this.orchid, e.id)
                            }
                            ))
                        }
                    };
                    (0,
                    dt.z)(qs.show(this._matDialog, n)).then((t => {
                        t && (this.events = this.events.filter((t => t.id !== e.id)),
                        this.tableData.data = this.events,
                        this.eventCategoryFilters = this.getCategoryFilters(),
                        this.getAllTags().then(( () => {
                            this._cleanUpActiveFilters()
                        }
                        )),
                        this._resetPaginator())
                    }
                    ))
                }
                onSortChange(e) {
                    this.events = this._sortEvents(this.events, e),
                    this.currentSort = e,
                    this._applyFilterAndSort()
                }
                onOrchidSelected(e) {
                    this.removeAllFilters(),
                    this.fetchOrchidSubscriptionData(e)
                }
                fetchOrchidSubscriptionData(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (this.loadingSubscriptionData = uh.Loading,
                        this.orchid = e,
                        null === e)
                            this.orchidSelected = !1,
                            this.searchField.disable(),
                            this.tableData.data = [],
                            this.loadingSubscriptionData = uh.Loaded;
                        else {
                            const t = () => {
                                this.orchidSelected = !0,
                                this.searchField.enable();
                                const t = this._orchidDataService.fetchEventSubscriptions(e)
                                  , n = this._orchidDataService.fetchOnvifCameraTopics(e)
                                  , i = this._orchidDataService.fetchEventCategories(e);
                                Promise.all([t, n, i]).then((e => (0,
                                c.mG)(this, void 0, void 0, (function*() {
                                    const t = e[0]
                                      , n = e[1]
                                      , i = e[2];
                                    this.getAllTags(),
                                    this.eventCategories = ld(i),
                                    this.events = t.sort(( (e, t) => e.name.localeCompare(t.name, void 0, {
                                        numeric: !0
                                    }))),
                                    this.cameraOnvifTopicMappings = n,
                                    this.cameraOnvifTopicMappings.forEach((e => {
                                        e.onvifTopics.sort(( (e, t) => B_(e).localeCompare(B_(t), void 0, {
                                            numeric: !0
                                        })))
                                    }
                                    )),
                                    this.tableData.data = this.events,
                                    this.eventCategoryIndex = this._generateEventCategoryIndex(),
                                    this.eventCategoryFilters = this.getCategoryFilters(),
                                    this.activeFilters.length > 0 && this.filterEventTable(),
                                    this.loadingSubscriptionData = uh.Loaded
                                }
                                )))).catch((e => {
                                    tx.error(e),
                                    this.loadingSubscriptionData = uh.Failed
                                }
                                ))
                            }
                            ;
                            if (this.isOrchid || this._sessionIdService.hasSessionId(e.id))
                                t();
                            else
                                try {
                                    yield(0,
                                    dt.z)(this._sessionIdService.getSessionId$(e.id)),
                                    t()
                                } catch (e) {
                                    tx.error(e),
                                    this.loadingSubscriptionData = uh.Failed
                                }
                        }
                    }
                    ))
                }
                _sortEvents(e, t) {
                    return e.sort(( (e, n) => {
                        const i = "asc" === t.direction;
                        switch (t.active) {
                        case nx.NAME:
                            return e.name.localeCompare(n.name, void 0, {
                                numeric: !0
                            }) * (i ? 1 : -1);
                        case nx.CATEGORY:
                            return this.eventCategoryIndex[e.categoryId].name.localeCompare(this.eventCategoryIndex[n.categoryId].name, void 0, {
                                numeric: !0
                            }) * (i ? 1 : -1);
                        case nx.TYPE:
                            return e.type.localeCompare(n.type) * (i ? 1 : -1);
                        case nx.CAMERAS:
                            return (e.associatedCameraIds.length < n.associatedCameraIds.length ? -1 : 1) * (i ? 1 : -1);
                        case nx.TOPIC:
                            return null === e.onvifTopic ? -1 * (i ? 1 : -1) : null === n.onvifTopic ? 1 * (i ? 1 : -1) : B_(e.onvifTopic).localeCompare(B_(n.onvifTopic), void 0, {
                                numeric: !0
                            }) * (i ? 1 : -1);
                        default:
                            return e.name.localeCompare(n.name, void 0, {
                                numeric: !0
                            }) * (i ? 1 : -1)
                        }
                    }
                    )),
                    e
                }
                _applyFilterAndSort() {
                    this.tableData.data = this._sortEvents(this.events, this.currentSort)
                }
                _generateEventCategoryIndex() {
                    const e = {};
                    return this.eventCategories.forEach((t => {
                        const n = cd[t.id];
                        e[t.id] = {
                            name: t.name,
                            translatedName: t.translatedName,
                            icon: void 0 === n ? "fa-question-circle" : n
                        }
                    }
                    )),
                    e
                }
                getCategoryFilters() {
                    const e = []
                      , t = new Set(this.events.map((e => e.categoryId)));
                    return this.eventCategories.length > 0 && t.forEach((t => {
                        const n = this.eventCategories.find((e => e.id === t));
                        if (n) {
                            const t = this.activeFilters.some((e => e.type === ix.CATEGORY && e.data.label === n.name));
                            e.push({
                                type: ix.CATEGORY,
                                typeLabel: this.msgs.category(),
                                data: {
                                    label: w.isOrchid ? n.translatedName : n.name
                                },
                                value: t,
                                id: n.id
                            })
                        }
                    }
                    )),
                    e.sort(( (e, t) => e.data.label.localeCompare(t.data.label, void 0, {
                        numeric: !0
                    })))
                }
                getAllTags() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        let e = {
                            tags: []
                        }
                          , t = [];
                        this.orchid && (w.isOrchid || this._versionService.isFeatureSupported(this.orchid, Sr.RESOURCE_TAGGING)) && (e = yield(0,
                        dt.z)(this._resourceTaggingService.fetchSubscriptionTags({
                            id: this.orchid.id,
                            uri: this.orchid.uri
                        })).catch(( () => ({
                            tags: []
                        }))),
                        t = e.tags.sort(( (e, t) => e.key.localeCompare(t.key, void 0, {
                            numeric: !0
                        })))),
                        this.eventTags = t,
                        this.eventTagFilters = ms(this.activeFilters, this.eventTags)
                    }
                    ))
                }
                _cleanUpActiveFilters() {
                    this.activeFilters = this.activeFilters.filter((e => this._isAValidActiveTagFilter(e) || this._isAValidActiveCategoryFilter(e) || e.type !== ix.RESOURCE_TAG && e.type !== ix.CATEGORY)),
                    this.filterEventTable()
                }
                _isAValidActiveTagFilter(e) {
                    return e.type === ix.RESOURCE_TAG && this.eventTagFilters.some((t => e.data.label === t.data.label && e.data.value === t.data.value))
                }
                _isAValidActiveCategoryFilter(e) {
                    return e.type === ix.CATEGORY && this.eventCategoryFilters.some((t => e.data.label === t.data.label))
                }
                _resetPaginator() {
                    this._applyFilterAndSort()
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.events.eventsSubscriptions), L.messages.events.orchidSelector), L.messages.common),
                    this.initialTypeFiltersData = [{
                        type: ix.EVENT_TYPE,
                        typeLabel: this.msgs.type(),
                        data: {
                            label: this.msgs.onvif()
                        },
                        id: tm.ONVIF,
                        value: !1
                    }, {
                        type: ix.EVENT_TYPE,
                        typeLabel: this.msgs.type(),
                        data: {
                            label: this.msgs.external()
                        },
                        id: tm.EXTERNAL,
                        value: !1
                    }],
                    this.eventTypeFilters = [...this.initialTypeFiltersData],
                    this.loadingOrchidsPromise = uh.Loading,
                    this.orchidSelected = !1,
                    this._renewableService.orchidsPromise().then((e => {
                        this.isRecorderAdmin && !this.canManageAllRecorders ? this._parseManagedRecorders$(e) : this._finishInit(e)
                    }
                    )).catch(( () => {
                        this.loadingOrchidsPromise = uh.Failed
                    }
                    ))
                }
                _parseManagedRecorders$(e) {
                    const t = e.map((e => e.id));
                    this._managedRecordersService.isManaged(t).subscribe({
                        next: t => {
                            const n = e.filter(( (e, n) => t[n]));
                            this._finishInit(n)
                        }
                        ,
                        error: e => {
                            tx.error(e),
                            this._finishInit([])
                        }
                    })
                }
                ngOnDestroy() {
                    this._unsubscribe$.next(!0),
                    this._unsubscribe$.complete()
                }
                checkServers() {
                    return !!this.isOrchid || !this.isOrchid && this.orchids.length > 0
                }
                hasSubscriptions() {
                    return this.loadingSubscriptionData !== uh.Failed && this.events.length > 0
                }
                removeFilter(e) {
                    const t = this.activeFilters[e];
                    if (this.activeFilters.splice(e, 1),
                    t) {
                        if (t.type === ix.EVENT_TYPE) {
                            const e = this.eventTypeFilters;
                            for (let n = 0; n < this.eventTypeFilters.length; n++)
                                t.id === this.eventTypeFilters[n].id && (e[n].value = t.value);
                            this.eventTypeFilters = [...e]
                        }
                        if (t.type === ix.CATEGORY) {
                            const e = this.eventCategoryFilters;
                            for (let n = 0; n < this.eventCategoryFilters.length; n++)
                                t.id === this.eventCategoryFilters[n].id && (e[n].value = t.value);
                            this.eventCategoryFilters = [...e]
                        }
                        if (t.type === ix.RESOURCE_TAG) {
                            const e = this.eventTagFilters;
                            for (let n = 0; n < this.eventTagFilters.length; n++)
                                t.data.label === this.eventTagFilters[n].data.label && (t.data.value || null) === (this.eventTagFilters[n].data.value || null) && (e[n].value = t.value);
                            this.eventTagFilters = [...e]
                        }
                    }
                    this.activeFilters.length > 0 ? this.filterEventTable() : (this.tableData.data = this.events,
                    this._resetPaginator())
                }
                removeAllFilters() {
                    this.tableData.data = this.events,
                    this._resetPaginator(),
                    this.activeFilters = [],
                    this.eventTypeFilters = [...this.initialTypeFiltersData],
                    this.eventCategoryFilters = this.getCategoryFilters(),
                    this.eventTagFilters = ms(this.activeFilters, this.eventTags)
                }
                filterEventTable() {
                    const e = this.activeFilters.filter((e => e.type === ix.SEARCH))
                      , t = this.activeFilters.filter((e => e.type === ix.EVENT_TYPE))
                      , n = this.activeFilters.filter((e => e.type === ix.CATEGORY))
                      , i = this.activeFilters.filter((e => e.type === ix.RESOURCE_TAG));
                    function a(t) {
                        var n;
                        if (0 === e.length)
                            return !0;
                        const i = t.name.toLowerCase();
                        for (let a = 0; a < e.length; a++) {
                            const r = e[a].data.label.toLowerCase()
                              , s = i.includes(r)
                              , o = null === (n = t.onvifTopic) || void 0 === n ? void 0 : n.toLowerCase().includes(r);
                            if (s || o)
                                return !0
                        }
                        return !1
                    }
                    function r(e) {
                        if (0 === t.length)
                            return !0;
                        for (let n = 0; n < t.length; n++) {
                            const i = e.type;
                            if (t[n].id === i)
                                return !0
                        }
                        return !1
                    }
                    function s(e) {
                        if (0 === n.length)
                            return !0;
                        for (let t = 0; t < n.length; t++) {
                            const i = e.categoryId;
                            if (n[t].id === i)
                                return !0
                        }
                        return !1
                    }
                    const o = this.events.filter((e => {
                        const t = e.tags;
                        return t ? a(e) && r(e) && s(e) && us(t, i) : a(e) && r(e) && s(e)
                    }
                    ));
                    this.tableData.data = o
                }
                handleSearchKeyUp(e) {
                    "Enter" !== e.key && 13 !== e.keyCode || this._handleSearchSubmit(e.target)
                }
                _handleSearchSubmit(e) {
                    const t = e.value;
                    e.blur(),
                    e.value = "",
                    this.activeFilters.push({
                        type: ix.SEARCH,
                        data: {
                            label: t
                        },
                        value: !0,
                        id: t
                    }),
                    this.filterEventTable()
                }
                onAddFilter(e) {
                    this.activeFilters.push(e),
                    this.filterEventTable()
                }
                onRemoveFilter(e) {
                    const t = this.activeFilters.findIndex((t => t.id === e.id));
                    this.removeFilter(t)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW, {
                static: !1
            }), (0,
            c.w6)("design:type", "function" == typeof (H_ = void 0 !== pi.NW && pi.NW) ? H_ : Object), (0,
            c.w6)("design:paramtypes", ["function" == typeof (W_ = void 0 !== pi.NW && pi.NW) ? W_ : Object])], ax.prototype, "matPaginator", null),
            ax = (0,
            c.gn)([(0,
            i.Component)({
                selector: "external-events-manager",
                template: n(53071)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(xe)), (0,
            c.fM)(1, (0,
            i.Inject)(pb)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(3, (0,
            i.Inject)(Cr)), (0,
            c.fM)(4, (0,
            i.Inject)(pt)), (0,
            c.fM)(5, (0,
            i.Inject)(Gt)), (0,
            c.fM)(6, (0,
            i.Inject)(oE)), (0,
            c.fM)(7, (0,
            i.Inject)(ur)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (q_ = void 0 !== xe && xe) ? q_ : Object, "function" == typeof (Y_ = void 0 !== pb && pb) ? Y_ : Object, "function" == typeof (X_ = void 0 !== hn.uw && hn.uw) ? X_ : Object, "function" == typeof (K_ = void 0 !== Cr && Cr) ? K_ : Object, "function" == typeof (Z_ = pt) ? Z_ : Object, "function" == typeof (J_ = Gt) ? J_ : Object, "function" == typeof (Q_ = void 0 !== oE && oE) ? Q_ : Object, "function" == typeof (ex = void 0 !== ur && ur) ? ex : Object])], ax);
            let rx = class {
                constructor() {
                    this.msgs = L.messages.expired
                }
            }
            ;
            var sx, ox;
            rx = (0,
            c.gn)([(0,
            i.Component)({
                selector: "expired",
                template: n(72389)
            })], rx);
            let cx = class {
                constructor(e, t) {
                    this.authenticator = e,
                    this.router = t
                }
                canActivate() {
                    const e = this.authenticator.getAuthenticationData().isAdministrator()
                      , t = !w.isOrchid;
                    return !(!e || !t) || this.router.parseUrl("stage")
                }
            }
            ;
            var lx, dx;
            cx = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(xe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (sx = void 0 !== xe && xe) ? sx : Object, "function" == typeof (ox = void 0 !== Bt.F0 && Bt.F0) ? ox : Object])], cx);
            let ux = class {
                constructor(e, t) {
                    this._authenticator = e,
                    this._router = t
                }
                canActivate() {
                    const e = this._authenticator.getAuthenticationData()
                      , t = e.isAdministrator()
                      , n = e.isRecorderAdministrator()
                      , i = !w.isOrchid;
                    return !!(t && !i || (t || n) && i) || this._router.parseUrl("stage")
                }
            }
            ;
            var mx;
            ux = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(xe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (lx = void 0 !== xe && xe) ? lx : Object, "function" == typeof (dx = void 0 !== Bt.F0 && Bt.F0) ? dx : Object])], ux);
            let hx = class {
                constructor(e) {
                    this._brandService = e,
                    this.msgs = L.messages.incognito,
                    this.appName = this._brandService.brand.APP_LOGO_TEXT
                }
            }
            ;
            var px, gx;
            hx = (0,
            c.gn)([(0,
            i.Component)({
                selector: "incognito",
                template: n(60656)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Hm)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (mx = void 0 !== Hm && Hm) ? mx : Object])], hx);
            let fx = class {
                constructor(e, t) {
                    this.authenticator = e,
                    this.router = t
                }
                canActivate() {
                    return !!this.authenticator.getAuthenticationData().hasLibraryAccess() || this.router.parseUrl("stage")
                }
            }
            ;
            fx = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(xe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (px = void 0 !== xe && xe) ? px : Object, "function" == typeof (gx = void 0 !== Bt.F0 && Bt.F0) ? gx : Object])], fx);
            let vx = class {
                constructor() {
                    this.msgs = L.messages.notFound
                }
            }
            ;
            var yx, bx, Sx;
            vx = (0,
            c.gn)([(0,
            i.Component)({
                selector: "not-found",
                template: n(90206)
            })], vx);
            const Cx = O("PreAuthGuard");
            let wx = class {
                constructor(e, t, n) {
                    this._authenticationService = e,
                    this._fusionConfigService = t,
                    this._window = n
                }
                canActivate() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (!w.isOrchid)
                            try {
                                this._authenticationService.init(this._fusionConfigService.getConfigPreAuth().authProviders)
                            } catch (e) {
                                if (Cx.error("Failed to fetch pre-auth data", e),
                                w.isPWA) {
                                    const e = (0,
                                    i.isDevMode)() ? this._window.localStorage["dev.pwa.url"] : "https://pwa.ipconfigure.com/";
                                    return this._window.location.replace(`${e}select`),
                                    !1
                                }
                            }
                        return !0
                    }
                    ))
                }
            }
            ;
            var Ix, Tx, Ex, _x, xx, Dx, Ox;
            wx = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(xe)), (0,
            c.fM)(1, (0,
            i.Inject)(cc)), (0,
            c.fM)(2, (0,
            i.Inject)(Window)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (yx = void 0 !== xe && xe) ? yx : Object, "function" == typeof (bx = void 0 !== cc && cc) ? bx : Object, "function" == typeof (Sx = "undefined" != typeof Window && Window) ? Sx : Object])], wx);
            const Ax = O("SignInGuard");
            let Rx = class {
                constructor(e, t, n, i, a, r, s) {
                    this.$rootScope = e,
                    this.authenticator = t,
                    this.browserInfoService = n,
                    this.fusionConfigService = i,
                    this.playerModeService = a,
                    this.prerequisitesService = r,
                    this.router = s
                }
                canActivate() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        let e;
                        return e = yield this.preCheck(),
                        !0 !== e ? this.router.parseUrl(e) : (e = this.browserCheck(),
                        !0 === e || this.router.parseUrl(e))
                    }
                    ))
                }
                preCheck() {
                    var e;
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const t = null === (e = this.router.getCurrentNavigation()) || void 0 === e ? void 0 : e.extras.state;
                        if (!0 === (null == t ? void 0 : t.skipAuth))
                            return !0;
                        try {
                            return yield this.authenticator.getAuthenticationDataPromise(),
                            "stage"
                        } catch (e) {
                            return !0
                        }
                    }
                    ))
                }
                browserCheck() {
                    var e;
                    const t = this.prerequisitesService;
                    if (!1 === t.supportsLocalStorage())
                        return "incognito";
                    if (!1 === t.browserSupportsWebSockets())
                        return "unsupported-ws";
                    const n = this.browserInfoService.isIE11()
                      , i = !this.browserInfoService.isChromeWebSocketCompatible()
                      , a = null === (e = this.router.getCurrentNavigation()) || void 0 === e ? void 0 : e.extras.state;
                    if (!(null == a ? void 0 : a.isUnsupportedBrowserAllowed) && (n || i))
                        return "unsupported";
                    const r = !t.browserSupportsWebRTC(t.getBrowser())
                      , s = !this.playerModeService.warned;
                    if (r && s) {
                        this.playerModeService.warned = !0;
                        try {
                            const e = this.fusionConfigService.getConfigPreAuth().config;
                            return ie(e["player.low.bandwidth"]) ? "dinosaur" : "unsupported"
                        } catch (e) {
                            return Ax.error("Unable to determine the state of player.low.bandwidth. The app has failed to load.", e),
                            "dinosaur"
                        }
                    }
                    return !0
                }
            }
            ;
            var Px, kx;
            Rx = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)("$rootScope")), (0,
            c.fM)(1, (0,
            i.Inject)(xe)), (0,
            c.fM)(2, (0,
            i.Inject)(rt)), (0,
            c.fM)(3, (0,
            i.Inject)(cc)), (0,
            c.fM)(4, (0,
            i.Inject)(Lm)), (0,
            c.fM)(5, (0,
            i.Inject)(Ve)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Ix = "undefined" != typeof angular && angular.IRootScopeService) ? Ix : Object, "function" == typeof (Tx = void 0 !== xe && xe) ? Tx : Object, "function" == typeof (Ex = rt) ? Ex : Object, "function" == typeof (_x = void 0 !== cc && cc) ? _x : Object, "function" == typeof (xx = void 0 !== Lm && Lm) ? xx : Object, "function" == typeof (Dx = Ve) ? Dx : Object, "function" == typeof (Ox = void 0 !== Bt.F0 && Bt.F0) ? Ox : Object])], Rx);
            let Mx = class {
                constructor(e, t) {
                    this.authenticator = e,
                    this.router = t
                }
                canActivate(e, t) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        try {
                            return yield this.authenticator.getAuthenticationDataPromise(),
                            !0
                        } catch (e) {
                            return this.router.navigate(["sign-in"], {
                                queryParams: {
                                    redirectTo: t.url
                                },
                                preserveFragment: !0,
                                queryParamsHandling: "merge"
                            })
                        }
                    }
                    ))
                }
            }
            ;
            var Lx, Nx, Fx;
            Mx = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(xe)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Px = void 0 !== xe && xe) ? Px : Object, "function" == typeof (kx = void 0 !== Bt.F0 && Bt.F0) ? kx : Object])], Mx);
            let Ux = class {
                constructor(e, t, n) {
                    this.$rootScope = e,
                    this.dataService = t,
                    this.fusionConfigService = n
                }
                resolve() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        if (!1 === w.isOrchid)
                            try {
                                const e = yield this.dataService.fetchPrivate();
                                this.fusionConfigService.setPostAuthentication(e.data)
                            } catch (e) {
                                o().noop()
                            }
                        this.$rootScope.appLoaded = !0
                    }
                    ))
                }
            }
            ;
            var $x, jx;
            Ux = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)("$rootScope")), (0,
            c.fM)(1, (0,
            i.Inject)(tt)), (0,
            c.fM)(2, (0,
            i.Inject)(cc)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Lx = void 0 !== o() && o().IRootScopeService) ? Lx : Object, "function" == typeof (Nx = tt) ? Nx : Object, "function" == typeof (Fx = void 0 !== cc && cc) ? Fx : Object])], Ux);
            let Vx = class {
                constructor(e, t) {
                    this.$rootScope = e,
                    this._browserInfoService = t,
                    this.isUnsupported = !1,
                    this.isUnsupported = t.isIE11() || !t.isChromeWebSocketCompatible()
                }
                get appDestroyed() {
                    return this.$rootScope.appDestroyed
                }
            }
            ;
            var Gx;
            Vx = (0,
            c.gn)([(0,
            i.Component)({
                template: n(36673)
            }), (0,
            c.fM)(0, (0,
            i.Inject)("$rootScope")), (0,
            c.w6)("design:paramtypes", ["function" == typeof ($x = "undefined" != typeof angular && angular.IRootScopeService) ? $x : Object, "function" == typeof (jx = rt) ? jx : Object])], Vx);
            let Bx = class {
                constructor(e) {
                    this.router = e,
                    this.msgs = L.messages.dinosaur
                }
                allowUnsupportedBrowser() {
                    this.router.navigateByUrl("/sign-in", {
                        state: {
                            isUnsupportedBrowserAllowed: !0
                        }
                    })
                }
            }
            ;
            var zx;
            Bx = (0,
            c.gn)([(0,
            i.Component)({
                selector: "unsupported-browser",
                template: n(69528)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Bt.F0)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Gx = void 0 !== Bt.F0 && Bt.F0) ? Gx : Object])], Bx);
            let Hx = class {
                constructor(e, t) {
                    this.dialogRef = e,
                    this.data = t
                }
            }
            ;
            Hx = (0,
            c.gn)([(0,
            i.Component)({
                selector: "signIn-alert-dialog",
                template: n(63180)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.so)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.WI)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (zx = void 0 !== hn.so && hn.so) ? zx : Object, Object])], Hx);
            n.p;
            var Wx, qx;
            let Yx = Wx = class {
                constructor(e, t) {
                    this.data = e,
                    this.dialogRef = t
                }
                close() {
                    this.dialogRef.close(!1)
                }
                accept() {
                    this.dialogRef.close(!0)
                }
                onEsc() {
                    this.close()
                }
                static showDialog(e) {
                    return e.greeting ? e.dialog.open(Wx, {
                        panelClass: "greeting-dialog-custom-panel-class",
                        disableClose: !0,
                        data: {
                            title: e.title,
                            greeting: e.greeting,
                            msgs: e.msgs
                        }
                    }).afterClosed() : new Ln.y
                }
            }
            ;
            var Xx, Kx, Zx, Jx, Qx, eD, tD, nD, iD, aD, rD, sD, oD;
            (0,
            c.gn)([(0,
            i.HostListener)("keydown.esc"), (0,
            c.w6)("design:type", Function), (0,
            c.w6)("design:paramtypes", []), (0,
            c.w6)("design:returntype", void 0)], Yx.prototype, "onEsc", null),
            Yx = Wx = (0,
            c.gn)([(0,
            i.Component)({
                changeDetection: i.ChangeDetectionStrategy.OnPush,
                selector: "greeting",
                template: n(81649)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.so)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (qx = void 0 !== hn.so && hn.so) ? qx : Object])], Yx);
            O("sign-in");
            let cD = class {
                constructor(e, t, n, i, a, r, s, o, c, l, d, u) {
                    this._router = e,
                    this._route = t,
                    this._matDialog = n,
                    this._authService = i,
                    this._brandService = a,
                    this._fusionConfigService = r,
                    this._playerModeService = s,
                    this._dataService = o,
                    this._windowLocationService = c,
                    this.$rootScope = l,
                    this._userSettingsService = d,
                    this._appService = u,
                    this.messages = Object.assign(Object.assign({}, L.messages.signIn), {
                        singlePlayer: L.messages.singlePlayer,
                        dialogs: L.messages.dialogs
                    }),
                    this.destroy$ = new St.x,
                    this.appLogo = this._brandService.brand.APP_LOGO_TEXT,
                    this.processing = !1,
                    this.isGreetingAccepted = !1,
                    this.greeting = null,
                    this._rememberMe = !0,
                    this.signInForm = (new p.qu).group({
                        username: [""],
                        password: [""]
                    })
                }
                get isOrchid() {
                    return w.isOrchid
                }
                ngAfterViewInit() {
                    this.$rootScope.appLoaded = !0,
                    this.focusUserName()
                }
                ngOnInit() {
                    this.checkForUrlErrors(),
                    this.setupLowBandwidthMode(),
                    this.setupPWAMode(),
                    !1 === this.isOrchid && this.setupFusion(),
                    this._getAppInfo(),
                    this._userSettingsService.setTheme()
                }
                checkForUrlErrors() {
                    this._route.queryParams.subscribe((e => {
                        "401" === e.error && this._signInFailed(this.messages.singlePlayer.authenticationFailed())
                    }
                    ))
                }
                setupLowBandwidthMode() {
                    this.showLowBandwidthMode = !0;
                    const e = this._playerModeService.getAvailablePlayerModes();
                    this.lowBandwidthMode = e[0] === tn,
                    this.hasLowBandwidthOption = e.indexOf(nn) > -1
                }
                setupFusion() {
                    this.providers = [];
                    const e = this._fusionConfigService.getConfigPreAuth();
                    this.greeting = e.greeting,
                    this.providers = this._authService.getAuthenticationProviders().filter((e => "fusion" !== e.type)).map((e => {
                        let t;
                        return e.type.includes(De.FREEIPA) || e.type === De.ACTIVE_DIRECTORY ? t = void 0 : e.type.includes(De.GOOGLE_OAUTH) ? this.isPWA || (t = {
                            providerType: "Google",
                            action: () => this.authenticateOAUTH("Google")
                        }) : e.type.includes(De.AZURE) ? this.isPWA || (t = {
                            providerType: "Azure",
                            action: () => this.authenticateOAUTH("Azure")
                        }) : t = {
                            providerType: e.configuration.commonName,
                            action: () => this.authenticateSaml(e.configuration.clientName)
                        },
                        t
                    }
                    )).filter((e => void 0 !== e)),
                    this.providerSignIn = this.providers.length > 0,
                    this.showLowBandwidthMode = this._playerModeService.isLbmAvailable(),
                    !1 === this.showLowBandwidthMode && this._playerModeService.clearDefaultPlayerMode()
                }
                setupPWAMode() {
                    this.isPWA = w.isPWA,
                    this.isPWA && (this.urlRedirectPWA = (0,
                    i.isDevMode)() ? window.localStorage["dev.pwa.url"] : "https://pwa.ipconfigure.com/")
                }
                showGreeting(e) {
                    ne(this.greeting) || (e.event && (e.event.preventDefault(),
                    e.event.stopPropagation()),
                    Yx.showDialog({
                        dialog: this._matDialog,
                        title: this.messages.accessAgreement().slice(0, -1),
                        greeting: this.greeting,
                        msgs: [L.messages.dialogs.greetingDialog.dismiss(), L.messages.dialogs.greetingDialog.accept()]
                    }).pipe((0,
                    oa.R)(this.destroy$)).subscribe((t => {
                        t ? (this.isGreetingAccepted = !0,
                        e.provider ? e.provider.action({}) : e.signInWithPassword && this.authenticateForm()) : this.processing = !1
                    }
                    )))
                }
                toggleAcceptGreeting() {
                    this.isGreetingAccepted = !this.isGreetingAccepted
                }
                toggleCompatibilityMode() {
                    this.lowBandwidthMode = !this.lowBandwidthMode,
                    this.lowBandwidthMode ? this._playerModeService.setDefaultPlayerMode(tn) : this._playerModeService.clearDefaultPlayerMode()
                }
                isFormValid() {
                    return "" !== this.signInForm.controls.username.value && "" !== this.signInForm.controls.password.value
                }
                signInWithPassword() {
                    this.greeting && this.isFormValid() ? this.isGreetingAccepted ? this.authenticateForm() : this.showGreeting({
                        signInWithPassword: !0
                    }) : this.authenticateForm()
                }
                signInWithExternalLogin(e) {
                    this.greeting ? this.isGreetingAccepted ? e.provider.action({}) : this.showGreeting({
                        provider: e.provider
                    }) : e.provider.action({})
                }
                authenticateOAUTH(e) {
                    this.processing = !0;
                    const t = {
                        cookie: this._rememberMe ? we : Ie,
                        expiresIn: Ee
                    }
                      , n = new ye(me,{
                        provider: e.toLowerCase(),
                        data: t
                    })
                      , i = this._authService.authenticate(n);
                    this.handleSignIn(i)
                }
                authenticateForm() {
                    this.processing = !0;
                    const e = new ye(he,{
                        username: this.signInForm.controls.username.value,
                        password: this.signInForm.controls.password.value,
                        rememberMe: this._rememberMe || this.isPWA
                    })
                      , t = this._authService.authenticate(e);
                    this.handleSignIn(t)
                }
                authenticateSaml(e) {
                    let t;
                    t = w.isPWA ? `${window.localStorage["api.url"]}/service/sessions/login/saml/generic?force_client=${e}&redirect=https://pwa.ipconfigure.com/assets/ui/${this.version}/${this.brand}/index.html#!/stage` : `${window.location.protocol}//${window.location.hostname}${window.location.port ? ":" + window.location.port : ""}/service/sessions/login/saml/generic?force_client=${e}`,
                    this._windowLocationService.href = t
                }
                handleSignIn(e) {
                    e.then(( () => {
                        this._redirectToStage()
                    }
                    )).catch((e => {
                        let t = this.messages.unexpectedError();
                        if (re(e) || -1 === e.status)
                            t = this.messages.offlineError();
                        else if (o().isDefined(e.reason))
                            switch (e.reason) {
                            case Te:
                                t = "";
                                break;
                            case "popup_blocked_by_browser":
                                t = this.messages.googleSignInUnsupported();
                                break;
                            default:
                                t = e.reason
                            }
                        else
                            o().isDefined(e.data) && o().isDefined(e.data.reason) && (t = e.data.reason);
                        "" !== t && this._signInFailed(t),
                        this.processing = !1
                    }
                    ))
                }
                _redirectToStage() {
                    const e = xn(window.location);
                    e && e.redirectTo ? this._router.navigateByUrl(e.redirectTo) : this._router.navigateByUrl("/stage")
                }
                _getAppInfo() {
                    this._appService.version$.pipe((0,
                    oa.R)(this.destroy$)).subscribe((e => this.version = e)),
                    this._appService.brand$.pipe((0,
                    oa.R)(this.destroy$)).subscribe((e => this.brand = e)),
                    this.license$ = this._appService.license$
                }
                _signInFailed(e) {
                    setTimeout(( () => {
                        this._matDialog.open(Hx, {
                            disableClose: !0,
                            data: {
                                title: this.messages.failDialogTitle(),
                                message: e,
                                ok: this.messages.okay()
                            }
                        }).afterClosed().subscribe((e => {
                            e && (this._router.navigateByUrl("/sign-in"),
                            this.focusUserName())
                        }
                        ))
                    }
                    ))
                }
                ngOnDestroy() {
                    this.destroy$.next(),
                    this.destroy$.complete()
                }
                focusUserName() {
                    this._userInput && this._userInput.nativeElement.focus()
                }
            }
            ;
            var lD, dD, uD;
            (0,
            c.gn)([(0,
            i.ViewChild)("userInput"), (0,
            c.w6)("design:type", "function" == typeof (Xx = void 0 !== i.ElementRef && i.ElementRef) ? Xx : Object)], cD.prototype, "_userInput", void 0),
            cD = (0,
            c.gn)([(0,
            i.Component)({
                selector: "sign-in",
                template: n(51850)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Bt.F0)), (0,
            c.fM)(1, (0,
            i.Inject)(Bt.gz)), (0,
            c.fM)(2, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(3, (0,
            i.Inject)(xe)), (0,
            c.fM)(4, (0,
            i.Inject)(Hm)), (0,
            c.fM)(5, (0,
            i.Inject)(cc)), (0,
            c.fM)(6, (0,
            i.Inject)(Lm)), (0,
            c.fM)(7, (0,
            i.Inject)(tt)), (0,
            c.fM)(8, (0,
            i.Inject)(sm)), (0,
            c.fM)(9, (0,
            i.Inject)("$rootScope")), (0,
            c.fM)(10, (0,
            i.Inject)(Qt)), (0,
            c.fM)(11, (0,
            i.Inject)(tf)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (Kx = void 0 !== Bt.F0 && Bt.F0) ? Kx : Object, "function" == typeof (Zx = void 0 !== Bt.gz && Bt.gz) ? Zx : Object, "function" == typeof (Jx = void 0 !== hn.uw && hn.uw) ? Jx : Object, "function" == typeof (Qx = void 0 !== xe && xe) ? Qx : Object, "function" == typeof (eD = void 0 !== Hm && Hm) ? eD : Object, "function" == typeof (tD = void 0 !== cc && cc) ? tD : Object, "function" == typeof (nD = void 0 !== Lm && Lm) ? nD : Object, "function" == typeof (iD = tt) ? iD : Object, "function" == typeof (aD = void 0 !== sm && sm) ? aD : Object, "function" == typeof (rD = "undefined" != typeof ng && ng.IRootScopeService) ? rD : Object, "function" == typeof (sD = Qt) ? sD : Object, "function" == typeof (oD = void 0 !== tf && tf) ? oD : Object])], cD),
            function(e) {
                e.ADD = "add",
                e.REMOVE = "remove"
            }(uD || (uD = {}));
            let mD = class {
                constructor() {
                    this.icons = Object.assign(Object.assign({}, Ht), zt),
                    this.operationType = uD.ADD,
                    this.orchids = [],
                    this.onTagClick = new i.EventEmitter,
                    this.RecorderTagOperationStatus = gs,
                    this.TagOperationType = uD,
                    this.InformationIcons = zt,
                    this.paginatedOrchids = [],
                    this.pageSizeOptions = [10, 25, 50],
                    this.pageSize = 10,
                    this.pageIndex = 0,
                    this.isPaginationVisible = !0,
                    this._destroy$ = new St.x,
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.resourceTagging), L.messages.common), L.messages.events.orchidSelector)
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                ngOnChanges(e) {
                    e.orchids && (this.isPaginationVisible = this.orchids.length > this.pageSize,
                    this.paginatedOrchids = Mc(this.orchids, this.pageSize, this.pageIndex))
                }
                onPaginatorChange(e) {
                    this.paginatedOrchids = Mc(this.orchids, e.pageSize, e.pageIndex)
                }
                handleTagClick(e) {
                    this.onTagClick.emit(e)
                }
            }
            ;
            var hD, pD, gD, fD, vD, yD;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], mD.prototype, "operationType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], mD.prototype, "orchids", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], mD.prototype, "requiredOrchidVersion", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (lD = void 0 !== i.EventEmitter && i.EventEmitter) ? lD : Object)], mD.prototype, "onTagClick", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW), (0,
            c.w6)("design:type", "function" == typeof (dD = void 0 !== pi.NW && pi.NW) ? dD : Object)], mD.prototype, "paginator", void 0),
            mD = (0,
            c.gn)([(0,
            i.Component)({
                selector: "affected-recorders",
                template: n(69634)
            })], mD),
            function(e) {
                e.ADD = "add",
                e.EDIT = "edit"
            }(yD || (yD = {}));
            let bD = hD = class {
                constructor(e, t, n, i) {
                    this.dialogData = e,
                    this._resourceTaggingService = t,
                    this._renewableService = n,
                    this._minimumVersionService = i,
                    this.showInfoPanel = !1,
                    this.infoPanelTitle = "",
                    this.infoPanelBodyText = "",
                    this.icons = Object.assign(Object.assign({}, Ht), zt),
                    this.TagResourceType = ps,
                    this.allResourceTags = [],
                    this.tagConfigs = [],
                    this.isDirty = !1,
                    this.orchids = [],
                    this.resources = [],
                    this.initialSelectedRecorders = [],
                    this.selectedRecorders = [],
                    this.selectedCameras = [],
                    this.initialSelectedCameras = [],
                    this.componentState = xr.LOADING,
                    this.ComponentState = xr,
                    this.BulkTagDialogType = yD,
                    this.log = O("BulkDeleteRecorderTagDialog"),
                    this.ERROR_TYPE = wr,
                    this.bulkDeleteErrorMessage = "",
                    this.tagDetailsErrorMessage = "",
                    this.currentStepperStep = 0,
                    this.tagOperationAttempted = !1,
                    this.showCancelButton = !0,
                    this.recordersToAdd = [],
                    this.recordersToRemove = [],
                    this._failedToAddRecorders = [],
                    this._failedToRemoveRecorders = [],
                    this.camerasToAdd = [],
                    this.camerasToRemove = [],
                    this._failedToAddCameras = [],
                    this._failedToRemoveCameras = [],
                    this.camerasToAddCount = 0,
                    this.camerasToRemoveCount = 0,
                    this.operationInProgress$ = this._resourceTaggingService.bulkOperationInProgress$,
                    this.VersionSpecificFeature = Sr,
                    this.processing = !1,
                    this.showCloseButton = !1,
                    this._destroy$ = new St.x,
                    this.msgs = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, L.messages.resourceTagging), L.messages.common), L.messages.dialogs), L.messages.errorBanner), {
                        tryAgain: L.messages.errors.tryAgain
                    }),
                    this.resourceType = this.dialogData.resourceType,
                    this.orchids = this.dialogData.orchids,
                    this.allResourceTags = this.dialogData.allTags,
                    this.tagConfigs = this.dialogData.tag ? [this.dialogData.tag] : [];
                    let a = !1
                      , r = [];
                    this.resourceType === ps.CAMERA ? (a = this.initialSelectedCameras.length > 0,
                    r = this.initialSelectedCameras) : (a = this.initialSelectedRecorders.length > 0,
                    r = this.initialSelectedRecorders);
                    const s = new p.qu;
                    this.resourceTagForm = s.group({
                        tags: [[]],
                        selectedResources: [r, a ? [p.kI.required] : []]
                    })
                }
                get oneOrMoreRecordersFailed() {
                    return this._failedToAddRecorders.length > 0 || this._failedToRemoveRecorders.length > 0
                }
                get oneOrMoreCamerasFailed() {
                    return this._failedToAddCameras.length > 0 || this._failedToRemoveCameras.length > 0
                }
                get dialogTitle() {
                    switch (this.dialogData.resourceType) {
                    case ps.SERVER:
                        return this.dialogData.dialogType === yD.EDIT ? this.msgs.editServerTag() : this.msgs.addServerTag();
                    case ps.CAMERA:
                        return this.dialogData.dialogType === yD.EDIT ? this.msgs.editCameraTag() : this.msgs.addCameraTag();
                    default:
                        return ""
                    }
                }
                get dialogResourceTitle() {
                    switch (this.dialogData.resourceType) {
                    case ps.SERVER:
                        return this.msgs.servers();
                    case ps.CAMERA:
                        return this.msgs.cameras();
                    default:
                        return ""
                    }
                }
                get dialogResourceSubtitle() {
                    switch (this.dialogData.resourceType) {
                    case ps.SERVER:
                        return this.msgs.newUpdateWillBeAppliedToServers();
                    case ps.CAMERA:
                        return this.msgs.newUpdateWillBeAppliedToCameras();
                    default:
                        return ""
                    }
                }
                get dialogResourceIcon() {
                    switch (this.dialogData.resourceType) {
                    case ps.SERVER:
                        return this.icons.servers.server;
                    case ps.CAMERA:
                        return this.icons.camera;
                    default:
                        return ""
                    }
                }
                get dialogResourceHelperText() {
                    switch (this.dialogData.resourceType) {
                    case ps.SERVER:
                        return this.msgs.selectServers();
                    case ps.CAMERA:
                        return this.msgs.selectCameras();
                    default:
                        return ""
                    }
                }
                get existingTagBannerMessage() {
                    const e = this.resourceType === ps.SERVER ? this.msgs.servers().toLowerCase() : this.msgs.cameras().toLowerCase();
                    return this.msgs.theTagYouSelectedAlreadyExisted({
                        RESOURCES: e
                    })
                }
                get canEditTag() {
                    return this.dialogData.dialogType === yD.ADD && this.componentState === xr.LOADED
                }
                get formIsInvalid() {
                    const e = this.resourceTagForm.controls.tags.value[0]
                      , t = this.resourceTagForm.controls.selectedResources;
                    return !!e && (e.invalid || t.invalid)
                }
                get isExistingTagSelected() {
                    const e = this.resourceTagForm.controls.tags.value[0];
                    return !!e && (e.controls.selected.value && !e.controls.isNewTag.value)
                }
                ngOnInit() {
                    this.dialogData.tag ? this.resourceType === ps.SERVER ? this._resourceTaggingService.fetchRecorderTagDetails(this.dialogData.tag).pipe((0,
                    pn.q)(1), (0,
                    oa.R)(this._destroy$)).subscribe({
                        next: e => {
                            const t = [];
                            e.recorders.forEach((e => {
                                const n = this._renewableService.findOrchid(e);
                                t.push(n)
                            }
                            )),
                            this.initialSelectedRecorders = [...t],
                            this.selectedRecorders = [...t],
                            this.componentState = xr.LOADED
                        }
                        ,
                        error: e => {
                            this._handleRecorderTagDetailsError(e)
                        }
                    }) : this.resourceType === ps.CAMERA && this._resourceTaggingService.fetchCameraTagDetails(this.dialogData.tag).pipe((0,
                    pn.q)(1), (0,
                    oa.R)(this._destroy$)).subscribe({
                        next: e => {
                            const t = [];
                            e.forEach((e => {
                                t.push({
                                    id: e.cameraId,
                                    orchidId: e.orchidId
                                })
                            }
                            )),
                            this.initialSelectedCameras = [...t],
                            this.selectedCameras = [...t],
                            this.componentState = xr.LOADED
                        }
                        ,
                        error: e => {
                            this._handleRecorderTagDetailsError(e)
                        }
                    }) : this.componentState = xr.LOADED
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                handleSave() {
                    switch (this.tagOperationAttempted = !0,
                    this.showCancelButton = !0,
                    this.resourceType) {
                    case ps.SERVER:
                        this.saveRecorderTags();
                        break;
                    case ps.CAMERA:
                        this.saveCameraTags()
                    }
                }
                saveRecorderTags() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.processing = !0;
                        const e = this.recordersToAdd.length > 0
                          , t = this.recordersToRemove.length > 0
                          , n = this._getRecorderIdsToAdd(e)
                          , i = this._getRecorderIdsToRemove(t);
                        let a = [];
                        (e ? this._resourceTaggingService.bulkAddRecorderTags(this.tagConfigs, n) : (0,
                        ze.of)([])).pipe((0,
                        Tr.b)((e => (a = e,
                        t ? this._resourceTaggingService.bulkDeleteRecorderTags(this.tagConfigs, i) : (0,
                        ze.of)([]))))).subscribe({
                            next: n => {
                                e && this.handleRecorderTagsResult(uD.ADD, a),
                                t && this.handleRecorderTagsResult(uD.REMOVE, n),
                                0 === this._failedToAddRecorders.length && 0 === this._failedToRemoveRecorders.length && (this.showCloseButton = !0,
                                this.showCancelButton = !1),
                                this.processing = !1
                            }
                        })
                    }
                    ))
                }
                _getRecorderIdsToAdd(e) {
                    const t = [];
                    return e && (this.oneOrMoreRecordersFailed ? this._failedToAddRecorders.forEach((e => {
                        t.push(e.uuid)
                    }
                    )) : this.recordersToAdd.forEach((e => {
                        t.push(e.uuid)
                    }
                    )),
                    this.recordersToAdd.forEach((e => {
                        e.status !== gs.SUCCESS && (e.status = gs.IN_PROGRESS)
                    }
                    )),
                    this._failedToAddRecorders = []),
                    t
                }
                _getRecorderIdsToRemove(e) {
                    const t = [];
                    return e && (this.oneOrMoreRecordersFailed ? this._failedToRemoveRecorders.forEach((e => {
                        t.push(e.uuid)
                    }
                    )) : this.recordersToRemove.forEach((e => {
                        t.push(e.uuid)
                    }
                    )),
                    this.recordersToRemove.forEach((e => {
                        e.status !== gs.SUCCESS && (e.status = gs.IN_PROGRESS)
                    }
                    )),
                    this._failedToRemoveRecorders = []),
                    t
                }
                handleRecorderTagsResult(e, t) {
                    const n = e === uD.ADD ? this.recordersToAdd : this.recordersToRemove
                      , i = e === uD.ADD ? this._failedToAddRecorders : this._failedToRemoveRecorders;
                    n.forEach((e => {
                        const n = t.find((t => t.resource.orchidId === e.uuid));
                        n && (e.status = ws(n),
                        e.status !== gs.SUCCESS && i.push(Object.assign({}, e)))
                    }
                    ))
                }
                saveCameraTags() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.processing = !0;
                        const e = this.camerasToAdd.length > 0
                          , t = this.camerasToRemove.length > 0
                          , n = this._getCameraIdPairsToAdd(e)
                          , i = this._getCameraIdPairsToRemove(t);
                        let a = [];
                        (e ? this._resourceTaggingService.bulkAddCameraTags(this.tagConfigs, n) : (0,
                        ze.of)([])).pipe((0,
                        Tr.b)((e => (a = e,
                        t ? this._resourceTaggingService.bulkDeleteCameraTags(this.tagConfigs, i) : (0,
                        ze.of)([]))))).subscribe({
                            next: n => {
                                e && this.handleCameraTagsResult(uD.ADD, a),
                                t && this.handleCameraTagsResult(uD.REMOVE, n),
                                0 === this._failedToAddCameras.length && 0 === this._failedToRemoveCameras.length && (this.showCloseButton = !0,
                                this.showCancelButton = !1),
                                this.processing = !1
                            }
                        })
                    }
                    ))
                }
                _getCameraIdPairsToAdd(e) {
                    const t = [];
                    return e && (this.oneOrMoreCamerasFailed ? this._failedToAddCameras.forEach((e => {
                        t.push(e)
                    }
                    )) : this.camerasToAdd.forEach((e => {
                        e.cameraRecords.forEach((n => {
                            t.push({
                                cameraId: n.id,
                                orchidId: e.recorderUUID
                            })
                        }
                        ))
                    }
                    )),
                    this.camerasToAdd.forEach((e => {
                        e.cameraRecords.forEach((e => {
                            e.status !== gs.SUCCESS && (e.status = gs.IN_PROGRESS)
                        }
                        ))
                    }
                    )),
                    this._failedToAddCameras = []),
                    t
                }
                _getCameraIdPairsToRemove(e) {
                    const t = [];
                    return e && (this.oneOrMoreCamerasFailed ? this._failedToRemoveCameras.forEach((e => {
                        t.push(e)
                    }
                    )) : this.camerasToRemove.forEach((e => {
                        e.cameraRecords.forEach((n => {
                            t.push({
                                cameraId: n.id,
                                orchidId: e.recorderUUID
                            })
                        }
                        ))
                    }
                    )),
                    this.camerasToRemove.forEach((e => {
                        e.cameraRecords.forEach((e => {
                            e.status !== gs.SUCCESS && (e.status = gs.IN_PROGRESS)
                        }
                        ))
                    }
                    )),
                    this._failedToRemoveCameras = []),
                    t
                }
                handleCameraTagsResult(e, t) {
                    const n = e === uD.ADD ? this.camerasToAdd : this.camerasToRemove
                      , i = e === uD.ADD ? this._failedToAddCameras : this._failedToRemoveCameras;
                    t.forEach((e => {
                        const t = n.find((t => t.recorderUUID === e.resource.orchidId));
                        if (t) {
                            const n = t.cameraRecords.find((t => t.id === e.resource.cameraId));
                            n && ("200" === e.status ? n.status = gs.SUCCESS : "410" === e.status ? n.status = gs.CANCELED : "408" === e.status ? n.status = gs.TIMED_OUT : n.status = gs.FAILED,
                            "200" !== e.status && i.push({
                                cameraId: e.resource.cameraId,
                                orchidId: e.resource.orchidId
                            }))
                        }
                    }
                    ))
                }
                _handleRecorderTagDetailsError(e) {
                    return this.componentState = xr.ERROR,
                    this.tagDetailsErrorMessage = e.error && e.error.reason ? e.error.reason : this.msgs.somethingWentWrong(),
                    this.log.error(`Failed to fetch tag details: ${e.error.reason}`),
                    (0,
                    cr._)(( () => new Error(this.tagDetailsErrorMessage)))
                }
                static showBulkRecorderTag(e, t) {
                    const n = {
                        minWidth: "300px",
                        data: t,
                        disableClose: !0,
                        panelClass: "bulk-recorder-tagging-dialog-panel"
                    };
                    return e.open(hD, n).afterClosed().pipe((0,
                    pn.q)(1))
                }
                static showBulkCameraTag(e, t) {
                    const n = {
                        minWidth: "300px",
                        data: t,
                        disableClose: !0,
                        panelClass: "bulk-recorder-tagging-dialog-panel"
                    };
                    return e.open(hD, n).afterClosed().pipe((0,
                    pn.q)(1))
                }
                handleOrchidSelected(e) {
                    if (this.selectedRecorders = e,
                    this.resourceTagForm.controls.selectedResources.setValue(this.selectedRecorders),
                    e.length === this.initialSelectedRecorders.length) {
                        const t = new Set(this.initialSelectedRecorders.map((e => e.id)));
                        let n = !1;
                        e.forEach((e => {
                            t.has(e.id) || (n = !0)
                        }
                        )),
                        this.isDirty = n
                    } else
                        this.isDirty = !0
                }
                handleCamerasAndServersSelected(e) {
                    this.selectedCameras = [];
                    const t = e[0]
                      , n = e[1];
                    if (t.forEach((e => {
                        const t = this.orchids.find((t => t.id === e));
                        null == t || t.cameras.forEach((t => {
                            this.selectedCameras.push({
                                orchidId: e,
                                id: "number" == typeof t.id ? t.id : parseInt(t.id)
                            })
                        }
                        ))
                    }
                    )),
                    n.forEach((e => {
                        this.selectedCameras.push(e)
                    }
                    )),
                    this.resourceTagForm.controls.selectedResources.setValue(this.selectedCameras),
                    this.selectedCameras.length === this.initialSelectedCameras.length) {
                        const e = new Set(this.initialSelectedCameras.map((e => e.id)));
                        let t = !1;
                        this.selectedCameras.forEach((n => {
                            e.has(n.id) || (t = !0)
                        }
                        )),
                        this.isDirty = t
                    } else
                        this.isDirty = !0
                }
                onStepperStepChange(e) {
                    if (this.currentStepperStep = e.selectedIndex,
                    1 === this.currentStepperStep) {
                        if (this.showCancelButton = !1,
                        this.resourceType === ps.SERVER) {
                            const e = new Set(this.initialSelectedRecorders.map((e => e.id)))
                              , t = new Set(this.selectedRecorders.map((e => e.id)));
                            let n = [];
                            this.selectedRecorders.forEach((t => {
                                !e.has(t.id) && n.push({
                                    uuid: t.id,
                                    name: t.name,
                                    uri: t.uri,
                                    cameraCount: t.cameras.length,
                                    status: gs.DEFAULT,
                                    orchid: t
                                })
                            }
                            )),
                            this.recordersToAdd = n,
                            n = [],
                            this.initialSelectedRecorders.forEach((e => {
                                !t.has(e.id) && this._minimumVersionService.isFeatureSupported(e, Sr.BULK_TAGGING) && n.push({
                                    uuid: e.id,
                                    name: e.name,
                                    uri: e.uri,
                                    cameraCount: e.cameras.length,
                                    status: gs.DEFAULT,
                                    orchid: e
                                })
                            }
                            )),
                            this.recordersToRemove = n
                        } else if (this.resourceType === ps.CAMERA) {
                            const e = new Map;
                            this.initialSelectedCameras.forEach((t => {
                                e.set(t.id, t.orchidId)
                            }
                            ));
                            const t = [];
                            this.selectedCameras.forEach((e => {
                                if (!this.initialSelectedCameras.some((t => t.id === e.id && t.orchidId === e.orchidId))) {
                                    const n = this.orchids.find((t => t.id === e.orchidId));
                                    if (n) {
                                        t[n.id] || (t[n.id] = {
                                            recorderName: n.name,
                                            recorderUUID: n.id,
                                            cameraRecords: []
                                        });
                                        const i = n.cameras.find((t => t.id === e.id));
                                        i && (t[n.id].cameraRecords.push({
                                            id: i.id,
                                            name: i.name,
                                            status: gs.DEFAULT
                                        }),
                                        this.camerasToAddCount++)
                                    }
                                }
                            }
                            )),
                            this.camerasToAdd = Object.values(t);
                            const n = [];
                            this.initialSelectedCameras.forEach((e => {
                                if (!this.selectedCameras.find((t => t.orchidId === e.orchidId && t.id === e.id))) {
                                    const t = this.orchids.find((t => t.id === e.orchidId));
                                    if (t) {
                                        n[t.id] || (n[t.id] = {
                                            recorderName: t.name,
                                            recorderUUID: t.id,
                                            cameraRecords: []
                                        });
                                        const i = t.cameras.find((t => t.id === e.id));
                                        i && (n[t.id].cameraRecords.push({
                                            id: i.id,
                                            name: i.name,
                                            status: gs.DEFAULT
                                        }),
                                        this.camerasToRemoveCount++)
                                    }
                                }
                            }
                            )),
                            this.camerasToRemove = Object.values(n)
                        }
                        this.tagConfigs = this.dialogData.dialogType === yD.ADD ? ys(this.resourceTagForm.controls.tags.value) : this.tagConfigs
                    } else
                        this.recordersToAdd = [],
                        this.recordersToRemove = [],
                        this.camerasToAdd = [],
                        this.camerasToRemove = [],
                        this.camerasToAddCount = 0,
                        this.camerasToRemoveCount = 0
                }
                handleTagStatusClick(e) {
                    switch (e) {
                    case gs.TIMED_OUT:
                        this.showInfoPanel = !0,
                        this.infoPanelTitle = this.msgs.requestTimedOut(),
                        this.infoPanelBodyText = this.msgs.operationStatusUncertainDescription();
                        break;
                    case gs.CANCELED:
                        this.showInfoPanel = !0,
                        this.infoPanelTitle = this.msgs.tagOperationCanceled(),
                        this.infoPanelBodyText = this.msgs.operationStatusUncertainDescription()
                    }
                }
            }
            ;
            var SD, CD, wD, ID;
            (0,
            c.gn)([(0,
            i.ViewChild)("stepper"), (0,
            c.w6)("design:type", "function" == typeof (pD = void 0 !== Ti.Vq && Ti.Vq) ? pD : Object)], bD.prototype, "stepper", void 0),
            bD = hD = (0,
            c.gn)([(0,
            i.Component)({
                selector: "bulk-tagging-dialog",
                template: n(98776),
                animations: [(0,
                Jo.X$)("openClose", [(0,
                Jo.eR)(":enter", [(0,
                Jo.oB)({
                    height: 0
                }), (0,
                Jo.jt)("0.2s ease-out", (0,
                Jo.oB)({
                    height: "*"
                }))]), (0,
                Jo.eR)(":leave", [(0,
                Jo.oB)({
                    height: "*"
                }), (0,
                Jo.jt)("0.2s ease-in", (0,
                Jo.oB)({
                    height: 0
                }))])])]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(oE)), (0,
            c.fM)(2, (0,
            i.Inject)(Gt)), (0,
            c.fM)(3, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (gD = void 0 !== oE && oE) ? gD : Object, "function" == typeof (fD = Gt) ? fD : Object, "function" == typeof (vD = void 0 !== Cr && Cr) ? vD : Object])], bD);
            let TD = class {
                constructor(e, t, n, i) {
                    this._router = e,
                    this._dialog = t,
                    this._tagService = n,
                    this._RenewableService = i,
                    this.msgs = Object.assign(Object.assign(Object.assign(Object.assign({}, L.messages.resourceTagging), L.messages.common), L.messages.errorBanner), {
                        servers: L.messages.bag.servers,
                        cameras: L.messages.bag.cameras,
                        reset: L.messages.common.reset
                    }),
                    this.icons = Object.assign(Object.assign({}, Ht), zt),
                    this.TagResourceType = ps,
                    this.orchids = [],
                    this.displayedResource = ps.SERVER,
                    this.activeTab = 0,
                    this.recorderTags = [],
                    this.recorderTagsFilters = [],
                    this.recorderTagsFiltered = [],
                    this.cameraTags = [],
                    this.cameraTagsFilters = [],
                    this.cameraTagsFiltered = [],
                    this._loadingCameraTags = !0,
                    this._loadingRecorderTags = !0,
                    this._loadingRecorders = !0,
                    this.operationInProgress$ = this._tagService.bulkOperationInProgress$,
                    this._requestCanceller$ = new St.x,
                    this._destroy$ = new St.x,
                    this._refetchTags$ = new St.x,
                    this._skippedWSCount = 0,
                    this._tagFetchInProgress = !1,
                    this.ComponentState = xr
                }
                get ERROR_TYPE() {
                    return wr
                }
                get componentState() {
                    switch (this.displayedResource) {
                    case ps.SERVER:
                        return this._loadingRecorders || this._loadingRecorderTags ? xr.LOADING : xr.LOADED;
                    case ps.CAMERA:
                        return this._loadingRecorders || this._loadingCameraTags ? xr.LOADING : xr.LOADED
                    }
                }
                ngOnInit() {
                    const e = ["ORCHID_ADDED", "ORCHID_BULK_TAG_END", "ORCHID_REMOVED", "ORCHID_TAG_MODIFIED"]
                      , t = ["CAMERA_BULK_TAG_END", "CAMERA_REMOVED", "CAMERA_TAG_MODIFIED", "ORCHID_ADDED", "ORCHID_REMOVED"];
                    this._RenewableService.messages$.pipe((0,
                    ra.h)((n => {
                        switch (this.displayedResource) {
                        case ps.SERVER:
                            return e.includes(n.eventType);
                        case ps.CAMERA:
                            return t.includes(n.eventType)
                        }
                    }
                    )), (0,
                    oa.R)(this._destroy$)).subscribe(( () => {
                        this._tagFetchInProgress ? this._skippedWSCount++ : (this._skippedWSCount = 0,
                        this._refetchTags$.next())
                    }
                    ));
                    const n = this._fetchRecorderTags().pipe((0,
                    sa.b)((e => this.recorderTags = e)))
                      , i = this._fetchCameraTags().pipe((0,
                    sa.b)((e => this.cameraTags = e)));
                    this._refetchTags$.pipe((0,
                    sa.b)(( () => this._tagFetchInProgress = !0)), (0,
                    Ks.w)(( () => (this.displayedResource === ps.SERVER ? n : i).pipe((0,
                    sa.b)(( () => this.filterAndUpdateTagTable(this.displayedResource))), (0,
                    ig.g)(3e3), (0,
                    sa.b)(( () => {
                        this._skippedWSCount > 0 ? (this._skippedWSCount = 0,
                        this._refetchTags$.next()) : this._tagFetchInProgress = !1
                    }
                    )), (0,
                    oa.R)(this._requestCanceller$)))), (0,
                    oa.R)(this._destroy$)).subscribe({
                        error: e => {
                            switch (this.displayedResource) {
                            case ps.SERVER:
                                this._handleRecorderFetchError(e);
                                break;
                            case ps.CAMERA:
                                this._handleCameraFetchError(e)
                            }
                        }
                    }),
                    this._fetchOrchids(),
                    this._fetchRecorderTags().subscribe({
                        next: e => {
                            this.recorderTags = e,
                            this.filterAndUpdateTagTable(ps.SERVER)
                        }
                        ,
                        error: e => this._handleRecorderFetchError(e)
                    })
                }
                ngOnDestroy() {
                    this._requestCanceller$.next(),
                    this._requestCanceller$.complete(),
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                navigateToServersPage() {
                    this._router.navigateByUrl("/orchids")
                }
                changeDisplayedResource(e) {
                    switch (this.displayedResource = e,
                    this._requestCanceller$.next(),
                    this._tagFetchInProgress = !1,
                    this.displayedResource) {
                    case ps.SERVER:
                        this.activeTab = 0,
                        this._loadingRecorderTags = !0,
                        this.recorderTagsError = void 0,
                        this._fetchRecorderTags().subscribe({
                            next: e => {
                                this.recorderTags = e,
                                this.filterAndUpdateTagTable(ps.SERVER)
                            }
                            ,
                            error: e => this._handleRecorderFetchError(e)
                        });
                        break;
                    case ps.CAMERA:
                        this.activeTab = 1,
                        this._loadingCameraTags = !0,
                        this.cameraTagsError = void 0,
                        this._fetchCameraTags().subscribe({
                            next: e => {
                                this.cameraTags = e,
                                this.filterAndUpdateTagTable(ps.CAMERA)
                            }
                            ,
                            error: e => this._handleCameraFetchError(e)
                        })
                    }
                }
                addBulkRecorderTag() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const e = {
                            resourceType: ps.SERVER,
                            tag: null,
                            allTags: this.recorderTags,
                            orchids: this.orchids,
                            dialogType: yD.ADD
                        };
                        bD.showBulkRecorderTag(this._dialog, e).pipe((0,
                        pn.q)(1)).subscribe()
                    }
                    ))
                }
                editBulkRecorderTag(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const t = {
                            resourceType: ps.SERVER,
                            allTags: this.recorderTags,
                            orchids: this.orchids,
                            tag: e,
                            dialogType: yD.EDIT
                        };
                        bD.showBulkRecorderTag(this._dialog, t).pipe((0,
                        pn.q)(1)).subscribe()
                    }
                    ))
                }
                addBulkCameraTag() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const e = {
                            resourceType: ps.CAMERA,
                            tag: null,
                            orchids: this.orchids,
                            allTags: this.cameraTags,
                            dialogType: yD.ADD
                        };
                        bD.showBulkCameraTag(this._dialog, e).pipe((0,
                        pn.q)(1)).subscribe()
                    }
                    ))
                }
                editBulkCameraTag(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const t = {
                            resourceType: ps.CAMERA,
                            orchids: this.orchids,
                            allTags: this.cameraTags,
                            tag: e,
                            dialogType: yD.EDIT
                        };
                        bD.showBulkCameraTag(this._dialog, t).pipe((0,
                        pn.q)(1)).subscribe()
                    }
                    ))
                }
                filterAndUpdateTagTable(e) {
                    function t(e, t) {
                        var n;
                        if (0 === t.length)
                            return !0;
                        for (let i = 0; i < t.length; i++) {
                            const a = t[i].data.label.toLowerCase();
                            if (e.key.includes(a) || (null === (n = e.value) || void 0 === n ? void 0 : n.includes(a)))
                                return !0
                        }
                        return !1
                    }
                    switch (e) {
                    case ps.SERVER:
                        this.recorderTagsFiltered = this.recorderTags.filter((e => t(e, this.recorderTagsFilters))).sort(( (e, t) => _t(e.key, t.key))),
                        this._loadingRecorderTags = !1;
                        break;
                    case ps.CAMERA:
                        this.cameraTagsFiltered = this.cameraTags.filter((e => t(e, this.cameraTagsFilters))).sort(( (e, t) => _t(e.key, t.key))),
                        this._loadingCameraTags = !1
                    }
                }
                handleSearchKeyUp(e, t) {
                    if ("Enter" === e.key || 13 === e.keyCode) {
                        const n = e.target
                          , i = n.value;
                        if (0 === i.length)
                            return;
                        n.blur(),
                        n.value = "";
                        const a = {
                            data: {
                                label: i
                            },
                            id: i,
                            type: ix.SEARCH,
                            value: !0
                        };
                        switch (t) {
                        case ps.SERVER:
                            if (this.recorderTagsFilters.some((e => e.id === a.id)))
                                return;
                            this.recorderTagsFilters.push(a);
                            break;
                        case ps.CAMERA:
                            if (this.cameraTagsFilters.some((e => e.id === a.id)))
                                return;
                            this.cameraTagsFilters.push(a)
                        }
                        this.filterAndUpdateTagTable(t)
                    }
                }
                _fetchOrchids() {
                    this._RenewableService.orchidsPromise().then((e => {
                        this.orchids = e,
                        this._loadingRecorders = !1
                    }
                    ), ( () => {
                        this.orchids = [],
                        this._loadingRecorders = !1
                    }
                    ))
                }
                _fetchRecorderTags() {
                    return this._tagService.fetchAllRecorderTags().pipe((0,
                    oa.R)(this._requestCanceller$))
                }
                _fetchCameraTags() {
                    return this._tagService.fetchAllCameraTags().pipe((0,
                    oa.R)(this._requestCanceller$))
                }
                removeFilter(e, t) {
                    switch (t) {
                    case ps.SERVER:
                        this.recorderTagsFilters.splice(e, 1);
                        break;
                    case ps.CAMERA:
                        this.cameraTagsFilters.splice(e, 1)
                    }
                    this.filterAndUpdateTagTable(t)
                }
                removeAllFilters(e) {
                    switch (e) {
                    case ps.SERVER:
                        this.recorderTagsFilters = [];
                        break;
                    case ps.CAMERA:
                        this.cameraTagsFilters = []
                    }
                    this.filterAndUpdateTagTable(e)
                }
                _handleCameraFetchError(e) {
                    var t, n;
                    this.cameraTags = [],
                    this._loadingCameraTags = !1,
                    this.cameraTagsError = null !== (n = null === (t = e.error) || void 0 === t ? void 0 : t.reason) && void 0 !== n ? n : this.msgs.somethingWentWrong()
                }
                _handleRecorderFetchError(e) {
                    var t, n;
                    this.recorderTags = [],
                    this._loadingRecorderTags = !1,
                    this.recorderTagsError = null !== (n = null === (t = e.error) || void 0 === t ? void 0 : t.reason) && void 0 !== n ? n : this.msgs.somethingWentWrong()
                }
            }
            ;
            var ED, _D, xD;
            TD = (0,
            c.gn)([(0,
            i.Component)({
                selector: "bulk-tagging",
                template: n(33851)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Bt.F0)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(2, (0,
            i.Inject)(oE)), (0,
            c.fM)(3, (0,
            i.Inject)(Gt)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (SD = void 0 !== Bt.F0 && Bt.F0) ? SD : Object, "function" == typeof (CD = void 0 !== hn.uw && hn.uw) ? CD : Object, "function" == typeof (wD = void 0 !== oE && oE) ? wD : Object, "function" == typeof (ID = Gt) ? ID : Object])], TD);
            let DD = class {
                constructor(e) {
                    this.$rootScope = e
                }
            }
            ;
            DD = (0,
            c.gn)([(0,
            c.fM)(0, (0,
            i.Inject)("$rootScope")), (0,
            c.w6)("design:paramtypes", ["function" == typeof (ED = "undefined" != typeof ng && ng.IRootScopeService) ? ED : Object])], DD);
            class OD extends DD {
                ngAfterViewInit() {
                    this.$rootScope.appLoaded = !0
                }
            }
            let AD = class {
            }
            ;
            AD = (0,
            c.gn)([(0,
            i.Component)({
                template: "<camera-group-config></camera-group-config>"
            })], AD);
            let RD = class extends OD {
            }
            ;
            RD = (0,
            c.gn)([(0,
            i.Component)({
                template: "<sing-swagger></sing-swagger>"
            })], RD);
            let PD = class extends DD {
            }
            ;
            PD = (0,
            c.gn)([(0,
            i.Component)({
                template: '<notification-settings [orchids]="$rootScope.orchids"></notification-settings>'
            })], PD);
            let kD = class {
                constructor(e, t) {
                    this.$rootScope = e,
                    this.route = t,
                    this.componentName = t.snapshot.data.component
                }
            }
            ;
            kD = (0,
            c.gn)([(0,
            i.Component)({
                template: '<orchid-admin [orchids]="$rootScope.orchids" [component]="componentName" [route]="route"></orchid-admin>'
            }), (0,
            c.fM)(0, (0,
            i.Inject)("$rootScope")), (0,
            c.fM)(1, (0,
            i.Inject)(Bt.gz)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (_D = void 0 !== Bt.gz && Bt.gz) ? _D : Object])], kD);
            let MD = class {
                constructor(e, t) {
                    this.$rootScope = e,
                    this.route = t
                }
            }
            ;
            MD = (0,
            c.gn)([(0,
            i.Component)({
                template: '<dashboard [orchids]="$rootScope.orchids" [route]="route"></dashboard>'
            }), (0,
            c.fM)(0, (0,
            i.Inject)("$rootScope")), (0,
            c.fM)(1, (0,
            i.Inject)(Bt.gz)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (xD = void 0 !== Bt.gz && Bt.gz) ? xD : Object])], MD);
            let LD = class {
            }
            ;
            LD = (0,
            c.gn)([(0,
            i.Component)({
                template: "<controlled-server-shutdown></controlled-server-shutdown>"
            })], LD);
            let ND = class extends DD {
            }
            ;
            ND = (0,
            c.gn)([(0,
            i.Component)({
                template: '<single-player [orchids]="$rootScope.orchids"></single-player>'
            })], ND);
            let FD = class extends DD {
            }
            ;
            FD = (0,
            c.gn)([(0,
            i.Component)({
                template: '<stage [orchids]="$rootScope.orchids" class="ios-prevent-drag"></stage>'
            })], FD);
            const UD = [{
                path: "",
                canActivate: [wx],
                children: [{
                    path: "",
                    redirectTo: "sign-in",
                    pathMatch: "full"
                }, {
                    path: "access-denied",
                    component: __
                }, {
                    path: "dinosaur",
                    component: A_
                }, {
                    path: "expired",
                    component: rx
                }, {
                    path: "incognito",
                    component: hx
                }, {
                    path: "not-found",
                    component: vx
                }, {
                    path: "player",
                    component: ND
                }, {
                    path: "sign-in",
                    component: cD,
                    canActivate: [Rx]
                }, {
                    path: "unsupported",
                    component: Bx
                }, {
                    path: "unsupported-ws",
                    component: A_,
                    data: {
                        reason: "ws"
                    }
                }, {
                    path: "",
                    component: Vx,
                    canActivate: [Mx],
                    resolve: {
                        postAuthData: Ux
                    },
                    children: [{
                        path: "flags",
                        component: zm
                    }, {
                        path: "stage/:layoutId",
                        component: FD
                    }, {
                        path: "stage",
                        component: FD
                    }, {
                        path: "events-viewer",
                        component: Cd
                    }, {
                        path: "users",
                        component: GC,
                        canActivate: [cx]
                    }, {
                        path: "account-settings",
                        component: Gh
                    }, {
                        path: "version",
                        component: Rh
                    }, {
                        path: "events-subscriptions",
                        component: ax,
                        canActivate: [ux]
                    }, {
                        path: "camera-groups",
                        component: AD,
                        canActivate: [cx]
                    }, {
                        path: "library",
                        component: hh,
                        canActivate: [fx]
                    }, {
                        path: "licensing",
                        component: wf,
                        canActivate: [cx]
                    }, {
                        path: "system-alerts",
                        component: PD,
                        canActivate: [cx]
                    }, {
                        path: "motion-alerts",
                        component: UE,
                        canActivate: [cx]
                    }, {
                        path: "smtp-servers",
                        component: v_,
                        canActivate: [cx]
                    }, {
                        path: "orchids",
                        component: MD,
                        canActivate: [ux]
                    }, {
                        path: "orchids/tags",
                        component: TD,
                        canActivate: [cx]
                    }, {
                        path: "permission-groups",
                        component: yb,
                        canActivate: [cx]
                    }, {
                        path: "plugin/:plugin/:extension",
                        component: E_
                    }]
                }]
            }, {
                path: "api",
                component: RD
            }, {
                path: "external-redirect",
                component: lm
            }, {
                path: "**",
                component: vx
            }];
            var $D, jD;
            let VD = class {
                constructor(e, t) {
                    this.deathService = e,
                    this.brandService = t,
                    this.msgs = L.messages.applicationDeath,
                    this.showAmbulance = e.reason() !== e.reasons.ws,
                    this.errorHelp = null
                }
                ngOnInit() {
                    this.brandService.brand.SUPPORT_URL && (this.errorHelp = L.messages.errors.errorHelp({
                        VALUE: this.brandService.brand.SUPPORT_URL
                    }))
                }
                reload() {
                    window.location.reload()
                }
                getReason() {
                    return this.showAmbulance ? this.msgs.cannotReachServer() : this.msgs.cannotUseWS()
                }
            }
            ;
            var GD;
            VD = (0,
            c.gn)([(0,
            i.Component)({
                selector: "application-death",
                template: n(70253)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(gt)), (0,
            c.fM)(1, (0,
            i.Inject)(Hm)), (0,
            c.w6)("design:paramtypes", ["function" == typeof ($D = gt) ? $D : Object, "function" == typeof (jD = void 0 !== Hm && Hm) ? jD : Object])], VD);
            let BD = class {
                constructor(e) {
                    this.$rootScope = e,
                    this.msgs = L.messages.error,
                    this.showProceedToStage = !0
                }
                ngAfterViewInit() {
                    this.$rootScope.appLoaded = !0
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], BD.prototype, "icon", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], BD.prototype, "message", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", String)], BD.prototype, "title", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], BD.prototype, "showProceedToStage", void 0),
            BD = (0,
            c.gn)([(0,
            i.Component)({
                selector: "error",
                template: n(8633)
            }), (0,
            c.fM)(0, (0,
            i.Inject)("$rootScope")), (0,
            c.w6)("design:paramtypes", ["function" == typeof (GD = "undefined" != typeof ng && ng.IRootScopeService) ? GD : Object])], BD);
            let zD = class {
            }
            ;
            zD = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [__, A_, BD, rx, hx, UC, vx, Bx],
                entryComponents: [__, A_, BD, rx, hx, UC, vx, Bx],
                exports: [__, A_, BD, rx, hx, UC, vx, Bx],
                imports: [l.ez, Bt.Bz, Ai]
            })], zD);
            let HD = class {
            }
            ;
            HD = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [jC, GC, uC],
                entryComponents: [],
                imports: [PE, l.ez, ii.QW],
                exports: [jC, GC, uC]
            })], HD);
            let WD = class {
            }
            ;
            WD = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [VD, AD, PD, kD, MD, ND, E_, LD, Vx, FD, w_, RD],
                imports: [l.ez, ii.QW, ti.ot, S_, Bt.Bz.forRoot(UD, {
                    useHash: !0,
                    scrollPositionRestoration: "top",
                    onSameUrlNavigation: "reload"
                }), PE, zD, ME, HD],
                exports: [Bt.Bz]
            })], WD);
            let qD = class {
            }
            ;
            qD = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [MS, YS, dC, oC, VS, US],
                entryComponents: [MS],
                exports: [MS],
                imports: [l.ez, ym, p.u5, Ai, p.UX, PE]
            })], qD);
            let YD = class {
            }
            ;
            var XD, KD, ZD, JD, QD, eO, tO;
            YD = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [hc, sc, bc],
                exports: [hc, sc, bc],
                imports: [l.ez, u.PW, qD, ym, Ai, p.UX],
                entryComponents: [hc, sc, bc]
            })], YD);
            const nO = O("ActivationReportComponent");
            var iO;
            !function(e) {
                e[e.LOADING = 0] = "LOADING",
                e[e.LOADED = 1] = "LOADED"
            }(iO || (iO = {}));
            let aO = class {
                constructor(e, t, n) {
                    this._dataService = e,
                    this._datePipe = t,
                    this._downloaderService = n,
                    this.licenses = [],
                    this.refreshDelayMs = 1e3,
                    this.componentState = iO.LOADING,
                    this.msgs = L.messages.licensing,
                    this.fmts = L.formats.licensing,
                    this.dataSource = new Ei.by,
                    this.pageSizeOptions = [10, 20, 50],
                    this.defaultSort = {
                        id: "orchidName",
                        start: "asc",
                        disableClear: !0
                    },
                    this.destroyed$ = new St.x,
                    this.displayCols = ["orchidName", "licenseEdition", "cameras", "retention", "expires", "activationCode"],
                    this.columns = [{
                        columnDef: "orchidName",
                        header: this.msgs.columnHeaders.server(),
                        formatter: e => `${e.orchidName}`,
                        sortAccessor: e => e.orchidName.toLowerCase()
                    }, {
                        columnDef: "licenseEdition",
                        header: this.msgs.columnHeaders.edition(),
                        formatter: e => `${e.licenseEdition}`
                    }, {
                        columnDef: "cameras",
                        header: this.msgs.columnHeaders.camerasLicensed(),
                        formatter: e => `${e.camerasRegistered}/${e.cameraCount}`,
                        comparator: (e, t) => {
                            const n = [e.cameraCount - t.cameraCount, e.camerasRegistered - t.camerasRegistered].find((e => 0 !== e));
                            return void 0 === n ? 0 : n
                        }
                    }, {
                        columnDef: "retention",
                        header: this.msgs.columnHeaders.archiveRetention(),
                        formatter: e => "number" == typeof e.retention ? (new er).transform(e.retention.toString()) : this.msgs.unlimited(),
                        sortAccessor: e => "number" == typeof e.retention ? e.retention : 1 / 0
                    }, {
                        columnDef: "expires",
                        header: this.msgs.columnHeaders.supportExpiration(),
                        formatter: e => e.expires > 8623372036854776 ? this.msgs.na() : `${this._datePipe.transform(new Date(e.expires), this.fmts.supportExpiration)}`
                    }, {
                        columnDef: "activationCode",
                        header: this.msgs.columnHeaders.activationCode(),
                        formatter: e => e.activationCode ? `${e.activationCode}` : this.msgs.na()
                    }]
                }
                ngOnInit() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this.dataSource.sortData = this.sortData.bind(this),
                        yield this.loadLicenseData(),
                        this.componentState = iO.LOADED,
                        (0,
                        Jl.F)(this.refreshDelayMs).pipe((0,
                        oa.R)(this.destroyed$)).subscribe(( () => this.loadLicenseData()))
                    }
                    ))
                }
                ngAfterViewInit() {
                    this.paginatorWatcher.changes.pipe((0,
                    oa.R)(this.destroyed$)).subscribe(( () => {
                        this.dataSource.paginator = this.paginatorWatcher.first
                    }
                    ))
                }
                ngOnDestroy() {
                    this.destroyed$.next(),
                    this.destroyed$.complete()
                }
                sortData(e, t) {
                    if (void 0 === t.active || "" === t.direction)
                        return e;
                    const n = t.active
                      , i = "desc" === t.direction
                      , a = this.findColumn(n)
                      , r = a.sortAccessor || (e => e[n])
                      , s = a.comparator || ( (e, t) => r(e) < r(t) ? -1 : r(e) > r(t) ? 1 : 0);
                    return e.sort(( (e, t) => {
                        let n = s(e, t);
                        return i && (n *= -1),
                        n
                    }
                    ))
                }
                findColumn(e) {
                    return this.columns.find((t => t.columnDef === e))
                }
                loadLicenseData() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        try {
                            this.licenses = yield this._dataService.fetchLicenses(G.JSON),
                            this.refreshTable(),
                            this.error = void 0
                        } catch (e) {
                            return this.error = this.msgs.errors.errorFetchingActivationData(),
                            nO.error(e),
                            null
                        }
                    }
                    ))
                }
                getRowId(e, t) {
                    return t.id
                }
                refreshTable() {
                    this.dataSource.data = this.licenses,
                    this.dataSource.sort = this.sort
                }
                export() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const e = new Date
                          , t = new Date(e.getTime() + 6e4 * e.getTimezoneOffset())
                          , n = this._dataService.licensesUrl()
                          , i = this.msgs.activationReportTimeExtension({
                            TIME: this._datePipe.transform(t, this.fmts.fileName),
                            EXTENSION: "csv"
                        });
                        this._downloaderService.createDownloader((e => i)).download(n)
                    }
                    ))
                }
                get canExport() {
                    return 0 !== this.licenses.length
                }
                get hidePaginator() {
                    return this.licenses.length <= this.pageSizeOptions[0]
                }
                get ComponentState() {
                    return iO
                }
            }
            ;
            var rO, sO, oO, cO, lO, dO;
            (0,
            c.gn)([(0,
            i.ViewChildren)(pi.NW), (0,
            c.w6)("design:type", "function" == typeof (XD = void 0 !== i.QueryList && i.QueryList) ? XD : Object)], aO.prototype, "paginatorWatcher", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW), (0,
            c.w6)("design:type", "function" == typeof (KD = void 0 !== pi.NW && pi.NW) ? KD : Object)], aO.prototype, "paginator", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(Ii.YE), (0,
            c.w6)("design:type", "function" == typeof (ZD = void 0 !== Ii.YE && Ii.YE) ? ZD : Object)], aO.prototype, "sort", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(Ei.BZ), (0,
            c.w6)("design:type", "function" == typeof (JD = void 0 !== Ei.BZ && Ei.BZ) ? JD : Object)], aO.prototype, "table", void 0),
            aO = (0,
            c.gn)([(0,
            i.Component)({
                selector: "activation-report",
                template: n(55999)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Qe)), (0,
            c.fM)(1, (0,
            i.Inject)(l.uU)), (0,
            c.fM)(2, (0,
            i.Inject)(ih)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (QD = Qe) ? QD : Object, "function" == typeof (eO = void 0 !== l.uU && l.uU) ? eO : Object, "function" == typeof (tO = void 0 !== ih && ih) ? tO : Object])], aO);
            const uO = O("BulkLicenseReportComponent");
            class mO {
                constructor() {
                    this.state = !1,
                    this.reason = ""
                }
                get active() {
                    return this.state
                }
                set(e=0, t="") {
                    this.transition(!0, e, t)
                }
                clear(e=0) {
                    this.transition(!1, e)
                }
                transition(e, t=0, n="") {
                    this.changeSub && (this.changeSub.unsubscribe(),
                    this.changeSub = void 0),
                    t > 0 ? this.changeSub = (0,
                    Kl.H)(t).subscribe(( () => {
                        this.state = e,
                        this.changeSub = void 0,
                        this.reason = n
                    }
                    )) : (this.state = e,
                    this.reason = n)
                }
            }
            var hO, pO;
            !function(e) {
                e[e.LOADING = 0] = "LOADING",
                e[e.LOADED = 1] = "LOADED"
            }(hO || (hO = {})),
            function(e) {
                e.FEEDBACK = "FEEDBACK"
            }(pO || (pO = {}));
            let gO = class {
                constructor(e, t, n) {
                    this._dataService = e,
                    this._dialogRef = t,
                    this._datePipe = n,
                    this.msgs = L.messages.licensing,
                    this.dataSource = new Ei.by,
                    this.componentState = hO.LOADING,
                    this.processState = z.IDLE,
                    this.licenseImports = [],
                    this.errorFlags = {
                        fetch: new mO,
                        retry: new mO,
                        cancel: new mO,
                        clear: new mO
                    },
                    this.importFormats = [".csv"],
                    this.refreshDelayMs = 1e3,
                    this.errorClearDelayMs = 3e4,
                    this.feedbackDurationMs = 500,
                    this.pageSizeOptions = [10, 20, 50],
                    this.defaultSort = {
                        id: "lastUpdated",
                        start: "desc",
                        disableClear: !0
                    },
                    this.refreshSub = Ql.E.subscribe(),
                    this.remainingSleepDuration = 0,
                    this.displayCols = ["orchidName", "applyCode", "itemStatus", "lastUpdated"],
                    this.columns = [{
                        columnDef: "orchidName",
                        header: L.messages.licensing.columnHeaders.server(),
                        formatter: e => e.orchidName ? `${e.orchidName}` : L.messages.licensing.unknown()
                    }, {
                        columnDef: "applyCode",
                        header: L.messages.licensing.columnHeaders.activationCode(),
                        formatter: e => `${e.applyCode}`,
                        hideable: !1
                    }, {
                        columnDef: "lastUpdated",
                        header: L.messages.licensing.columnHeaders.lastUpdate(),
                        formatter: e => `${this._datePipe.transform(new Date(e.lastUpdated), L.formats.licensing.lastUpdated)}`
                    }],
                    this.specialColumns = {
                        status: {
                            columnDef: "itemStatus",
                            header: L.messages.licensing.columnHeaders.importStatus(),
                            formatter: e => 0 !== e.retryCount && e.itemStatus === B.FAILED ? `${this.getImportStatusString(e.itemStatus)} (${e.retryCount})` : `${this.getImportStatusString(e.itemStatus)}`
                        }
                    }
                }
                ngOnInit() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        yield this.loadImportData(),
                        this.componentState = hO.LOADED,
                        this._enableRefresh()
                    }
                    ))
                }
                ngOnDestroy() {
                    this._disableRefresh()
                }
                _enableRefresh() {
                    this.refreshSub.closed && (this.refreshSub = (0,
                    Kl.H)(this.refreshDelayMs, this.refreshDelayMs).subscribe(( () => this.loadImportData(!0))))
                }
                _disableRefresh() {
                    this.refreshSub.closed || this.refreshSub.unsubscribe()
                }
                retry() {
                    var e, t;
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        try {
                            this._disableRefresh(),
                            this.processState = pO.FEEDBACK,
                            yield this._dataService.putLicenseImportRetry(),
                            yield new Promise((e => setTimeout(e, this.feedbackDurationMs))),
                            yield this.loadImportData(),
                            this._enableRefresh(),
                            this.errorFlags.retry.clear()
                        } catch (n) {
                            uO.error(n);
                            const i = null !== (t = null === (e = null == n ? void 0 : n.data) || void 0 === e ? void 0 : e.reason) && void 0 !== t ? t : "";
                            this.errorFlags.retry.set(0, i),
                            this.errorFlags.retry.clear(this.errorClearDelayMs)
                        }
                    }
                    ))
                }
                cancel() {
                    var e, t;
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        try {
                            this._disableRefresh(),
                            this.processState = pO.FEEDBACK,
                            yield this._dataService.putLicenseImportCancel(),
                            yield new Promise((e => setTimeout(e, this.feedbackDurationMs))),
                            yield this.loadImportData(),
                            this._enableRefresh(),
                            this.errorFlags.cancel.clear()
                        } catch (n) {
                            uO.error(n);
                            const i = null !== (t = null === (e = null == n ? void 0 : n.data) || void 0 === e ? void 0 : e.reason) && void 0 !== t ? t : "";
                            this.errorFlags.cancel.set(0, i),
                            this.errorFlags.cancel.clear(this.errorClearDelayMs)
                        }
                    }
                    ))
                }
                clear() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        const e = {
                            confirmText: L.messages.licensing.buttons.clear(),
                            cancelText: L.messages.licensing.buttons.cancel(),
                            message: L.messages.licensing.areYouSureThisWillCancelAnyPendingActivationsAndClearTheTable(),
                            confirmCallbackAsync: () => (0,
                            c.mG)(this, void 0, void 0, (function*() {
                                var e, t;
                                try {
                                    yield this._dataService.clearLicenseImports(),
                                    (0,
                                    Kl.H)(500).subscribe(( () => this.loadImportData())),
                                    this.errorFlags.clear.clear()
                                } catch (n) {
                                    uO.error(n);
                                    const i = null !== (t = null === (e = null == n ? void 0 : n.data) || void 0 === e ? void 0 : e.reason) && void 0 !== t ? t : "";
                                    this.errorFlags.clear.set(0, i),
                                    this.errorFlags.clear.clear(this.errorClearDelayMs)
                                }
                            }
                            ))
                        };
                        qs.show(this._dialogRef, {
                            data: e
                        })
                    }
                    ))
                }
                upload() {
                    const e = L.messages.licensing.uploadDialog
                      , t = {
                        title: e.uploadActivationBundle(),
                        message: [e.pleaseSelectALicenseBundleFile(), e.theLicenseBundleFileIsACsvFileProvidedForBulkUpdatingChildLicenses()],
                        okText: e.upload(),
                        cancelText: e.cancel(),
                        accept: this.importFormats,
                        styleClass: "bulk-import-dialog",
                        okCallbackAsync: (e, t) => (0,
                        c.mG)(this, void 0, void 0, (function*() {
                            var n;
                            try {
                                yield this.uploadLicenses(e[0])
                            } catch (i) {
                                let a = L.messages.licensing.errors.errorUploadingLicenseBundleFile();
                                throw (null === (n = null == i ? void 0 : i.data) || void 0 === n ? void 0 : n.reason) ? a += " " + i.data.reason : "NotReadableError" === i.name && (a = L.messages.licensing.errors.errorTheFileWasModifiedAfterSelectionPleaseReselectTheFile({
                                    FILE: e[0].name
                                }),
                                t.clear()),
                                new Error(a)
                            }
                        }
                        ))
                    };
                    Go.show(this._dialogRef, t)
                }
                loadImportData(e) {
                    var t, n;
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        try {
                            const t = yield this._dataService.fetchLicenseImportStatus()
                              , n = this.remainingSleepDuration
                              , i = this.processState;
                            if (this.licenseImports = t.items,
                            this.processState = t.state,
                            this.remainingSleepDuration = t.sleepTimePendingMs,
                            e && t.sleepTimePendingMs > n && i === z.PENDING_RETRY)
                                return void (yield this.showFeedback());
                            this.refreshTable(),
                            this.errorFlags.fetch.clear()
                        } catch (e) {
                            uO.error(e);
                            const i = null !== (n = null === (t = null == e ? void 0 : e.data) || void 0 === t ? void 0 : t.reason) && void 0 !== n ? n : "";
                            this.errorFlags.fetch.set(0, i),
                            this.errorFlags.fetch.clear(this.errorClearDelayMs)
                        }
                    }
                    ))
                }
                showFeedback() {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        this._disableRefresh(),
                        this.processState = pO.FEEDBACK,
                        yield new Promise((e => setTimeout(e, this.feedbackDurationMs))),
                        yield this.loadImportData(),
                        this._enableRefresh()
                    }
                    ))
                }
                getRowId(e, t) {
                    return t.orchidId
                }
                refreshTable() {
                    this.dataSource.data = this.licenseImports,
                    this.dataSource.paginator = this.paginator,
                    this.dataSource.sort = this.sort
                }
                uploadLicenses(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        yield this._dataService.uploadLicenses(e)
                    }
                    ))
                }
                getImportStatusString(e) {
                    const t = L.messages.licensing.importStatus;
                    switch (e) {
                    case B.SUCCESS:
                        return t.success();
                    case B.FAILED:
                        return t.failed();
                    case B.PENDING:
                        return t.pending();
                    case B.CANCELED:
                        return t.cancelled();
                    default:
                        return uO.error(`Unexpected import item status: ${e}`),
                        ""
                    }
                }
                get processStateString() {
                    const e = L.messages.licensing.processState;
                    switch (this.processState) {
                    case z.IDLE:
                        return e.idle();
                    case z.PROCESSING:
                        return e.processing();
                    case z.PENDING_RETRY:
                        return this.remainingSleepDuration >= 1e3 ? e.automaticRetryInTime({
                            TIME: this.remainingSleepDurationString
                        }) : e.retryPending();
                    case z.PENDING_CANCEL:
                        return e.cancelled();
                    case z.SUCCESS:
                        return e.successful();
                    case pO.FEEDBACK:
                        return e.pending();
                    default:
                        return uO.error(`Unexpected import process state: ${this.processState}`),
                        ""
                    }
                }
                get errors() {
                    const e = []
                      , t = this.errorFlags
                      , n = L.messages.licensing.errors;
                    return t.fetch.active && e.push(i(n.errorFetchingActivationData(), t.fetch)),
                    t.retry.active && e.push(i(n.errorRetryingActivationRequest(), t.retry)),
                    t.cancel.active && e.push(i(n.errorCancellingActivationRequest(), t.cancel)),
                    t.clear.active && e.push(i(n.errorClearingActivationHistory(), t.clear)),
                    e;
                    function i(e, t) {
                        return t.reason ? `${e} ${t.reason}` : e
                    }
                }
                getStatusDetailString(e) {
                    return e.itemStatus === B.FAILED ? e.statusDetail : ""
                }
                get numProcessed() {
                    return this.licenseImports.filter((e => e.itemStatus === B.SUCCESS)).length
                }
                get progress() {
                    return this.numProcessed / this.licenseImports.length * 100
                }
                get canCancel() {
                    return this.processState !== z.SUCCESS && (this.processState !== pO.FEEDBACK && !this.licenseImports.every((e => {
                        switch (e.itemStatus) {
                        case B.SUCCESS:
                        case B.CANCELED:
                            return !0;
                        default:
                            return !1
                        }
                    }
                    )))
                }
                get canRetry() {
                    return this.processState !== z.SUCCESS && this.processState !== pO.FEEDBACK
                }
                get canClear() {
                    return !0
                }
                isFail(e) {
                    return e === B.FAILED
                }
                get isProcessing() {
                    return this.processState === z.PROCESSING
                }
                get isShowingFeedback() {
                    return this.processState === pO.FEEDBACK
                }
                get hidePaginator() {
                    return this.licenseImports.length <= this.pageSizeOptions[0]
                }
                get ComponentState() {
                    return hO
                }
                get remainingSleepDurationString() {
                    return (new yl).transform(this.remainingSleepDuration, !0)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW), (0,
            c.w6)("design:type", "function" == typeof (rO = void 0 !== pi.NW && pi.NW) ? rO : Object)], gO.prototype, "paginator", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(Ii.YE), (0,
            c.w6)("design:type", "function" == typeof (sO = void 0 !== Ii.YE && Ii.YE) ? sO : Object)], gO.prototype, "sort", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(Ei.BZ), (0,
            c.w6)("design:type", "function" == typeof (oO = void 0 !== Ei.BZ && Ei.BZ) ? oO : Object)], gO.prototype, "table", void 0),
            gO = (0,
            c.gn)([(0,
            i.Component)({
                selector: "bulk-license-import",
                template: n(62095)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Qe)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.uw)), (0,
            c.fM)(2, (0,
            i.Inject)(l.uU)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (cO = Qe) ? cO : Object, "function" == typeof (lO = void 0 !== hn.uw && hn.uw) ? lO : Object, "function" == typeof (dO = void 0 !== l.uU && l.uU) ? dO : Object])], gO);
            let fO = class {
            }
            ;
            fO = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [wf, gO, aO],
                entryComponents: [wf],
                imports: [l.ez, ym, Ai, PE],
                providers: [{
                    provide: pi.ye,
                    useFactory: y_
                }]
            })], fO);
            let vO = class {
            }
            ;
            var yO, bO, SO;
            vO = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [Xv, tc, kf],
                entryComponents: [Xv, tc, kf],
                exports: [Xv, tc, kf],
                imports: [l.ez, ym, h._t, p.u5, Ai, Zn.U8, g.ud, xf.eL, bm, PE]
            })], vO);
            let CO = class {
                constructor(e) {
                    this._miminumVersionService = e,
                    this.msgs = Object.assign(Object.assign({}, L.messages.events.orchidSelector), L.messages.resourceTagging),
                    this.orchidOptions = [],
                    this.autocompleteOrchidOptions = [],
                    this.orchidsFormControl = new p.NI,
                    this.selectedOrchid = null,
                    this.orchids = [],
                    this.collapsible = !0,
                    this.collapsed = !1,
                    this.onSelectedOrchid = new i.EventEmitter
                }
                ngOnChanges() {
                    const e = []
                      , t = [];
                    this.orchids.sort(( (e, t) => {
                        const n = e.name.toLowerCase()
                          , i = t.name.toLowerCase();
                        return n < i ? -1 : n > i ? 1 : 0
                    }
                    )),
                    this.orchids.forEach((n => {
                        let i = !1;
                        i = this.requiredVersion ? this._miminumVersionService.isFeatureSupported(n, this.requiredVersion) && n.isAvailable : n.isAvailable;
                        const a = {
                            id: n.id,
                            name: n.name,
                            version: n.version.version,
                            disabled: !i,
                            unavailableText: i ? "" : this.getUnavailableText(n)
                        };
                        i ? e.push(a) : t.push(a)
                    }
                    )),
                    this.orchidOptions = [...e, ...t],
                    this.filteredOrchids = this.orchidsFormControl.valueChanges.pipe((0,
                    lu.O)(""), (0,
                    He.U)((e => this._getAutocompleteOptions(e))))
                }
                _getAutocompleteOptions(e) {
                    let t = e.length > 0 ? this.filterOrchids(e) : this.orchidOptions;
                    if (t.length > hs) {
                        const e = t.length - hs;
                        t = t.slice(0, hs),
                        t.push({
                            id: "extra-orchids",
                            name: this.msgs.plusVALUEMore({
                                VALUE: e
                            }),
                            version: "",
                            disabled: !0,
                            unavailableText: ""
                        })
                    }
                    return t
                }
                clearInput(e) {
                    this.orchidsFormControl.reset(""),
                    this.selectedOrchid = null,
                    this.onSelectedOrchid.emit(null),
                    setTimeout(( () => {
                        e.openPanel()
                    }
                    ), 50)
                }
                filterOrchids(e) {
                    return this.orchidOptions.filter((t => t.name.toLowerCase().includes(e.toLowerCase())))
                }
                isSelected(e) {
                    var t;
                    return e.id === (null === (t = this.selectedOrchid) || void 0 === t ? void 0 : t.id)
                }
                onSelect(e, t) {
                    var n;
                    const i = e.option.value.id;
                    i !== (null === (n = this.selectedOrchid) || void 0 === n ? void 0 : n.id) && (this.selectedOrchid = this.orchids.find((e => e.id === i)) || null,
                    this.onSelectedOrchid.emit(this.selectedOrchid)),
                    setTimeout(( () => {
                        t.closePanel()
                    }
                    ), 50),
                    this.searchInput.nativeElement.blur()
                }
                getOrchidOptionLabel(e) {
                    return e ? e.name : ""
                }
                getUnavailableText(e) {
                    return e.isAvailable ? L.messages.events.orchidSelector.notAvailable({
                        VALUE: e.version.version
                    }) : this.msgs.serverUnavailable()
                }
                toggleContainerMode() {
                    this.collapsed = !this.collapsed
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], CO.prototype, "orchids", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], CO.prototype, "collapsible", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], CO.prototype, "requiredVersion", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (yO = void 0 !== i.EventEmitter && i.EventEmitter) ? yO : Object)], CO.prototype, "onSelectedOrchid", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("searchInput"), (0,
            c.w6)("design:type", "function" == typeof (bO = void 0 !== i.ElementRef && i.ElementRef) ? bO : Object)], CO.prototype, "searchInput", void 0),
            CO = (0,
            c.gn)([(0,
            i.Component)({
                selector: "orchid-selector",
                template: n(81752)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (SO = void 0 !== Cr && Cr) ? SO : Object])], CO);
            let wO = class {
            }
            ;
            wO = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [G_, CO],
                imports: [l.ez, Ai, p.UX],
                exports: [G_, CO]
            })], wO);
            let IO = class {
                transform(e, t) {
                    if (ue.isSet(e, "value"),
                    ue.isSet(t, "msgs"),
                    t[e])
                        return t[e]();
                    throw new Error(`The translation for ${e} could not be found`)
                }
            }
            ;
            IO = (0,
            c.gn)([(0,
            i.Pipe)({
                name: "localizeMessage"
            })], IO),
            o().module("ipconfigure.orchid.singularity").factory("BytesPipe", (0,
            r.dV)(er)).factory("TimeDurationPipe", (0,
            r.dV)(yl)).filter("bytes", ( () => er.transform)).filter("timeDuration", ( () => yl.transform));
            let TO = class {
            }
            ;
            var EO, _O, xO, DO;
            TO = (0,
            c.gn)([(0,
            i.NgModule)({
                providers: [Ja, er, Km, tr, IO, z_, yl],
                declarations: [Ja, er, Km, tr, IO, z_, yl],
                exports: [Ja, er, Km, tr, IO, z_, yl]
            })], TO);
            const OO = O("BulkDeleteCameraTagDialog");
            let AO = EO = class {
                constructor(e, t, n, i) {
                    this.dialogData = e,
                    this._tagService = t,
                    this._minimumVersionService = n,
                    this._renewableService = i,
                    this.msgs = Object.assign(Object.assign(Object.assign(Object.assign({}, L.messages.resourceTagging), L.messages.common), L.messages.errorBanner), {
                        close: L.messages.maps.close,
                        tryAgain: L.messages.events.eventsViewer.tryAgain
                    }),
                    this.icons = Object.assign(Object.assign({}, Ht), zt),
                    this.hasSomeUnsupportedCameras = !1,
                    this.hasAllUnsupportedCameras = !1,
                    this.showInfoPanel = !1,
                    this.infoPanelTitle = "",
                    this.infoPanelBodyText = "",
                    this.recorderIdRecord = [],
                    this.loading = !0,
                    this.processing = !1,
                    this.operationInProgress$ = this._tagService.bulkOperationInProgress$,
                    this.firstDeleteComplete = !1,
                    this.error = void 0,
                    this.deleteError = void 0,
                    this.VersionSpecificFeature = Sr,
                    this._destroy$ = new St.x,
                    this._failedCameras = []
                }
                get DeleteStatus() {
                    return gs
                }
                get numTagsToDelete() {
                    return this.firstDeleteComplete ? this._failedCameras.length : this.dialogData.tag.resourceCount
                }
                get oneOrMoreDeletesFailed() {
                    return this._failedCameras.length > 0
                }
                ngOnInit() {
                    this._fetchDialogDataAndFinishLoading()
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                confirmDelete() {
                    this.processing = !0,
                    this.hasSomeUnsupportedCameras = !1,
                    this.deleteError = void 0,
                    this.recorderIdRecord.forEach((e => {
                        e.cameraRecords = e.cameraRecords.filter((e => e.status !== gs.UNSUPPORTED)),
                        e.cameraRecords.forEach((e => e.status = gs.IN_PROGRESS))
                    }
                    )),
                    this.recorderIdRecord = [...this.recorderIdRecord.filter((e => e.cameraRecords.length > 0))];
                    const e = this.recorderIdRecord.flatMap((e => e.cameraRecords.filter((e => e.status !== gs.UNSUPPORTED)).map((t => ({
                        orchidId: e.recorderUUID,
                        cameraId: t.id
                    })))));
                    this._tagService.bulkDeleteCameraTags([{
                        key: this.dialogData.tag.key,
                        value: this.dialogData.tag.value
                    }], e).pipe((0,
                    pn.q)(1), (0,
                    Ir.x)(( () => {
                        this.firstDeleteComplete = !0,
                        this.processing = !1
                    }
                    )), (0,
                    oa.R)(this._destroy$)).subscribe({
                        next: e => {
                            this._handleBulkDeleteResponse(e)
                        }
                        ,
                        error: e => {
                            this._handleDeleteError(e)
                        }
                    })
                }
                retryFailedTags() {
                    this.processing = !0,
                    this.deleteError = void 0,
                    this.recorderIdRecord = bs(this._failedCameras, this._renewableService),
                    this.recorderIdRecord.forEach((e => {
                        e.cameraRecords.forEach((e => e.status = gs.IN_PROGRESS))
                    }
                    )),
                    this._tagService.bulkDeleteCameraTags([{
                        key: this.dialogData.tag.key,
                        value: this.dialogData.tag.value
                    }], this._failedCameras).pipe((0,
                    pn.q)(1), (0,
                    Ir.x)(( () => {
                        this.processing = !1
                    }
                    )), (0,
                    oa.R)(this._destroy$)).subscribe({
                        next: e => {
                            this._failedCameras = [],
                            this._handleBulkDeleteResponse(e)
                        }
                        ,
                        error: e => {
                            this._handleDeleteError(e)
                        }
                    })
                }
                _handleBulkDeleteResponse(e) {
                    e.forEach((e => {
                        const t = this.recorderIdRecord.find((t => t.recorderUUID === e.resource.orchidId));
                        if (t) {
                            const n = t.cameraRecords.find((t => t.id === e.resource.cameraId));
                            n && (n.status = ws(e),
                            n.status !== gs.SUCCESS && this._failedCameras.push({
                                cameraId: e.resource.cameraId,
                                orchidId: e.resource.orchidId
                            }))
                        }
                    }
                    ))
                }
                _handleDeleteError(e) {
                    var t, n;
                    this.recorderIdRecord.forEach((e => {
                        e.cameraRecords.forEach((e => e.status = void 0))
                    }
                    )),
                    this.deleteError = null !== (n = null === (t = e.error) || void 0 === t ? void 0 : t.reason) && void 0 !== n ? n : this.msgs.somethingWentWrong()
                }
                _fetchDialogDataAndFinishLoading() {
                    this._tagService.fetchCameraTagDetails(this.dialogData.tag).pipe((0,
                    lr.K)((e => {
                        var t, n;
                        return this.error = null !== (n = null === (t = e.error) || void 0 === t ? void 0 : t.reason) && void 0 !== n ? n : this.msgs.somethingWentWrong(),
                        (0,
                        ze.of)([])
                    }
                    )), (0,
                    oa.R)(this._destroy$)).subscribe({
                        next: e => {
                            this.recorderIdRecord = bs(e, this._renewableService),
                            this.hasSomeUnsupportedCameras = !1,
                            this.hasAllUnsupportedCameras = !0,
                            this.recorderIdRecord.forEach((e => {
                                e.cameraRecords.forEach((t => {
                                    this._minimumVersionService.isFeatureSupported(this._renewableService.findOrchid(e.recorderUUID), Sr.BULK_TAGGING) ? (t.status = gs.DEFAULT,
                                    this.hasAllUnsupportedCameras = !1) : (t.status = gs.UNSUPPORTED,
                                    this.hasSomeUnsupportedCameras = !0)
                                }
                                ))
                            }
                            )),
                            this.loading = !1
                        }
                        ,
                        error: e => {
                            OO.error(`Unexpected error during initialization: ${e}`)
                        }
                    })
                }
                static show(e, t) {
                    const n = {
                        data: t,
                        disableClose: !0,
                        panelClass: "bulk-delete-camera-tag-dialog-custom-panel-class"
                    };
                    return e.open(EO, n).afterClosed().pipe((0,
                    pn.q)(1))
                }
                handleTagStatusClick(e) {
                    switch (e) {
                    case gs.TIMED_OUT:
                        this.showInfoPanel = !0,
                        this.infoPanelTitle = this.msgs.requestTimedOut(),
                        this.infoPanelBodyText = this.msgs.operationStatusUncertainDescription();
                        break;
                    case gs.CANCELED:
                        this.showInfoPanel = !0,
                        this.infoPanelTitle = this.msgs.tagOperationCanceled(),
                        this.infoPanelBodyText = this.msgs.operationStatusUncertainDescription()
                    }
                }
            }
            ;
            var RO, PO, kO;
            AO = EO = (0,
            c.gn)([(0,
            i.Component)({
                selector: "bulk-delete-camera-tag",
                template: n(89675)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(oE)), (0,
            c.fM)(2, (0,
            i.Inject)(Cr)), (0,
            c.fM)(3, (0,
            i.Inject)(Gt)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (_O = void 0 !== oE && oE) ? _O : Object, "function" == typeof (xO = void 0 !== Cr && Cr) ? xO : Object, "function" == typeof (DO = Gt) ? DO : Object])], AO);
            let MO = class {
                constructor() {
                    this.filteredAutocompleteTags = (0,
                    ze.of)([]),
                    this.tagName = "",
                    this.tagValue = "",
                    this.canDelete = !0,
                    this.onTagDelete = new i.EventEmitter,
                    this.icons = Object.assign({}, Ht),
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.resourceTagging), L.messages.resourceTagging.tagEditor), L.messages.common)
                }
                markKeySelected(e, t) {
                    e.controls.selected.setValue(!0);
                    t.option.viewValue.includes(this.msgs.newTag()) ? e.controls.isNewTag.setValue(!0) : e.controls.isNewTag.setValue(!1)
                }
                clearInputIfNoKeySelected(e) {
                    !1 === e.controls.selected.value && (e.controls.key.setValue(""),
                    e.controls.isNewTag.setValue(!1))
                }
                revalidateTagKey(e) {
                    e.controls.key.updateValueAndValidity({
                        emitEvent: !0,
                        onlySelf: !0
                    })
                }
                deleteNewTag() {
                    this.onTagDelete.emit(null)
                }
                focusKeyInput() {
                    this.keyInput.nativeElement.focus()
                }
            }
            ;
            var LO, NO, FO, UO;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (RO = void 0 !== Ln.y && Ln.y) ? RO : Object)], MO.prototype, "filteredAutocompleteTags", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (PO = void 0 !== p.cw && p.cw) ? PO : Object)], MO.prototype, "newTagForm", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], MO.prototype, "tagName", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], MO.prototype, "tagValue", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], MO.prototype, "canDelete", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], MO.prototype, "onTagDelete", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("keyInput"), (0,
            c.w6)("design:type", "function" == typeof (kO = void 0 !== i.ElementRef && i.ElementRef) ? kO : Object)], MO.prototype, "keyInput", void 0),
            MO = (0,
            c.gn)([(0,
            i.Component)({
                selector: "new-tag-form",
                template: n(23488)
            })], MO);
            const $O = O("BulkDeleteRecorderTagDialog");
            let jO = LO = class {
                constructor(e, t, n, i) {
                    this.data = e,
                    this._tagService = t,
                    this._renewableService = n,
                    this._minimumVersionService = i,
                    this.ActionsIcons = Ht,
                    this.InformationIcons = zt,
                    this.showInfoPanel = !1,
                    this.infoPanelTitle = "",
                    this.infoPanelBodyText = "",
                    this.processing = !1,
                    this.componentState = xr.LOADING,
                    this.ComponentState = xr,
                    this.log = O("BulkDeleteRecorderTagDialog"),
                    this.bulkDeleteErrorMessage = "",
                    this.tagDetailsErrorMessage = "",
                    this.numFailedTagDeletions = 0,
                    this.canShowBanner = !1,
                    this.operationInProgress$ = this._tagService.bulkOperationInProgress$,
                    this.deleteOperationsCount = 0,
                    this.orchidsAffected = [],
                    this.ERROR_TYPE = wr,
                    this.showDeleteButton = !0,
                    this.hasSomeUnsupportedOrchids = !1,
                    this.hasAllUnsupportedOrchids = !1,
                    this._destroy$ = new St.x,
                    this.msgs = Object.assign(Object.assign(Object.assign(Object.assign(Object.assign({}, L.messages.resourceTagging), L.messages.common), L.messages.errorBanner), L.messages.dialogs), {
                        tag: L.messages.cameras.tag,
                        tryAgain: L.messages.errors.tryAgain
                    }),
                    this.VersionSpecificFeature = Sr
                }
                ngOnInit() {
                    this._fetchDialogDataAndFinishLoading()
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                delete() {
                    this.hasSomeUnsupportedOrchids = !1,
                    this.orchidsAffected = this.orchidsAffected.filter((e => e.status !== gs.SUCCESS && e.status !== gs.UNSUPPORTED)),
                    this.processing = !0,
                    this.canShowBanner = !1,
                    this.orchidsAffected.forEach((e => {
                        e.status = gs.IN_PROGRESS
                    }
                    ));
                    const e = this.orchidsAffected.map((e => e.uuid));
                    0 !== e.length ? this._tagService.bulkDeleteRecorderTags([this.data.tag], e).pipe((0,
                    pn.q)(1), (0,
                    Ir.x)(( () => {
                        this.processing = !1,
                        this.canShowBanner = !0
                    }
                    )), (0,
                    oa.R)(this._destroy$)).subscribe({
                        next: e => {
                            this._updateAffectedOrchids(e),
                            this._updateFailedDeleteOperationCount(),
                            this.showDeleteButton = !1
                        }
                        ,
                        error: e => {
                            this._handleBulkDeleteRecorderTagError(e)
                        }
                    }) : this.showDeleteButton = !1
                }
                _handleBulkDeleteRecorderTagError(e) {
                    return this.orchidsAffected.forEach((e => {
                        e.status = gs.DEFAULT
                    }
                    )),
                    this.bulkDeleteErrorMessage = e.error && e.error.reason ? e.error.reason : this.msgs.somethingWentWrong(),
                    this.log.error(`Failed to bulk delete recorder tag: ${this.bulkDeleteErrorMessage}`),
                    (0,
                    cr._)(( () => new Error(this.bulkDeleteErrorMessage)))
                }
                handleErrorMessageClose() {
                    this.bulkDeleteErrorMessage = ""
                }
                _updateAffectedOrchids(e) {
                    e.forEach((e => {
                        const t = this.orchidsAffected.findIndex((t => e.resource.orchidId === t.uuid));
                        -1 !== t && (this.orchidsAffected[t].status = ws(e))
                    }
                    ))
                }
                _updateFailedDeleteOperationCount() {
                    this.numFailedTagDeletions = this.orchidsAffected.filter((e => e.status === gs.FAILED)).length,
                    this.deleteOperationsCount = this.numFailedTagDeletions
                }
                _populateAffectedOrchids(e) {
                    e.forEach((e => {
                        const t = this._renewableService.findOrchid(e);
                        this.orchidsAffected.push({
                            name: t.name,
                            uri: t.uri,
                            uuid: e,
                            cameraCount: t.cameras.length,
                            status: this._minimumVersionService.isFeatureSupported(t, Sr.BULK_TAGGING) ? gs.DEFAULT : gs.UNSUPPORTED,
                            orchid: t
                        })
                    }
                    )),
                    this.hasSomeUnsupportedOrchids = !1,
                    this.hasAllUnsupportedOrchids = !0,
                    this.orchidsAffected.forEach((e => {
                        e.status === gs.UNSUPPORTED ? this.hasSomeUnsupportedOrchids = !0 : this.hasAllUnsupportedOrchids = !1
                    }
                    ))
                }
                _fetchDialogDataAndFinishLoading() {
                    this._tagService.fetchRecorderTagDetails(this.data.tag).pipe((0,
                    lr.K)((e => {
                        var t, n;
                        return this.tagDetailsErrorMessage = null !== (n = null === (t = e.error) || void 0 === t ? void 0 : t.reason) && void 0 !== n ? n : this.msgs.somethingWentWrong(),
                        this.log.error(`Failed to fetch tag details: ${e.statusText}`),
                        this.componentState = xr.ERROR,
                        (0,
                        ze.of)({
                            recorders: []
                        })
                    }
                    )), (0,
                    oa.R)(this._destroy$)).subscribe({
                        next: e => {
                            this._populateAffectedOrchids(e.recorders),
                            this.deleteOperationsCount = this.orchidsAffected.length,
                            this.componentState === xr.LOADING && (this.componentState = xr.LOADED)
                        }
                        ,
                        error: e => {
                            $O.error(`Unexpected error during initialization: ${e}`)
                        }
                    })
                }
                static openDialog(e, t) {
                    const n = {
                        disableClose: !0,
                        panelClass: "bulk-delete-recorder-tag-dialog-panel",
                        data: t
                    };
                    return e.open(LO, n).afterClosed().pipe((0,
                    pn.q)(1))
                }
                handleTagStatusClick(e) {
                    switch (e) {
                    case gs.TIMED_OUT:
                        this.showInfoPanel = !0,
                        this.infoPanelTitle = this.msgs.requestTimedOut(),
                        this.infoPanelBodyText = this.msgs.operationStatusUncertainDescription();
                        break;
                    case gs.CANCELED:
                        this.showInfoPanel = !0,
                        this.infoPanelTitle = this.msgs.tagOperationCanceled(),
                        this.infoPanelBodyText = this.msgs.operationStatusUncertainDescription()
                    }
                }
            }
            ;
            var VO, GO, BO, zO;
            jO = LO = (0,
            c.gn)([(0,
            i.Component)({
                selector: "bulk-delete-recorder-tag-dialog",
                template: n(49016)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.WI)), (0,
            c.fM)(1, (0,
            i.Inject)(oE)), (0,
            c.fM)(2, (0,
            i.Inject)(Gt)), (0,
            c.fM)(3, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (NO = void 0 !== oE && oE) ? NO : Object, "function" == typeof (FO = Gt) ? FO : Object, "function" == typeof (UO = void 0 !== Cr && Cr) ? UO : Object])], jO);
            let HO = class {
                constructor(e) {
                    this._dialog = e,
                    this.msgs = Object.assign(Object.assign({}, L.messages.resourceTagging), {
                        server: L.messages.notifications.server,
                        camera: L.messages.notifications.camera
                    }),
                    this.icons = Object.assign(Object.assign({}, zt), Ht),
                    this.resourceType = ps.SERVER,
                    this.tableData = [],
                    this.onResourceTagClick = new i.EventEmitter,
                    this.dataSource = new Ei.by([]),
                    this.pageSizeOptions = [10, 25, 50]
                }
                get resourceIcon() {
                    switch (this.resourceType) {
                    case ps.SERVER:
                        return this.icons.servers.server;
                    case ps.CAMERA:
                        return this.icons.camera
                    }
                }
                get resourceColumnName() {
                    switch (this.resourceType) {
                    case ps.SERVER:
                        return this.msgs.server();
                    case ps.CAMERA:
                        return this.msgs.camera()
                    }
                }
                ngAfterViewInit() {
                    this.dataSource.paginator = this.paginator,
                    this.dataSource.data = this.tableData,
                    this.dataSource.sort = this.sort
                }
                ngOnChanges(e) {
                    e.tableData && !e.tableData.firstChange && this.handleSort(this.sort)
                }
                handleResourceTagRowClick(e) {
                    this.onResourceTagClick.emit(e)
                }
                handleSort(e) {
                    const t = this.tableData.slice();
                    e.active && "" !== e.direction ? this.dataSource.data = t.sort(( (t, n) => {
                        const i = "asc" === e.direction;
                        switch (e.active) {
                        case "tag":
                            return t.key > n.key ? 1 * (i ? 1 : -1) : t.key < n.key ? -1 * (i ? 1 : -1) : 0;
                        case "resource":
                            return t.resourceCount > n.resourceCount ? 1 * (i ? 1 : -1) : t.resourceCount < n.resourceCount ? -1 * (i ? 1 : -1) : 0;
                        default:
                            return 0
                        }
                    }
                    )) : this.dataSource.data = t
                }
                openDeleteDialog(e) {
                    switch (this.resourceType) {
                    case ps.SERVER:
                        jO.openDialog(this._dialog, {
                            tag: e
                        });
                        break;
                    case ps.CAMERA:
                        AO.show(this._dialog, {
                            resourceType: this.resourceType,
                            tag: e
                        })
                    }
                }
            }
            ;
            var WO, qO, YO, XO;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], HO.prototype, "resourceType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], HO.prototype, "tableData", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (VO = void 0 !== i.EventEmitter && i.EventEmitter) ? VO : Object)], HO.prototype, "onResourceTagClick", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW), (0,
            c.w6)("design:type", "function" == typeof (GO = void 0 !== pi.NW && pi.NW) ? GO : Object)], HO.prototype, "paginator", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(Ii.YE), (0,
            c.w6)("design:type", "function" == typeof (BO = void 0 !== Ii.YE && Ii.YE) ? BO : Object)], HO.prototype, "sort", void 0),
            HO = (0,
            c.gn)([(0,
            i.Component)({
                selector: "summary-table",
                template: n(36506)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(hn.uw)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (zO = void 0 !== hn.uw && hn.uw) ? zO : Object])], HO);
            let KO = class {
                constructor(e, t) {
                    this._formBuilder = e,
                    this._versionService = t,
                    this.existingTags = [],
                    this.newTags = [],
                    this.tags = [],
                    this.icons = Object.assign({}, Ht),
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.resourceTagging), L.messages.resourceTagging.tagEditor), L.messages.common),
                    this.filteredAutocompleteTags = [],
                    this.resourceTagKeys = [],
                    this.nonAlphanumericTagValuesSupported = !0,
                    this.uniqueExistingTags = [],
                    this.tagType = "",
                    this.tagTitle = "",
                    this.tagName = "",
                    this.tagValue = "",
                    this.destroy$ = new St.x,
                    this._oldKeyInputsLength = 0
                }
                ngOnInit() {
                    w.isOrchid || this._versionService.isFeatureSupported(this.orchid, Sr.BULK_TAGGING) || (this.nonAlphanumericTagValuesSupported = !1),
                    this.resourceTagKeys = this.tags.map((e => e.key)),
                    this.uniqueExistingTags = this.existingTags.filter(( (e, t) => t === this.existingTags.findIndex((t => t.key === e.key)))),
                    this.setTagLabels()
                }
                ngAfterViewInit() {
                    this.keyInputs.changes.pipe((0,
                    oa.R)(this.destroy$)).subscribe(( () => {
                        this._oldKeyInputsLength < this.keyInputs.length && setTimeout(( () => {
                            this.keyInputs.last.focusKeyInput()
                        }
                        )),
                        this._oldKeyInputsLength = this.newTags.length
                    }
                    ))
                }
                ngOnDestroy() {
                    this.destroy$.next(),
                    this.destroy$.complete()
                }
                setTagLabels() {
                    switch (this.resourceType) {
                    case ps.CAMERA:
                        this.tagType = this.msgs.cameraTags(),
                        this.tagTitle = this.msgs.newCameraTags(),
                        this.tagName = this.msgs.cameraTagName(),
                        this.tagValue = this.msgs.cameraTagValue();
                        break;
                    case ps.SERVER:
                        this.tagType = this.msgs.serverTags(),
                        this.tagTitle = this.msgs.newServerTags(),
                        this.tagName = this.msgs.serverTagName(),
                        this.tagValue = this.msgs.serverTagValue();
                        break;
                    case ps.EVENT_SUBSCRIPTION:
                        this.tagType = this.msgs.eventSubscriptionTags(),
                        this.tagTitle = this.msgs.newEventSubscriptionTags(),
                        this.tagName = this.msgs.eventSubscriptionTagName(),
                        this.tagValue = this.msgs.eventSubscriptionTagValue()
                    }
                }
                deleteTag(e) {
                    this.tags.splice(e, 1),
                    this.newTags.forEach((e => e.controls.key.updateValueAndValidity()))
                }
                addNewTag(e, t) {
                    var n;
                    let i = null;
                    for (let e = 0; e < this.newTags.length; e++)
                        0 === this.newTags[e].controls.key.value.length && (i = e);
                    if (null !== i)
                        null === (n = this.keyInputs.get(i)) || void 0 === n || n.focusKeyInput();
                    else {
                        const n = this._formBuilder.group({
                            key: [null != e ? e : "", {
                                validators: [this._tagNameValidator()]
                            }],
                            value: [null != t ? t : "", {
                                validators: [this._tagValueValidator()]
                            }],
                            selected: !1,
                            isNewTag: !1
                        });
                        n.controls.key.markAsTouched(),
                        this.newTags.push(n),
                        this.filteredAutocompleteTags.push(n.controls.key.valueChanges.pipe((0,
                        sa.b)(( () => {
                            this.newTags.forEach((e => {
                                e.controls.key.updateValueAndValidity({
                                    emitEvent: !1,
                                    onlySelf: !0
                                })
                            }
                            ))
                        }
                        )), (0,
                        lu.O)(n.controls.key.value), (0,
                        He.U)((e => this._filterTagsForAutocomplete(e))))),
                        n.controls.key.valueChanges.pipe((0,
                        mf.x)(), (0,
                        oa.R)(this.destroy$)).subscribe(( () => n.controls.selected.setValue(!1)))
                    }
                }
                deleteNewTag(e) {
                    this.newTags.splice(e, 1),
                    this.filteredAutocompleteTags.splice(e, 1),
                    this.newTags.forEach((e => e.controls.key.updateValueAndValidity()))
                }
                _tagNameValidator() {
                    return e => {
                        const t = e.value.toLocaleLowerCase();
                        if ("" === t)
                            return {
                                errMsg: this.msgs.errors.tagNameRequired()
                            };
                        if (!oo.test(t))
                            return {
                                errMsg: this.msgs.errors.alphanumericCharactersOnly()
                            };
                        const n = this.tags.some((e => e.key === t))
                          , i = this.newTags.filter((e => e.controls.key.value.toLocaleLowerCase() === t)).length > 1;
                        return n || i ? {
                            errMsg: this.msgs.errors.noDuplicateTagNames()
                        } : t.length > 128 ? {
                            errMsg: this.msgs.errors.tagNameTooLong()
                        } : null
                    }
                }
                _tagValueValidator() {
                    return e => {
                        const t = e.value.toLocaleLowerCase();
                        return this.nonAlphanumericTagValuesSupported || oo.test(t) ? t.length > 128 ? {
                            errMsg: this.msgs.errors.tagValueTooLong()
                        } : null : {
                            errMsg: this.msgs.errors.alphanumericCharactersOnly()
                        }
                    }
                }
                _filterTagsForAutocomplete(e) {
                    const t = e.toLocaleLowerCase()
                      , n = new Set([...this.newTags.map((e => e.value.key)), ...this.tags.map((e => e.key))]);
                    let i = this.uniqueExistingTags.slice().sort(( (e, n) => e.key === t ? -1 : n.key === t ? 1 : _t(e.key, n.key))).filter((e => {
                        const i = e.key.toLocaleLowerCase();
                        return n.has(i) && i === t || !n.has(i) && i.includes(t)
                    }
                    ));
                    const a = i.length;
                    return i = i.slice(0, 49),
                    t.length > 0 && void 0 === this.uniqueExistingTags.find((e => e.key === t)) && i.push({
                        key: e,
                        value: null,
                        displayValue: e + " " + this.msgs.newTag()
                    }),
                    a > hs && i.push({
                        key: "",
                        value: "",
                        disabled: !0,
                        displayValue: this.msgs.plusVALUEMore({
                            VALUE: a - hs
                        })
                    }),
                    i
                }
            }
            ;
            var ZO, JO, QO;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], KO.prototype, "existingTags", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], KO.prototype, "newTags", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (WO = void 0 !== ps && ps) ? WO : Object)], KO.prototype, "resourceType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], KO.prototype, "tags", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], KO.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.ViewChildren)(MO), (0,
            c.w6)("design:type", "function" == typeof (qO = void 0 !== i.QueryList && i.QueryList) ? qO : Object)], KO.prototype, "keyInputs", void 0),
            KO = (0,
            c.gn)([(0,
            i.Component)({
                selector: "tag-editor",
                template: n(19473)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(p.qu)), (0,
            c.fM)(1, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (YO = void 0 !== p.qu && p.qu) ? YO : Object, "function" == typeof (XO = void 0 !== Cr && Cr) ? XO : Object])], KO);
            let eA = class {
                constructor(e) {
                    this._formBuilder = e,
                    this.existingTags = [],
                    this.newTags = [],
                    this.tags = [],
                    this.canEditTags = !0,
                    this.isSingleTag = !1,
                    this.icons = Object.assign({}, Ht),
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.resourceTagging), L.messages.resourceTagging.tagEditor), L.messages.common),
                    this.filteredAutocompleteTags = [],
                    this.resourceTagKeys = [],
                    this.uniqueExistingTags = [],
                    this.tagType = "",
                    this.tagTitle = "",
                    this.tagName = "",
                    this.tagValue = "",
                    this.destroy$ = new St.x,
                    this._oldKeyInputsLength = 0
                }
                ngOnInit() {
                    const e = Array.from(new Set(this.existingTags.map((e => e.key))));
                    this.uniqueExistingTags = e.map((e => ({
                        key: e
                    }))).sort(( (e, t) => _t(e.key, t.key))),
                    this.tags.length > 0 ? this.tags.forEach((e => {
                        this.createTagForm(e.key, e.value)
                    }
                    )) : this.addNewTag(),
                    this.setTagLabels()
                }
                ngOnChanges(e) {
                    e.canEditTags && (this.canEditTags ? this.newTags.forEach((e => e.enable())) : this.newTags.forEach((e => e.disable())))
                }
                ngAfterViewInit() {
                    this.keyInputs.changes.pipe((0,
                    oa.R)(this.destroy$)).subscribe(( () => {
                        this._oldKeyInputsLength < this.keyInputs.length && setTimeout(( () => {
                            this.keyInputs.last.focusKeyInput()
                        }
                        )),
                        this._oldKeyInputsLength = this.newTags.length
                    }
                    ))
                }
                ngOnDestroy() {
                    this.destroy$.next(),
                    this.destroy$.complete()
                }
                setTagLabels() {
                    switch (this.resourceType) {
                    case ps.CAMERA:
                        this.tagType = this.msgs.cameraTags(),
                        this.tagTitle = this.msgs.newCameraTags(),
                        this.tagName = this.msgs.cameraTagName(),
                        this.tagValue = this.msgs.cameraTagValue();
                        break;
                    case ps.SERVER:
                        this.tagType = this.msgs.serverTags(),
                        this.tagTitle = this.msgs.newServerTags(),
                        this.tagName = this.msgs.serverTagName(),
                        this.tagValue = this.msgs.serverTagValue();
                        break;
                    case ps.EVENT_SUBSCRIPTION:
                        this.tagType = this.msgs.eventSubscriptionTags(),
                        this.tagTitle = this.msgs.newEventSubscriptionTags(),
                        this.tagName = this.msgs.eventSubscriptionTagName(),
                        this.tagValue = this.msgs.eventSubscriptionTagValue()
                    }
                }
                deleteTag(e) {
                    this.tags.splice(e, 1),
                    this.newTags.forEach((e => e.controls.key.updateValueAndValidity()))
                }
                addNewTag(e, t) {
                    var n;
                    let i = null;
                    for (let e = 0; e < this.newTags.length; e++)
                        0 === this.newTags[e].controls.key.value.length && (i = e);
                    null !== i ? null === (n = this.keyInputs.get(i)) || void 0 === n || n.focusKeyInput() : this.createTagForm(e, t)
                }
                createTagForm(e, t) {
                    const n = this._formBuilder.group({
                        key: [{
                            value: null != e ? e : "",
                            disabled: !this.canEditTags
                        }, {
                            validators: this.canEditTags ? [this._tagNameValidator()] : []
                        }],
                        value: [{
                            value: null != t ? t : "",
                            disabled: !this.canEditTags
                        }, {
                            validators: this.canEditTags ? [this._tagValueValidator()] : []
                        }],
                        selected: !1,
                        isNewTag: !1
                    });
                    n.controls.key.markAsTouched(),
                    this.newTags.push(n),
                    this.filteredAutocompleteTags.push(n.controls.key.valueChanges.pipe((0,
                    sa.b)(( () => {
                        this.newTags.forEach((e => {
                            e.controls.key.updateValueAndValidity({
                                emitEvent: !1,
                                onlySelf: !0
                            })
                        }
                        ))
                    }
                    )), (0,
                    lu.O)(n.controls.key.value), (0,
                    He.U)((e => this._filterTagsForAutocomplete(e))))),
                    n.controls.key.valueChanges.pipe((0,
                    mf.x)(), (0,
                    oa.R)(this.destroy$)).subscribe(( () => n.controls.selected.setValue(!1)))
                }
                deleteNewTag(e) {
                    this.newTags.splice(e, 1),
                    this.filteredAutocompleteTags.splice(e, 1),
                    this.newTags.forEach((e => e.controls.key.updateValueAndValidity()))
                }
                _tagNameValidator() {
                    return e => {
                        const t = e.value.toLocaleLowerCase();
                        if ("" === t)
                            return {
                                errMsg: this.msgs.errors.tagNameRequired()
                            };
                        if (!oo.test(t))
                            return {
                                errMsg: this.msgs.errors.alphanumericCharactersOnly()
                            };
                        const n = this.tags.some((e => e.key === t))
                          , i = this.newTags.filter((e => e.controls.key.value.toLocaleLowerCase() === t)).length > 1;
                        return n || i ? {
                            errMsg: this.msgs.errors.noDuplicateTagNames()
                        } : t.length > 128 ? {
                            errMsg: this.msgs.errors.tagNameTooLong()
                        } : null
                    }
                }
                _tagValueValidator() {
                    return e => e.value.toLocaleLowerCase().length > 128 ? {
                        errMsg: this.msgs.errors.tagValueTooLong()
                    } : null
                }
                _filterTagsForAutocomplete(e) {
                    const t = e.toLocaleLowerCase()
                      , n = new Set([...this.newTags.map((e => e.value.key)), ...this.tags.map((e => e.key))]);
                    let i = this.uniqueExistingTags.slice().sort(( (e, n) => e.key === t ? -1 : n.key === t ? 1 : _t(e.key, n.key))).filter((e => {
                        const i = e.key.toLocaleLowerCase();
                        return n.has(i) && i === t || !n.has(i) && i.includes(t)
                    }
                    ));
                    const a = i.length;
                    return i = i.slice(0, 50),
                    t.length > 0 && void 0 === this.uniqueExistingTags.find((e => e.key === t)) && i.push({
                        key: e,
                        displayValue: e + " " + this.msgs.newTag()
                    }),
                    a > 50 && i.push({
                        key: "",
                        disabled: !0,
                        displayValue: this.msgs.plusVALUEMore({
                            VALUE: a - 50
                        })
                    }),
                    i
                }
            }
            ;
            var tA, nA, iA;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], eA.prototype, "existingTags", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], eA.prototype, "newTags", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (ZO = void 0 !== ps && ps) ? ZO : Object)], eA.prototype, "resourceType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], eA.prototype, "tags", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], eA.prototype, "canEditTags", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], eA.prototype, "isSingleTag", void 0),
            (0,
            c.gn)([(0,
            i.ViewChildren)(MO), (0,
            c.w6)("design:type", "function" == typeof (JO = void 0 !== i.QueryList && i.QueryList) ? JO : Object)], eA.prototype, "keyInputs", void 0),
            eA = (0,
            c.gn)([(0,
            i.Component)({
                selector: "multi-new-tag-form",
                template: n(93479)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(p.qu)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (QO = void 0 !== p.qu && p.qu) ? QO : Object])], eA);
            let aA = class {
                constructor() {
                    this.icons = Object.assign(Object.assign({}, Ht), zt),
                    this.operationType = uD.ADD,
                    this.recorderCameras = [],
                    this.count = 0,
                    this.onTagClick = new i.EventEmitter,
                    this.paginatedRecorders = [],
                    this.pageSizeOptions = [10, 25, 50],
                    this.pageSize = 10,
                    this.pageIndex = 0,
                    this.isPaginationVisible = !0,
                    this.TagOperationType = uD,
                    this._destroy$ = new St.x,
                    this.msgs = Object.assign(Object.assign({}, L.messages.resourceTagging), L.messages.common)
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                ngOnChanges(e) {
                    e.recorderCameras && (this.isPaginationVisible = this.recorderCameras.length > this.pageSize,
                    this.paginatedRecorders = Mc(this.recorderCameras, this.pageSize, this.pageIndex))
                }
                onPaginatorChange(e) {
                    this.paginatedRecorders = Mc(this.recorderCameras, e.pageSize, e.pageIndex)
                }
                handleTagStatusClick(e) {
                    this.onTagClick.emit(e)
                }
            }
            ;
            var rA, sA, oA;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (tA = void 0 !== uD && uD) ? tA : Object)], aA.prototype, "operationType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], aA.prototype, "recorderCameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], aA.prototype, "count", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (nA = void 0 !== i.EventEmitter && i.EventEmitter) ? nA : Object)], aA.prototype, "onTagClick", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW), (0,
            c.w6)("design:type", "function" == typeof (iA = void 0 !== pi.NW && pi.NW) ? iA : Object)], aA.prototype, "paginator", void 0),
            aA = (0,
            c.gn)([(0,
            i.Component)({
                selector: "affected-recorder-cameras",
                template: n(70565)
            })], aA);
            let cA = class {
                constructor() {
                    this.icons = Object.assign(Object.assign({}, Ht), zt),
                    this.operationType = uD.ADD,
                    this.onTagClick = new i.EventEmitter,
                    this.paginatedCameras = [],
                    this.pageSizeOptions = [10, 25, 50],
                    this.pageSize = 10,
                    this.pageIndex = 0,
                    this.isPaginationVisible = !0,
                    this.CameraTagOperationStatus = gs,
                    this.TagOperationType = uD,
                    this._destroy$ = new St.x,
                    this.msgs = Object.assign(Object.assign({}, L.messages.resourceTagging), L.messages.common)
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                ngOnChanges(e) {
                    e.recorder && (this.isPaginationVisible = this.recorder.cameraRecords.length > this.pageSize,
                    this.paginatedCameras = Mc(this.recorder.cameraRecords, this.pageSize, this.pageIndex))
                }
                onPaginatorChange(e) {
                    this.paginatedCameras = Mc(this.recorder.cameraRecords, e.pageSize, e.pageIndex)
                }
                handleTagClick(e) {
                    this.onTagClick.emit(e)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (rA = void 0 !== uD && uD) ? rA : Object)], cA.prototype, "operationType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], cA.prototype, "recorder", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (sA = void 0 !== i.EventEmitter && i.EventEmitter) ? sA : Object)], cA.prototype, "onTagClick", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(pi.NW), (0,
            c.w6)("design:type", "function" == typeof (oA = void 0 !== pi.NW && pi.NW) ? oA : Object)], cA.prototype, "paginator", void 0),
            cA = (0,
            c.gn)([(0,
            i.Component)({
                selector: "affected-cameras",
                template: n(32514)
            })], cA);
            const lA = (0,
            Jo.X$)("expandEnterLeave", [(0,
            Jo.eR)(":enter", [(0,
            Jo.oB)({
                opacity: 0,
                height: 0,
                transform: "translateY(3px)"
            }), (0,
            Jo.ru)([(0,
            Jo.jt)("225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
            Jo.oB)({
                height: "*"
            })), (0,
            Jo.jt)("525ms 100ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
            Jo.oB)({
                opacity: 1,
                transform: "translateY(0)"
            }))])]), (0,
            Jo.eR)(":leave", [(0,
            Jo.jt)("225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
            Jo.oB)({
                opacity: 0,
                height: 0
            }))])])
              , dA = [(0,
            Jo.X$)("fadeEnter", [(0,
            Jo.eR)(":enter", [(0,
            Jo.oB)({
                opacity: 0
            }), (0,
            Jo.jt)("225ms 225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
            Jo.oB)({
                opacity: 1
            }))])]), (0,
            Jo.X$)("fadeLeave", [(0,
            Jo.eR)(":leave", [(0,
            Jo.jt)("225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
            Jo.oB)({
                opacity: 0
            }))])]), (0,
            Jo.X$)("fadeEnterLeave", [(0,
            Jo.eR)(":enter", [(0,
            Jo.oB)({
                opacity: 0,
                transform: "translateY(10px)"
            }), (0,
            Jo.jt)("225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
            Jo.oB)({
                opacity: 1,
                transform: "translateY(0)"
            }))]), (0,
            Jo.eR)(":leave", [(0,
            Jo.jt)("225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
            Jo.oB)({
                opacity: 0
            }))])])];
            (0,
            Jo.X$)("slideDownUp", [(0,
            Jo.eR)(":enter", [(0,
            Jo.oB)({
                height: 0,
                opacity: 0
            }), (0,
            Jo.jt)("0.2s ease-out", (0,
            Jo.oB)({
                height: "*",
                opacity: 1
            }))]), (0,
            Jo.eR)(":leave", [(0,
            Jo.oB)({
                height: "*",
                opacity: 1
            }), (0,
            Jo.jt)("0.2s ease-in", (0,
            Jo.oB)({
                height: 0,
                opacity: 0
            }))])]),
            (0,
            Jo.X$)("slideDownUpBoolean", [(0,
            Jo.SB)("true", (0,
            Jo.oB)({
                height: "*",
                opacity: 1,
                visibility: "visible"
            })), (0,
            Jo.SB)("false", (0,
            Jo.oB)({
                height: "0px",
                opacity: 0,
                visibility: "hidden"
            })), (0,
            Jo.eR)("false <=> true", [(0,
            Jo.jt)(200)])]),
            (0,
            Jo.X$)("openClose", [(0,
            Jo.eR)(":enter", [(0,
            Jo.oB)({
                height: 0
            }), (0,
            Jo.jt)("0.2s ease-out", (0,
            Jo.oB)({
                height: "*"
            }))]), (0,
            Jo.eR)(":leave", [(0,
            Jo.oB)({
                height: "*"
            }), (0,
            Jo.jt)("0.2s ease-in", (0,
            Jo.oB)({
                height: 0
            }))])]),
            (0,
            Jo.X$)("slideInLeft", [(0,
            Jo.eR)(":enter", [(0,
            Jo.oB)({
                transform: "translateX(-100%)"
            }), (0,
            Jo.jt)("0.3s ease-out", (0,
            Jo.oB)({
                transform: "translateX(0%)"
            }))])]),
            (0,
            Jo.X$)("slideInRight", [(0,
            Jo.eR)(":enter", [(0,
            Jo.oB)({
                transform: "translateX(+100%)"
            }), (0,
            Jo.jt)("0.3s ease-out", (0,
            Jo.oB)({
                transform: "translateX(0%)"
            }))])]),
            (0,
            Jo.X$)("blockInitialRenderAnimation", [(0,
            Jo.eR)(":enter", [])]);
            var uA;
            let mA = class {
                constructor(e) {
                    this._tagService = e,
                    this.waitIcon = zt.wait,
                    this._destroy$ = new St.x,
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.resourceTagging.operationInProgress), L.messages.common), L.messages.errorBanner),
                    this.isExpanded = !1,
                    this.cancelErrorMessage = "",
                    this.hasError = !1,
                    this.processing = !1,
                    this.onCancel = new i.EventEmitter,
                    this.animate = !0
                }
                ngOnDestroy() {
                    this._destroy$.next(),
                    this._destroy$.complete()
                }
                hideDetails() {
                    this.hasError = !1,
                    this.cancelErrorMessage = "",
                    this.isExpanded = !1
                }
                showDetails() {
                    this.isExpanded = !0
                }
                handleCancelOperation() {
                    this.cancelErrorMessage = "",
                    this.hasError = !1,
                    this.processing = !0,
                    this._tagService.cancelBulkOperation().pipe((0,
                    pn.q)(1), (0,
                    oa.R)(this._destroy$)).subscribe({
                        next: e => {
                            this.processing = !1,
                            e.status === fs.BUSY ? (this.hasError = !0,
                            this.cancelErrorMessage = this.msgs.unableToCancelOperation()) : this.onCancel.emit()
                        }
                        ,
                        error: e => {
                            var t;
                            this.processing = !1,
                            this.hasError = !0,
                            this.cancelErrorMessage = null !== (t = e.error.reason) && void 0 !== t ? t : this.msgs.somethingWentWrong()
                        }
                    })
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], mA.prototype, "onCancel", void 0),
            (0,
            c.gn)([(0,
            i.HostBinding)("@fadeEnterLeave"), (0,
            c.w6)("design:type", Object)], mA.prototype, "animate", void 0),
            mA = (0,
            c.gn)([(0,
            i.Component)({
                selector: "operation-in-progress",
                template: n(70),
                animations: [lA, ...dA]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(oE)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (uA = void 0 !== oE && oE) ? uA : Object])], mA);
            let hA = class {
            }
            ;
            hA = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [cA, aA, mD, AO, TD, bD, SE, eA, MO, mA, wE, CE, fE, HO, KO, hE, jO],
                imports: [l.ez, qD, ym, p.u5, Ai, p.UX, PE],
                exports: [MO, wE, CE, KO],
                providers: [oE],
                entryComponents: [SE, wE, CE, fE, hE, jO, AO]
            })], hA);
            let pA = class {
            }
            ;
            pA = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [tE],
                entryComponents: [tE],
                exports: [tE],
                imports: [l.ez, Ai, ym, hA, p.UX]
            })], pA);
            let gA = class {
            }
            ;
            var fA, vA, yA;
            gA = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [ax, V_],
                entryComponents: [V_],
                imports: [l.ez, ym, Ai, wO, TO, p.UX, hA, pA, PE],
                exports: []
            })], gA);
            let bA = class {
                constructor(e, t) {
                    this._dataService = e,
                    this._minimumVersionService = t,
                    this.msgs = {},
                    this.cameras = [],
                    this.handleSelectCamera = new i.EventEmitter,
                    this._cameraDisablementIsSupported = !0
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign({}, L.messages.events.eventDetails), L.messages.events.eventsViewer),
                    w.isOrchid || (this._cameraDisablementIsSupported = this._minimumVersionService.isFeatureSupported(this.orchid, Sr.CAMERA_DISABLEMENT))
                }
                ngOnChanges() {
                    this.event && (this.cameras = this.event.cameras.map((e => Object.assign(Object.assign({}, e), {
                        thumbnail: this.getPreviewImage(e.id)
                    }))))
                }
                getPreviewImage(e) {
                    return this._dataService.cameraPreviewUrl(this.orchid.id, e, j.SMALL, !0)
                }
                getEventSourceLabelText(e) {
                    return e === tm.ONVIF ? this.msgs.onvifTopic() : this.msgs.sourceCamera()
                }
                cameraIsEnabled(e) {
                    var t;
                    return !this._cameraDisablementIsSupported || null !== (t = e.active) && void 0 !== t && t
                }
            }
            ;
            var SA, CA, wA, IA, TA, EA, _A, xA;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], bA.prototype, "event", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], bA.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (fA = void 0 !== i.EventEmitter && i.EventEmitter) ? fA : Object)], bA.prototype, "handleSelectCamera", void 0),
            bA = (0,
            c.gn)([(0,
            i.Component)({
                selector: "event-details",
                template: n(74634)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(tt)), (0,
            c.fM)(1, (0,
            i.Inject)(Cr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (vA = tt) ? vA : Object, "function" == typeof (yA = void 0 !== Cr && Cr) ? yA : Object])], bA),
            function(e) {
                e["1HOUR"] = "1HOUR",
                e["12HOURS"] = "12HOURS",
                e["24HOURS"] = "24HOURS",
                e.DATE_RANGE = "DATE_RANGE",
                e.ALL = "ALL"
            }(xA || (xA = {}));
            let DA = class {
                constructor(e, t) {
                    this.formBuilder = e,
                    this.dateRangeDialog = t,
                    this.msgs = {},
                    this.handleFiltersChanges = new i.EventEmitter,
                    this.categories = [],
                    this.dateFilterOptions = [],
                    this.separatorKeysCodes = [ia.K5, ia.OC],
                    this.isDateRangeDirty = !1,
                    this.eventNameSearchTerms = [],
                    this.cameraNameSearchTerms = [],
                    this.eventStateFilters = [],
                    this.dateFilterOptionSelected = !1
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign({}, L.messages.events.eventsFilters), {
                        eventName: L.messages.events.eventName,
                        cameraName: L.messages.cameras.cameraName
                    }),
                    this.dateFilterOptions = [{
                        id: xA["1HOUR"],
                        label: this.msgs.lastHour()
                    }, {
                        id: xA["12HOURS"],
                        label: this.msgs.last12Hours()
                    }, {
                        id: xA["24HOURS"],
                        label: this.msgs.last24Hours()
                    }, {
                        id: xA.DATE_RANGE,
                        label: ""
                    }, {
                        id: xA.ALL,
                        label: this.msgs.all()
                    }],
                    this.defaultDateFilterOption = this.dateFilterOptions[this.dateFilterOptions.length - 1].id,
                    this.dateFilterOptionSelected = !1,
                    this.filtersForm = this.formBuilder.group({
                        selectedCategories: new p.NI([]),
                        selectedDateFilter: new p.NI(this.defaultDateFilterOption)
                    }),
                    this.selectedDateRange = this.resetDateRange()
                }
                ngOnChanges(e) {
                    e.orchid && !e.orchid.firstChange && (this.handleResetClick(),
                    this.accordion.closeAll())
                }
                handleSearchClick() {
                    var e, t;
                    const n = null === (e = this.filtersForm) || void 0 === e ? void 0 : e.value.selectedCategories
                      , i = this.getDateFilterData();
                    let a = []
                      , r = []
                      , s = [];
                    this.eventNameSearchTerms.length > 0 && (r = this.subscriptions.filter((e => this.eventNameSearchTerms.some((t => e.name.toLowerCase().indexOf(t.toLowerCase()) > -1)))).map((e => e.id.toString()))),
                    this.cameraNameSearchTerms.length > 0 && (s = this.subscriptions.filter((e => e.cameras.filter((e => this.cameraNameSearchTerms.some((t => e.name.toLowerCase().indexOf(t.toLowerCase()) > -1)))).length > 0)).map((e => e.id.toString()))),
                    this.cameraNameSearchTerms.length > 0 && this.eventNameSearchTerms.length > 0 && (a = r.filter((e => s.includes(e)))),
                    this.cameraNameSearchTerms.length > 0 && 0 === this.eventNameSearchTerms.length && (a = s),
                    0 === this.cameraNameSearchTerms.length && this.eventNameSearchTerms.length > 0 && (a = r),
                    this.handleFiltersChanges.emit({
                        categoryIds: n.map((e => e.id)),
                        range: i,
                        isDateRange: (null === (t = this.filtersForm) || void 0 === t ? void 0 : t.value.selectedDateFilter) === xA.DATE_RANGE,
                        eventNameSearchTerms: this.eventNameSearchTerms,
                        cameraNameSearchTerms: this.cameraNameSearchTerms,
                        eventStateFilters: this.eventStateFilters,
                        subscriptionIds: a
                    })
                }
                handleResetClick() {
                    var e;
                    null === (e = this.filtersForm) || void 0 === e || e.reset({
                        selectedCategories: [],
                        selectedDateFilter: this.defaultDateFilterOption
                    }),
                    this.eventNameSearchTerms = [],
                    this.cameraNameSearchTerms = [],
                    this.eventStateFilters = [],
                    this._activeToggle.checked = !1,
                    this._inactiveToggle.checked = !1,
                    this._nullToggle.checked = !1,
                    this.selectedDateRange = this.resetDateRange(),
                    this.dateFilterOptionSelected = !1,
                    this.handleSearchClick()
                }
                resetDateRange() {
                    return {
                        start: {
                            timestamp: Date.now() - 864e5,
                            label: this.msgs.fromDate()
                        },
                        end: {
                            timestamp: Date.now(),
                            label: this.msgs.toDate()
                        }
                    }
                }
                getDateFilterData() {
                    var e, t, n;
                    const i = null === (e = this.filtersForm) || void 0 === e ? void 0 : e.controls.selectedDateFilter.value
                      , a = new Date;
                    let r;
                    switch (i) {
                    case xA["1HOUR"]:
                        return r = new Date(a.getTime() - 36e5),
                        {
                            from: r.getTime(),
                            to: a.getTime()
                        };
                    case xA["12HOURS"]:
                        return r = new Date(a.getTime() - 432e5),
                        {
                            from: r.getTime(),
                            to: a.getTime()
                        };
                    case xA["24HOURS"]:
                        return r = new Date(a.getTime() - 864e5),
                        {
                            from: r.getTime(),
                            to: a.getTime()
                        };
                    case xA.DATE_RANGE:
                        return {
                            from: null === (t = this.selectedDateRange) || void 0 === t ? void 0 : t.start.timestamp,
                            to: (null === (n = this.selectedDateRange) || void 0 === n ? void 0 : n.end.timestamp) || 0
                        };
                    default:
                        return {
                            from: void 0,
                            to: Date.now()
                        }
                    }
                }
                openDateRangeDialog() {
                    this.isDateRangeDirty || (this.selectedDateRange = this.resetDateRange());
                    this.dateRangeDialog.open(fw, {
                        width: "500px",
                        data: this.selectedDateRange
                    }).afterClosed().subscribe((e => {
                        e && (this.selectedDateRange = {
                            start: e.start,
                            end: e.end
                        },
                        this.isDateRangeDirty = !0)
                    }
                    ))
                }
                handleDateRadioButtonClick(e) {
                    this.dateFilterOptionSelected = e.id !== xA.ALL,
                    e.id === xA.DATE_RANGE && this.openDateRangeDialog()
                }
                onSearchTermAdded(e, t) {
                    const n = e.input
                      , i = e.value;
                    (i || "").trim() && ("camera" === t ? this.cameraNameSearchTerms.push(i) : "event" === t && this.eventNameSearchTerms.push(i)),
                    n.value = ""
                }
                onSearchTermRemoved(e, t) {
                    let n = [];
                    "camera" === t ? n = this.cameraNameSearchTerms : "event" === t && (n = this.eventNameSearchTerms);
                    const i = n.indexOf(e);
                    i > -1 && n.splice(i, 1)
                }
                onStatusToggleChange(e, t) {
                    const n = !1 === this._orchidSupportsMultipleActiveStates();
                    switch (t) {
                    case "active":
                        if (e.checked)
                            n ? (this.eventStateFilters = ["true"],
                            this._inactiveToggle.checked = !1,
                            this._nullToggle.checked = !1) : this.eventStateFilters.push("true");
                        else {
                            const e = this.eventStateFilters.indexOf("true");
                            e > -1 && this.eventStateFilters.splice(e, 1)
                        }
                        break;
                    case "inactive":
                        if (e.checked)
                            n ? (this.eventStateFilters = ["false"],
                            this._activeToggle.checked = !1,
                            this._nullToggle.checked = !1) : this.eventStateFilters.push("false");
                        else {
                            const e = this.eventStateFilters.indexOf("false");
                            e > -1 && this.eventStateFilters.splice(e, 1)
                        }
                        break;
                    case "no state":
                        if (e.checked)
                            n ? (this.eventStateFilters = ["null"],
                            this._activeToggle.checked = !1,
                            this._inactiveToggle.checked = !1) : this.eventStateFilters.push("null");
                        else {
                            const e = this.eventStateFilters.indexOf("null");
                            e > -1 && this.eventStateFilters.splice(e, 1)
                        }
                    }
                }
                _orchidSupportsMultipleActiveStates() {
                    if (w.isOrchid)
                        return !0;
                    const [e,t] = this.orchid.version.version.split(".");
                    return 0 === parseInt(e) || parseInt(e) >= 23 && parseInt(t) > 6
                }
            }
            ;
            var OA, AA, RA, PA;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], DA.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (SA = void 0 !== i.EventEmitter && i.EventEmitter) ? SA : Object)], DA.prototype, "handleFiltersChanges", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], DA.prototype, "categories", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], DA.prototype, "subscriptions", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("activeToggle"), (0,
            c.w6)("design:type", "function" == typeof (CA = void 0 !== Si.Rr && Si.Rr) ? CA : Object)], DA.prototype, "_activeToggle", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("inactiveToggle"), (0,
            c.w6)("design:type", "function" == typeof (wA = void 0 !== Si.Rr && Si.Rr) ? wA : Object)], DA.prototype, "_inactiveToggle", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("nullToggle"), (0,
            c.w6)("design:type", "function" == typeof (IA = void 0 !== Si.Rr && Si.Rr) ? IA : Object)], DA.prototype, "_nullToggle", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)(ci.pp), (0,
            c.w6)("design:type", "function" == typeof (TA = void 0 !== ci.pp && ci.pp) ? TA : Object)], DA.prototype, "accordion", void 0),
            DA = (0,
            c.gn)([(0,
            i.Component)({
                selector: "events-filters",
                template: n(24490)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(p.qu)), (0,
            c.fM)(1, (0,
            i.Inject)(hn.uw)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (EA = void 0 !== p.qu && p.qu) ? EA : Object, "function" == typeof (_A = void 0 !== hn.uw && hn.uw) ? _A : Object])], DA),
            function(e) {
                e.ready = "ready",
                e.awaitingAuth = "awaiting-auth"
            }(PA || (PA = {}));
            let kA = class {
                constructor(e, t) {
                    this._authenticator = e,
                    this._sanitizer = t,
                    this.msgs = L.messages.iFrameApiPlayer,
                    this.time = 0,
                    this.onIFrameReady = new i.EventEmitter,
                    this._iFrameIsReady = !1,
                    this.source = this._sanitizer.bypassSecurityTrustResourceUrl("#!/player?single-player=true&show-header=true&show-dewarp=true&single-player-ptz=true&manage-ptz-presets=true&doNotStart=true&single-player=true")
                }
                get iFrameIsReady() {
                    return this._iFrameIsReady && void 0 !== this.orchid && void 0 !== this.camera
                }
                ngOnChanges() {
                    var e, t;
                    this.orchid && this.camera && (null === (t = null === (e = this._iframe) || void 0 === e ? void 0 : e.nativeElement.contentWindow) || void 0 === t || t.postMessage({
                        orchidId: this.orchid.id,
                        cameraId: this.camera.id,
                        time: this.time
                    }, "*"))
                }
                _onMessage(e) {
                    var t, n;
                    e === PA.ready && (this._iFrameIsReady = !0,
                    this.onIFrameReady.emit()),
                    e === PA.awaitingAuth && (null === (n = null === (t = this._iframe) || void 0 === t ? void 0 : t.nativeElement.contentWindow) || void 0 === n || n.postMessage({
                        sid: this._authenticator.getAuthenticationData().sessionId
                    }, "*"))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Number)], kA.prototype, "id", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], kA.prototype, "orchid", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], kA.prototype, "camera", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], kA.prototype, "time", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], kA.prototype, "onIFrameReady", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("player"), (0,
            c.w6)("design:type", "function" == typeof (OA = void 0 !== i.ElementRef && i.ElementRef) ? OA : Object)], kA.prototype, "_iframe", void 0),
            (0,
            c.gn)([(0,
            i.HostListener)("window:message", ["$event.data.event.type"]), (0,
            c.w6)("design:type", Function), (0,
            c.w6)("design:paramtypes", [String]), (0,
            c.w6)("design:returntype", void 0)], kA.prototype, "_onMessage", null),
            kA = (0,
            c.gn)([(0,
            i.Component)({
                selector: "iframe-api-player",
                template: n(69603)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(xe)), (0,
            c.fM)(1, (0,
            i.Inject)(m.H7)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (AA = void 0 !== xe && xe) ? AA : Object, "function" == typeof (RA = void 0 !== m.H7 && m.H7) ? RA : Object])], kA);
            let MA = class {
                transform(e, t) {
                    return function(e, t) {
                        const n = e.slice(0, t).join(", ");
                        return e.length > t ? n + ` and ${e.length - t} more` : n
                    }(e, t)
                }
            }
            ;
            MA = (0,
            c.gn)([(0,
            i.Pipe)({
                name: "stringArrayFormatter"
            })], MA);
            let LA = class {
            }
            ;
            LA = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [fw, Cd, bA, od, DA, MA, kA],
                entryComponents: [Cd, bA, od, DA, fw],
                exports: [Cd, bA, od, DA],
                imports: [l.ez, d.fX, ym, Ri, Ai, wO, TO, p.UX, PE],
                providers: []
            })], LA);
            let NA = class {
            }
            ;
            var FA;
            NA = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [],
                providers: [td],
                exports: [],
                imports: [LA, gA, wO]
            })], NA);
            let UA = class {
                constructor() {
                    this.processing = !1,
                    this.icons = Object.assign(Object.assign(Object.assign(Object.assign({}, zt), Yt), Wt), Ht),
                    this.msgs = {}
                }
                get externalProviderId() {
                    return this.samlProvider.externalProviderId
                }
                get attributeMappings() {
                    var e;
                    return null !== (e = this.externalGroupForm.controls.attributeMapping.value[this.externalProviderId]) && void 0 !== e ? e : []
                }
                get attributeMappingRecord() {
                    return this.externalGroupForm.controls.attributeMapping.value
                }
                get supportedAttributes() {
                    return this.samlProvider.configuration.supportedAttributes
                }
                get attributeSetCountValue() {
                    return jb(this.attributeMappings)
                }
                get hasDeprecatedAttributes() {
                    return this.attributeMappings.some((e => e.conditions.some((e => e.attributeName.length > 0 && !this.samlProvider.configuration.supportedAttributes.includes(e.attributeName)))))
                }
                ngOnInit() {
                    this.msgs = Object.assign(Object.assign(Object.assign({}, L.messages.externalProviders), L.messages.groups), L.messages.groups.extendedSaml)
                }
                addAttributeSet() {
                    void 0 === this.attributeMappingRecord[this.externalProviderId] ? this.attributeMappingRecord[this.externalProviderId] = [{
                        conditions: [{
                            attributeName: "",
                            attributeValue: ""
                        }],
                        externalProviderId: this.externalProviderId
                    }] : this.attributeMappings.push({
                        conditions: [{
                            attributeValue: "",
                            attributeName: ""
                        }],
                        externalProviderId: this.externalProviderId
                    })
                }
                removeAttributeMapping(e) {
                    this.attributeMappings.splice(e, 1)
                }
                addCondition(e) {
                    this.attributeMappings[e].conditions.push({
                        attributeValue: "",
                        attributeName: ""
                    })
                }
                removeCondition(e, t) {
                    this.attributeMappings[t].conditions.splice(e, 1),
                    0 === this.attributeMappings[t].conditions.length && this.removeAttributeMapping(t)
                }
                isAttributeDeprecated(e) {
                    return "" !== e && !this.supportedAttributes.includes(e)
                }
                setContainsDeprecatedAttribute(e) {
                    return e.some((e => this.isAttributeDeprecated(e.attributeName)))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], UA.prototype, "samlProvider", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (FA = void 0 !== p.cw && p.cw) ? FA : Object)], UA.prototype, "externalGroupForm", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], UA.prototype, "processing", void 0),
            UA = (0,
            c.gn)([(0,
            i.Component)({
                selector: "saml-mapping",
                template: n(60361)
            })], UA);
            let $A = class {
                constructor() {
                    this.attributeMappings = [],
                    this.attributeSets = [],
                    this.icons = Object.assign({}, zt),
                    this.msgs = Object.assign(Object.assign({}, L.messages.groups.extendedSaml), L.messages.groups)
                }
                get hasDeprecatedAttributes() {
                    return this.attributeMappings.some((e => e.conditions.some((e => !this.samlProvider.configuration.supportedAttributes.includes(e.attributeName)))))
                }
                get attributeSetCountValue() {
                    return jb(this.attributeSets)
                }
                ngOnInit() {
                    this.attributeMappings.forEach((e => {
                        if (e.conditions.length > 0) {
                            const t = {};
                            e.conditions.forEach((e => {
                                t[e.attributeName] ? t[e.attributeName] += `, ${e.attributeValue}` : t[e.attributeName] = e.attributeValue
                            }
                            )),
                            this.attributeSets.push(t)
                        }
                    }
                    ))
                }
                attributeNotDeprecated(e) {
                    return this.samlProvider.configuration.supportedAttributes.includes(e)
                }
                setContainsDeprecatedAttribute(e) {
                    return Object.keys(e).some((e => !this.attributeNotDeprecated(e)))
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], $A.prototype, "samlProvider", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], $A.prototype, "attributeMappings", void 0),
            $A = (0,
            c.gn)([(0,
            i.Component)({
                selector: "saml-mapping-summary",
                template: n(4893)
            })], $A);
            let jA = class {
            }
            ;
            var VA;
            jA = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [yb, aS, lS, yS, gS, Xb, Mb, Fb, UA, $A],
                entryComponents: [yb, Xb],
                exports: [yb],
                imports: [l.ez, u.PW, qD, ym, Ai, p.UX, p.u5, PE]
            })], jA),
            function(e) {
                e[e.DELETE = 0] = "DELETE",
                e[e.MIGRATE = 1] = "MIGRATE",
                e[e.ADD = 2] = "ADD"
            }(VA || (VA = {}));
            let GA = class {
                constructor() {
                    this.oldCameras = [],
                    this.newCameras = [],
                    this.mappingData = {
                        allCameras: [],
                        camerasToDelete: [],
                        camerasToMigrate: [],
                        camerasToAdd: []
                    },
                    this.activeFilters = [VA.DELETE, VA.MIGRATE, VA.ADD],
                    this.allMappingFields = [],
                    this.camsToRemove = [],
                    this.camsToAdd = [],
                    this.camsToMigrate = [],
                    this.paginatedMappingFields = [],
                    this.sortActionsDescending = !0,
                    this.msgs = Object.assign({}, L.messages.recorderRecovery.dialogs),
                    this.pageSizeOptions = [10, 50, 100, 250],
                    this.pageIndex = 0,
                    this.pageSize = this.pageSizeOptions[1]
                }
                get filterEnum() {
                    return VA
                }
                ngOnChanges(e) {
                    "mappingData"in e && (this._mapDataToFields(this.mappingData),
                    this.allMappingFields = [...this.camsToRemove, ...this.camsToMigrate, ...this.camsToAdd],
                    this.paginatedMappingFields = Mc(this.allMappingFields, this.pageSize, this.pageIndex))
                }
                _getNewCameraAddressById(e) {
                    const t = this.newCameras.find((t => t.id === e));
                    return t ? "IPAddress"in t.configuration ? t.configuration.IPAddress : t.configuration.BaseUri : ""
                }
                _getNewCameraNameById(e) {
                    const t = this.newCameras.find((t => t.id === e));
                    return t ? t.name : ""
                }
                _mapDataToFields(e) {
                    this.camsToRemove = e.camerasToDelete.map((e => ({
                        filterType: VA.DELETE,
                        oldCamera: {
                            name: e.name,
                            ipAddress: "IPAddress"in e.configuration ? e.configuration.IPAddress : e.configuration.BaseUri
                        },
                        newCamera: void 0
                    }))),
                    this.camsToRemove.sort(( (e, t) => e.oldCamera && t.oldCamera ? Tt(e.oldCamera.name).localeCompare(Tt(t.oldCamera.name)) : 0)),
                    this.camsToMigrate = e.camerasToMigrate.map((e => ({
                        filterType: VA.MIGRATE,
                        oldCamera: {
                            name: e.name,
                            ipAddress: "IPAddress"in e.configuration ? e.configuration.IPAddress : e.configuration.BaseUri
                        },
                        newCamera: {
                            name: this._getNewCameraNameById(e.mappedCameraId),
                            ipAddress: this._getNewCameraAddressById(e.mappedCameraId)
                        }
                    }))),
                    this.camsToMigrate.sort(( (e, t) => e.oldCamera && t.oldCamera ? Tt(e.oldCamera.name).localeCompare(Tt(t.oldCamera.name)) : 0)),
                    this.camsToAdd = e.camerasToAdd.map((e => ({
                        filterType: VA.ADD,
                        oldCamera: void 0,
                        newCamera: {
                            name: e.name,
                            ipAddress: "IPAddress"in e.configuration ? e.configuration.IPAddress : e.configuration.BaseUri
                        }
                    }))),
                    this.camsToAdd.sort(( (e, t) => e.newCamera && t.newCamera ? Tt(e.newCamera.name).localeCompare(Tt(t.newCamera.name)) : 0))
                }
                onPaginatorChange(e) {
                    this.pageIndex = e.pageIndex,
                    this.pageSize = e.pageSize,
                    this.paginatedMappingFields = Mc(this.allMappingFields, this.pageSize, this.pageIndex)
                }
                toggleActionSort() {
                    this.sortActionsDescending = !this.sortActionsDescending,
                    this.sortActionsDescending ? this.allMappingFields = [...this.camsToRemove, ...this.camsToMigrate, ...this.camsToAdd] : this.allMappingFields = [...this.camsToAdd, ...this.camsToMigrate, ...this.camsToRemove],
                    this.paginatedMappingFields = Mc(this.allMappingFields, this.pageSize, this.pageIndex)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], GA.prototype, "oldCameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], GA.prototype, "newCameras", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], GA.prototype, "mappingData", void 0),
            GA = (0,
            c.gn)([(0,
            i.Component)({
                selector: "camera-mapping-summary",
                template: n(49240)
            }), (0,
            c.w6)("design:paramtypes", [])], GA);
            let BA = class {
                constructor() {
                    this.msgs = Object.assign({}, L.messages.recorderRecovery.dialogs),
                    this.mappedCameraIds = [],
                    this.mappedCameraIdsChange = new i.EventEmitter,
                    this.oldCameras = [],
                    this.oldCamerasChange = new i.EventEmitter,
                    this.newCameras = [],
                    this.newCamerasChange = new i.EventEmitter,
                    this.stateChange = new i.EventEmitter,
                    this.oldCamerasFiltered = [],
                    this.oldCamerasPaginated = [],
                    this.numCamsMapped = 0,
                    this.showNumCamsMsg = !1,
                    this.numCamsMsg = "",
                    this.pageSizeOptions = [10, 50, 100, 250],
                    this.pageIndex = 0,
                    this.pageSize = this.pageSizeOptions[1]
                }
                ngOnChanges(e) {
                    "mappedCameraIds"in e && (this.showNumCamsMsg = !1,
                    this.numCamsMapped = 0),
                    "oldCameras"in e && (this.oldCamerasFiltered = xt(this.oldCameras),
                    this.oldCamerasPaginated = Mc(this.oldCamerasFiltered, this.pageSize, this.pageIndex))
                }
                get countOldCamerasUnmapped() {
                    return this.oldCameras.length - this.mappedCameraIds.length
                }
                get countCamerasToAdd() {
                    return this.newCameras.length - this.mappedCameraIds.length
                }
                getNewCameraAddressById(e) {
                    const t = this.newCameras.find((t => t.id === e));
                    return t ? "IPAddress"in t.configuration ? t.configuration.IPAddress : t.configuration.BaseUri : ""
                }
                getNewCameraNameById(e) {
                    const t = this.newCameras.find((t => t.id === e));
                    return t ? t.name : ""
                }
                getCameraNameAndAddress(e) {
                    return "IPAddress"in e.configuration ? [e.name, e.configuration.IPAddress] : [e.name, e.configuration.BaseUri]
                }
                onOldCameraSearchChanged(e) {
                    e.sort(( (e, t) => Tt(e.name).localeCompare(Tt(t.name)))),
                    this.oldCamerasFiltered = e,
                    this.pageIndex = 0,
                    this.oldCamerasPaginated = Mc(this.oldCamerasFiltered, this.pageSize, this.pageIndex)
                }
                onPaginatorChange(e) {
                    this.pageSize = e.pageSize,
                    this.pageIndex = e.pageIndex,
                    this.oldCamerasPaginated = Mc(this.oldCamerasFiltered, e.pageSize, e.pageIndex)
                }
                mapCamerasByIp() {
                    this.showNumCamsMsg && (this.showNumCamsMsg = !1),
                    this.numCamsMapped = 0,
                    this.oldCameras.forEach((e => {
                        if (!e.mappedCameraId) {
                            const t = this.newCameras.find((t => !this.mappedCameraIds.includes(t.id) && ("IPAddress"in t.configuration && "IPAddress"in e.configuration ? t.configuration.IPAddress === e.configuration.IPAddress : "BaseUri"in t.configuration && "BaseUri"in e.configuration && t.configuration.BaseUri === e.configuration.BaseUri)));
                            if (t) {
                                this.oldCamerasFiltered.find((t => t.id === e.id)).mappedCameraId = t.id;
                                this.oldCameras.find((t => t.id === e.id)).mappedCameraId = t.id,
                                this.mappedCameraIds.push(t.id),
                                this.numCamsMapped++
                            }
                        }
                    }
                    )),
                    this.numCamsMsg = this.msgs.mappedVALUECameras({
                        VALUE: this.numCamsMapped
                    }),
                    this.showNumCamsMsg = !0,
                    this.mappedCameraIdsChange.emit(this.mappedCameraIds),
                    this.oldCamerasChange.emit(this.oldCameras),
                    this.newCamerasChange.emit(this.newCameras),
                    this.stateChange.emit()
                }
                mapCamerasByName() {
                    this.showNumCamsMsg && (this.showNumCamsMsg = !1),
                    this.numCamsMapped = 0,
                    this.oldCameras.forEach((e => {
                        if (!e.mappedCameraId) {
                            const t = this.newCameras.find((t => t.name === e.name && !this.mappedCameraIds.includes(t.id)));
                            if (t) {
                                this.oldCamerasFiltered.find((t => t.id === e.id)).mappedCameraId = t.id;
                                this.oldCameras.find((t => t.id === e.id)).mappedCameraId = t.id,
                                this.mappedCameraIds.push(t.id),
                                this.numCamsMapped++
                            }
                        }
                    }
                    )),
                    this.numCamsMsg = this.msgs.mappedVALUECameras({
                        VALUE: this.numCamsMapped
                    }),
                    this.showNumCamsMsg = !0,
                    this.mappedCameraIdsChange.emit(this.mappedCameraIds),
                    this.oldCamerasChange.emit(this.oldCameras),
                    this.newCamerasChange.emit(this.newCameras),
                    this.stateChange.emit()
                }
                clearMapping(e, t) {
                    t.value = "";
                    const n = this.oldCameras.find((t => t.id === e.id));
                    this.mappedCameraIds.splice(this.mappedCameraIds.indexOf(n.mappedCameraId), 1),
                    n.mappedCameraId = void 0,
                    e.mappedCameraId = void 0,
                    this.showNumCamsMsg && (this.showNumCamsMsg = !1),
                    this.mappedCameraIdsChange.emit(this.mappedCameraIds),
                    this.oldCamerasChange.emit(this.oldCameras),
                    this.newCamerasChange.emit(this.newCameras),
                    this.stateChange.emit()
                }
                getCameraOptions(e, t) {
                    return this.newCameras.filter((n => {
                        if (t)
                            if ("IPAddress"in n.configuration) {
                                if (!n.name.toLocaleLowerCase().includes(t) && !n.configuration.IPAddress.includes(t))
                                    return !1
                            } else if (!n.name.toLocaleLowerCase().includes(t) && !n.configuration.BaseUri.includes(t))
                                return !1;
                        return !(!e || n.id !== e) || !this.mappedCameraIds.includes(n.id)
                    }
                    ))
                }
                onNewCameraSelect(e, t) {
                    const n = e.option.value
                      , i = this.oldCameras.find((e => e.id === t.id));
                    if (i.mappedCameraId) {
                        const e = this.mappedCameraIds.indexOf(i.mappedCameraId);
                        -1 !== e && this.mappedCameraIds.splice(e, 1)
                    }
                    t.mappedCameraId = n.id,
                    i.mappedCameraId = n.id,
                    this.mappedCameraIds.push(n.id),
                    this.showNumCamsMsg = !1,
                    this.mappedCameraIdsChange.emit(this.mappedCameraIds),
                    this.oldCamerasChange.emit(this.oldCameras),
                    this.newCamerasChange.emit(this.newCameras),
                    this.stateChange.emit()
                }
                clearAll() {
                    this.showNumCamsMsg && (this.showNumCamsMsg = !1),
                    this.oldCameras.forEach((e => {
                        e.mappedCameraId = void 0
                    }
                    )),
                    this.oldCamerasFiltered.forEach((e => {
                        e.mappedCameraId = void 0
                    }
                    )),
                    this.mappedCameraIds = [],
                    this.mappedCameraIdsChange.emit(this.mappedCameraIds),
                    this.oldCamerasChange.emit(this.oldCameras),
                    this.newCamerasChange.emit(this.newCameras),
                    this.stateChange.emit()
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], BA.prototype, "mappedCameraIds", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], BA.prototype, "mappedCameraIdsChange", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], BA.prototype, "oldCameras", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], BA.prototype, "oldCamerasChange", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array)], BA.prototype, "newCameras", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], BA.prototype, "newCamerasChange", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", Object)], BA.prototype, "stateChange", void 0),
            BA = (0,
            c.gn)([(0,
            i.Component)({
                selector: "camera-mapping-table",
                template: n(25520),
                animations: [(0,
                Jo.X$)("fadeInOut", [(0,
                Jo.eR)(":enter", [(0,
                Jo.oB)({
                    opacity: 0
                }), (0,
                Jo.jt)("200ms", (0,
                Jo.oB)({
                    opacity: 1
                }))]), (0,
                Jo.eR)(":leave", [(0,
                Jo.jt)("200ms", (0,
                Jo.oB)({
                    opacity: 0
                }))])])]
            }), (0,
            c.w6)("design:paramtypes", [])], BA);
            let zA = class {
                constructor() {
                    this.countCamerasToAdd = 0,
                    this.countCamerasToMigrate = 0,
                    this.countCamerasToRemove = 0,
                    this.msgs = Object.assign({}, L.messages.recorderRecovery.dialogs)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zA.prototype, "oldRecorder", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zA.prototype, "newRecorder", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Boolean)], zA.prototype, "readOnly", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zA.prototype, "readData", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zA.prototype, "countCamerasToAdd", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zA.prototype, "countCamerasToMigrate", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], zA.prototype, "countCamerasToRemove", void 0),
            zA = (0,
            c.gn)([(0,
            i.Component)({
                selector: "recovery-summary",
                template: n(66685)
            })], zA);
            let HA = class {
            }
            ;
            var WA;
            HA = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [GA, BA, Ao, NI, yo, To, zA],
                exports: [To, Ao, NI],
                imports: [l.ez, u.PW, ym, p.u5, Ai, p.UX, p.UX],
                providers: [],
                entryComponents: [Ao, NI, yo, To]
            })], HA);
            const qA = O("ActiveStreamStateService");
            let YA = class {
                constructor(e) {
                    this._orchidDataService = e,
                    this._activeStreamsMap = {},
                    this._pollingTimerSubscription = void 0,
                    this._orchid = void 0
                }
                get activeStreamsMap() {
                    return this._activeStreamsMap
                }
                startPolling(e) {
                    this._pollingTimerSubscription && this.stopPolling(),
                    this._orchid = e,
                    this._pollingTimerSubscription = (0,
                    Kl.H)(0, 5e3).subscribe(( () => {
                        this._orchidDataService.getStreamStati(this._orchid).then((e => {
                            this._updateAllOrchidCameraStreamsStati(e.data.streams)
                        }
                        ))
                    }
                    ))
                }
                stopPolling() {
                    this._activeStreamsMap = {},
                    this._orchid && (this._orchid = void 0),
                    this._pollingTimerSubscription && this._pollingTimerSubscription.unsubscribe()
                }
                _updateAllOrchidCameraStreamsStati(e) {
                    this._activeStreamsMap = {},
                    e.forEach((e => {
                        this._activeStreamsMap[e.id] = e
                    }
                    ))
                }
                pollStreamStatusAndUpdateActiveStreamsMap(e) {
                    return (0,
                    c.mG)(this, void 0, void 0, (function*() {
                        try {
                            const t = yield this._orchidDataService.getStreamStatus(this._orchid, e.id);
                            this._activeStreamsMap[e.id] = t.data
                        } catch (e) {
                            qA("error", "Failed to poll stream status on stream status endpoint", e)
                        }
                        return this._activeStreamsMap
                    }
                    ))
                }
            }
            ;
            var XA, KA;
            YA = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pt)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (WA = pt) ? WA : Object])], YA);
            let ZA = class extends ug {
                constructor(e, t, n) {
                    super(e),
                    this._renewableService = t,
                    this._fusionDataService = n
                }
                _fetchTimeInfo() {
                    return this._renewableService.orchidsPromise().then(( () => this._fusionDataService.fetchOrchidTimes())).then((e => {
                        const t = [];
                        return e.data.forEach((e => {
                            t.push({
                                id: e.id,
                                offset: Date.now() - e.time,
                                tz: e.tz,
                                tzOffset: e.tzOffset
                            })
                        }
                        )),
                        t
                    }
                    ))
                }
            }
            ;
            var JA, QA;
            ZA = (0,
            c.gn)([(0,
            c.fM)(1, (0,
            i.Inject)(Gt)), (0,
            c.fM)(2, (0,
            i.Inject)(Qe)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (XA = Gt) ? XA : Object, "function" == typeof (KA = Qe) ? KA : Object])], ZA);
            let eR = class extends ug {
                constructor(e, t, n) {
                    super(e),
                    this._renewableService = t,
                    this._orchidDataService = n
                }
                _fetchTimeInfo() {
                    return this._renewableService.orchidsPromise().then((e => this._orchidDataService.fetchTimeExtended(e[0]).then((t => [{
                        id: e[0].id,
                        offset: Date.now() - t.data.time,
                        tz: t.data.tz,
                        tzOffset: t.data.tzOffset
                    }]))))
                }
            }
            ;
            eR = (0,
            c.gn)([(0,
            c.fM)(1, (0,
            i.Inject)(Gt)), (0,
            c.fM)(2, (0,
            i.Inject)(pt)), (0,
            c.w6)("design:paramtypes", [Object, "function" == typeof (JA = Gt) ? JA : Object, "function" == typeof (QA = pt) ? QA : Object])], eR);
            var tR, nR, iR = n(93833);
            let aR = class {
                constructor(e, t) {
                    this._orchidDataService = e,
                    this._requestService = t,
                    this._wsManagerMap = new Map,
                    this._stop$ = new St.x
                }
                ngOnDestroy() {
                    this.stop(),
                    this._stop$.complete()
                }
                _initializeManager(e) {
                    const t = {};
                    return t.activeSessionRefs = new Set,
                    t.killSignal$ = new St.x,
                    t.deadSignal$ = new St.x,
                    t.wsSubject$$ = this._isTrackingEnabled$(e.id).pipe((0,
                    ra.h)((e => !!e)), (0,
                    pn.q)(1), (0,
                    He.U)(( () => (0,
                    ag.j)({
                        url: this._orchidDataService.generateOrchidWebSocketUrl(e, "/service/performance"),
                        closeObserver: {
                            next: () => t.deadSignal$.next()
                        }
                    }))), (0,
                    rE.d)({
                        bufferSize: 1,
                        refCount: !1
                    })),
                    t.event$ = new St.x,
                    t.eventProcessor$ = t.event$.pipe((0,
                    Tr.b)((e => {
                        switch (e.type) {
                        case "open":
                            return t.wsSubject$$.pipe((0,
                            sa.b)((e => e.pipe((0,
                            oa.R)(t.killSignal$)).subscribe())));
                        case "post":
                            return t.wsSubject$$.pipe((0,
                            sa.b)((t => t.next(e.stats))));
                        case "close":
                            return (0,
                            Xl.S)((0,
                            Kl.H)(1e3).pipe((0,
                            iR.h)(!0)), t.event$.pipe((0,
                            pn.q)(1), (0,
                            iR.h)(!1))).pipe((0,
                            ra.h)((e => e)), (0,
                            Ks.w)(( () => (0,
                            ze.of)(void 0).pipe((0,
                            sa.b)(( () => t.killSignal$.next())), (0,
                            Ks.w)(( () => (0,
                            Xl.S)(t.deadSignal$.pipe((0,
                            pn.q)(1)), (0,
                            Kl.H)(5e3))))))))
                        }
                    }
                    )), (0,
                    oa.R)(this._stop$)),
                    t.eventProcessor$.subscribe(),
                    this._wsManagerMap.set(e, t),
                    t
                }
                _isTrackingEnabled$(e) {
                    return w.isOrchid ? this._requestService.createRequest(`${w.baseUrl}/service/discoverable/orchids/${e}`).with(Ch.authorizeRecorder()).get().pipe((0,
                    He.U)((e => {
                        var t;
                        return null !== (t = e.performanceLogging) && void 0 !== t && t
                    }
                    ))) : this._requestService.createRequest(`${w.baseUrl}/service/orchids/${e}`).with(lo.authorizeFusion()).get().pipe((0,
                    He.U)((e => {
                        var t, n;
                        return null !== (n = null === (t = e.discoverableOrchid) || void 0 === t ? void 0 : t.performanceLogging) && void 0 !== n && n
                    }
                    )))
                }
                startTracking(e) {
                    var t;
                    const n = null !== (t = this._wsManagerMap.get(e)) && void 0 !== t ? t : this._initializeManager(e)
                      , i = {};
                    return n.activeSessionRefs.size || n.event$.next({
                        type: "open"
                    }),
                    n.activeSessionRefs.add(i),
                    {
                        done: () => {
                            n.activeSessionRefs.delete(i),
                            n.activeSessionRefs.size || n.event$.next({
                                type: "close"
                            })
                        }
                        ,
                        post: e => {
                            n.activeSessionRefs.has(i) && n.event$.next({
                                type: "post",
                                stats: e
                            })
                        }
                    }
                }
                getPerformanceLog() {
                    return this._requestService.createRequest(`${w.baseUrl}/service/performance/logs`).with(Ch.authorizeRecorder()).get()
                }
                stop() {
                    this._stop$.next(),
                    this._wsManagerMap.clear()
                }
            }
            ;
            aR = (0,
            c.gn)([(0,
            i.Injectable)({
                providedIn: "root"
            }), (0,
            c.fM)(0, (0,
            i.Inject)(pt)), (0,
            c.fM)(1, (0,
            i.Inject)(gr)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (tR = pt) ? tR : Object, "function" == typeof (nR = void 0 !== gr && gr) ? nR : Object])], aR);
            o().module("ipconfigure.orchid.singularity").factory("ActiveStreamStateService", (0,
            r.dV)(YA)).factory("DownloaderService", (0,
            r.dV)(ih)).factory("OpenPanelService", (0,
            r.dV)(Eu)).factory("SessionIdService", (0,
            r.dV)(ur)).factory("PerformanceTrackerService", (0,
            r.dV)(aR)).factory("ActivationService", (0,
            r.dV)(qC)).factory("TimeService", (0,
            r.dV)(ug)).factory("OrchidProxyService", (0,
            r.dV)(mt)).factory("NGStageService", (0,
            r.dV)(gf));
            let rR = class {
            }
            ;
            rR = (0,
            c.gn)([(0,
            i.NgModule)({
                providers: [Hm, Ye, Tg, Eu, gg, Lm, ur, aR, {
                    provide: ug,
                    useFactory: (e, t, n) => w.isOrchid ? new eR(new wn,e,t) : new ZA(new wn,e,n),
                    deps: [Gt, pt, Qe]
                }, Rg, og, sg, qC, mt, gf, BI],
                declarations: [],
                exports: [],
                imports: []
            })], rR);
            let sR = class {
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], sR.prototype, "error", void 0),
            sR = (0,
            c.gn)([(0,
            i.Component)({
                selector: "error-overlay",
                template: n(46408)
            })], sR);
            let oR = class {
            }
            ;
            var cR, lR, dR, uR;
            oR = (0,
            c.gn)([(0,
            i.Component)({
                selector: "loading-overlay",
                template: n(39646)
            })], oR);
            let mR = class {
                constructor(e) {
                    this._el = e
                }
                get aspectRatio() {
                    return this._el.nativeElement.clientWidth / this._el.nativeElement.clientHeight
                }
                clear() {
                    const e = this.canvasPlayer.nativeElement.getContext("2d");
                    null == e || e.clearRect(0, 0, this.canvasPlayer.nativeElement.width, this.canvasPlayer.nativeElement.height),
                    this.videoPlayer.nativeElement.src = ""
                }
                ngOnChanges(e) {
                    e.source && void 0 !== e.source.currentValue && (this.clear(),
                    e.source.previousValue && e.source.previousValue.off("resize", this._onResize.bind(this)),
                    this.source.on("resize", this._onResize.bind(this)))
                }
                _onResize(e) {
                    var t;
                    if ("canvas" === (null === (t = this.source) || void 0 === t ? void 0 : t.targetElementType)) {
                        let t = "height";
                        e.width / e.height > this.aspectRatio && (t = "width"),
                        this.canvasPlayer.nativeElement.setAttribute("style", `aspect-ratio: auto ${e.width} / ${e.height}; ${t}: 100%`)
                    }
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (cR = void 0 !== zl && zl) ? cR : Object)], mR.prototype, "source", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("videoPlayer", {
                static: !0
            }), (0,
            c.w6)("design:type", "function" == typeof (lR = void 0 !== i.ElementRef && i.ElementRef) ? lR : Object)], mR.prototype, "videoPlayer", void 0),
            (0,
            c.gn)([(0,
            i.ViewChild)("canvasPlayer", {
                static: !0
            }), (0,
            c.w6)("design:type", "function" == typeof (dR = void 0 !== i.ElementRef && i.ElementRef) ? dR : Object)], mR.prototype, "canvasPlayer", void 0),
            mR = (0,
            c.gn)([(0,
            i.Component)({
                selector: "source-player",
                template: n(24704)
            }), (0,
            c.fM)(0, (0,
            i.Inject)(i.ElementRef)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (uR = void 0 !== i.ElementRef && i.ElementRef) ? uR : Object])], mR);
            let hR = class {
            }
            ;
            hR = (0,
            c.gn)([(0,
            i.NgModule)({
                providers: [Zy, Xy, BT],
                declarations: [XI, KT, sR, oR, ZI, dI, RE, vE, _d, Ed, mR, yC, ab, ib, fI, Jw, PI, LC],
                entryComponents: [XI, KT, sR, oR, ZI, dI, RE, vE, _d, Ed, mR, yC, ab, ib, fI, Jw, PI, LC],
                exports: [XI, sR, oR, ZI, mR, yC, ab, ib, LC],
                imports: [l.ez, Ai, p.u5, u.PW, p.UX]
            })], hR);
            let pR = class {
            }
            ;
            pR = (0,
            c.gn)([(0,
            i.NgModule)({
                providers: [Ug],
                declarations: [Cf, Av, pf],
                exports: [Cf, Av, pf],
                entryComponents: [Cf, Av, pf],
                imports: [l.ez, ym, vO, Ai, hR, uf.Cl, bm, PE]
            })], pR);
            let gR = class {
            }
            ;
            var fR, vR, yR, bR;
            gR = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [ss, MC],
                entryComponents: [MC, ss],
                exports: [MC],
                imports: [m.b2, ym, l.ez, Ai, PE],
                providers: [{
                    provide: "$scope",
                    useExisting: "$rootScope"
                }]
            })], gR),
            function(e) {
                e.DESCRIPTION = "description",
                e.RESOURCE = "resource",
                e.USER = "user",
                e.DATE = "date"
            }(bR || (bR = {}));
            let SR = class {
                constructor() {
                    this.trustedIssuerName = "",
                    this.servicesActionsMap = new Map,
                    this.servicesDescriptionsMap = new Map,
                    this.servicesResourcesMap = new Map,
                    this._logs = [],
                    this.pageSize = 1e3,
                    this.sort = {
                        active: bR.DATE,
                        direction: "desc"
                    },
                    this.state = Ew.LOADING,
                    this.moreClick = new i.EventEmitter,
                    this.onSort = new i.EventEmitter,
                    this.COLUMNS = bR,
                    this.columnsToDisplay = [bR.DESCRIPTION, bR.RESOURCE, bR.USER, bR.DATE],
                    this.dataSource = new Ei.by([]),
                    this.msgs = Object.assign(Object.assign({}, L.messages.auditLogs.table), L.messages.common),
                    this.statusMsgs = L.messages.statuses,
                    this.dateFormat = L.formats.auditLogs,
                    this.expandedLogs = {}
                }
                get logs() {
                    return this._logs
                }
                set logs(e) {
                    this.expandedLogs = {},
                    this._logs = e,
                    this.dataSource.data = e
                }
                get ComponentState() {
                    return Ew
                }
                handleSummaryClick(e) {
                    this.expandedLogs[e] = !this.expandedLogs[e]
                }
                stringify(e) {
                    return JSON.stringify(e, null, 2)
                }
                handleSort(e) {
                    this.expandedLogs = {},
                    this.onSort.emit(e)
                }
                getAction(e) {
                    if (!this.servicesActionsMap)
                        return "";
                    const t = this.servicesActionsMap.get(e.serviceId);
                    return t || ""
                }
                getDescription(e) {
                    if (!this.servicesDescriptionsMap)
                        return "";
                    const t = this.servicesDescriptionsMap.get(e.serviceId);
                    return t || ""
                }
                getResource(e) {
                    if (!this.servicesResourcesMap)
                        return "";
                    const t = this.servicesResourcesMap.get(e.serviceId);
                    return t || ""
                }
                getParentResource(e) {
                    if (!this.servicesResourcesMap)
                        return "";
                    const t = this.servicesResourcesMap.get(e.serviceId);
                    return !e.request.parentResource || t !== X.ARCHIVE && t !== X.STREAM && t !== X.SMART_SEARCH ? t || "" : X.CAMERA
                }
                getParentName(e) {
                    const t = this.servicesResourcesMap.get(e.serviceId);
                    if (e.request.parentResource) {
                        if (t === X.ARCHIVE || t === X.STREAM || t === X.SMART_SEARCH)
                            return e.request.parentResource.name;
                        if (t === X.EVENT)
                            return e.request.parentResource.name
                    }
                    return hw(t, e)
                }
                getAuthType(e, t) {
                    const n = t ? mw(t) : "";
                    return uw(e, this.trustedIssuerName, n)
                }
            }
            ;
            var CR, wR;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], SR.prototype, "trustedIssuerName", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], SR.prototype, "servicesActionsMap", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], SR.prototype, "servicesDescriptionsMap", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], SR.prototype, "servicesResourcesMap", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Array), (0,
            c.w6)("design:paramtypes", [Array])], SR.prototype, "logs", null),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], SR.prototype, "pageSize", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", "function" == typeof (fR = void 0 !== Ew && Ew) ? fR : Object)], SR.prototype, "state", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (vR = void 0 !== i.EventEmitter && i.EventEmitter) ? vR : Object)], SR.prototype, "moreClick", void 0),
            (0,
            c.gn)([(0,
            i.Output)(), (0,
            c.w6)("design:type", "function" == typeof (yR = void 0 !== i.EventEmitter && i.EventEmitter) ? yR : Object)], SR.prototype, "onSort", void 0),
            SR = (0,
            c.gn)([(0,
            i.Component)({
                selector: "audit-logs-table",
                template: n(64161),
                changeDetection: i.ChangeDetectionStrategy.OnPush,
                animations: [(0,
                Jo.X$)("rowReveal", [(0,
                Jo.eR)(":enter", [(0,
                Jo.IO)("mat-cell", [(0,
                Jo.oB)({
                    opacity: 0
                }), (0,
                Jo.EY)(50, [(0,
                Jo.jt)("0.25s", (0,
                Jo.oB)({
                    opacity: 1
                }))])])])]), (0,
                Jo.X$)("detailExpand", [(0,
                Jo.eR)(":enter", [(0,
                Jo.oB)({
                    opacity: 0,
                    height: 0,
                    transform: "translateY(3px)"
                }), (0,
                Jo.ru)([(0,
                Jo.jt)("225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
                Jo.oB)({
                    height: "*"
                })), (0,
                Jo.jt)("525ms 100ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
                Jo.oB)({
                    opacity: 1,
                    transform: "translateY(0)"
                }))])]), (0,
                Jo.eR)(":leave", [(0,
                Jo.jt)("225ms cubic-bezier(0.4, 0.0, 0.2, 1)", (0,
                Jo.oB)({
                    opacity: 0,
                    height: 0
                }))])])]
            })], SR);
            let IR = class {
                constructor(e, t) {
                    this.datePipe = e,
                    this.timeDurationPipe = t,
                    this.resourceType = void 0,
                    this.logType = "",
                    this.userType = "",
                    this.description = "",
                    this.resourceName = "",
                    this.msgs = Object.assign(Object.assign({}, L.messages.auditLogs.table.details), L.messages.common),
                    this.statusMsgs = L.messages.statuses,
                    this.dateFormat = L.formats.auditLogs
                }
                formatDuration(e) {
                    return this.timeDurationPipe.transform(e, !0)
                }
                ngOnInit() {
                    this.resourceName = hw(this.resourceType, this.log)
                }
                convertToChipData() {
                    return [{
                        icon: "fa-solid fa-circle-user",
                        name: this.log.client.username,
                        title: this.userType
                    }, {
                        icon: "fa-regular fa-clock",
                        name: `${this.datePipe.transform(this.log.request.time, this.dateFormat.medium)}`,
                        title: this.msgs.date()
                    }]
                }
                getChangeDiff(e) {
                    return JSON.stringify(e, null, 2)
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], IR.prototype, "log", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], IR.prototype, "resourceType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], IR.prototype, "logType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], IR.prototype, "userType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], IR.prototype, "description", void 0),
            IR = (0,
            c.gn)([(0,
            i.Component)({
                selector: "audit-logs-expanded-detail",
                template: n(76984),
                providers: [l.uU]
            }), (0,
            c.fM)(0, (0,
            i.Inject)(l.uU)), (0,
            c.fM)(1, (0,
            i.Inject)(yl)), (0,
            c.w6)("design:paramtypes", ["function" == typeof (CR = void 0 !== l.uU && l.uU) ? CR : Object, "function" == typeof (wR = void 0 !== yl && yl) ? wR : Object])], IR);
            const TR = {
                archive: "fa-regular fa-archive-box",
                camera: "fa-solid fa-video",
                stream: "fa-regular fa-circle-play",
                user: "fa-solid fa-user",
                "smart-search": "fa-kit fa-smart-search",
                "metadata-event": "fa-kit fa-events",
                "metadata-event-subscription": "fa-kit fa-events-subscriptions",
                license: "fa-solid fa-id-card",
                properties: "fa-solid fa-gears",
                server: "fa-regular fa-server",
                session: "fa-kit fa-session",
                "trusted-issuer": "fa-solid fa-plug",
                log: "fa-kit fa-user-activity",
                ui: "fa-kit fa-ui-update"
            };
            let ER = class {
                constructor() {
                    this.actionType = "",
                    this._resourceData = {
                        type: "",
                        name: ""
                    },
                    this.resourceTypeLabel = ""
                }
                get resourceData() {
                    return this._resourceData
                }
                set resourceData(e) {
                    this._resourceData = e,
                    this.resourceTypeLabel = function(e) {
                        switch (e) {
                        case X.ARCHIVE:
                            return L.messages.auditLogs.resources.archive();
                        case X.CAMERA:
                            return L.messages.auditLogs.resources.camera();
                        case X.STREAM:
                            return L.messages.auditLogs.resources.stream();
                        case X.USER:
                            return L.messages.auditLogs.resources.user();
                        case X.SMART_SEARCH:
                            return L.messages.auditLogs.resources.smartSearch();
                        case X.EVENT:
                            return L.messages.auditLogs.resources.event();
                        case X.EVENT_SUBSCRIPTION:
                            return L.messages.auditLogs.resources.eventSubscription();
                        case X.LICENSE:
                            return L.messages.auditLogs.resources.license();
                        case X.PROPERTIES:
                            return L.messages.auditLogs.resources.properties();
                        case X.SERVER:
                            return L.messages.auditLogs.resources.server();
                        case X.SESSION:
                            return L.messages.auditLogs.resources.session();
                        case X.TRUSTED_ISSUER:
                            return L.messages.auditLogs.resources.trustedIssuer();
                        case X.LOG:
                            return L.messages.auditLogs.resources.log();
                        case X.UI:
                            return L.messages.auditLogs.resources.ui();
                        default:
                            return ""
                        }
                    }(e.type)
                }
                getIcon() {
                    const e = this.resourceData.type;
                    return Object.keys(TR).includes(e) ? TR[e] : ""
                }
            }
            ;
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object)], ER.prototype, "actionType", void 0),
            (0,
            c.gn)([(0,
            i.Input)(), (0,
            c.w6)("design:type", Object), (0,
            c.w6)("design:paramtypes", [Object])], ER.prototype, "resourceData", null),
            ER = (0,
            c.gn)([(0,
            i.Component)({
                selector: "audit-logs-resource-chip",
                template: n(72703)
            })], ER);
            let _R = class {
            }
            ;
            _R = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [ER, _w, Sw, SR, IR],
                entryComponents: [_w],
                exports: [_w],
                imports: [m.b2, l.ez, Ei.p0, Ai, PE, p.u5, Ii.JX, ym, p.UX],
                providers: [{
                    provide: "$scope",
                    useExisting: "$rootScope"
                }]
            })], _R);
            let xR = class {
            }
            ;
            var DR, OR;
            xR = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [cD, Yx, Hx],
                entryComponents: [Yx, Hx],
                exports: [cD],
                imports: [m.b2, p.UX, ym, Ai],
                providers: [sm]
            })], xR);
            let AR = class {
                constructor(e, t) {
                    this._requestBuilder = e,
                    this._featureFlagService = t
                }
                initialize() {
                    return !1 === w.isOrchid ? (0,
                    ze.of)(void 0) : this._requestBuilder.createRequest(`${w.baseUrl}/service/about`).with().get().pipe((0,
                    sa.b)((e => {
                        this._featureFlagService.setFeatures(e.sprouts)
                    }
                    )))
                }
            }
            ;
            var RR, PR, kR;
            AR = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.w6)("design:paramtypes", ["function" == typeof (DR = void 0 !== gr && gr) ? DR : Object, "function" == typeof (OR = void 0 !== Ye && Ye) ? OR : Object])], AR);
            let MR = class {
                constructor(e, t, n) {
                    this._requestBuilder = e,
                    this._featureFlagService = t,
                    this._fusionConfigService = n
                }
                initialize() {
                    return !0 === w.isOrchid ? (0,
                    ze.of)(void 0) : this._requestBuilder.createRequest(`${w.baseUrl}/service/about`).with().get().pipe((0,
                    sa.b)((e => {
                        this._featureFlagService.setFeatures(e.protos),
                        this._fusionConfigService.setPreAuthentication(e)
                    }
                    )))
                }
            }
            ;
            MR = (0,
            c.gn)([(0,
            i.Injectable)(), (0,
            c.w6)("design:paramtypes", ["function" == typeof (RR = void 0 !== gr && gr) ? RR : Object, "function" == typeof (PR = void 0 !== Ye && Ye) ? PR : Object, "function" == typeof (kR = void 0 !== cc && cc) ? kR : Object])], MR);
            let LR = class {
            }
            ;
            var NR, FR, UR;
            LR = (0,
            c.gn)([(0,
            i.NgModule)({
                declarations: [cs, Vr, AE, Xr, zr],
                exports: [cs, Xr, zr],
                imports: [l.ez, ym, Ai, p.UX, p.u5],
                entryComponents: [Xr, zr, cs]
            })], LR);
            let $R = class {
                constructor(e, t, n) {
                    this.upgrade = e,
                    this.router = t,
                    this.ngZone = n
                }
                ngDoBootstrap() {
                    this.upgrade.bootstrap(document.body, ["ipconfigure.orchid.singularity"], {
                        strictDi: !0
                    })
                }
            }
            ;
            $R = (0,
            c.gn)([(0,
            i.NgModule)({
                providers: [{
                    provide: Window,
                    useValue: window
                }, {
                    provide: i.LOCALE_ID,
                    useValue: "en"
                }, {
                    provide: l.mr,
                    useValue: "!"
                }, {
                    provide: i.APP_INITIALIZER,
                    useFactory: e => () => e.getAppInfo(),
                    deps: [tf],
                    multi: !0
                }, {
                    provide: i.APP_INITIALIZER,
                    useFactory: e => () => e.initialize(),
                    deps: [AR, gr, Ye],
                    multi: !0
                }, {
                    provide: i.APP_INITIALIZER,
                    useFactory: e => () => e.initialize(),
                    deps: [MR, gr, Ye, cc],
                    multi: !0
                }, l.uU, tf, sf, Hw, AR, MR],
                imports: [kE, ME, d.fX, WD, _R, u.PW, m.b2, YD, LR, ym, Ri, h._t, pA, p.u5, fO, vO, Ai, S_, NA, Zn.U8, Zn.U8, jA, TO, g.ud, p.UX, HA, hA, rR, xR, pR, bm, gR, r.NQ, PE, HD],
                declarations: [Pm, zm, qm, lf, hh, vh, xc, Sh, Rh, Kw, FI, Xs, JT],
                entryComponents: [Pm, zm, qm, lf, hh, vh, xc, Sh, Rh, Kw, su, FI, Xs, JT]
            }), (0,
            c.w6)("design:paramtypes", ["function" == typeof (NR = void 0 !== r.NQ && r.NQ) ? NR : Object, "function" == typeof (FR = void 0 !== Bt.F0 && Bt.F0) ? FR : Object, "function" == typeof (UR = void 0 !== i.NgZone && i.NgZone) ? UR : Object])], $R);
            const jR = O("Main");
            (0,
            i.enableProdMode)(),
            (0,
            r.eg)(s),
            (0,
            a.y)().bootstrapModule($R).then((e => {
                const t = e.instance.router;
                e.instance.ngZone.run(( () => {
                    w.singlePlayerMode ? t.navigateByUrl("/player", {
                        skipLocationChange: !0
                    }) : t.initialNavigation()
                }
                ))
            }
            )).catch((e => jR("error", e)))
        }
        ,
        76166: () => {
            document.addEventListener("touchmove", (function(e) {
                if (angular.isDefined(e.scale) && 1 !== e.scale)
                    e.preventDefault();
                else if (navigator.userAgent.match(/(iPod|iPhone|iPad)/) || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1)
                    if (90 === Math.abs(window.orientation) && navigator.userAgent.match(/(iPod|iPhone)/))
                        ;
                    else
                        for (var t = e.target; (!t.classList || !t.classList.contains("ios-prevent-drag")) && t.parentNode; )
                            if ((t = t.parentNode).parentNode && t.parentNode.classList) {
                                if (t.parentNode.classList.contains("ios-allow-drag"))
                                    break;
                                if (t.parentNode.classList.contains("ios-prevent-drag")) {
                                    e.preventDefault();
                                    break
                                }
                            }
            }
            ), {
                passive: !1
            })
        }
        ,
        24654: () => {}
    }, s = {};
    function o(e) {
        var t = s[e];
        if (void 0 !== t)
            return t.exports;
        var n = s[e] = {
            id: e,
            loaded: !1,
            exports: {}
        };
        return r[e].call(n.exports, n, n.exports, o),
        n.loaded = !0,
        n.exports
    }
    o.m = r,
    e = [],
    o.O = (t, n, i, a) => {
        if (!n) {
            var r = 1 / 0;
            for (d = 0; d < e.length; d++) {
                for (var [n,i,a] = e[d], s = !0, c = 0; c < n.length; c++)
                    (!1 & a || r >= a) && Object.keys(o.O).every((e => o.O[e](n[c]))) ? n.splice(c--, 1) : (s = !1,
                    a < r && (r = a));
                if (s) {
                    e.splice(d--, 1);
                    var l = i();
                    void 0 !== l && (t = l)
                }
            }
            return t
        }
        a = a || 0;
        for (var d = e.length; d > 0 && e[d - 1][2] > a; d--)
            e[d] = e[d - 1];
        e[d] = [n, i, a]
    }
    ,
    o.n = e => {
        var t = e && e.__esModule ? () => e.default : () => e;
        return o.d(t, {
            a: t
        }),
        t
    }
    ,
    n = Object.getPrototypeOf ? e => Object.getPrototypeOf(e) : e => e.__proto__,
    o.t = function(e, i) {
        if (1 & i && (e = this(e)),
        8 & i)
            return e;
        if ("object" == typeof e && e) {
            if (4 & i && e.__esModule)
                return e;
            if (16 & i && "function" == typeof e.then)
                return e
        }
        var a = Object.create(null);
        o.r(a);
        var r = {};
        t = t || [null, n({}), n([]), n(n)];
        for (var s = 2 & i && e; "object" == typeof s && !~t.indexOf(s); s = n(s))
            Object.getOwnPropertyNames(s).forEach((t => r[t] = () => e[t]));
        return r.default = () => e,
        o.d(a, r),
        a
    }
    ,
    o.d = (e, t) => {
        for (var n in t)
            o.o(t, n) && !o.o(e, n) && Object.defineProperty(e, n, {
                enumerable: !0,
                get: t[n]
            })
    }
    ,
    o.f = {},
    o.e = e => Promise.all(Object.keys(o.f).reduce(( (t, n) => (o.f[n](e, t),
    t)), [])),
    o.u = e => "./js/" + e + "." + {
        58: "38ad53111e1766aa4cc2",
        169: "454ab89677ed1e9364df",
        235: "528fa046a42ad817d43e",
        463: "01cbcd0c6aa310d56836",
        464: "25da64b560d800e4d0c7",
        536: "c4c72a401084edff58c9",
        646: "52b55dbb24c2dc03b607",
        879: "b52d7a06f30f72d32be9",
        909: "55a5567fd46a4173aef7",
        920: "36b57dda048a77828922",
        926: "4106f18c8067df15789c",
        968: "9a7d3fb784cfa56f56e3",
        977: "378b5129d87e161483c6"
    }[e] + ".js",
    o.miniCssF = e => {}
    ,
    o.g = function() {
        if ("object" == typeof globalThis)
            return globalThis;
        try {
            return this || new Function("return this")()
        } catch (e) {
            if ("object" == typeof window)
                return window
        }
    }(),
    o.o = (e, t) => Object.prototype.hasOwnProperty.call(e, t),
    i = {},
    a = "singularity:",
    o.l = (e, t, n, r) => {
        if (i[e])
            i[e].push(t);
        else {
            var s, c;
            if (void 0 !== n)
                for (var l = document.getElementsByTagName("script"), d = 0; d < l.length; d++) {
                    var u = l[d];
                    if (u.getAttribute("src") == e || u.getAttribute("data-webpack") == a + n) {
                        s = u;
                        break
                    }
                }
            s || (c = !0,
            (s = document.createElement("script")).charset = "utf-8",
            s.timeout = 120,
            o.nc && s.setAttribute("nonce", o.nc),
            s.setAttribute("data-webpack", a + n),
            s.src = e),
            i[e] = [t];
            var m = (t, n) => {
                s.onerror = s.onload = null,
                clearTimeout(h);
                var a = i[e];
                if (delete i[e],
                s.parentNode && s.parentNode.removeChild(s),
                a && a.forEach((e => e(n))),
                t)
                    return t(n)
            }
              , h = setTimeout(m.bind(null, void 0, {
                type: "timeout",
                target: s
            }), 12e4);
            s.onerror = m.bind(null, s.onerror),
            s.onload = m.bind(null, s.onload),
            c && document.head.appendChild(s)
        }
    }
    ,
    o.r = e => {
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
            value: "Module"
        }),
        Object.defineProperty(e, "__esModule", {
            value: !0
        })
    }
    ,
    o.nmd = e => (e.paths = [],
    e.children || (e.children = []),
    e),
    ( () => {
        var e;
        o.g.importScripts && (e = o.g.location + "");
        var t = o.g.document;
        if (!e && t && (t.currentScript && (e = t.currentScript.src),
        !e)) {
            var n = t.getElementsByTagName("script");
            n.length && (e = n[n.length - 1].src)
        }
        if (!e)
            throw new Error("Automatic publicPath is not supported in this browser");
        e = e.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/"),
        o.p = e + "../"
    }
    )(),
    ( () => {
        var e = {
            179: 0
        };
        o.f.j = (t, n) => {
            var i = o.o(e, t) ? e[t] : void 0;
            if (0 !== i)
                if (i)
                    n.push(i[2]);
                else {
                    var a = new Promise(( (n, a) => i = e[t] = [n, a]));
                    n.push(i[2] = a);
                    var r = o.p + o.u(t)
                      , s = new Error;
                    o.l(r, (n => {
                        if (o.o(e, t) && (0 !== (i = e[t]) && (e[t] = void 0),
                        i)) {
                            var a = n && ("load" === n.type ? "missing" : n.type)
                              , r = n && n.target && n.target.src;
                            s.message = "Loading chunk " + t + " failed.\n(" + a + ": " + r + ")",
                            s.name = "ChunkLoadError",
                            s.type = a,
                            s.request = r,
                            i[1](s)
                        }
                    }
                    ), "chunk-" + t, t)
                }
        }
        ,
        o.O.j = t => 0 === e[t];
        var t = (t, n) => {
            var i, a, [r,s,c] = n, l = 0;
            if (r.some((t => 0 !== e[t]))) {
                for (i in s)
                    o.o(s, i) && (o.m[i] = s[i]);
                if (c)
                    var d = c(o)
            }
            for (t && t(n); l < r.length; l++)
                a = r[l],
                o.o(e, a) && e[a] && e[a][0](),
                e[a] = 0;
            return o.O(d)
        }
          , n = self.webpackChunksingularity = self.webpackChunksingularity || [];
        n.forEach(t.bind(null, 0)),
        n.push = t.bind(null, n.push.bind(n))
    }
    )();
    var c = o.O(void 0, [736], ( () => o(84715)));
    c = o.O(c)
}
)();
